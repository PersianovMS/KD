//@skip-check module-structure-top-region
#Область ПРОГРАММНЫЙИНТЕРФЕЙС

// Добавляет команду в дерево дочерней формы - по ИД из макета или новую
// Параметры:
//  ИДПередКоторымВставить  - Строка - ИД команды, перед которой добавить новую. Если команда добавляется последней - указывается ИД её родителя с "К" на конце.
&НаКлиенте
Процедура ДобавитьКоманду(ИДПередКоторымВставить = "") Экспорт
	Если ЗначениеЗаполнено(ИДПередКоторымВставить) Тогда
		ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.УФормаСохраненияКоманды", Новый Структура("ПутьККоманде", ИДПередКоторымВставить), ЭтотОбъект, ЭтотОбъект);
	КонецЕсли;
КонецПроцедуры // ДобавитьКоманду

// Записывает новую команду с заданными параметрами в дерево
// Параметры:
//  ПараметрыСохранения  - Структура - Ключи ИмяКоманды,ИмяПодменю,Подсказка,ПредставлениеКоманды,ПредставлениеПодменю,ПутьККоманде,ПутьККартинке,ПередПосле,
//				ПерезаписатьТекстЗапроса,ПерезаписатьТекстКода,СохранитьТекстКода,СохранитьТекстЗапроса,СохранитьПредмет,
//				СохранитьПараметры,СохранитьКоманды,СохранитьМеню,СохранитьЧАКО,ЭтоРазделитель,СохранитьСКД,СохранитьТаб1,СохранитьТаб2,СохранитьТД,ТолькоДляМеня,ХотКей 
//	КудаСохранять - Строка - Пустая для команд. Для записи настроек = Имя настройки, или #Файл, или #Авто, или #Текущие
// Возвращаемое значение:
//   Число   - Найденных.
//				+ записывается в общее хранилище команда (структура)
//					ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", ИмяНастроек, ЭтиНастройки,, Имя_Пользователя);
//				где ключи см. СтандартныйСписокНастроек(): ДобавленныеТаблицы,ДопТаблица,
//				ЕстьДобавленныеТаблицы,ЕстьДопТаблица,ЕстьМВТ,ЕстьПараметры_,ЕстьПредмет,ЕстьСКД,ЕстьТабДокумент,ЕстьТабЗначений,ЕстьТекстЗапроса,ЕстьТекстКода,ЕстьЧАКО,
//				МВТ,Параметры_,Предмет,СКД,НастройкиСКД,ПерезаписатьТекстЗапроса,ПерезаписатьТекстКода,ТабДокумент,ТабЗначений,ТекстЗапроса,ТекстКода,ЧАКО
&НаКлиенте
Функция ЗаписатьНовуюСК(ПараметрыСохранения, КудаСохранять) Экспорт
	ПараметрыСохранения.Вставить("Результат", 0);
	Если ЗначениеЗаполнено(КудаСохранять) Тогда
		Если КудаСохранять = "#Файл" Тогда
			АдресСохранения = ПоместитьВоВременноеХранилище(Неопределено, УникальныйИдентификатор);
			ПараметрыСохранения.Вставить("ВХранилищеОбщих", Ложь);
			ПараметрыСохранения.Вставить("ПутьСохранения", АдресСохранения);
		ИначеЕсли КудаСохранять = "#Текущие" Тогда
			ПараметрыСохранения.Вставить("ВХранилищеОбщих", Истина);
			ПараметрыСохранения.Вставить("ПутьСохранения", "#Текущие");
		Иначе
			ПараметрыСохранения.Вставить("ВХранилищеОбщих", Истина);
			ПараметрыСохранения.Вставить("ПутьСохранения", ПараметрыСохранения.ИмяКоманды);//КудаСохранять);
			Имена_Настроек.Добавить(ПараметрыСохранения.ИмяКоманды, ПараметрыСохранения.ИмяКоманды);
		КонецЕсли;
		Если ПараметрыСохранения.СохранитьКоманды Тогда
			ПараметрыСохранения.Вставить("КомандыСписок", КомандыСписок);
		КонецЕсли;
		Если ПараметрыСохранения.СохранитьМеню Тогда
			ПараметрыСохранения.Вставить("АдресДереваМеню", АдресДереваМеню);
		КонецЕсли;
		ПараметрыСохранения.Вставить("НастройкиЧАКО", НастройкиЧАКО);
		ПараметрыСохранения.Вставить("Имена_Настроек", Имена_Настроек.Скопировать());
		ПараметрыСохранения.Вставить("ИнтервалАвтосохраненияВСекундах", ИнтервалАвтосохраненияВСекундах);
		Код = "Результат = ПодготовитьИСохранитьНастройки(ПутьСохранения, Прм,, ВХранилищеОбщих)"
	Иначе
		Код = "Результат = ЗаписатьКоманду(Прм)";
	КонецЕсли;
	ВызватьАлгоритмСервер(Код, ПараметрыСохранения,, Истина);
	Если КудаСохранять = "#Файл" Тогда
		НачатьПолучениеФайлаССервера(, АдресСохранения, ПутьДляСохранения);
		ПоместитьВоВременноеХранилище(Неопределено, АдресСохранения);
	КонецЕсли;
	Возврат ПараметрыСохранения.Результат
КонецФункции // ЕстьВДеревеМеню

// Возвращает наличие команды в дереве меню
// Параметры:
//  ИмяКоманды  - Строка - Имя искомой команды
// Возвращаемое значение:
//   Булево   - Команда есть в списке команд
&НаКлиенте
Функция КомандаЕстьВСК(ИмяКоманды) Экспорт
	Результат = ЕстьВДеревеМеню(ИмяКоманды);
	Возврат Результат
КонецФункции // КомандаЕстьВСК

//Читает данные этажа ветки МД с сервера, пересохраняет дерево с учётом прочитанного, и возвращает массив структур по прочитанным строкам
// Параметры:
//	Путь - Строка - многострочная, где каждая строка = уровень дерева = от корня до читаемой строки
// Возвращаемое значение:
//   Массив из Структура, Неопределено   - Прочитанные строки или Неопределено, если путь не найден
//@skip-check export-method-in-command-form-module
&НаСервере
Функция ПрочитатьМДсСервера(Путь) Экспорт
	Результат = Неопределено;
	Дровина = ПолучитьИзВременногоХранилища(АдресДереваМД);
	Ветка = Дровина;
	КСтрок = СтрЧислоСтрок(Путь);
	ПутьПройден = Истина;
	Для Ё = 0 По КСтрок - 2 Цикл
		Ветка = Ветка.Строки.Найти(СтрПолучитьСтроку(Путь, КСтрок - Ё), "Команда");
		Если Ветка = Неопределено Тогда
			ПутьПройден = Ложь;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если ПутьПройден Тогда
		Дровина.Колонки.Команда.Имя = "Представление";
		Настоящий = Неопределено;
		ПроверитьНастоящий(Настоящий);
		Настоящий.ЗаполнитьДеревоМД(Ветка, Ветка.МД);
		Дровина.Колонки.Представление.Имя = "Команда";
		Результат = Новый Массив;
		Для каждого СтрокаМД Из Ветка.Строки Цикл
			ЛокРез = Новый Структура("Команда,ТекстДляКода,ТекстДляЗапроса");
			ЗаполнитьЗначенияСвойств(ЛокРез, СтрокаМД);
			Результат.Добавить(ЛокРез);
		КонецЦикла;
		ПоместитьВХранилищеФормы(Дровина, АдресДереваМД);
	КонецЕсли;
	Возврат Результат
КонецФункции
 
// Удаляет команду с заданным ИД из меню. Встроенные команды помечаются ДопИнф = "СКРЫТЬ"
// Параметры:
//  Результат  - КодВозвратаДиалога - Результат обрабочика
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика. Ключи ИДУдаляемой и АдресДерева
&НаКлиенте
Процедура УдалитьИДизМеню(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат = "ДА" ИЛИ Результат = КодВозвратаДиалога.Да ИЛИ Результат = "Подменю" Тогда
		УдалитьИзДереваМеню(СтруктураПараметров.ИДУдаляемой, Результат = "Подменю");
	КонецЕсли;
КонецПроцедуры // УдалитьИДизМеню
					   
// Удаляет команду из дерева дочерней формы
// Параметры:
//  ИДУдаляемой  - Строка - ИД удаляемой команды.
&НаКлиенте
Процедура УдалитьКоманду(ИДУдаляемой) Экспорт
	ТекВопрос = ПроверитьИДвМеню(ИДУдаляемой);
	СтруктураПараметров = Новый Структура("ИДУдаляемой", ИДУдаляемой);
	СЗ_Кнопки = Новый СписокЗначений;
	СЗ_Кнопки.Добавить("ДА", "ДА");
	СЗ_Кнопки.Добавить("НЕТ", "НЕТ");
	СЗ_Кнопки.Добавить("Подменю", "Вместе с подменю");
	Если ТекВопрос = "" Тогда
		УдалитьИДизМеню(КодВозвратаДиалога.Да, СтруктураПараметров);
	ИначеЕсли ТекВопрос = "ИД не обнаружен в меню" Тогда
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = ТекВопрос;
//		Сообщение.Поле = "";
//		Сообщение.УстановитьДанные();
		Сообщение_.Сообщить();
	ИначеЕсли СтрНайти(ТекВопрос, "Удалить вместе с подменю?") > 0 Тогда
		ПоказатьВопрос(Новый ОписаниеОповещения("УдалитьИДизМеню", ЭтотОбъект, СтруктураПараметров), ТекВопрос, СЗ_Кнопки);
	Иначе
		ПоказатьВопрос(Новый ОписаниеОповещения("УдалитьИДизМеню", ЭтотОбъект, СтруктураПараметров), ТекВопрос, РежимДиалогаВопрос.ДаНет);
	КонецЕсли;
КонецПроцедуры // УдалитьКоманду

#КонецОбласти

#Область ОБРАБОТЧИКИСОБЫТИЙФОРМЫ
	
//Обработчик события.
//Когда вызывается из конструктора СКД в Толстом клиенте, ВыбранноеЗначение - СхемаКомпоновкиДанных, а ИсточникВыбора - КонструкторСхемыКомпоновкиДанных.
&НаКлиенте
Процедура ОбработкаВыбора(ВыбранноеЗначение, ИсточникВыбора)
	#Если ТолстыйКлиентУправляемоеПриложение Тогда
		Настройки_СКД = ВыбранноеЗначение.ВариантыНастроек[0].Настройки;
		ТекСКД = ВыбранноеЗначение;
		АдресСКД = ПоместитьВХранилищеФормы(ТекСКД, АдресСКД);
	#КонецЕсли 
КонецПроцедуры

//@skip-check module-unused-method
&НаКлиенте
Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
	Если НЕ ЗавершениеРаботы Тогда
		ВызватьАлгоритмСервер("МВТ.Закрыть()");
		Если НЕ ИнтервалАвтосохраненияВСекундах = 9999999999 Тогда
			СохранитьВсеТекущиеНастройки();
		КонецЕсли;
	ИначеЕсли НЕ ИнтервалАвтосохраненияВСекундах = 9999999999 И ТекущаяУниверсальнаяДатаВМиллисекундах() - ПоследнееАС > 90000 Тогда
		ТекстПредупреждения = "Консоль данных: Последнее автосохранение было более 1,5 минут назад. Закрыть без сохранения?";
		Отказ = Истина;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	#Область СПИСОК_ВЫБОРА_ЗНАЧЕНИЙ_ПАРАМЕТРОВ
		ТекСВ = Элементы.Параметры_ЗначениеПараметра.СписокВыбора;
		ТекСВ.Добавить("Результат = ", "Код");
		ТекСВ.Добавить("&Код", "Выражение");
		ТекСВ.Добавить("&ТабЗначений", "Таб1");
		ТекСВ.Добавить("&ДопТаблица", "Таб2");
		ТекСВ.Добавить("&Предмет", "Прдм");
	#КонецОбласти
	СформироватьКомандныеПанели();
	#Область ТЕКСТ_О_ПРАВАХ
		Если НетПрав() Тогда
			ПоказатьТекстОПравах();
		КонецЕсли;
	#КонецОбласти
	Элементы.Пользователь_.СписокВыбора.Добавить("№№№");
	СтартОжиданияАвтоСохранения();
	Сообщение_ = Новый СообщениеПользователю;
	Сообщение_.Текст = СообщалкаПриОткрытии;
	Сообщение_.Сообщить();
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	СообщалкаПриОткрытии = Настоящий.Планы____();
	//ЭлементыКоманд = Новый Структура;
	//ИмяПользователя = ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	МодульКС = Настоящий.ПолучитьМакет("МодульКС").ПолучитьТекст();
	МенюНастройкиИКомандыВРеквизиты(Настоящий);
	ПрименитьНастройки(Настоящий, Истина);
	НоваяДоска = Новый ДеревоЗначений;
	Настоящий.ЗаполнитьДеревоМД(НоваяДоска);
	НоваяДоска.Колонки.Представление.Имя = "Команда";
	НоваяДоска.Колонки.Добавить("Имя");
	НоваяДоска.Колонки.Добавить("ПолноеОписание");
	АдресДереваМД = ПоместитьВХранилищеФормы(НоваяДоска, АдресДереваМД);
КонецПроцедуры

#КонецОбласти 

#Область ОБРАБОТЧИКИСОБЫТИЙЭЛЕМЕНТОВШАПКИФОРМЫ
	
&НаКлиенте
Процедура ИнтервалАвтосохраненияВСекундахПриИзменении(Элемент)
	СтартОжиданияАвтоСохранения();
КонецПроцедуры

&НаКлиенте
Процедура Пользователь_НачалоВыбора(Элемент, ДанныеВыбора, ВыборДобавлением, СтандартнаяОбработка)
	ТекСписок = Элементы.Пользователь_.СписокВыбора;
	ТекСписок.Очистить();
	Для каждого Имечко Из СписокПользователейИБ() Цикл
		ТекСписок.Добавить(Имечко, Имечко);
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура Файл_НачалоВыбора(Элемент, ДанныеВыбора, ВыборДобавлением, СтандартнаяОбработка)
	СтрПрм = Новый Структура("ИмяЭлементаКуда", "Файл_");
	ВыбратьФайлИПродолжить(
			"ВставитьРезультатВТекст",
		    ЭтотОбъект,
			СтрПрм,
			"Файлы консоли данных|*.КД3",,
			Ложь,,,,
			ПутьДляСохранения);
КонецПроцедуры

#КонецОбласти

#Область ОБРАБОТЧИКИКОМАНДФОРМЫ

#Область 	НАСТОЯЩИЕ_КОМАНДЫ

#Область 		БЕЗ_КНОПОК
	
//@skip-check module-empty-method
&НаКлиенте
Процедура Ничего(Команда)
КонецПроцедуры

#КонецОбласти

#Область 		С_КНОПКАМИ

#Область 			БУФЕР
	
&НаКлиенте
Процедура ВБуфер(Команда)
	Если ТекущийЭлемент = Элементы.ТекстКода ИЛИ ТекущийЭлемент = Элементы.ТекстЗапроса Тогда
		ТекБуфер = ТекущийЭлемент.ВыделенныйТекст;
	ИначеЕсли ТекущийЭлемент = Элементы.ТабЗначений ИЛИ ТекущийЭлемент = Элементы.ДопТаблица ИЛИ ТекущийЭлемент = Элементы.НастройкиЧАКО
			ИЛИ ТекущийЭлемент = Элементы.Параметры_ ИЛИ ТекущийЭлемент = Элементы.Настройки_Значение Тогда
		//@skip-check unknown-method-property
		ИмяКолонки = ИмяКолонкиДанныхЭлемента(ТекущийЭлемент.ТекущийЭлемент.Имя);
		ТекБуфер = ТекущийЭлемент.ТекущиеДанные[ИмяКолонки];
	ИначеЕсли ТекущийЭлемент = Элементы.ТабДокумент Тогда
		ТекОбласть = Элементы.ТабДокумент.ТекущаяОбласть;
		Если ТипЗнч(ТекОбласть) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			ТекБуфер = ?(ТекОбласть.СодежитЗначение, ТекОбласть.Значение, ТекОбласть.Текст);
		ИначеЕсли ТипЗнч(ТекОбласть) = Тип("РисунокТабличногоДокумента") Тогда
			ТекБуфер = ТекОбласть.Картинка;
		КонецЕсли;
	ИначеЕсли ТекущийЭлемент = Элементы.Предмет Тогда
		ТекБуфер = Предмет;
	ИначеЕсли ТекущийЭлемент = Элементы.Файл_ Тогда
		ТекБуфер = "";
	КонецЕсли;
	Буфер = ТекБуфер;
КонецПроцедуры

&НаКлиенте
Процедура ИзБуфера(Команда)
	Если ТекущийЭлемент = Элементы.ТекстКода ИЛИ ТекущийЭлемент = Элементы.ТекстЗапроса Тогда
		ТекущийЭлемент.ВыделенныйТекст = Строка(Буфер);
	ИначеЕсли ТекущийЭлемент = Элементы.ТабЗначений ИЛИ ТекущийЭлемент = Элементы.ДопТаблица ИЛИ ТекущийЭлемент = Элементы.НастройкиЧАКО
			ИЛИ ТекущийЭлемент = Элементы.Параметры_ ИЛИ ТекущийЭлемент = Элементы.Настройки_Значение Тогда
		//@skip-check unknown-method-property
		ИмяКолонки = ИмяКолонкиДанныхЭлемента(ТекущийЭлемент.ТекущийЭлемент.Имя);
		ТекущийЭлемент.ТекущиеДанные[ИмяКолонки] = Буфер;
	ИначеЕсли ТекущийЭлемент = Элементы.ТабДокумент Тогда
		ТекОбласть = Элементы.ТабДокумент.ТекущаяОбласть;
		Если ТипЗнч(Буфер) = Тип("Строка") Тогда
			ТекОбласть.Текст = Буфер;
		ИначеЕсли ТипЗнч(Буфер) = Тип("Картинка") Тогда
			ТабДокумент.Рисунки.Добавить().Картинка = Буфер;
		Иначе
			ТекОбласть.СодержитЗначение = Истина;
			ТекОбласть.Значение = Буфер;
		КонецЕсли; 
	ИначеЕсли ТекущийЭлемент = Элементы.Предмет Тогда
		Предмет = Буфер;
	ИначеЕсли ТекущийЭлемент = Элементы.Файл_ Тогда
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область 			НАСТРОЙКИ
	
&НаКлиенте
Процедура ЗагрузитьНастройкиИзФайла(Команда)
	НачатьПомещениеФайлаНаСервер(Новый ОписаниеОповещения("ПрименитьНастройкиИзФайла", ЭтотОбъект),,,, ПутьДляСохранения, УникальныйИдентификатор);
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьНастройки_Кнопа(Команда)
	МенюНастройкиИКомандыВРеквизиты("СБРОСИТЬ",,,,, Элементы.Настройки_.ТекущиеДанные.Значение);
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьНастройкиПользователя(Команда)
	МенюНастройкиИКомандыВРеквизиты("СБРОСИТЬ",,,, Пользователь_, ИмяНастройки);
КонецПроцедуры

&НаКлиенте
Процедура ОчиститьТекущиеНастройки(Команда)
	ОчиститьТекНастройкиНаСервере();
	ОтключитьОбработчикОжидания("СохранитьВсеТекущиеНастройки");
	ИнтервалАвтосохраненияВСекундах = 9999999999;
КонецПроцедуры

&НаКлиенте
Процедура СохранитьНастройкиВФайл(Команда)
	ПараметрыФормы = Новый Структура("КудаСохранять,РежимНастроек", "#Файл", Истина);
	ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.УФормаСохраненияКоманды", ПараметрыФормы, ЭтотОбъект, 25);
КонецПроцедуры

&НаКлиенте
Процедура СохранитьНастройкиПоИмени(Команда)
	ПараметрыФормы = Новый Структура("КудаСохранять,РежимНастроек,ИмяКоманды", ИмяНастройки, Истина, ИмяНастройки);
	ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.УФормаСохраненияКоманды", ПараметрыФормы, ЭтотОбъект, 25);
КонецПроцедуры

&НаКлиенте
Процедура СохранитьТекущиеНастройки(Команда)
	СохранитьВсеТекущиеНастройки();
КонецПроцедуры

#КонецОбласти

#Область 			РЕДАКТИРОВАНИЕ_РЕКВИЗИТОВ
	
&НаКлиенте
Процедура ПредметОткрыть(Команда)
	ПредметОткрытьНаСервере();
	ОбновитьОтображениеДанных(Элементы.ТабЗначений);
КонецПроцедуры

&НаКлиенте
Процедура ПредметОткрытьТЧ(Команда)
	ПредметОткрытьТЧНаСервере(Элементы.ТабЗначений.ТекущиеДанные.ИмяРеквизита);
	ОбновитьОтображениеДанных(Элементы.ДопТаблица);
КонецПроцедуры

&НаКлиенте
Процедура ПредметСохранить(Команда)
	ПредметСохранитьНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ПредметСохранитьТЧ(Команда)
	ИмяТЧ = Элементы.ТабЗначений.ТекущиеДанные.ИмяРеквизита;
	ПоказатьВопрос(Новый ОписаниеОповещения("СохранитьПредметПослеПодтверждения", ЭтотОбъект, Новый Структура("ИмяТЧ", ИмяТЧ)),
			"Сохранить табчасть " + ИмяТЧ + "? (будет сохранена в базу только ТЧ)", РежимДиалогаВопрос.ДаНет);
КонецПроцедуры

#КонецОбласти

#Область 			ЧАКО
	
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура НастроитьЧАКО(Команда)
	//!!!!
КонецПроцедуры

&НаКлиенте
Процедура ЧАКО1(Команда)
	НомерЧАКО = Прав(Команда.Имя, 1);
	СтрокиЧАКО = НастройкиЧАКО.НайтиСтроки(Новый Структура("Номер", НомерЧАКО));
	Если СтрокиЧАКО.Количество() Тогда
		ТекСтрока = СтрокиЧАКО[0];
		ВыполнитьКомандуЭтойФормы(ТекСтрока.Команда);
		Если ЗначениеЗаполнено(ТекСтрока.ТекстКоманды) Тогда
			ВыполнитьКодСНастройками(ТекСтрока.ТекстКоманды);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область 	ВЫЗОВ_ИЗ_ГЕНЕРИРУЕМЫХ_ПАНЕЛЕЙ
	
#Область 		ПАНЕЛЬ_НАД_КОДОМ

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВставитьИзКонфы_Выполнить()
	ВставитьИзДерева("ТекстКода");
КонецПроцедуры

// Открывает меню дерева команд
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВыполнитьИзДерева()
	СПараметры = НовыеПараметрыФормыДерева();
	СПараметры.Вставить("АдресДерева", АдресДерева_КомандДляФормы());
	//@skip-check structure-consructor-too-many-keys
	СПараметры.Вставить("КомандыФормы",
			Новый Структура("Добавить,Удалить",
				Новый Структура("Заголовок,Код,Картинка,Подсказка", "Добавить команду", "ВладелецФормы.ДобавитьКоманду(Элементы.Деревяшка.ТекущиеДанные.ИД_); Закрыть()",
					БиблиотекаКартинок.ДобавитьЭлементСписка, "Добавить команду перед текущей"),
				Новый Структура("Заголовок,Код,Картинка,Подсказка", "Удалить команду", "ВладелецФормы.УдалитьКоманду(Элементы.Деревяшка.ТекущиеДанные.ИД_); Закрыть()",
					БиблиотекаКартинок.УдалитьЭлементСписка, "Удалить эту команду")));
	СПараметры.Вставить("ОтображатьРеквизиты", "-ХотКей,Картинка,Команда");
	СПараметры.Вставить("ТолькоПросмотрДерева", Истина);
	СПараметры.Вставить("РежимВыбораДерева", Истина);
	ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.ВыборИзДерева", СПараметры, 
			ЭтотОбъект, ЭтотОбъект,,, Новый ОписаниеОповещения("ВыполнитьВыбраннуюКоманду", ЭтотОбъект));
	ПоместитьВХранилищеФормы(Неопределено, СПараметры.АдресДерева);
КонецПроцедуры // ВыполнитьИзДерева

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура БиблиотекаФункций()
	АдресБФ = ПоместитьВХранилищеФормы(Неопределено);
	Код = "НоваяДоска = ДеревоМетодовМодуля(ПолучитьМакет(""МодульКлиент"").ПолучитьТекст());
			|НоваяДоска = ДеревоМетодовМодуля(ПолучитьМакет(""МодульСервер"").ПолучитьТекст(),,,, НоваяДоска);
			|НоваяДоска = ДеревоМетодовМодуля(ПолучитьМакет(""МодульВС"").ПолучитьТекст(),,,, НоваяДоска);
			|НоваяДоска = ДеревоМетодовМодуля(ПолучитьМакет(""МодульКС"").ПолучитьТекст(),,,, НоваяДоска);
			|НоваяДоска = ДеревоМетодовМодуля(ПолучитьМакет(""МодульПовтИсп"").ПолучитьТекст(),,,, НоваяДоска);
			|АдресДерева = ПоместитьВоВременноеХранилище(НоваяДоска, АдресДерева);
			|";
	СтрОтвет = Новый Структура("АдресДерева", АдресБФ);
	ВызватьАлгоритмСервер(Код, СтрОтвет,, Истина);
	СПараметры = НовыеПараметрыФормыДерева();
	СПараметры.Вставить("АдресДерева", СтрОтвет.АдресДерева);
	СПараметры.Вставить("ВозвращаемыеРеквизиты", "ПолноеОписание");
	СПараметры.Вставить("ВыборМногих", Истина);
	СПараметры.Вставить("ИмяКолонкиДерева", "Представление");
	СПараметры.Вставить("ОтображатьРеквизиты", "-ПолноеОписание,Представление,Описание");
	ТекФорма = ЭтотОбъект;
	//@skip-check wrong-string-literal-content
	ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.ВыборИзДерева", СПараметры, 
			ТекФорма, ТекФорма,,, Новый ОписаниеОповещения("ВставитьРезультатВТекст", ТекФорма));
	ПоместитьВХранилищеФормы(Неопределено, СПараметры.АдресДерева);
КонецПроцедуры

// Возвращает закомментированный текст
// Параметры:
//  ТекстКода  - Строка - изменяемый текст
//  Закомментировать  - Булево - Истина - раскомментировать, Ложь - закомментировать
// Возвращаемое значение:
//   Строка   - Закомментированный или раскомментированный текст
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Функция Комментарий(ТекстКода, Закомментировать = Истина)
	Возврат КомментарийНаСервере(ТекстКода, Закомментировать)
КонецФункции // Комментарий

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ЗаполнитьПараметрыПоКоду(Какому = "")
	ТекЭлемент = ТекущийЭлемент;
	Если Какому = "Д" Тогда
		ВесьТекст = ТекстЗапроса;
	ИначеЕсли Какому = "О" Тогда
		ВесьТекст = ТекстКода;
	ИначеЕсли ТекЭлемент = Элементы.ТекстЗапроса Тогда
		ВесьТекст = ТекстЗапроса;
	Иначе
		ВесьТекст = ТекстКода;
	КонецЕсли;
	ВызватьАлгоритмСервер("ДополнитьПараметрыПоКоду(ВесьТекст, СПарам)", Новый Структура("ВесьТекст", ВесьТекст),, Истина);
КонецПроцедуры

//RUN! - см раздел Выполнение

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура КомандаДиректива()
	ДляВызова = Новый Структура("Результат", Неопределено);
	ВызватьАлгоритмСервер("Результат = СписокДиректив()", ДляВызова, Ложь, Истина);
	ДляВызова.Результат.ПоказатьВыборЭлемента(Новый ОписаниеОповещения("ВставитьРезультатВТекст", ЭтотОбъект , Новый Структура("ТекЭл", ТекущийЭлемент)));
КонецПроцедуры

#КонецОбласти

#Область 		ПАНЕЛЬ_ЗАПРОСА
	
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВызватьКонструкторЗапроса()
	Если Элементы.ТекстЗапроса.ВыделенныйТекст <> "" Тогда
		НовыйКЗ = Новый КонструкторЗапроса(Элементы.ТекстЗапроса.ВыделенныйТекст);
	ИначеЕсли ТекстЗапроса = "" Тогда
		НовыйКЗ = Новый КонструкторЗапроса();
	Иначе
		НовыйКЗ = Новый КонструкторЗапроса(ТекстЗапроса);
	КонецЕсли; 
	#Если ТолстыйКлиентУправляемоеПриложение Тогда
		НовыйКЗ.АвтоДобавлениеПредставлений = Ложь;
		НовыйКЗ.РежимКомпоновкиДанных = Ложь;
	#КонецЕсли
	НовыйКЗ.Показать(Новый ОписаниеОповещения("КЗПослеЗакрытия", ЭтотОбъект, Новый Структура));
КонецПроцедуры

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ЗаполнитьПараметрыПоЗапросу()
	ВызватьАлгоритмСервер("ДополнитьПараметрыПоЗапросу(Запрос_, СПарам)",,, Истина);
КонецПроцедуры
 
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВыполнитьЗапрос()
	Попытка
		ВызватьАлгоритмСервер("Старт = ТекущаяУниверсальнаяДатаВМиллисекундах();
				|ТабЗначений = Запрос_.Выполнить().Выгрузить();
				|Сек = (ТекущаяУниверсальнаяДатаВМиллисекундах() - Старт) / 1000;
				|Текстуёк = ""Выполнение запроса "" + Сек + "" сек., записей = "" + ТабЗначений.Количество();
				|Сообщение_ = Новый СообщениеПользователю;
				|Сообщение_.Текст = Текстуёк;
				|Сообщение_.Сообщить();");
	Исключение
		ООШ = ОписаниеОшибки();
		Если СтрНайти(ООШ, "не был освобожден менеджер временных таблиц") = 0 Тогда
			Текстуёк = "Не удалось выпонить запрос по причине: " + ООШ;
		Иначе
			Текстуёк = "Менеджер ВТ остался на сервере, в нём есть таблицы, но у них только ПолноеИмя - содержимое пропадает. Кто бы подсказал, как передать МВТ из первого обращения к серверу во второе? 1С этому противится!";
		КонецЕсли;
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Текстуёк;
		Сообщение_.Сообщить();
	КонецПопытки;
КонецПроцедуры

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ИзменитьМВТ()
	КнопаИМВТ = Элементы.КПЗапроса.ПодчиненныеЭлементы.Найти("ФлагИспользоватьМВТ");
	Если КнопаИМВТ <> Неопределено Тогда
		КнопаИМВТ.Пометка = НЕ КнопаИМВТ.Пометка;
	КонецЕсли; 
КонецПроцедуры

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВывестиВТвТЗ()
	СписокВТ = Новый СписокЗначений;
	#Область СПИСОК_ВТ
		ПозСледЗапроса = 6;
		ПозПом = 6;
		ПозУн = 6;
		ИндексЗапроса = 0;
		ТекстВрегЗ = ВРег(ТекстЗапроса);
		Длина_ = СтрДлина(ТекстЗапроса);
		ПересчитатьУничтожить = Истина;
		ПересчитатьПоместить = Истина;
		ВПакете = 0;
		МаксИндекс = 0;
		Пока ПозСледЗапроса > 0 Цикл
			ПозСледЗапроса = СтрНайти(ТекстВрегЗ, ";",, ПозСледЗапроса + 1);
			Если ПересчитатьПоместить Тогда
				ПозПом = СтрНайти(ТекстВрегЗ, "ПОМЕСТИТЬ",, ПозПом + 1);
				ПересчитатьПоместить = Ложь;
			КонецЕсли;
			Если ПозПом > 0 И (ПозПом < ПозСледЗапроса ИЛИ ПозСледЗапроса = 0) Тогда
				ПозПом = ПозПом + 8;
				ТекСимвол = " ";
				Метка = ПозПом;
				Пока ПозПом < Длина_ И НЕ ЗначениеЗаполнено(ТекСимвол) Цикл
					ПозПом = ПозПом + 1;
					ТекСимвол = Сред(ТекстЗапроса, ПозПом, 1);
				КонецЦикла;
				Если ПозПом - Метка > 1 Тогда
					//Хотя бы одна пустышка
					ТекИмя = "";
					Пока ЗначениеЗаполнено(ТекСимвол) И ТекСимвол <> ";" Цикл
						ТекИмя = ТекИмя + ТекСимвол;
						ПозПом = ПозПом + 1;
						ТекСимвол = Сред(ТекстЗапроса, ПозПом, 1);
					КонецЦикла;
					Если ТекИмя <> "" Тогда
						СписокВТ.Добавить(ИндексЗапроса, ТекИмя);
					КонецЕсли;
				КонецЕсли;
				ПересчитатьПоместить = Истина;
			Иначе
				Если ПересчитатьУничтожить Тогда
					ПозУн = СтрНайти(ТекстВрегЗ, "УНИЧТОЖИТЬ",, ПозУн + 1);
				КонецЕсли;
				ПересчитатьУничтожить = ПозУН > 0 И (ПозУн < ПозСледЗапроса ИЛИ ПозСледЗапроса = 0);
				Если Не ПересчитатьУничтожить Тогда
					СписокВТ.Добавить(ИндексЗапроса, "ЗАПРОС ПАКЕТА #" + ИндексЗапроса);
					ВПакете = ВПакете + 1;
					МаксИндекс = ИндексЗапроса;
				КонецЕсли;
			КонецЕсли;
			ИндексЗапроса = ИндексЗапроса + 1;
		КонецЦикла;
	#КонецОбласти
	СписокВТ.ПоказатьВыборЭлемента(Новый ОписаниеОповещения("ВывестиВыбраннуюВТвДопТЗ", ЭтотОбъект, Новый Структура("ВПакете,МаксИндекс", ВПакете, МаксИндекс)));
КонецПроцедуры

//Комментарии - см. панель кода

// Преобразует строку в текст запроса и обратно
// Параметры:
//  Направление  - Строка - Вид преобразования ("ВЗапрос", "ВКод"...)
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ПреобразоватьТекст(Направление)
	Если ТекущийЭлемент = Элементы.ТекстЗапроса Тогда
		Источник = ТекущийЭлемент;
		ИмяРекв = "ТекстЗапроса";
	Иначе
		Источник = Элементы.ТекстКода;
		ИмяРекв = "ТекстКода";
	КонецЕсли; 
	Текст_ = Источник.ВыделенныйТекст;
	НеВыделено = Текст_ = "";
	Если НеВыделено Тогда
		Текст_ = ЭтотОбъект[ИмяРекв];
	КонецЕсли;
	Результат = Неопределено;
	Прм = Новый Структура("Текст_, Результат", Текст_, "");
	Если Направление = "ВЗапрос" Тогда
		ВызватьАлгоритмСервер("Результат = Текст_КодаВЗапрос(Текст_)", Прм);
	ИначеЕсли Направление = "ВКод" Тогда
		ВызватьАлгоритмСервер("Результат = Текст_ЗапросаВКод(Текст_)", Прм);
	КонецЕсли;
	Результат = Прм.Результат;
	Если Результат <> Неопределено Тогда
		Если НеВыделено Тогда
			ЭтотОбъект[ИмяРекв] = Результат;
		Иначе
			ВставитьТекстВЭлемент(Результат, Источник);
		КонецЕсли; 
	КонецЕсли;
КонецПроцедуры //ПреобразоватьТекст 

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВставитьОбъектКонфигурацииВЗапрос()
	ВставитьИзДерева("ТекстЗапроса");
КонецПроцедуры

//Вставляет запрос из библиотеки
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ВставитьЗапрос()
	//!!!!НЕ НАПИСАНА!!!!
КонецПроцедуры // ВставитьЗапрос

//Выполнение кода - см. панель кода

#КонецОбласти

#Область 		ПАНЕЛЬ_СКД
	
//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура ОткрытьКонструкторСКД()
	#Если ТолстыйКлиентУправляемоеПриложение Тогда
		Если ЗначениеЗаполнено(АдресСКД) Тогда
			ТекСкД = ПолучитьИзВременногоХранилища(АдресСКД);
		КонецЕсли;
		Если ТекСКД = Неопределено Тогда
			ТекСКД = Новый СхемаКомпоновкиДанных;
		КонецЕсли;
		КСКД = Новый КонструкторСхемыКомпоновкиДанных(ТекСКД);
		//ТекСКД = ХСЗ.СКД; //а вот как сюда вставить вариант настроек 0 с заданными настройками - не знаю. Впрочем, он и так д.б. там...
		//КСКД.УстановитьСхему(ТекСКД);
		КСКД.Редактировать(ЭтотОбъект);
	#Иначе 	
		Текстуёк = "Доступно только в толстом клиенте!";
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Текстуёк;
		Сообщение_.Сообщить();
	#КонецЕсли 
КонецПроцедуры

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура СКДвТЗ_()
	ВызватьАлгоритмСервер("ТабЗначений = ТаблицаСКД(СКД, НастройкиСКД)");
	ОбновитьОтображениеДанных(Элементы.ТабЗначений);
КонецПроцедуры

//@skip-check module-structure-form-event-regions
//@skip-check module-unused-method
&НаКлиенте
Процедура СКДвТД_()
	СКДвТДнаСервере();
	ОбновитьОтображениеДанных(Элементы.ТабДокумент);
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область 	ВЫЗОВ_ИЗ_МЕНЮ_И_МАКЕТА
	
// Вставляет заданный текст в выделенный текст заданного элемента
// Параметры:
//  ТекстКВставке  - Строка - Текст, который надо вставить
//  Элемент  - ЭлементФормы - Элемент, в который надо вставить
//@skip-check module-structure-form-event-regions
//@skip-check doc-comment-type
&НаКлиенте
Процедура ВставитьТекстВЭлемент(ТекстКВставке, Элемент = Неопределено)
	Куда = ?(Элемент = Неопределено, ?(ТекущийЭлемент = Элементы.ТекстЗапроса, ТекущийЭлемент, Элементы.ТекстКода), Элементы[Элемент]);
	Если Куда.Высота < 2 Тогда
		Дл_ТР = СтрДлина(Куда.ТекстРедактирования);
		Если Дл_ТР > 0 Тогда
			Куда.УстановитьГраницыВыделения(1, Дл_ТР + 1);
		КонецЕсли;
	КонецЕсли;
	Куда.ВыделенныйТекст = ТекстКВставке
КонецПроцедуры // ВставитьТекстВЭлемент

#КонецОбласти

#Область 	КЛИЕНТСКИЕ_ПРОДОЛЖЕНИЯ

//Вызывает диалог вставки значенияия, выбранного из дерева.
//Параметры:
//	НазначениеРезультата - Строка - режим диалога:
//			>"ТекстКода" - выбор объекта конфигурации для вставки в код;
//			>"ТекстЗапроса" - выбор объекта конфигурации для вставки в хапрос;
//			>"ИзМодуля" - Выбор процедуры из макета - модуля для вставки в код
//@skip-check module-structure-form-event-regions
//@skip-check doc-comment-field-type
//@skip-check doc-comment-type
&НаКлиенте
Процедура ВставитьИзДерева(НазначениеРезультата)
	СПараметры = НовыеПараметрыФормыДерева();
	ПостроитьМД_ДляВыбора();
	СПараметры.Вставить("АдресДерева", АдресДерева_МД_дляВыбора);
	СПараметры.Вставить("ТолькоПросмотрДерева", Истина);
	СПараметры.Вставить("РежимВыбораДерева", Истина);
	СПараметры.Вставить("ОтображатьРеквизиты", "-Имя,Команда");
	СПараметры.Вставить("ВозвращаемыеРеквизиты", ?(НазначениеРезультата = "ТекстЗапроса", "ТекстДляЗапроса", "ТекстДляКода"));
	СПараметры.Вставить("ВыборМногих", Истина);
	СПараметры.Вставить("ОбработчикВыбора", "
			|ТекВетка = ТекСтрока;
			|Путь = """";
			|Пока ТекВетка <> Неопределено Цикл
			|	Путь = Путь + Символы.ПС + ТекВетка.Команда;
			|	ТекВетка = ТекВетка.ПолучитьРодителя();
			|КонецЦикла;
			|СтрокиДМД = ВладелецФормы.ПрочитатьМДсСервера(Путь);
			|Если СтрокиДМД <> Неопределено Тогда
			|	ВыборСделан = СтрокиДМД.Количество() = 0;
			|	КСтрок = ТекСтрока.ПолучитьЭлементы();
			|	Для каждого СтрокаМД Из СтрокиДМД Цикл
			|		ЗаполнитьЗначенияСвойств(КСтрок.Добавить(), СтрокаМД);
			|	КонецЦикла;
			|КонецЕсли;");
	ОткрытьФорму("ВнешняяОбработка.КонсольДанных31.Форма.ВыборИзДерева", СПараметры, 
			ЭтотОбъект, ЭтотОбъект,,, Новый ОписаниеОповещения("ВставитьРезультатВТекст", ЭтотОбъект));
КонецПроцедуры

// Вставляет в текст результат выбора из формы списка значений или дерева - строку или массив строк
// Параметры:
//  Результат  - Структура - Результат обрабочика, ключи Адрес - адрес хранилища со структурой изменённых команд, и ИмяКоманды.
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика = Неопределено
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура ВставитьРезультатВТекст(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат = "" И ?(ТипЗнч(СтруктураПараметров) = Тип("Структура"), СтруктураПараметров.Свойство("Ошибка__ИнфоОбОшибке"), Ложь) Тогда
		Текстуёк = "ОШИБКА:" + СтруктураПараметров.Ошибка__ИнфоОбОшибке.Описание
				+ Символы.ПС + "(" + СтруктураПараметров.Ошибка__ИнфоОбОшибке.ИсходнаяСтрока + ")"
				+ Символы.ПС + "в строке " + СтруктураПараметров.Ошибка__ИнфоОбОшибке.НомерСтроки + " модуля " + СтруктураПараметров.Ошибка__ИнфоОбОшибке.ИмяМодуля;
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Текстуёк;
		Сообщение_.Сообщить();
	ИначеЕсли ТипЗнч(Результат) = Тип("Массив") Тогда
		Если СтруктураПараметров.Свойство("ИмяЭлементаКуда") Тогда
			ВставитьТекстВЭлемент(СтрСоединить(Результат, Символы.ПС + Символы.ПС), СтруктураПараметров.ИмяЭлементаКуда);
		Иначе
			ВставитьТекстВЭлемент(СтрСоединить(Результат, Символы.ПС + Символы.ПС));
		КонецЕсли;
	ИначеЕсли ТипЗнч(Результат) = Тип("ЭлементСпискаЗначений") Тогда
		ВставитьТекстВЭлемент(Результат.Значение, СтруктураПараметров.ТекЭл);
	ИначеЕсли Результат <> Неопределено Тогда
		Если ЗначениеЗаполнено(Результат.Текст) Тогда
			ВставитьТекстВЭлемент(Результат.Текст, Элементы[СтруктураПараметров.ИмяЭлементаКуда]);
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры // ВыполнитьВыбраннуюКоманду

// Формирует запрос и выводит его таблицу в допТаблицу, а результат - в основную
// Параметры:
//  Результат  - ЭлементСпискаЗначений, Неопределено - Результат обрабочика
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура ВывестиВыбраннуюВТвДопТЗ(Результат, СтруктураПараметров = Неопределено) Экспорт
    Если Результат <> Неопределено Тогда
		КВыполнению = "Старт = ТекущаяУниверсальнаяДатаВМиллисекундах(); мРЗ = Запрос_.ВыполнитьПакетСПромежуточнымиДанными();
				|Сек = (ТекущаяУниверсальнаяДатаВМиллисекундах() - Старт) / 1000; ТМП = мРЗ[" + Результат.Значение + "]; Колво2 = 0; Колво1 = 0;
				|Если ТМП <> Неопределено Тогда
				| 	ДопТаблица = ТМП.Выгрузить();
				|	Колво2 = ДопТаблица.Количество();
				|КонецЕсли; ТМП = ";
		Финиш = Символы.ПС + "
				|Если ТМП <> Неопределено Тогда
				| 	ТабЗначений = ТМП.Выгрузить();
				|	Колво1 = ТабЗначений.Количество();
				|КонецЕсли;
				|Сообщить(""Выполнение запроса "" + Сек + "" сек., записей осн = "" + Колво1 + ""; доп = "" + Колво2)";
		Если СтруктураПараметров.ВПакете = 0 Тогда
			Серединка = "мРЗ[мРЗ.ВГраница()];";
		Иначе
			Серединка = "мРЗ[" + СтруктураПараметров.МаксИндекс + "];";
		КонецЕсли;
		КВыполнению = КВыполнению + Серединка + Финиш;
		ВызватьАлгоритмСервер(КВыполнению);
	КонецЕсли;
КонецПроцедуры // ВывестиВыбраннуюВТвДопТЗ

// Выполняет полученную выбранную команду дерева
// Параметры:
//  Результат  - Структура - Результат обрабочика, ключи Адрес - адрес хранилища со структурой изменённых команд, и ИмяКоманды.
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика = Неопределено
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура ВыполнитьВыбраннуюКоманду(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
	ИначеЕсли Результат.Количество() Тогда
		ВыполнитьКомандуЭтойФормы(Новый Структура("Имя", "Команда___" + Результат[0]));
	КонецЕсли; 
КонецПроцедуры // ВыполнитьВыбраннуюКоманду

//Обработчик после закрытия конструктора запросов
// Параметры:
//	Текст_ - Строка - Текст запроса
//	ДопПараметры - Структура - обязательный параметр обработчика, не используется
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура КЗПослеЗакрытия(Текст_, ДопПараметры) Экспорт
	Если Текст_ <> Неопределено Тогда
		Если Элементы.ТекстЗапроса.ВыделенныйТекст = "" Тогда
			ТекстЗапроса = Текст_;
		Иначе
			Элементы.ТекстЗапроса.ВыделенныйТекст = Текст_;
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры

// Применяет загруженные из файла настройки
// Параметры:
//  Результат  - ОписаниеПомещенногоФайла - Результат обрабочика
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура ПрименитьНастройкиИзФайла(Результат, СтруктураПараметров = Неопределено) Экспорт
    Если ?(Результат = Неопределено, Ложь, НЕ Результат.ПомещениеФайлаОтменено) Тогда
		ПрочитатьНастройкиИЗапихнутьВХранилище(Результат.Адрес);
	КонецЕсли;
КонецПроцедуры // ПрименитьНастройкиИзФайла

 // Сохраняет указанную табчасть Предмета
// Параметры:
//  Результат  - КодВозвратаДиалога - Результат обрабочика
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика
//@skip-check module-structure-form-event-regions
&НаКлиенте
Процедура СохранитьПредметПослеПодтверждения(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат = КодВозвратаДиалога.Да Тогда
		Код = "
			|ПредметОбъект = Предмет.ПолучитьОбъект();
			|ПредметОбъект." + СтруктураПараметров.ИмяТЧ + ".Загрузить(ДопТаблица);
			|ПредметОбъект.ОбменДанными.Загрузка = Истина;
			|ПредметОбъект.ДополнительныеСвойства.Вставить(""ОтключитьМеханизмРегистрацииОбъектов"", Истина);
			|ПредметОбъект.Записать();";
		ВызватьАлгоритмСервер(Код);
		Текстуёк = "ПРЕДМЕТ записан ок";
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Текстуёк;
		Сообщение_.Сообщить();
		ТекущийЭлемент = Элементы.ТабЗначений;
	КонецЕсли; 
КонецПроцедуры // СохранитьПредметПослеПодтверждения

#КонецОбласти 

#Область 	СЕРВЕРНЫЕ_ЧАСТИ

//@skip-check module-structure-form-event-regions
&НаСервере
Функция КомментарийНаСервере(ТекстКода, Закомментировать)
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Возврат Настоящий.Комментарий(ТекстКода, Закомментировать)
КонецФункции // Комментарий

// Очищает сохранённые текущие настройки и отключает флаг автосохранения
//@skip-check module-structure-form-event-regions
&НаСервере
Процедура ОчиститьТекНастройкиНаСервере()
	Имя_Пользователя = ИмяПользователя();
	ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Команды", Неопределено,, Имя_Пользователя);
	ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Меню", Неопределено,, Имя_Пользователя);
	ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Настройки", Неопределено,, Имя_Пользователя);
КонецПроцедуры // ОчиститьТекНастройкиНаСервере

//@skip-check module-structure-form-event-regions
&НаСервере
Процедура ПредметОткрытьНаСервере()
	Код = "
		|СтруктураРеквизитов = СформироватьСтруктуруВсехРеквизитов(Предмет, Истина, Истина);
		|ТабЗначений = Новый ТаблицаЗначений;
		|ЭтиКолонки = ТабЗначений.Колонки;
		|ЭтиКолонки.Добавить(""ИмяРеквизита"", Новый ОписаниеТипов(""Строка"",, Новый КвалификаторыСтроки(120, ДопустимаяДлина.Переменная)));
		|ЭтиКолонки.Добавить(""ЗначениеРеквизита"");
		|МассивНедопустимыхТипов = Новый Массив;
		|МассивНедопустимыхТипов.Добавить(Тип(""ХранилищеЗначения""));
		|Для каждого КиЗ Из СтруктураРеквизитов Цикл
		|	ЗаполнитьЗначенияСвойств(ТабЗначений.Добавить(),
		|			Новый Структура(""ИмяРеквизита,ЗначениеРеквизита"", КиЗ.Ключ,
		|			?(МассивНедопустимыхТипов.Найти(ТипЗнч(КиЗ.Значение)) = Неопределено, КиЗ.Значение, ""###"" + СокрЛП(КиЗ.Значение))));
		|КонецЦикла;";
	ВызватьАлгоритмСервер(Код);
КонецПроцедуры

//@skip-check module-structure-form-event-regions
&НаСервере
Процедура ПредметОткрытьТЧНаСервере(ИмяТЧ)
	Код = "ДопТаблица = Предмет." + ИмяТЧ + ".Выгрузить()";
	ВызватьАлгоритмСервер(Код);
КонецПроцедуры

//@skip-check module-structure-form-event-regions
&НаСервере
Процедура ПредметСохранитьНаСервере()
	Код = "ПредметОбъект = Предмет.ПолучитьОбъект();
		|Для каждого Строчка Из ТабЗначений Цикл
		|	Если Лев(Строчка.ЗначениеРеквизита, 3) = ""###"" Тогда
		|		Сообщить(""Реквизит "" + Строчка.ИмяРеквизита + "" не был записан!"");
		|	Иначе
		|		Попытка
		|			ПредметОбъект[Строчка.ИмяРеквизита] = Строчка.ЗначениеРеквизита;
		|			Сообщить(""Записан "" + Строчка.ИмяРеквизита);
		|		Исключение
		|			Сообщить(""Реквизит "" + Строчка.ИмяРеквизита + "" не был записан!"");
		|		КонецПопытки;
		|	КонецЕсли; 
		|КонецЦикла;
		|ПредметОбъект.ОбменДанными.Загрузка = Истина;
		|ПредметОбъект.ДополнительныеСвойства.Вставить(""ОтключитьМеханизмРегистрацииОбъектов"", Истина);
		|ПредметОбъект.Записать();";
	ВызватьАлгоритмСервер(Код);
	Текстуёк = "ПРЕДМЕТ записан ок";
	Сообщение_ = Новый СообщениеПользователю;
	Сообщение_.Текст = Текстуёк;
	Сообщение_.Сообщить();
КонецПроцедуры

// Получает сохранённую СКД, выполняет и результат выводит в табличный документ.
//@skip-check module-structure-form-event-regions
&НаСервере
Процедура СКДвТДнаСервере()
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Настоящий.СКДвТДнаСервере(ТабДокумент, ПолучитьИзВременногоХранилища(АдресСКД), Настройки_СКД);
КонецПроцедуры // СКДвТДнаСервере

#КонецОбласти

#КонецОбласти //ОБРАБОТЧИКИКОМАНДФОРМЫ

//@skip-check module-structure-top-region
#Область СЛУЖЕБНЫЕ

#Область 	ВСПОМОГАТЕЛЬНЫЕ_ОБЩЕГО_НАЗНАЧЕНИЯ
	
// Читает асинхронно строку из файла и вызывает заданный обработчик
// Параметры:
//  Результат  - Булево - Результат обрабочика проверки существования файла
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика. Содержит параметры Обработчик___ и ИмяФайла___
&НаКлиенте
Процедура АсинхронноеЧтениеСтрокиИзФайла(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат Тогда
		ЧтениеИзФайла = Новый ТекстовыйДокумент;
		СтруктураПараметров.Обработчик___.ДополнительныеПараметры.Вставить("Текст", ЧтениеИзФайла);
		ЧтениеИзФайла.НачатьЧтение(СтруктураПараметров.Обработчик___, СтруктураПараметров.ИмяФайла___);
	Иначе
		ВыполнитьОбработкуОповещения(Новый ОписаниеОповещения(СтруктураПараметров.Обработчик___.ИмяПроцедуры + "_Н", СтруктураПараметров.Обработчик___.Модуль, СтруктураПараметров.Обработчик___.ДополнительныеПараметры), Неопределено); 
	КонецЕсли; 
КонецПроцедуры // АсинхронноеЧтениеСтрокиИзФайла

&НаСервере
Функция ИмяКолонкиДанныхЭлемента(ИмяЭлемента)
	РазобранноеИмя = СтрЗаменить(Элементы[ИмяЭлемента].ПутьКДанным, ".", Символы.ПС);
	Возврат СтрПолучитьСтроку(РазобранноеИмя, СтрЧислоСтрок(РазобранноеИмя))
КонецФункции // ИмяКолонкиДанныхЭлемента

// Читает в асинхронном режиме данные из файла и передаёт эти данные в заданный обработчик
// Параметры:
//  ИмяФайла	- Строка - Путь к файлу - источнику данных
//  Обработчик	- ОписаниеОповещения - Обработчик чтения строки из файла
//@skip-check module-unused-method
&НаКлиенте
Процедура ПрочитатьСтрокуИзФайла(ИмяФайла, Обработчик)
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Обработчик___", Обработчик);
	СтруктураПараметров.Вставить("ИмяФайла___", ИмяФайла);
	ЧтениеИзФайла = Новый Файл(ИмяФайла);
	ЧтениеИзФайла.НачатьПроверкуСуществования(Новый ОписаниеОповещения("АсинхронноеЧтениеСтрокиИзФайла", ЭтотОбъект, СтруктураПараметров));
КонецПроцедуры // ПрочитатьСтрокуИзФайла
 
#КонецОбласти

#Область 	ВЫПОЛНЕНИЕ
	
#Область 		ЗАПУСК_КОДА

// Может служить обработчиком ожидания и при этом запускает заданный алгоритм на клиенте этой формы по имени. В алгоритме будут доступны
//	переменные РезультатОповещения и ключи структуры, передаваемой при описании оповещения, в т.ч. ИмяАлгоритма
// Параметры:
//  РезультатОповещения  - Произвольный - Результат действия. Тип зависит от действия.
//  ПараметрыИзВызова  - Структура - Обязательные ключи "Алгоритмы" и "ИмяАлгоритма". Ключи структуры будут доступны в алгоритме как переменные.
&НаКлиенте
Процедура ВызватьАлгоритмОповещения(РезультатОповещения, ПараметрыИзВызова) Экспорт
	ПараметрыИзВызова.Вставить("РезультатОповещения", РезультатОповещения);
	ВызватьАлгоритмФорма(ПараметрыИзВызова.Алгоритмы[ПараметрыИзВызова.ИмяАлгоритма], ПараметрыИзВызова);
КонецПроцедуры // ВызватьАлгоритмОповещения
	
//Вызывает выполнение кода из модуля объекта или из модуля формы с сервера.
//Предполагается, что из МО выполняются только общие алгоритмы для выполнения команд КД
//и там не будет библиотек, т.к. в МО невозможно организовать клиентскую часть. Выполнение пользовательских алгоритмов
//из МО будет доступно, но без библиотек, и считается, что в порядке исключения: основной вариант
//выполнения = из формы на клиенте или на сервере.
// Параметры:
//	Код - Строка - Текст выполняемого в МО кода
//	Прм - Структура - Параметры выполнения
//	Подготовка - Булево - Требуется прочитать данные из формы в Прм (т.е. они не были прочитаны ранее)
//	НаОбъект - Булево - Выполнение будет из МО. По умолчанию Ложь.
//@skip-check export-method-in-command-form-module
&НаСервере
Процедура ВызватьАлгоритмСервер(Код, Прм = Неопределено, Подготовка = Истина, НаОбъект = Ложь) Экспорт
	Если Прм = Неопределено Тогда
		Прм = Новый Структура;
	КонецЕсли;
	Если НаОбъект Тогда
		Настоящий = Неопределено;
		ПроверитьНастоящий(Настоящий);
	КонецЕсли;
	АдресДляСтруктурыПараметров = ЗаполнитьСтруктуруПараметровС();
	Прм.Вставить("СПарам", ПолучитьИзВременногоХранилища(АдресДляСтруктурыПараметров));
	Если Подготовка Тогда
		ФлагМВТ = Элементы.Найти("ФлагИспользоватьМВТ");
		Прм.Вставить("ИспользоватьМВТ", ?(ФлагМВТ <> Неопределено, ФлагМВТ.Пометка, Ложь));
		Если НаОбъект Тогда
			Прм.Вставить("Параметры_", Параметры_.Выгрузить());
			Прм.Вставить("ФормаЭтойОбработки", ЭтотОбъект);
		КонецЕсли;
		ЗаполнитьПараметрыВыполненияИзФормыС(Прм, НаОбъект);
	КонецЕсли;
	
	Если НаОбъект Тогда
		Настоящий.ВызватьАлгоритмОбъект(Код, Прм, ?(Прм.Свойство("ДобавлятьПараметрыВКодНаОбъекте"), Прм.ДобавлятьПараметрыВКодНаОбъекте, Истина));
	Иначе
		ВыполнитьКод(Код, Прм);
	КонецЕсли;
	
	РазместитьРезультатВыполненияВРеквизитыС(Прм, Прм.ИспользоватьМВТ, Подготовка, ФлагМВТ, НаОбъект);
	Если НаОбъект Тогда
		Прм.Удалить("Параметры_");
		Прм.Удалить("ФормаЭтойОбработки");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ВызватьАлгоритмФорма(Код, Прм = Неопределено, Подготовка = Истина, ТекстПараметр = "") Экспорт
	Если Прм = Неопределено Тогда
		Прм = Новый Структура;
	КонецЕсли;
	Если Подготовка Тогда
		ФлагМВТ = Элементы.Найти("ФлагИспользоватьМВТ");
		Если ФлагМВТ <> Неопределено Тогда
			Прм.Вставить("ИспользоватьМВТ", ФлагМВТ.Пометка);
		КонецЕсли;
		Прм.Вставить("ТекстПараметр", ТекстПараметр);
		Прм.Вставить("Алгоритмы", Объект.Алгоритмы);
		Прм.Вставить("ТабЗначений", ОснДФК);
		Прм.Вставить("ДопТаблица", ДопДФК);
	КонецЕсли;
	Прм.Вставить("СПарам", ЗаполнитьСтруктуруПараметровК());
	ВыполнитьКод(Код, Прм);
	Если Подготовка Тогда
		//ЗаполнитьЗначенияСвойств(Это(), Прм, "ТекстЗапроса,ТекстКода,ТабДокумент,Предмет,Буфер");
		Если ФлагМВТ <> Неопределено Тогда
			ФлагМВТ.Пометка = Прм.ИспользоватьМВТ;
		КонецЕсли;
	КонецЕсли;
	ВыгрузитьСтруктуруПараметров(Параметры_, Прм.СПарам);
КонецПроцедуры

// Выполняет код с разбором и подготовкой
// Параметры:
//  Код  - Строка - Текст кода
//  Прм  - Структура - Параметры для алгоритма
//  ГдеВыполнять  - Строка - "Форма", "Сервер"  или (по умолчанию) "Объект"
//  ИмяНастроек  - Строка - имя настроек, загружаемых перед выполнением, по умолчанию ""
//  Подготовка  - Булево - Требуется подготовка параметровиз формы.
//  ТекстПараметр  - Строка - На клиенте - параметр, который попадёт в список параметров с ключом ТекстПараметр, по умолчанию ""
//@skip-check method-too-many-params
&НаКлиенте
Процедура ВыполнитьКодСНастройками(
		Код,
		Прм = Неопределено,
		ГдеВыполнять = "Объект",
		ИмяНастроек = "",
		Подготовка = Истина,
		ТекстПараметр = "")
	Если Прм = Неопределено Тогда
		Прм = Новый Структура;
	КонецЕсли;
	Если ЗначениеЗаполнено(ИмяНастроек) Тогда
		//@skip-check bsl-variable-name-invalid
		стрТексты = ЗагрузитьНастройкиПоИмени("СБРОСИТЬ", ИмяНастроек);
		Если ЗначениеЗаполнено(стрТексты.ТекстЗапроса) Тогда
			ВставитьТекстВЭлемент(стрТексты.ТекстЗапроса, "ТекстЗапроса");
		КонецЕсли;
		Если ЗначениеЗаполнено(стрТексты.ТекстКода) Тогда
			ВставитьТекстВЭлемент(стрТексты.ТекстКода, "ТекстКода");
		КонецЕсли;
	КонецЕсли;
	//@skip-check bsl-variable-name-invalid
	мКоды = РазобратьТекстКода(Код, ГдеВыполнять);
	Объект.Алгоритмы = мКоды[0];
	Для ЁХХ = 1 По мКоды.ВГраница() Цикл
		Если мКоды[ЁХХ].Тип = "Объект" Тогда
			ВызватьАлгоритмСервер(мКоды[ЁХХ].Код, Прм, Подготовка, Истина);
		ИначеЕсли мКоды[ЁХХ].Тип = "Сервер" Тогда
			ВызватьАлгоритмСервер(мКоды[ЁХХ].Код, Прм, Подготовка);
		ИначеЕсли мКоды[ЁХХ].Тип = "Форма" Тогда
			ВызватьАлгоритмФорма(мКоды[ЁХХ].Код, Прм, Подготовка, ТекстПараметр);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // ВыполнитьКодСНастройками

&НаСервере
Функция РазобратьТекстКода(Текст___Кода, ГдеВыполнять)
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Возврат Настоящий.РазобратьТекстКода(Текст___Кода, ГдеВыполнять);
КонецФункции // РазобратьТекстКода(Поле)

#КонецОбласти

#Область 		ЗАПУСК_КОМАНД_МЕНЮ_И_МАКЕТОВ
	
// Выполняет команду, сформулированную для меню этой формы в макете команд или в сохранённых командах
// Параметры:
//  Команда  - Команда - Выполняемая команда
//@skip-check doc-comment-type
&НаКлиенте
Процедура ВыполнитьКомандуЭтойФормы(Команда)
	//Выполнение сохранённой команды или получение параметров встроенной
	ТекИмя = Сред(Команда.Имя, 11); //В главных панелях элемент с тем же именем
	ВыполняемаяКоманда = "";
	Если КомандыСписок.Свойство(ТекИмя, ВыполняемаяКоманда) Тогда
		ВыполнитьКодСНастройками(ВыполняемаяКоманда.ТекстКоманды,, "Форма", Команда.Имя,, ВыполняемаяКоманда.ТекстПараметр);
		#Область ПОПОЛНИТЬ_ЧАКО
			Если НастройкиЧАКО.НайтиСтроки(Новый Структура("Команда", ВыполняемаяКоманда.Имя)).Количество() = 0 Тогда
				//@skip-check bsl-variable-name-invalid
				мЧАКО = Новый Массив;
				Для ЁХХ = 1 По 7 Цикл
					мПоИндексу = НастройкиЧАКО.НайтиСтроки(Новый Структура("Номер", "" + ЁХХ));
					Если мПоИндексу.Количество() = 0 Тогда
						Прервать;
					КонецЕсли;
					Если НЕ мПоИндексу[0].Фикс Тогда
						мЧАКО.Добавить(ЁХХ);
					КонецЕсли;
				КонецЦикла;
				Если ЁХХ < 8 Тогда
					мЧАКО.Добавить(ЁХХ);
				КонецЕсли;
				ВГраница = мЧАКО.ВГраница();
				Для ЁХХ = 1 По ВГраница Цикл
					Стр_Куда = НастройкиЧАКО.НайтиСтроки(Новый Структура("Номер", "" + мЧАКО[ВГраница - ЁХХ]));
					Для каждого Стр______Куда Из Стр_Куда Цикл
						Стр______Куда.Номер = мЧАКО[ВГраница - ЁХХ + 1];
					КонецЦикла;
					ЗаполнитьЗначенияСвойств(Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ + 1]], Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ]], "Картинка,Отображение");
					Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ + 1]].РасширеннаяПодсказка.Заголовок = Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ]].РасширеннаяПодсказка.Заголовок;
					Если Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ]].Заголовок = "" + мЧАКО[ВГраница - ЁХХ] Тогда
						Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ + 1]].Заголовок = "" +мЧАКО[ВГраница - ЁХХ + 1];
					Иначе
						Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ + 1]].Заголовок = Элементы["ЧАКО" + мЧАКО[ВГраница - ЁХХ]].Заголовок;
					КонецЕсли;
				КонецЦикла;
				Если мЧАКО.Количество() Тогда
					ДанныеМеню = ДанныеМенюПоКоманде(ТекИмя, "ХотКей,Картинка");
					ЁХХ = мЧАКО[0];
					Стр_Куда = НастройкиЧАКО.НайтиСтроки(Новый Структура("Номер", "" + ЁХХ));
					Стр_Куда = ?(Стр_Куда.Количество(), Стр_Куда[0], НастройкиЧАКО.Добавить());
					Стр_Куда.Фикс = Ложь;
					Стр_Куда.Номер = "" + ЁХХ;
					Стр_Куда.Заголовок = ""; //Только вручную
					Стр_Куда.Команда = ВыполняемаяКоманда.Имя;
					Стр_Куда.Подсказка = ВыполняемаяКоманда.Заголовок;
					Стр_Куда.ТекстКоманды = "";
					Стр_Куда.ХотКей = ДанныеМеню.ХотКей;
					Стр_Куда.Рисунок = ДанныеМеню.Картинка;
					Кнопа = Элементы["ЧАКО" + ЁХХ];
					Если ДанныеМеню.Картинка <> Неопределено И ДанныеМеню.Картинка.Вид <> ВидКартинки.Абсолютная Тогда
						Кнопа.Картинка = ДанныеМеню.Картинка;
					КонецЕсли;
					Если Кнопа.Картинка.Вид = ВидКартинки.Пустая Тогда
						Кнопа.Отображение = ОтображениеКнопки.Текст;
					Иначе
						Кнопа.Отображение = ОтображениеКнопки.Картинка;
					КонецЕсли;
					Кнопа.Заголовок = "" + ЁХХ;
					Кнопа.РасширеннаяПодсказка.Заголовок = ВыполняемаяКоманда.Заголовок;
					ХотКей = Новый Структура("Результат,Хоткей", "", ДанныеМеню.Хоткей);
					Сочетание = СочетаниеКлавишПоСтроке(Хоткей);
					Если Сочетание <> Неопределено Тогда
						Кнопа.СочетаниеКлавиш = Сочетание;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		#КонецОбласти
	Иначе
		Текстуёк = "" + ТекИмя + ": Текущая команда не обнаружена в списке. Возможно, это подменю.";
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Текстуёк;
		Сообщение_.Сообщить();
	КонецЕсли;
КонецПроцедуры // ВыполнитьКомандуЭтойФормы

#КонецОбласти

#КонецОбласти

#Область 	ДЕРЕВО_МЕНЮ
	
// Находит команду в меню и возвращает данные её строки дерева
// Параметры:
//  ИмяКоманды  - Строка - Имя для поиска
//  Ключи  - Строка - Ключи возвращаемой структуры
// Возвращаемое значение:
//   Структура   - с заданными ключами.
&НаСервере
Функция ДанныеМенюПоКоманде(ИмяКоманды, Ключи)
	Результат = Новый Структура(Ключи);
	ДеревоМеню = ПолучитьИзВременногоХранилища(АдресДереваМеню);
	СтрокаМеню = ДеревоМеню.Строки.Найти(ИмяКоманды, "Имя", Истина);
	Если СтрокаМеню <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(Результат, СтрокаМеню);
	КонецЕсли;
	Возврат Результат
КонецФункции // ДанныеМенюПоКоманде

// Выполняет поиск в дереве
// Параметры:
//  ИмяКоманды  - Строка - Что искат
// Возвращаемое значение:
//   Булево   - Найдена
&НаСервере
Функция ЕстьВДеревеМеню(ИмяКоманды)
	Клён = ПолучитьИзВременногоХранилища(АдресДереваМеню);
	Результат = Клён.Строки.Найти(ИмяКоманды, "Имя", Истина) <> Неопределено;
	Возврат Результат
КонецФункции // ЕстьВДеревеМеню

// Проверяет наличие ИД в меню команд и возможность его удалить.
// Возвращаемое значение:
//   Строка   - Текст вопроса перед удалением
&НаСервере
Функция ПроверитьИДвМеню(УдаляемыйИД)
	Результат = "";
	ДеревоМеню = ПолучитьИзВременногоХранилища(АдресДереваМеню);
	СтрокаКУдалению = ДеревоМеню.Строки.Найти(УдаляемыйИД, "ИД_", Истина);
	Если СтрокаКУдалению = Неопределено Тогда
		Результат = "ИД не обнаружен в меню";
	Иначе
		Родитель_ = СтрокаКУдалению.Родитель;
		Если Родитель_ = Неопределено Тогда
			Родитель_ = СтрокаКУдалению.Владелец();
		КонецЕсли;
		Если Родитель_.Строки.Количество() = 1 Тогда
			Результат = Результат + "Это единственный пункт в подменю. Удалить вместе с подменю?" + Символы.ПС;
		КонецЕсли;
		Если СтрокаКУдалению.Строки.Количество() > 0 Тогда
			Результат = Результат + "Это подменю. Удалить вместе с содержимым?" + Символы.ПС;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ПроверитьИДвМеню

// Удаляет ИД из дерева меню и сохраняет  дерево меню
// Параметры:
//  УдаляемыйИД  - Строка - ИД удаляемой команды
//  СПодменю  - Булево - УдалитьПодменю-родитель
&НаСервере
Процедура УдалитьИзДереваМеню(УдаляемыйИД, СПодменю)
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	ПоместитьВХранилищеФормы(Настоящий.УдалитьИзДереваМеню(УдаляемыйИД, СПодменю, АдресДереваМеню), АдресДереваМеню);
КонецПроцедуры // УдалитьИзДереваМеню

#КонецОбласти

#Область 	ЛИЦЕНЗИЯ
	
// Проверяет и устанавливает результат принятия соглашения
// Параметры:
//  ТолькоПринято  - Строка - Непустая = Принято = установить
// Возвращаемое значение:
//   Булево   - Соглашение не принято
&НаСервере
Функция НетПрав(ТолькоПринято = "")
	Настоящий = Неопределено; ПроверитьНастоящий(Настоящий);
	Возврат Настоящий.НетПрав(ТолькоПринято);
КонецФункции // НетПрав

// Проверяет ответ о согласии с лицензией
// Параметры:
//  Результат  - КодВозвратаДиалога - Результат обрабочика
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика
&НаКлиенте
Процедура ОбработкаОтветаОПравах(Результат, СтруктураПараметров = Неопределено) Экспорт
	Если Результат = КодВозвратаДиалога.Да Тогда
		НетПрав("40°");
	Иначе
		Закрыть(Ложь);
	КонецЕсли; 
КонецПроцедуры // ОбработкаОтветаОПравах

// Вызывает диалог о правах
&НаКлиенте
Процедура ПоказатьТекстОПравах() Экспорт
	ПоказатьВопрос(Новый ОписаниеОповещения("ОбработкаОтветаОПравах", ЭтотОбъект), ТекстПрав(), РежимДиалогаВопрос.ДаНет);
КонецПроцедуры // ПоказатьТекстОПравах

// Возвращает текст вопроса о лицензионных правах (да = согласие)
// Возвращаемое значение:
//   Строка   - Текст вопроса
&НаСервере
Функция ТекстПрав()
	Настоящий = Неопределено; ПроверитьНастоящий(Настоящий);
	Возврат Настоящий.ТекстОЛицензии();
КонецФункции // ТекстПрав

#КонецОбласти

#Область 	НАСТРОЙКИ_МЕНЮ_КОМАНДЫ_СОХРАНЕНИЕ_ВОССТАНОВЛЕНИЕ

#Область 		ПАНЕЛИ_И_КНОПЫ_ФОРМИРОВАНИЕ
	
// Создаёт командные панели формы 3.0 ок
&НаКлиенте
Процедура СформироватьКомандныеПанели()
	СформироватьПанель("КПКод", "ГруппаКода", 0);
	СформироватьПанель("КПЗапроса", "ГруппаЗапроса", 0);
	СформироватьПанель("КПСКД",  "ГруппаЗапроса", 1);
КонецПроцедуры // СформироватьКомандныеПанели
 
&НаСервере
Процедура СформироватьПанель(ИмяПанели, КудаДобавить, Позиция = Неопределено)
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Приёмник = Элементы.Найти(ИмяПанели);
	Если Приёмник = Неопределено Тогда
		Если Позиция = Неопределено Тогда
			Приёмник = Элементы.Добавить(ИмяПанели, Тип("ГруппаФормы"), Элементы[КудаДобавить]);
		Иначе
			Приёмник = Элементы.Вставить(ИмяПанели, Тип("ГруппаФормы"), Элементы[КудаДобавить], Элементы[КудаДобавить].ПодчиненныеЭлементы[Позиция]);
		КонецЕсли;
		Приёмник.Вид = ВидГруппыФормы.КоманднаяПанель;
	КонецЕсли;
	//@skip-check bsl-variable-name-invalid
	Ё = 1;
	ДеревоКомандПанели = Неопределено;
	Пока Истина Цикл
		ВсеПанели = ПолучитьИзВременногоХранилища(АдресДереваМеню);
		Если Ё > 3 Тогда
			Прервать;
		ИначеЕсли ЗначениеЗаполнено(ВсеПанели) Тогда
			ДеревоКомандПанели = ВсеПанели.Строки.Найти(ИмяПанели, "Имя", Ложь);
			Если ДеревоКомандПанели <> Неопределено Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
		МенюНастройкиИКомандыВРеквизиты(, Ложь,, Ложь);
		Ё = Ё + 1;
	КонецЦикла;
	ГруппаКнопок = СоздатьГруппуКноп(ИмяПанели + "____Гр1", Приёмник);
	Для каждого Строчка Из ДеревоКомандПанели.Строки Цикл
		ДобавитьКнопкиВПанель(ГруппаКнопок, Строчка, Настоящий, Приёмник);
	КонецЦикла; 
КонецПроцедуры // СформироватьПанель
 
&НаСервере
Функция СоздатьГруппуКноп(ИмяКнопы, КудаДобавить)
	ГруппаКнопок = Элементы.Добавить(ИмяКнопы, Тип("ГруппаФормы"), КудаДобавить);
	ГруппаКнопок.Вид = ВидГруппыФормы.ГруппаКнопок;
	//@skip-check wrong-type-expression
	ГруппаКнопок.Отображение = ОтображениеГруппыКнопок.Компактное;
	Возврат ГруппаКнопок
КонецФункции // СоздатьГруппуКноп
 
&НаСервере
//Добавляет кнопу
//	Параметры:
//	Подменю - КомПанель или подменю - приёмнкик, куда добавить
//	СтрокаДерева - Источник информации с колонками Имя, Представление, ДопИнф, Картинка, ХотКей и Подсказка
//	Обработка_ - Объект этой обработки - Для выполнения методов
//	Панель - КомПанель - для корня
Процедура ДобавитьКнопкиВПанель(Подменю, СтрокаДерева, Обработка_, Панель = Неопределено)
	НужнаКартинка = Истина;
	Если СтрокаДерева.ДопИнф = "СКРЫТЬ" Тогда
	ИначеЕсли СтрокаДерева.Строки.Количество() > 0 Тогда
		//Это подменю
		НоваяКнопа = Элементы.Добавить(СтрокаДерева.Имя, Тип("ГруппаФормы"), Подменю);
		НоваяКнопа.Заголовок = СтрокаДерева.Команда;
		НоваяКнопа.Вид = ВидГруппыФормы.Подменю;
		Для каждого Строчка Из СтрокаДерева.Строки Цикл
			ДобавитьКнопкиВПанель(НоваяКнопа, Строчка, Обработка_);
		КонецЦикла; 
	Иначе
		//Это кнопка
		Если СтрокаДерева.ДопИнф = "РАЗДЕЛИТЕЛЬ" Тогда
			Если Панель = Неопределено Тогда
				//Это подменю
				НоваяКнопа = Элементы.Добавить(СтрокаДерева.Имя, Тип("КнопкаФормы"), Подменю);
				НоваяКнопа.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели;
				НоваяКнопа.Заголовок = "--------------";
				НоваяКнопа.ИмяКоманды = "Ничего";
			Иначе
				//Это основная панель
				Подменю = СоздатьГруппуКноп(СтрокаДерева.Имя, Панель);
				НужнаКартинка = Ложь;
			КонецЕсли; 
		Иначе
			НоваяКнопа = Элементы.Добавить(СтрокаДерева.Имя, Тип("КнопкаФормы"), Подменю);
			НоваяКнопа.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели;
			ИмяКом = "Команда___" + СтрокаДерева.Имя;
			НоваяКоманда = Команды.Найти(ИмяКом);
			Если НоваяКоманда = Неопределено Тогда
				НоваяКоманда = Команды.Добавить(ИмяКом);
			КонецЕсли;
			НоваяКоманда.Действие = "ВыполнитьКомандуЭтойФормы";
			НоваяКнопа.Заголовок = ?(СтрокаДерева.Команда = "", СтрокаДерева.Имя, СтрокаДерева.Команда);
			НоваяКнопа.ИмяКоманды = ИмяКом;
			ВремСК = Обработка_.СочетаниеКлавишПоСтроке(СтрокаДерева.ХотКей);
			Если ВремСК <> Неопределено Тогда
				НоваяКнопа.СочетаниеКлавиш = ВремСК;
			КонецЕсли;
			Если СтрокаДерева.ДопИнф = "ФЛАГ" Тогда
				НоваяКнопа.Пометка = Истина;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Если НужнаКартинка Тогда
		Если ?(СтрокаДерева.Картинка = Неопределено, Истина, СтрокаДерева.Картинка.Вид = ВидКартинки.Абсолютная) Тогда
			НоваяКнопа.Отображение = ОтображениеКнопки.Текст;
		Иначе
			НоваяКнопа.Картинка = СтрокаДерева.Картинка;
		КонецЕсли; 
		НоваяКнопа.РасширеннаяПодсказка.Заголовок = СтрокаДерева.Подсказка;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти 

// Выполняет автоматический вариант сохранения текущих настроек (по умолчанию)
&НаСервере
Процедура АвтоСохранение_НастроекНаСервере()
	#Область АВТОПАРАМЕТРЫ
		ПараметрыСохранения = Новый Структура("ИмяКоманды,ИмяПодменю,Подсказка,ПредставлениеКоманды,ПредставлениеПодменю,ПутьККоманде,ПутьККартинке,ПередПосле,"
				+ "ПерезаписатьТекстЗапроса,ПерезаписатьТекстКода,СохранитьТекстКода,СохранитьТекстЗапроса,СохранитьПредмет,"
				+ "СохранитьПараметры,СохранитьКоманды,СохранитьМеню,СохранитьЧАКО,ЭтоРазделитель,СохранитьСКД,СохранитьТаб1,СохранитьТаб2,СохранитьТД,ТолькоДляМеня,ХотКей",
				"#Текущая",
				"",	"",	"",	"",	"",	"",	Неопределено, Ложь, Ложь,
				Истина, //Текст кода
				Истина,
				Истина,
				Истина,
				Ложь,  //Команды
				Ложь,
				Ложь,
				Ложь,
				Истина,
				Истина,
				Истина,
				Истина,
				Истина, "");
	#КонецОбласти
	ПараметрыСохранения.Вставить("ВХранилищеОбщих", Истина);
	ПараметрыСохранения.Вставить("ПутьСохранения", "#Текущие");
	ПараметрыСохранения.Вставить("ИнтервалАвтосохраненияВСекундах", ИнтервалАвтосохраненияВСекундах);
	ПараметрыСохранения.Вставить("Имена_Настроек", Имена_Настроек);
	Код = "Результат = ПодготовитьИСохранитьНастройки(ПутьСохранения, Прм,, ВХранилищеОбщих)";
	ВызватьАлгоритмСервер(Код, ПараметрыСохранения,, Истина);
	ПоследнееАС = ТекущаяУниверсальнаяДатаВМиллисекундах();
КонецПроцедуры // АвтоСохранение_НастроекНаСервере

&НаСервере
Функция ЗагрузитьНастройкиПоИмени(Настоящий = Неопределено, Имя = "Настройки")
	Сбросить = ПроверитьНастоящий(Настоящий);
	Результат = Настоящий.ЗагрузитьМенюНастройкиИКоманды(Новый Структура("Команды,Меню,Настройки"), "Общие", Имя, "", "");
	Результат = Настоящий.ЗагрузитьМенюНастройкиИКоманды(Результат, ИмяПользователя(), Имя, "", "");
	Если Результат.Настройки = Неопределено Тогда
		Результат = Новый Структура("ТекстЗапроса,ТекстКода", "", "");
	Иначе
		АдресНастроекФормы = ПоместитьВХранилищеФормы(Результат.Настройки, АдресНастроекФормы);
		Результат = ПрименитьНастройки(Настоящий);
	КонецЕсли;
	Сбросить = ПроверитьНастоящий(Настоящий, Сбросить);
	Возврат Результат
КонецФункции //ЗагрузитьНастройкиПоИмени

//@skip-check method-too-many-params
&НаСервере
Процедура МенюНастройкиИКомандыВРеквизиты(
		Настоящий = Неопределено,
		Команды = Истина,
		Меню = Истина,
		Настройки = Истина,
		Юзер = "",
		ИмяНастроек = "")
	Сбросить = ПроверитьНастоящий(Настоящий);
	ВсеНастройкиМенюИКоманды = Настоящий.ЗагрузитьМенюНастройкиИКоманды(, "Общие");
	ВсеНастройкиМенюИКоманды = Настоящий.ЗагрузитьМенюНастройкиИКоманды(ВсеНастройкиМенюИКоманды, ?(Юзер = "", ИмяПользователя(), Юзер),,,,, ИмяНастроек);
	Если Настройки Тогда
		АдресНастроекФормы = ПоместитьВХранилищеФормы(ВсеНастройкиМенюИКоманды.Настройки, АдресНастроекФормы);
	КонецЕсли;
	Если Команды Тогда
		КомандыСписок = ВсеНастройкиМенюИКоманды.Команды;
	КонецЕсли;
	Если Меню Тогда
		АдресДереваМеню = ПоместитьВХранилищеФормы(ВсеНастройкиМенюИКоманды.Меню, АдресДереваМеню);
	КонецЕсли;
	ИнтервалАвтосохраненияВСекундах = Настоящий.ЧтСтрукт(ВсеНастройкиМенюИКоманды, "ИнтервалАвтосохранения", 150);
	ВремИмена = Настоящий.ЧтСтрукт(ВсеНастройкиМенюИКоманды, "ИменаНастроек", Новый Соответствие);
	Если ЗначениеЗаполнено(ВремИмена) Тогда
		Имена_Настроек = ВремИмена.Скопировать(); 
	КонецЕсли;
	Сбросить = ПроверитьНастоящий(Настоящий, Сбросить);
КонецПроцедуры //МенюНастройкиИКомандыВРеквизиты

// Применяет настройки из временного хранилища к форме. Возвращает структуру данных для вставки в элементы
&НаСервере
Функция ПрименитьНастройки(Настоящий, ВсегдаПерезаписывать = Ложь)
	Сбросить = ПроверитьНастоящий(Настоящий);
	Результат = Новый Структура("ТекстЗапроса,ТекстКода", "", "");
	ДанныеНастройки = ПолучитьИзВременногоХранилища(АдресНастроекФормы); //см.МО.СтандартныйСписокНастроек
	//ДобавленныеТаблицы,ДопТаблица
	//ЕстьДобавленныеТаблицы,ЕстьДопТаблица,ЕстьМВТ,ЕстьПараметры_,ЕстьПредмет,ЕстьСКД,ЕстьТабДокумент,ЕстьТабЗначений,ЕстьТекстЗапроса,ЕстьТекКода,ЕстьЧАКО
	//МВТ,Параметры_,Предмет,СКД,НастройкиСКД,ПерезаписатьТекстЗапроса,ПерезаписатьТекстКода,ТабДокумент,ТабЗначений,ТекстЗапроса,ТекКода,ЧАКО
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьМВТ", Ложь) Тогда
		АдресМВТ = ПоместитьВХранилищеФормы(ДанныеНастройки.МВТ, АдресМВТ);
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьСКД", Ложь) Тогда
		АдресСКД = ПоместитьВХранилищеФормы(ДанныеНастройки.СКД, АдресСКД);
		АдресНастроекСКД =
				ПоместитьВХранилищеФормы(
					?(ДанныеНастройки.Свойство("НастройкиСКД"),
						ДанныеНастройки.НастройкиСКД,
						Неопределено),
					АдресНастроекСКД);
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьПараметры_", Ложь) Тогда
		Параметры_.Загрузить(ДанныеНастройки.Параметры_);
		Элементы.Параметры_.Обновить();
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьДопТаблица", Ложь) Тогда
		Настоящий.СоздатьКолонкиТаблицы(ЭтотОбъект, "ДопТаблица", ДанныеНастройки.ДопТаблица, "Загрузка");
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьТабЗначений", Ложь) Тогда
		Настоящий.СоздатьКолонкиТаблицы(ЭтотОбъект, "ТабЗначений", ДанныеНастройки.ТабЗначений, "Загрузка");
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьПредмет", Ложь) Тогда
		Предмет = ДанныеНастройки.Предмет;
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьТабДокумент", Ложь) Тогда
		ТабДокумент = ДанныеНастройки.ТабДокумент;
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьТекстЗапроса", Ложь) Тогда
		Если ВсегдаПерезаписывать ИЛИ ДанныеНастройки.ПерезаписатьТекстЗапроса Тогда
			ТекстЗапроса = ДанныеНастройки.ТекстЗапроса;
		Иначе
			Результат.Вставить("ТекстЗапроса", ДанныеНастройки.ТекстЗапроса);
		КонецЕсли;
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьТекстКода", Ложь) Тогда
		Если ВсегдаПерезаписывать ИЛИ ДанныеНастройки.ПерезаписатьТекстКода Тогда
			ТекстКода = ДанныеНастройки.ТекстКода;
		Иначе
			Результат.Вставить("ТекстКода", ДанныеНастройки.ТекстКода);
		КонецЕсли;
	КонецЕсли; 
	Если Настоящий.ЧтСтрукт(ДанныеНастройки, "ЕстьЧАКО", Ложь) Тогда
		Для каждого КиЗ Из ДанныеНастройки.ЧАКО Цикл
			СтрокиЧАКО = НастройкиЧАКО.НайтиСтроки(Новый Структура("Номер", КиЗ.Ключ));
			СтрокаЧАКО = ?(СтрокиЧАКО.Количество(), СтрокиЧАКО[0], НастройкиЧАКО.Добавить());
			СтрокаЧАКО.Номер = КиЗ.Ключ;
			ЗаполнитьЗначенияСвойств(СтрокаЧАКО, КиЗ.Значение);
			ТекЭлемент = Элементы["ЧАКО" + КиЗ.Ключ];
			ТекЭлемент.Заголовок = КиЗ.Значение.Заголовок;
			ТекЭлемент.Картинка = Настоящий.ПолучитьКартинку(КиЗ.Значение.Рисунок);
			ТекЭлемент.СочетаниеКлавиш = Настоящий.СочетаниеКлавишПоСтроке(КиЗ.Значение.ХотКей);
		КонецЦикла;
	КонецЕсли; 
	Сбросить = ПроверитьНастоящий(Настоящий, Сбросить);
	Возврат Результат
КонецФункции // ПрименитьНастройки

// Читает настройки из двоичных данных в хранилище, сохраняет их в общее хранилище и применяет
// Параметры:
//  АдресДД  - Строка - Адрес источника - двоичных данных
&НаСервере
Процедура ПрочитатьНастройкиИЗапихнутьВХранилище(АдресДД)
	ПотокЧтения = ПолучитьИзВременногоХранилища(АдресДД).ОткрытьПотокДляЧтения();
	Читалка = Новый ЧтениеXML;
	Читалка.ОткрытьПоток(ПотокЧтения);
	Корь = "http://v8.1c.ru/8.1/data/core";
	ТипОбъектаXDTO = ФабрикаXDTO.Тип(Корь,"Structure");
	//ФабрикаXDTO.ПрочитатьXML(ЧтениеXML,ТипОбъектаXDTO);
	//ОбъектXDTO = ФабрикаXDTO.ЭкспортМоделиXDTO(Корь);
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(Читалка, ТипОбъектаXDTO);
	ОбъектXDTO.Проверить();
	Читалка.Закрыть();
	ПотокЧтения.Закрыть();
	ПоместитьВоВременноеХранилище(Неопределено, АдресДД);
	СтруктураВсеНастройки = СериализаторXDTO.ПрочитатьXDTO(ОбъектXDTO);
	//СтруктураВсеНастройки = ПрочитатьXML(Читалка);
	//ПоместитьВХранилищеФормы(СтруктураВсеНастройки.Настройки, АдресНастроекФормы);
	//ПоместитьВХранилищеФормы(СтруктураВсеНастройки.Меню, АдресДереваМеню);
	//КомандыСписок = СтруктураВсеНастройки.Команды;
	Имя_Пользователя = ИмяПользователя();
	Если СтруктураВсеНастройки.Свойство("Команды") И ЗначениеЗаполнено(СтруктураВсеНастройки.Команды) Тогда
		 Для каждого КиЗКоманды Из СтруктураВсеНастройки.Команды Цикл
		 	 Если КиЗКоманды.Значение.Свойство("СтруктураНастроек") Тогда
				 ХранилищеОбщихНастроек.Сохранить(
				 		"КонсольДанных_____",
				 		"Команда___" + КиЗКоманды.Ключ,
				 		КиЗКоманды.Значение.СтруктураНастроек,,
						?(КиЗКоманды.Значение.Вид = "О", "Общие", Имя_Пользователя));
				 КиЗКоманды.Значение.Удалить("СтруктураНастроек");
			 КонецЕсли;
		 КонецЦикла;
	КонецЕсли;
	Для каждого КиЗ Из СтруктураВсеНастройки Цикл
		ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", КиЗ.Ключ, КиЗ.Значение,, Имя_Пользователя);
	КонецЦикла;
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	МенюНастройкиИКомандыВРеквизиты(Настоящий);
	ПрименитьНастройки(Настоящий, Истина);
КонецПроцедуры // ПрочитатьНастройкиИЗапихнутьВХранилище

// Сохраняет меню, команды, настройки, имена настроек и интервал автосохранения в текущие настройки общего хранилища
&НаКлиенте
Процедура СохранитьВсеТекущиеНастройки()
	АвтоСохранение_НастроекНаСервере();
КонецПроцедуры // СохранитьВсеТекущиеНастройки

// Стартует обработчик ожидания автосохранения
&НаКлиенте
Процедура СтартОжиданияАвтоСохранения()
	ПодключитьОбработчикОжидания("СохранитьВсеТекущиеНастройки", ИнтервалАвтосохраненияВСекундах);
КонецПроцедуры // СтартОжиданияАвтоСохранения

#КонецОбласти

#Область 	ПЕРЕХОД_КЛИЕНТ_СЕРВЕР_ОБЪЕКТ
	
// Возвращает в форму данные СПарам (Прм)
// Параметры:
//	ТабПараметров - ТаблицаЗначений - Приёмник данных, колонки ИмяПараметра и ЗначениеПараметра
//	Прм - Структура - Обычно возвращаемые из выполняемого блока параметры (СПарам)
&НаКлиентеНаСервереБезКонтекста
Процедура ВыгрузитьСтруктуруПараметров(ТабПараметров, Прм)
	Для каждого КиЗ Из Прм Цикл
		СтрочкиТП = ТабПараметров.НайтиСтроки(Новый Структура("ИмяПараметра", КиЗ.Ключ));
		КУдалению = Новый Массив;
		Спец = 0;
		Для каждого СтрочкаТП Из СтрочкиТП Цикл
			Если СтрочкаТП.ЗначениеПараметра = "&ТабЗначений"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&ДопТаблица"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&Предмет"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&Код"
					ИЛИ Лев(СтрочкаТП.ЗначениеПараметра, 11) = "Результат ="
					Тогда
				Спец = Спец + 1;
			Иначе
				КУдалению.Добавить(СтрочкаТП);
			КонецЕсли;
		КонецЦикла;
		Для каждого Удаляемая Из КУдалению Цикл
			ТабПараметров.Удалить(Удаляемая);
		КонецЦикла;
		Если ТипЗнч(КиЗ.Значение) = Тип("Массив") Тогда
			Для каждого Элм Из КиЗ.Значение Цикл
				НовСтрока = ТабПараметров.Добавить();
				НовСтрока.ИмяПараметра = КиЗ.Ключ;
				НовСтрока.ЗначениеПараметра = Элм;
			КонецЦикла;
		ИначеЕсли Спец <> 1 Тогда
			НовСтрока = ТабПараметров.Добавить();
			НовСтрока.ИмяПараметра = КиЗ.Ключ;
			НовСтрока.ЗначениеПараметра = КиЗ.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // ВыгрузитьСтруктуруПараметров

//Готовит параметры выполнения для запуска кода на сервере
// Параметры:
//	Настоящий - ЭтаОбработкаОббъект -
//	Прм - Структура - приёмник параметров
//	НаОбъект - Булево - Параметры создаются для выполнения алгоритма из МО, по умолчанию Ложь
&НаСервере
Процедура ЗаполнитьПараметрыВыполненияИзФормыС(Прм, НаОбъект = Ложь)
	Прм.Вставить("Алгоритмы", Объект.Алгоритмы);
	Прм.Вставить("МВТ", ЧтСтрукт(ПолучитьИзВременногоХранилища(АдресМВТ), "МВТ",, Истина));
	Прм.Вставить("Запрос_", СоздатьЗапрос(ТекстЗапроса, Прм.СПарам, ?(Прм.ИспользоватьМВТ, Прм.МВТ, Неопределено)));
	Прм.Вставить("СКД", ПолучитьИзВременногоХранилища(АдресСКД));
	Прм.Вставить("ДеревоМД", ПолучитьИзВременногоХранилища(АдресДереваМД));
	Прм.Вставить("ТабЗначений", ОснДФК.Выгрузить());
	Прм.Вставить("ДопТаблица", ДопДФК.Выгрузить());
	Если НаОбъект Тогда
		Прм.Вставить("ТекстЗапроса", ТекстЗапроса);
		Прм.Вставить("ТекстКода", ТекстКода);
		Прм.Вставить("ТабДокумент", ТабДокумент);
		Прм.Вставить("Предмет", Предмет);
		Прм.Вставить("НастройкиСКД", Настройки_СКД);
		Прм.Вставить("Буфер", Буфер);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция ЗаполнитьСтруктуруПараметровК()
	Результат = Новый Структура();
	Для Каждого Строчка Из Параметры_ Цикл
		//@skip-check empty-except-statement
		ПопыТка
			Если Строчка.ЗначениеПараметра = "&ТабЗначений" Тогда
				Результат.Вставить(Строчка.ИмяПараметра, ОснДФК);
			ИначеЕсли Строчка.ЗначениеПараметра = "&ДопТаблица" Тогда
				Результат.Вставить(Строчка.ИмяПараметра, ДопДФК);
			ИначеЕсли Строчка.ЗначениеПараметра = "&Предмет" Тогда
				Результат.Вставить(Строчка.ИмяПараметра, Предмет);
			ИначеЕсли Лев(Строчка.ЗначениеПараметра, 4) = "&Код" Тогда
				Если НЕ Результат.Свойство("___ИменаКод") Тогда
					Результат.Вставить("___ИменаКод", Новый Массив);
				КонецЕсли;
				Результат.___ИменаКод.Добавить(Строчка.ИмяПараметра);
				Результат.Вставить(Строчка.ИмяПараметра, Сред(Строчка.ЗначениеПараметра, 5));
			ИначеЕсли Лев(Строчка.ЗначениеПараметра, 11) = "Результат =" Тогда
				Если НЕ Результат.Свойство("___ИменаПрог") Тогда
					Результат.Вставить("___ИменаПрог", Новый Массив);
				КонецЕсли;
				Результат.___ИменаПрог.Добавить(Строчка.ИмяПараметра);
				Результат.Вставить(Строчка.ИмяПараметра, Строчка.ЗначениеПараметра);
			Иначе
				Результат.Вставить(Строчка.ИмяПараметра, Строчка.ЗначениеПараметра)
			КонецЕсли
		Исключение
		КонецПопытки
	КонецЦикла;
	Возврат Результат;
КонецФункции // ЗаполнитьСтруктуруПараметровК

&НаСервере
Функция ЗаполнитьСтруктуруПараметровС()
	СПарам = Новый Структура();
	Если ЗначениеЗаполнено(Параметры_) Тогда
		Для Каждого Строчка Из Параметры_ Цикл
			//@skip-check empty-except-statement
			ПопыТка
				Если Строчка.ЗначениеПараметра = "&ТабЗначений" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, ОснДФК.Выгрузить());
				ИначеЕсли Строчка.ЗначениеПараметра = "&ДопТаблица" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, ДопДФК.Выгрузить());
				ИначеЕсли Строчка.ЗначениеПараметра = "&Предмет" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, Предмет);
				ИначеЕсли Лев(Строчка.ЗначениеПараметра, 4) = "&Код" Тогда
					Если НЕ СПарам.Свойство("___ИменаКод") Тогда
						СПарам.Вставить("___ИменаКод", Новый Массив);
					КонецЕсли;
					СПарам.___ИменаКод.Добавить(Строчка.ИмяПараметра);
					СПарам.Вставить(Строчка.ИмяПараметра, Сред(Строчка.ЗначениеПараметра, 5));
				ИначеЕсли Лев(Строчка.ЗначениеПараметра, 11) = "Результат =" Тогда
					Если НЕ СПарам.Свойство("___ИменаПрог") Тогда
						СПарам.Вставить("___ИменаПрог", Новый Массив);
					КонецЕсли;
					СПарам.___ИменаПрог.Добавить(Строчка.ИмяПараметра);
					СПарам.Вставить(Строчка.ИмяПараметра, Строчка.ЗначениеПараметра);
				Иначе
					СПарам.Вставить(Строчка.ИмяПараметра, Строчка.ЗначениеПараметра)
				КонецЕсли
			Исключение
			КонецПопытки
		КонецЦикла;
	КонецЕсли;
	Возврат ПоместитьВХранилищеФормы(СПарам, АдресДляСтруктурыПараметров);
КонецФункции // ЗаполнитьСтруктуруПараметров

// помещает в хранилище по заданному адресу, если он пуст - создаёт новый. Возвращает адрес в хранилище
// Параметры:
//  ЧтоПоместить  - Произвольный - Что положить в хранилище
//  Адрес  - Строка - адрес в хранилище. Изменяется в теле функции.
// Возвращаемое значение:
//   Строка   - Адрес в хранилище формы
&НаСервере
Функция ПоместитьВХранилищеФормы(ЧтоПоместить, Адрес = Неопределено)
	Возврат ПоместитьВоВременноеХранилище(ЧтоПоместить, ?(ЗначениеЗаполнено(Адрес), Адрес, УникальныйИдентификатор))
КонецФункции // ПоместитьВХранилищеФормы

// Проверяет (если создан - не создаёт) и получает или сбрасывает объект этой обработки
// Параметры:
//  Настоящий  - Неопределено, Строка, ВнешняяОбработкаОбъект.Эта - проверяемый объект.
//	Сбросить - Булево - Объект будет сброшен. По умолчанию Ложь.
// Возвращаемое значение:
//	Булево - Истина, если в первом параметре было передано "СБРОСИТЬ".
//		Используется для последующего сброса объекта в целях предотвращения передачи на клиент.
//@skip-check doc-comment-type
&НаСервере
Функция ПроверитьНастоящий(Настоящий, Сбросить = Ложь)
	Результат = Настоящий = "СБРОСИТЬ";
	Если Сбросить Тогда
		Настоящий = Неопределено;
	ИначеЕсли Результат ИЛИ Настоящий = Неопределено Тогда
		Настоящий = РеквизитФормыВЗначение("Объект");
		Настоящий.ПриСоздании();
	КонецЕсли;
	Возврат Результат
КонецФункции // ПроверитьНастоящий

//Возвращает в форму результаты выполнения кода
&НаСервере
Процедура РазместитьРезультатВыполненияВРеквизитыС(Прм, ИспользоватьМВТ, Подготовка, ФлагМВТ, СОбъекта = Ложь)
	Если Подготовка Тогда
		ТипизироватьТаблицу(Прм.ТабЗначений);
		СоздатьКолонкиТаблицы(ЭтотОбъект, "ТабЗначений", Прм.ТабЗначений, "Загрузка");
		ТипизироватьТаблицу(Прм.ДопТаблица);
		СоздатьКолонкиТаблицы(ЭтотОбъект, "ДопТаблица", Прм.ДопТаблица, "Загрузка");
		Прм.Удалить("ТабЗначений");
		Прм.Удалить("ДопТаблица");
		Если СОбъекта Тогда
			ЗаполнитьЗначенияСвойств(ЭтотОбъект, Прм, "ТекстКода,ТабДокумент,Предмет,Буфер");
			Настройки_СКД = Прм.Настройки_СКД;
			Прм.Удалить("ТабДокумент");
			Прм.Удалить("ТекстКода");
			Прм.Удалить("Предмет");
			Прм.Удалить("Буфер");
			Прм.Удалить("НастройкиСКД");
		КонецЕсли;
		ТекстЗапроса = Прм.Запрос_.Текст;
		Если ФлагМВТ <> Неопределено Тогда
			ФлагМВТ.Пометка = ИспользоватьМВТ;
		КонецЕсли;
		АдресСКД = ПоместитьВХранилищеФормы(Прм.СКД, АдресСКД);
		АдресМВТ = ПоместитьВХранилищеФормы(Новый Структура("МВТ", Прм.МВТ), АдресМВТ);
		Прм.Удалить("Запрос_");
		Прм.Удалить("СКД");
		Прм.Удалить("МВТ");
	КонецЕсли;
	ВыгрузитьСтруктуруПараметров(Параметры_, Прм.СПарам);
	Прм.Удалить("СПарам");
	Прм.Удалить("Алгоритмы");
	Прм.Удалить("ДеревоМД");
КонецПроцедуры

#КонецОбласти

#Область 	ФОРМА_ДЕРЕВА_ПОДГОТОВКА_ВЫЗОВА
	
// Сохраняет ветвь дерева команд и возвращает адрес
// Возвращаемое значение:
//   Строка   - Адрес сохранённой ветви
&НаСервере
Функция АдресДерева_КомандДляФормы()
	ПолноеДерево = ПолучитьИзВременногоХранилища(АдресДереваМеню);
	НовоеДерево = ПолноеДерево.Скопировать();
	НовоеДерево.Строки.Очистить();
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Настоящий.СкопироватьДерево(НовоеДерево, ПолноеДерево.Строки.Найти("ДеревоКоманд", "Имя"),, Ложь,, "Результат = ДопИнф <> ""СКРЫТЬ""");
	Результат = ПоместитьВХранилищеФормы(НовоеДерево, УникальныйИдентификатор);
	Возврат Результат
КонецФункции // АдресДерева_КомандДляФормы

//Формирует начальные параметры для запуска формы дерева
&НаКлиенте
Функция НовыеПараметрыФормыДерева();
	СПараметры = Новый Структура;
	//СПараметры.Вставить("АдресДерева", "");
	//СПараметры.Вставить("АдресПроизвольногоПараметра", "");
	//СПараметры.Вставить("АдресРезультата", "");
	СПараметры.Вставить("ВозвращаемыеРеквизиты", "Имя");
	СПараметры.Вставить("ВыбиратьГруппы", Ложь);
	СПараметры.Вставить("ВыборМногих", Ложь);
	СПараметры.Вставить("ДублиСтрокОбрабатыватьКакОднуСтроку", Ложь);
	СПараметры.Вставить("ИмяКолонкиДерева", "Команда");
	СПараметры.Вставить("ИмяКолонкиФлагов", "");
	//СПараметры.Вставить("КомандыФормы", Новый Структура);
	//СПараметры.Вставить("НачальнаяПозиция", Неопределено);
	//СПараметры.Вставить("ОбработкаОбъект", Объект);
	//СПараметры.Вставить("ОбработчикВыбора, "");
	//СПараметры.Вставить("ОбработчикПриЗакрытии, "");
	//СПараметры.Вставить("ОбработчикПриОтакрытии, "");
	//СПараметры.Вставить("ОбработчикПриСоздании, "");
	СПараметры.Вставить("ОтображатьРеквизиты", "-ХотКей,Картинка,Команда");
	СПараметры.Вставить("ПоддержкаВОЛНА_Владельцем", Истина);
	СПараметры.Вставить("ПоправитьФлагиПриОткрытии", Ложь);
	СПараметры.Вставить("ПриОткрытииРаскрытьУровень1", "");
	//СПараметры.Вставить("ПроизвольныйПараметр", Неопределено);
	//СПараметры.Вставить("ПроизвольныйПараметрВХранилище", Неопределено);
	СПараметры.Вставить("РежимВыбораДерева", Истина);
	СПараметры.Вставить("РезультатВТаблицуЗначений", Ложь);
	СПараметры.Вставить("ТолькоПросмотрДерева", Истина);
	СПараметры.Вставить("ТриСостоянияВКолонкеФлагов", "Нигде");
	Возврат СПараметры
КонецФункции

&НаСервереБезКонтекста
Функция СписокПользователейИБ()
	//@skip-check bsl-variable-name-invalid
	мИмена = Новый Массив;
	Для каждого Юзер Из ПользователиИнформационнойБазы.ПолучитьПользователей() Цикл
		мИмена.Добавить(Юзер.Имя);
	КонецЦикла;
	Возврат мИмена
КонецФункции

// Удаляет из МД колонку и помещает в новый адрес
&НаСервере
Процедура ПостроитьМД_ДляВыбора()
	ДеревоМД = ПолучитьИзВременногоХранилища(АдресДереваМД).Скопировать();
	ДеревоМД.Колонки.Удалить("МД");
	АдресДерева_МД_дляВыбора = ПоместитьВХранилищеФормы(ДеревоМД, АдресДерева_МД_дляВыбора);
КонецПроцедуры // ПостроитьМД_ДляВыбора

#КонецОбласти

#КонецОбласти //СЛУЖЕБНЫЕ

//@skip-check module-structure-top-region
#Область БИБЛИОТЕКИ

// Библиотеки содержат общие методы, применимые в любой конфигурации. Пока они ориентированы
// на совсем любую конфигурацию, далее планирую ориентироваться всё же на конфигурации с БСП.
// Библиотека пригодна для разделения на 4 модуля ВОЛНА_ОбщегоНазначения: _Клиент, Сервер,
// КлиентСервер и ВызовСервера.
// При копировании в модули следует:
// 	1.Удалить все &НаКлиентеНаСервереБезКонтекста, &НаСерверебезКонтекста, &НаКлиенте, &НаСервере, &НаКлиентеБезКонтекста
// 	2.Заменить все 
// 		"//ИмяМодуляХЪ
// 		" (где ИМяМодуля = _Клиент, КлиентСервер, Сервер или ВызовСервера)
// 		на ВОЛНА_ОбщегоНазначенияИмяМодуля. (или иной префикс вместо ВОЛНА_)
// 	3.При необходимости заменить ВОЛНА_ОбщегоНазначения на другой префикс и скорректировать состав модулей.
//	Для понимания процедуры надо учитывать, что программно добиться единого кода неозможно:
//	1. ЭтотОбъект не определён вне контекста, и не находится объекта, ызыающего функции, а без объекта будет ошибка при ызоах из модуля.
//	2. Вызов без указания ЭтотОбъект. (или Модуль.) приведёт к ошибке при компиляции из модуля (даже в невыполняемом коде)
//	3. Присваивание переменным с именем как у существующего модуля (ВОЛНА_ОбщегоНазначенияСервер =...) тоже может привести к ошибке
//	4. Без контекста практически невозможно отличить форму от модуля
//	Для выполнения замен возможно применить эту функцию.
//	Параметры:
//	ТекстМодулей - Строка - Текст кода (возможно = всех модулей)
//	ТолькоПробелы - Булево - Только заменить пробелы на табуляцию
//	Возвращаемое значение:
//		Строка - Испраленный текст
//@skip-check method-too-many-params
//@skip-check module-unused-method
&НаКлиентеНаСервереБезКонтекста
Функция МодулиВолна(ТекстМодулей, ТолькоПробелы = Ложь)
	Результат =
		СтрЗаменить(ТекстМодулей, "    ", Символы.Таб);
	Если Не ТолькоПробелы Тогда
		СтарыйПрефикс = "//";
		СтарыйПостфикс = "ХЪ";
		НовыйПрефикс = "ВОЛНА_ОбщегоНазначения";
		Результат =
			СтрЗаменить(
				СтрЗаменить(
					СтрЗаменить(
						СтрЗаменить(
							СтрЗаменить(
								Результат,
								"&НаКлиентеНаСервереБезКонтекста" + Символы.ПС,
								""),
							"&НаСерверебезКонтекста" + Символы.ПС,
							""),
						"&НаКлиентеБезКонтекста" + Символы.ПС,
						""),
					"&НаКлиенте" + Символы.ПС,
					""),
				"&НаСервере" + Символы.ПС,
				"");
		СтарыйТекст = "";
		Пока СтрДлина(СтарыйТекст) = СтрДлина(Результат) Цикл
			СтарыйТекст = Результат;
			Результат = СтрЗаменить(Результат, СтарыйПостфикс + Символы.ПС, СтарыйПостфикс);
			Результат = СтрЗаменить(Результат, СтарыйПостфикс + " ", СтарыйПостфикс);
			Результат = СтрЗаменить(Результат, СтарыйПостфикс + Символы.Таб, СтарыйПостфикс);
		КонецЦикла;
		//@skip-check structure-consructor-too-many-keys
		ИменаМодулей = Новый Структура("_Клиент,ВызовСервера,КлиентСервер,Сервер");
		Для Каждого КиЗ Из ИменаМодулей Цикл
			//Для случев вызова внури кавычек
			Результат = 
				СтрЗаменить(
					Результат,
					СтарыйПрефикс + КиЗ.Ключ + СтарыйПостфикс + """",
					"""" + СтарыйПрефикс + КиЗ.Ключ + СтарыйПостфикс);
			//Основная замена
			Результат =
				СтрЗаменить(
					ТекстМодулей,
					СтарыйПрефикс + КиЗ.Ключ + СтарыйПостфикс,
					НовыйПрефикс + КиЗ.Ключ + ".");
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции

#Область 	БИБЛИОТЕКА_ФУНКЦИЙ_ВС

#Область 		ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//  ТекстКодаПараметр - Строка - Выполняемый код
//  Прм - Произвольный, Структура - параметры, по умолчанию Неопределено. Если содержит ключ
//  		"ПараметрыМетода" (Массив), тогда будет вызван серверный метод, имя которого в ТекстКодаПараметр,
//  		а ключи Прм, значения которых передадутся в метод в качестве параметров = в массиве.
//  		Если РежимВычисления Истина, будет возвращён результат метода (функции).
//  Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//  РежимВычисления - Булево - 
//  	    *Истина - к ТекстКода применяется Вычислить
//      	*Ложь - Выполнить, а возвращается значение переменной Результат.
//          По умолчанию Ложь
//  ПрямоеОбращение - Строка, Массив из Строка - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//          "-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//  Журнал - Булево - Выполнять в попытке и ошибку записать в журнал
//  ИмяПроцесса - Строка - Параметр записи журнала
//  ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке.
//  
//Возвращаемое значение:
//      Произвольный - то, что будет вычислено.
//@skip-check module-unused-method
//@skip-check doc-comment-field-type
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ВыполнитьКодНаСервере(
        ТекстКодаПараметр,
        Прм = Неопределено,
        Результат = Неопределено,
        РежимВычисления = Ложь,
        ПрямоеОбращение ="-В",
        Журнал = Ложь,
        ИмяПроцесса = "",
        ПрефиксОшибки = "")
    Результат_ = Результат;
    РежимМетода = Прм.Свойство("ПараметрыМетода");
    #Область ЗАЩИТА
        //Предполагается, что обычным пользователям доступ к выполнению функции ограничен, так как иначе УстановитьПривилегированныйРежим, и всё доступно.
        //А вот от легального входа ограниченного пользователя внешним соединением с последующим запуском этой функции нужна защита.
        //Специальная роль (которой можно и не делать) ИЛИ Запуск тонкого/толстого клиента ИЛИ Фоновое задание без пользователя.
        //Хотя внешнее соединение тоже может запустить реглзадание, и тут пока нет защиты, хотя ВС должен быть админом для запуска РЗ.
        Если РежимМетода ИЛИ ТекущийРежимЗапуска() <> Неопределено ИЛИ
                ИмяПользователя() = "" Тогда
            МожноВычислять = Истина;
        Иначе
            Попытка
                //@skip-check using-isinrole
                //@skip-check method-isinrole-role-exist
                МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
            Исключение
                МожноВычислять = Ложь;
            КонецПопытки;
        КонецЕсли;
    #КонецОбласти
    Если МожноВычислять Тогда
		КодКВыполнению = ТекстКодаПараметр;
		Если РежимМетода Тогда
			ТекстПараметров = "";
			Для Каждого ИмяПараметра Из Прм.ПараметрыМетода Цикл
				ТекстПараметров = ТекстПараметров + ", " + ИмяПараметра;
			КонецЦикла;
			КодКВыполнению = КодКВыполнению + "(" + Сред(ТекстПараметров, 3) + ")";
		КонецЕсли;
		Результат_ =
				//КлиентСерверХЪ 
				ВыполнитьКод(
	    			КодКВыполнению,
	    			Прм,
	    			Результат,
	    			РежимВычисления,
					ПрямоеОбращение,
					Журнал,
					ИмяПроцесса,
					ПрефиксОшибки);
	КонецЕсли;
    Возврат Результат_
КонецФункции

#Конецобласти

#Область 		КОЛЛЕКЦИИ

#Область 			ТАБЛИЦЫ_ЗНАЧЕНИЙ

//Загружает содержимое табличного документа в таблицу значений. Может возвращать массив структур.
//!!!Надо оптимизировать: при распознавании по ссылочному типу - распознавать колонку одним запросом.
//И читать табзначений построителем.
//Параметры:
//  ТабДокИлиExcel - ТабличныйДокумент, Строка - Источник. Колонки с пустыми заголовками не читаются.
//  		Строка рассматривается как адрес в хранилище (Префикс #, в конце = .Расширение (если нет, то XLSX)) или путь
//  		к файлу на сервере, из которого считывается	табдокумент xls, xlsx, mxl или ods.
//  		Если надо взять файл с клиента, надо предварительно его асинхронно прочитать в хранилище сервера,
//  		например, с помощью ФайлыВХранилищеНаСервере.
//  СтрокаТипов - Число, Массив из Произвольный - Номер строки, где расположены типы.
//  		0 - типы не загружаются. По умолчанию - 1. Строка типов должна содержать имя
//  		менеджера (например, Справочники.Номенклатура) или массив типов, менеджеров
//  		ссылочных значений или строк или массивов таких значений - типы колонок в порядке
//  		их следования (исключаемые колонки с пустыми заголовками не исключаются из массива
//  		(и других параметров далее)).
//  СтрокаЗаголовков - Число - Номер строки, содержащей заголовки колонок. По умолчанию - 2
//  СтрокаДанных - Число - Номер строки, с которой начинаются данные. По умолчанию = 3
//  Типизировать - Булево - Если Истина (Только для ТЗ на сервере), то колонки будут типизированы, что необходимо для использования ТЗ в параметре запроса и удобно для ручного выбора значения. По умолчанию = Ложь
//  Ширина - Число - Ширина таблицы в ТД. По умолчанию = 0, в этом случае определяется автоматически.
//  Высота - Число - Номер последней строки от начала ТД, используемой загрузки данных. По умолчанию 0. В этом случае загружается вся таблица.
//  Распознавание - Число -
//          > 0 - не распознавать
//          > 1 - распознавание только при заданном типе
//          > 2 - распознавание всегда (по умолчанию)
//          Распознавание простых типов - на общих основаниях.
//  СтрокаРеквизита - Число - Номер строки, в которой содержится имя реквизита, по которому распознаётся значение. По умолчанию = 0, реквизит определяется автоматически.
//  СтрокаРодитель - Число - Номер строки, в которой содержится имя колонки родителя, с учётом которого должен вестись поиск. По умолчанию = 0, родитель не учитывается.
//          Колонку родителя надо размещать левее подчинённой колонки.
//  СтрокаВладелец - Число - Номер строки, в которой содержится имя колонки владельца, с учётом которого должен вестись поиск. По умолчанию = 0, владелец не учитывается.
//          Колонку владельца надо размещать левее подчинённой колонки.
//  Подстановки - Строка, Структура - Ключи = Имена колонок, Значения = Соответствия с клюами ЧтоМенять и значениями НаЧтоМенять. Ключ "ВСЕ___КОЛОНКИ" = замена по всем колонкам.
//          По умолчанию = Неопределено, и замен нет. Далее в соответствиях накапливаются знания о распознанных значениях - по каждой колонке и общие. Если не надо накапливать, 
//          а каждый раз распознавать заново, надо создать ключ соответствий "КЭШ___" со значениями "ТОЛЬКО_КОЛОНКА", "ТОЛЬКО_ОБЩИЕ" или "НЕТ". "НЕТ" во ВСЕ___КОЛОНКИ полностью отключит кэширование.
//          После замены распознавание не производится.
//  ПослеРаспознавания - Строка, Массив из Строка - Обработчик(и (для каждой колонки)) после распознавания значения. По умолчанию "" - обработчика нет.
//          В Результат передаётся распознанное значение. Структура Прм имеют ключи (в обработчике обращение по ключам, без Прм):
//          *РазныеИмена - Произвольный - Заданные при вызове = см.Прм,
//          *РазныеИмена - Произвольный - Доназначенные в обработчике, (далее - ключи, автообновляемые для каждого значения/колонки)
//          *ИсходноеЗначение - Строка - распознаваемый текст
//          *Типы - Массив из Тип - допустимые типы
//          *ИмяКолонки - Строка
//          *ТекДанные - СтрокаТаблицыЗначений, Структура - редактируемая строка таблицы
//          *Таблица - ТаблицаЗначений, Массив из Структура - ссылка на таблицу в целом
//          *ПодстановкаПоКолонке - Соответствие из Произвольный - накопитель распознанных значений в колонке; наличие в соответствии автопроверяется и автоустанавливантся до обработчика;
//              после обрабочика - переустанавливается (согласно параметру Подстановки));
//          *Получен - Строка - ("НЕТ", "РАСПОЗНАН", "ИЗ_ОБЩЕЙ", или "ПО_КОЛОНКЕ")
//          *ОбщаяПодстановка - Строка - (то же, но по всем колонкам - см. Подстановки);
//          *Родитель - Строка - имя колонки родителя
//          *Владелец - Строка - имя колонки владельца
//  Прм - Структура - параметры, передаваемые в обработчики ПослеРаспознавания
//  ТипизацияКолонок - Массив из ОписаниеТипов - (Только для ТЗ на сервере) = Карта предварительной типизации колонок. Размерность строго по количеству колонок. Элементами м.б.:
//          > ОписаниеТипов - присвоится колонке при её создании
//          > Строка - "ПоТипу" = Тип будет определён по строке типов
//          > Остальные значения игнорируются и тип не присваивается.
//          > По умолчанию Неопределено - типизации нет.
//  ЗначенияНераспознанных - Произвольный -
//  		> Массив из Произвольный - по числу колонок, значения для каждой колонки берутся из элемента.
//          > Произвольный - Любое другое значение подставляется, если не распознано.
//          > ПоУмолчанию - Строка - "!_НЕ_НУЖНЫ_!" = берётся распознаваемая строка.
//          > "!_НЕ_НУЖНЫ_!" как элемент массива означает отмену замены нераспознанных в колонке.
//  НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//  СообщатьОКолонках - Булево - По умолчанию Ложь. Включает вывод сообщения после загрузки колонки.
//  СообщатьСюда - Строка, Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
//  ТипРезультата - Строка -
//  	> ТаблицаЗначений - по умолчанию кроме веб, тонкого и мобильного клиентов, иначе - недоступно
//  	> МассивСтруктур
//  	> Адрес - по умолчанию на веб, тонком и мобильном клиенте
//  	> Иное значение рассматривается как адрес хранилища.
//  СпособЧтения - СпособЧтенияЗначенийТабличногоДокумента - параметр чтения таблицы из Excel. По умолчанию Значение.
//  ОбластьЧтения - Строка - Имя области, из которой надо прочитать данные/листа Excel. По умолчанию пустая строка - чтение из всего ТД.
//Возвращаемое значение:
//  ТаблицаЗначений, Массив из Структура - загруженная из ТД с распознаванием значений
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-field-in-description-suggestion
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(
        ТабДокИлиExcel,
        СтрокаТипов = 1,
        СтрокаЗаголовков = 2,
        СтрокаДанных = 3,
        Типизировать = Ложь,
        Ширина = 0,
        Высота = 0,
        Распознавание = 2,
        СтрокаРеквизита = 0,
        СтрокаРодитель = 0,
        СтрокаВладелец = 0,
        Подстановки = Неопределено,
        ПослеРаспознавания = "",
        Прм = Неопределено,
        ТипизацияКолонок = Неопределено,
        ЗначенияНераспознанных = "!_НЕ_НУЖНЫ_!",
        НеРаспознаватьУИДБезТипа = Ложь,
        СообщатьОКолонках = Ложь,
        СообщатьСюда = Неопределено,
        ТипРезультата = "ТаблицаЗначений",
        СпособЧтения = Неопределено,
        ОбластьЧтения = "") Экспорт
    Результат = Неопределено;
	#Область ИНИЦИАЛИЗАЦИЯ
	    ТипМассив = Тип("Массив");
	    ТипТип = Тип("Тип");
	    ТипСтрока = Тип("Строка");
	    ПоСтроке = ТипЗнч(ТабДокИлиExcel) = ТипСтрока;
	    Если ПоСтроке Тогда
	    	Расширение =
	    			ВРег(
	    				//КлиентСерверХЪ
	    				РасширениеПути(ТабДокИлиExcel));
	    	ДлРасш = СтрДлина(Расширение);
	    	Если Расширение <> "MXL" И Расширение <> "XLS" И Расширение <> "ODS" Тогда
	    		Расширение = "XLSX";
	    	КонецЕсли;
	    	Префикс = Лев(ТабДокИлиExcel, 1);
	    	Если Префикс = "#" Тогда
	    		ДанныеДляЧтения = ПолучитьИзВременногоХранилища(Сред(ТабДокИлиExcel, 2, СтрДлина(ТабДокИлиExcel) - ДлРасш - 2));
	    	Иначе
	    		ДанныеДляЧтения = ТабДокИлиExcel;
	    	КонецЕсли;
	    	ТаблДокумент =
	    			//КлиентСерверХЪ
	    			ТДизExcel(ДанныеДляЧтения, Расширение);
	    Иначе
	        ТаблДокумент = ТабДокИлиExcel;
	    КонецЕсли;
	    Если СпособЧтения = Неопределено Тогда
	        СпособЧтения = СпособЧтенияЗначенийТабличногоДокумента.Значение;
	    КонецЕсли;
	    Если ЗначениеЗаполнено(ОбластьЧтения) Тогда
	        ТаблДокумент = ТаблДокумент.ПолучитьОбласть(ОбластьЧтения);
	    КонецЕсли;
	    ТекШирина_ = ?(Ширина = 0, ТаблДокумент.ШиринаТаблицы, Ширина);
	    ТекВысота_ = ?(Высота = 0, ТаблДокумент.ВысотаТаблицы, Высота);
	    Если ТипРезультата = "МассивСтруктур" Тогда
	        Результат = Новый Массив;
	        Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
	            НоваяСтрока_ = Новый Структура;
	            Результат.Добавить(НоваяСтрока_);
	        КонецЦикла;
	    Иначе
	        //@skip-check server-execution-safe-mode
	        Результат = Вычислить("Новый ТаблицаЗначений");
	        Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
	            НоваяСтрока_ = Результат.Добавить();
	        КонецЦикла;
	    КонецЕсли;
	    МассивТиповГотов = ТипЗнч(СтрокаТипов) = ТипМассив;
	    ЕстьОбработчик = ПослеРаспознавания <> "";
	    ЕстьУмолчаниЯ = ?(ТипЗнч(ЗначенияНераспознанных) = Тип("Массив"), ЗначенияНераспознанных.Количество() = ТекШирина_, Ложь);
	    ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	    Если СообщатьОКолонках Тогда
	        ТекстСообщения = "Старт загрузки: " + ТекущаяДатаСеанса();
	        Если ЕстьСтрокаТабло Тогда
	            СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
	        Иначе
	        	Сообщение = Новый СообщениеПользователю;
	        	Сообщение.Текст = ТекстСообщения;
	        	Сообщение.Сообщить();
	        КонецЕсли;      
	    КонецЕсли;
	    Если Подстановки = Неопределено Тогда
	    	Подстановки = Новый Структура;
	    КонецЕсли;
	    ЕстьОбщиеПодстановки = Подстановки.Свойство("ВСЕ___КОЛОНКИ");
	    ОбщийКэш = ?(ЕстьОбщиеПодстановки, Подстановки.ВСЕ___КОЛОНКИ, Новый Соответствие);
	    ОбщееКэширование = ?(ЕстьОбщиеПодстановки, Подстановки.ВСЕ___КОЛОНКИ["КЭШ___"], Неопределено);
	    ЕстьОбщиеПодстановки = ЗначениеЗаполнено(ОбщийКэш);
	    УстановитьБезопасныйРежим(Истина);
    #КонецОбласти
    #Область ЧТЕНИЕ
		Для СчКол = 0 По ТекШирина_ - 1 Цикл
	        Сч1 = СчКол + 1;
	        ТекИмяК = ТаблДокумент.Область(СтрокаЗаголовков, Сч1).Текст;
	        Если ТекИмяК <> "" Тогда
	            Если ТипРезультата <> "МассивСтруктур" Тогда
	                #Область ТИПЫ_КОЛОНКИ
	                    ЕстьТипы = Истина;
	                    ТекТипМ = Новый Массив; //Массив менеджеров
	                    ТекТипТ = Новый Массив; //Массив типов для типизации колонки
	                    Если МассивТиповГотов Тогда
	                        КОбработке = СтрокаТипов[СчКол];
	                        Если КОбработке = "" Тогда
	                            КОбработке = Новый Массив;
	                            ЕстьТипы = Ложь;
	                        ИначеЕсли ТипЗнч(КОбработке) = ТипСтрока Тогда
	                            КОбработке = СтрРазделить(КОбработке, ",", Истина);
	                        ИначеЕсли ТипЗнч(КОбработке) = ТипМассив Тогда
	                        ИначеЕсли ТипЗнч(КОбработке) = ТипТип Тогда
	                            ТекМенеджер =
	                            		//КлиентСерверХЪ
	                            		ЕслиПервоеВтороеРавныТоТретьеИначеПервое(
	                            			ИмяТаблицыОбъектаПоТипу(КОбработке, "Менеджер"),
	                            			Неопределено,
	                            			КОбработке);
	                            ТекТипТ.Добавить(КОбработке);
	                            ТекТипМ.Добавить(ТекМенеджер);
	                            КОбработке = Новый Массив;
	                        Иначе
	                            //Считаем, что это менеджер ссылки
	                            ТекТипМ.Добавить(КОбработке);
	                            ТекТипТ.Добавить(ТипЗнч(КОбработке.ПустаяСсылка()));
	                            КОбработке = Новый Массив;
	                        КонецЕсли;
	                    ИначеЕсли СтрокаТипов = 0 Тогда
	                        КОбработке = Новый Массив;
	                        ЕстьТипы = Ложь;
	                    Иначе
	                        //Тип представлен строкой. Возможно перечисление через запятую.
	                        СтрокиМенеджеров = ТаблДокумент.Область(СтрокаТипов, Сч1).Текст;
	                        Если СтрокиМенеджеров = "" Тогда
	                            КОбработке = Новый Массив;
	                            ЕстьТипы = Ложь;
	                        Иначе
	                            КОбработке = СтрРазделить(СтрокиМенеджеров, ",", Истина);
	                        КонецЕсли;
	                    КонецЕсли;
	                    Если ЕстьТипы Тогда
	                        Для каждого СтрочкаДляОпределенияТипа Из КОбработке Цикл
	                            Попытка
	                                ТекМенеджер = Вычислить(СтрочкаДляОпределенияТипа);
	                                ТекТип = ТипЗнч(ТекМенеджер.ПустаяСсылка());
	                            Исключение
	                                ТекТип = Тип(СтрочкаДляОпределенияТипа);
	                                ТекМенеджер =
	                                		//КлиентСерверХЪ
	                                		ЕслиПервоеВтороеРавныТоТретьеИначеПервое(
	                                			ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер"),
	                                			Неопределено,
	                                			ТекТип);
	                            КонецПопытки;
	                            ТекТипМ.Добавить(ТекМенеджер);
	                            ТекТипТ.Добавить(ТекТип);
	                        КонецЦикла;
	                    КонецЕсли; 
	                    Если ТипизацияКолонок <> Неопределено Тогда
	                        ТекОТКолонки = ТипизацияКолонок[СчКол];
	                        ТекТипОТ = ТипЗнч(ТекОТКолонки);
	                        ТекОТКолонки = ?(ТекОТКолонки = "ПоТипу", ?(ЕстьТипы, Новый ОписаниеТипов(ТекТипТ), Неопределено),
	                                ?(ТекТипОТ = Тип("ОписаниеТипов"), ТекОТКолонки,
	                                ?(ТекТипОТ = ТипМассив, Новый ОписаниеТипов(ТекОТКолонки),
	                                ?(ТекТипОТ = ТипТип, Новый ОписаниеТипов(ПреобразоватьВМассив(ТекОТКолонки)), Неопределено))));
	                    Иначе
	                        ТекОТКолонки = Неопределено;
	                    КонецЕсли;
	                    ТекТип = ?(ЕстьТипы, ТекТипМ, "");
	                #КонецОбласти 
	                #Область ДОБАВЛЕНИЕ_КОЛОНКИ
	                    Если ТекОТКолонки = Неопределено Тогда
	                        Результат.Колонки.Добавить(ТекИмяК);
	                    Иначе
	                        Результат.Колонки.Добавить(ТекИмяК, ТекОТКолонки);
	                    КонецЕсли;
	                #КонецОбласти 
	            КонецЕсли;
				#Область ПОДГОТОВКА_РАСПОЗНАВАНИЯ
		            Если СтрокаРеквизита = 0 Тогда
		                ТекИмяРеквизита = "";
		            Иначе
		                ТекИмяРеквизита = ТаблДокумент.Область(СтрокаРеквизита, Сч1).Текст;
		            КонецЕсли;
		            Если СтрокаРодитель = 0 Тогда
		                ТекРодитель = "";
		            Иначе
		                ТекРодитель = ТаблДокумент.Область(СтрокаРодитель, Сч1).Текст;
		            КонецЕсли;
		            Если СтрокаВладелец = 0 Тогда
		                ТекВладелец = "";
		            Иначе
		                ТекВладелец = ТаблДокумент.Область(СтрокаВладелец, Сч1).Текст;
		            КонецЕсли;
		            ТекУмолчание = ?(ЕстьУмолчаниЯ, ЗначенияНераспознанных[СчКол], ЗначенияНераспознанных);
		            ЕстьТекУмолчание = ТекУмолчание <> "!_НЕ_НУЖНЫ_!";
		            КЭШ_Колонки = ?(Подстановки.Свойство(ТекИмяК), Подстановки[ТекИмяК], Новый Соответствие);
		            ЕстьПодстановкиПоКолонке = ЗначениеЗаполнено(КЭШ_Колонки);
		            КэшироватьКолонку =
		            		КЭШ_Колонки["КЭШ___"] = "ТОЛЬКО_КОЛОНКА" ИЛИ КЭШ_Колонки["КЭШ___"] = "ВЕЗДЕ" ИЛИ
		            		КЭШ_Колонки["КЭШ___"] = Неопределено И (ОбщееКэширование = "ТОЛЬКО_КОЛОНКА" ИЛИ ОбщееКэширование = "ВЕЗДЕ" ИЛИ ОбщееКэширование = Неопределено);
		            КэшироватьОбщие =
		            		КЭШ_Колонки["КЭШ___"] = "ТОЛЬКО_ОБЩИЕ" ИЛИ КЭШ_Колонки["КЭШ___"] = "ВЕЗДЕ" ИЛИ
		            		КЭШ_Колонки["КЭШ___"] = Неопределено И (ОбщееКэширование = "ТОЛЬКО_ОБЩИЕ" ИЛИ ОбщееКэширование = "ВЕЗДЕ" ИЛИ ОбщееКэширование = Неопределено);
				#КонецОбласти
	            Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
	                ТекЗнч = ТаблДокумент.Область(СчСтр, Сч1).Текст;
	                НоваяСтрока_ = Результат[СчСтр - СтрокаДанных];
	                Получен = "НЕТ";
	                Если ЕстьПодстановкиПоКолонке Тогда
	                    РезультатРаспознавания = КЭШ_Колонки[ТекЗнч];
	                КонецЕсли;
	                Если РезультатРаспознавания = Неопределено Тогда
	                    Если ЕстьОбщиеПодстановки И КэшироватьОбщие Тогда
	                        РезультатРаспознавания = ОбщийКэш[ТекЗнч];
	                    КонецЕсли;
	                    Если РезультатРаспознавания = Неопределено Тогда
	                        Если (Распознавание = 0) ИЛИ ((ТекТип = "") И (Распознавание = 1)) Тогда
	                            РезультатРаспознавания = ТекЗнч;
	                        Иначе
	                            РезультатРаспознавания = РаспознатьЗначение(
	                            		ТекЗнч,
	                            		ТекТип,
	                                    ?(СтрокаРеквизита = 0, "", ТекИмяРеквизита),
	                                    ?(ТекРодитель = "", Неопределено, НоваяСтрока_[ТекРодитель]),
	                                    ?(ТекВладелец = "", Неопределено, НоваяСтрока_[ТекВладелец]),,
	                                    Истина);
	                            Если (РезультатРаспознавания = ТекЗнч) И ЕстьТекУмолчание Тогда
	                                РезультатРаспознавания = ТекУмолчание;
	                            КонецЕсли;
	                        КонецЕсли;
	                        Получен = "РАСПОЗНАН";
	                    Иначе
	                        Получен = "ИЗ_ОБЩЕЙ";
	                    КонецЕсли;
	                Иначе
	                    Получен = "ПО_КОЛОНКЕ"
	                КонецЕсли;
	                Если ЕстьОбработчик Тогда
	                    Если Прм = Неопределено Тогда
	                        Прм = Новый Структура;
	                    КонецЕсли;
	                    //@skip-check structure-consructor-too-many-keys
	                    ПараметрыОбработчика =
	                            //КлиентСерверХЪ
	                            ДополнитьСтруктуру(
	                               	Новый Структура("ИсходноеЗначение,Типы,ИмяКолонки,Таблица,ПодстановкаПоКолонке,ОбщаяПодстановка,Родитель,Владелец,Получен,ТекДанные",
	                                   	ТекЗнч, ТекТип, ТекИмяК, Результат, КЭШ_Колонки, ОбщийКэш, ТекРодитель, ТекВладелец, Получен, НоваяСтрока_),
	                               	Прм);
	                    РезультатРаспознавания =
	                    		//КлиентСерверХЪ
	                    		ВыполнитьКод(
			                    	ПослеРаспознавания,
	    		                	ПараметрыОбработчика,
	            		        	РезультатРаспознавания);
	                    Получен = "ВЫЧИСЛЕН";
	                КонецЕсли;
	                Если Получен = "РАСПОЗНАН" ИЛИ Получен = "ВЫЧИСЛЕН" Тогда
	                    Если КэшироватьОбщие Тогда
	                        ОбщийКэш.Вставить(ТекЗнч, РезультатРаспознавания);
	                        ЕстьОбщиеПодстановки = Истина;
	                    КонецЕсли;
	                    Если КэшироватьКолонку Тогда
	                        КЭШ_Колонки.Вставить(ТекЗнч, РезультатРаспознавания);
	                        ЕстьПодстановкиПоКолонке = Истина;
	                    КонецЕсли;
	                КонецЕсли;
	                Если ТипРезультата = "МассивСтруктур" Тогда
	                    НоваяСтрока_.Вставить(ТекИмяК, РезультатРаспознавания);
	                Иначе
	                    НоваяСтрока_[ТекИмяК] = РезультатРаспознавания;
	                КонецЕсли;
	            КонецЦикла  
	        КонецЕсли;
	        Если СообщатьОКолонках Тогда
	            ТекстСообщения = "Загружено " + ТекИмяК + ": " + ТекущаяДатаСеанса();
	            Если ЕстьСтрокаТабло Тогда
	                СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
	            Иначе
	            	Сообщение = Новый СообщениеПользователю;
	            	Сообщение.Текст = ТекстСообщения;
	            	Сообщение.Сообщить();
	            КонецЕсли;      
	        КонецЕсли;
	    КонецЦикла; 
    #КонецОбласти
    #Область ТИПИЗАЦИЯ
	    Если Типизировать И ТипРезультата <> "МассивСтруктур" Тогда
    		//СерверХЪ
			ТипизироватьТаблицу(Результат);
	        Если СообщатьОКолонках Тогда
	            ТекстСообщения = "Таблица типизирована: " + ТекущаяДатаСеанса();
	            Если ЕстьСтрокаТабло Тогда
	                СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
	            Иначе
	                Сообщение = Новый СообщениеПользователю;
	                Сообщение.Текст = ТекстСообщения;
	                Сообщение.Сообщить();
	            КонецЕсли;      
	        КонецЕсли;
	    КонецЕсли;
    #КонецОбласти
    #Область ПОМЕЩЕНИЕ_В_ХРАНИЛИЩЕ
	 	Если ТипРезультата <> "МассивСтруктур" И ТипРезультата <> "ТаблицаЗначений" Тогда
		    Если ТипРезультата = "Адрес" Тогда
		    	Результат = ПоместитьВоВременноеХранилище(Результат);
		    Иначе
		    	Результат = ПоместитьВоВременноеХранилище(Результат, ТипРезультата);
		    КонецЕсли;
	    КонецЕсли;
    #КонецОбласти
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции //ЗагрузитьТаблицуЗначенийИзТабличногоДокумента

// В таблице значений заменяет пустые значения на значения по умолчанию из структуры
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Произвольная
//  ЗначенияПоУмолчанию  - Структура - Ключи совпадают с именами колонок, где будет замена. Значения - новые значения.
//  ПрефиксФормулы - Строка - значение, начинающееся с этой строки, считается формулой. Обращение к данным строки через Строчка.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию(ТабЗн, ЗначенияПоУмолчанию, ПрефиксФормулы = "FRML") Экспорт
    ДлинаПрефикса = СтрДлина(ПрефиксФормулы);
    УстановитьБезопасныйРежим(Истина);
    Для каждого Строчка Из ТабЗн Цикл
        Для каждого КиЗ Из ЗначенияПоУмолчанию Цикл
            Если НЕ ЗначениеЗаполнено(Строчка[КиЗ.Ключ]) Тогда
                Строчка[КиЗ.Ключ] = ?(Лев(КиЗ.Значение, ДлинаПрефикса) = ПрефиксФормулы, Вычислить(Сред(КиЗ.Значение, ДлинаПрефикса + 1)), КиЗ.Значение);
            КонецЕсли; 
        КонецЦикла; 
    КонецЦикла; 
КонецПроцедуры // ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию()

#КонецОбласти

#КонецОбласти

#Область 		МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
    
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим уже д.б. проверен. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//  ИмяФайла - Строка - Полный путь к файлу обработки;
//  Параметры_ - Структура - Параметры выполнения, передаваемые в метод.
//Возвращаемое значение;
//  Произвольный - Результат, возвращаемый методом
&НаСервереБезКонтекста
Функция ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_)
    ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяФайла);
    Возврат ВнешняяОбработка.ЗапуститьМенеджер(Параметры_);
КонецФункции
 
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим проверяется этой функцией. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//  ИмяФайла - Строка - Полный путь к файлу обработки;
//  Параметры_ - Структура - Параметры выполнения, передаваемые в метод. В ключе "ОписаниеОшибки" возвращается строка - список ошибок выполнения.
//Возвращаемое значение;
//  Произвольный - Результат, возвращаемый методом. При ошибке - Неопределено.
&НаСервереБезКонтекста
Функция ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, Параметры_)
    Если БезопасныйРежим() Тогда
        Результат = Неопределено;
        ДобавитьОшибку(Параметры_, "В безопасном режиме нельзя прочитать " + ИмяФайла);
    Иначе
        Попытка
            Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_);
        Исключение
            Результат = Неопределено;
            ООШ = ОписаниеОшибки();
            ДобавитьОшибку(Параметры_, "Обработка " + ИмяФайла + " не была выполнена по причине:" + ООШ);
        КонецПопытки;
    КонецЕсли;
    Возврат Результат;
КонецФункции

//Возвращает результат распознавания строкового значения
//Параметры:
//  Значение_ - Строка - Распознаваемое значение в строковом выражении
//  ТипыИлиМенеджеры - Менеджер ссылочного значения или массив таких менеджеров или тип/массивТипов - типы, в которых ищется ссылочное значение. Если опущен, то возвращается простое нессылочное значение.
//  ПоРеквизиту - Строка - Имя реквизита, в котором ищется значение.
//  Родитель - ЛюбаяСсылка - Если требуется поиск по родителю, то задавать сюда. По умолчанию Неопределено (поиск не используется). Для поиска документа по номеру в этот реквизит надо поместить дату.
//  Владелец - ЛюбаяСсылка - Если требуется поиск по владельцу, то задавать сюда. По умолчанию Неопределено (поиск не используется)
//  АпострофЭтоСтрока - Булево - По умолчанию Истина. Значение, начинающееся с апострофа, будет считаться строкой.
//  НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//Возвращаемое значение:
//  Произвольный - Распознанное значение
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция РаспознатьЗначение(
		Значение_,
		ТипыИлиМенеджеры = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		АпострофЭтоСтрока = Истина,
		НеРаспознаватьУИДБезТипа = Ложь) Экспорт
    Результат = Значение_;
    ВРЕГ_ = Врег(Значение_);
    Если АпострофЭтоСтрока И Лев(ВРЕГ_, 1) = "'"  Тогда
        Результат = Сред(Значение_, 2);
    Иначе
        Распознан = Ложь;
        ЭтоСтрока = Ложь;
        ЭтоЧисло = Ложь;
        ЭтоДата = Ложь;
        ЭтоБулево = Ложь;
        ЭтоУниверсал = ТипыИлиМенеджеры = "";
        Если НЕ ЭтоУниверсал Тогда
			МТиМ =
					//КлиентСерверХЪ
					ПреобразоватьВМассив(ТипыИлиМенеджеры);
            ТипТип = Тип("Тип");
            ТипСтрока = Тип("Строка");
            ТипДата = Тип("Дата");
            ТипЧисло = Тип("Число");
            ТипБулево = Тип("Булево");
            Для каждого ТекТиМ Из мТиМ Цикл
            	#Область УЗНАТЬ_ТИП_ПРОСТОЙ_ИЛИ_ССЫЛОЧНЫЙ
	                ТекТип = ТипЗнч(ТекТиМ);
	                ОбработатьТип = Ложь;
	                Если ТекТип = ТипСтрока Тогда
	                    ВР_Т = Врег(ТекТиМ);
	                    Если ВР_Т = "СТРОКА" Тогда
	                        ЭтоСтрока = Истина;
	                    ИначеЕсли ВР_Т = "БУЛЕВО" Тогда
	                        ЭтоБулево = Истина;
	                    ИначеЕсли ВР_Т = "ЧИСЛО" Тогда
	                        ЭтоЧисло = Истина;
	                    ИначеЕсли ВР_Т = "ДАТА" Тогда
	                        ЭтоДата = Истина;
	                    Иначе
	                        ОбработатьТип = Истина;
	                    КонецЕсли;
	                Иначе
	                    Если ТекТиМ = ТипСтрока Тогда
	                        ЭтоСтрока = Истина;
	                    ИначеЕсли ТекТиМ = ТипБулево Тогда
	                        ЭтоБулево = Истина;
	                    ИначеЕсли ТекТиМ = ТипЧисло Тогда
	                        ЭтоЧисло = Истина;
	                    ИначеЕсли ТекТиМ = ТипДата Тогда
	                        ЭтоДата = Истина;
	                    Иначе
	                        ОбработатьТип = Истина;
	                    КонецЕсли;
	                КонецЕсли;
            	#КонецОбласти
                Если ОбработатьТип Тогда
                	#Область ССЫЛОЧНЫЙ_ТИП
	                    Если ТекТип = ТипТип Тогда
							Менеджер = ИмяТаблицыОбъектаПоТипу(ТекТиМ, "Менеджер");
	                    ИначеЕсли ТекТип = ТипСтрока Тогда
			                //@skip-check server-execution-safe-mode
	                        Менеджер = Вычислить(ТекТиМ);
	                    Иначе
	                        Менеджер = ТекТиМ;
	                    КонецЕсли; 
	                    ТипМенеджера = СтрПолучитьСтроку(СтрЗаменить(Менеджер, ".", Символы.ПС), 1);
						ЭтоУИД_ =
								//КлиентСерверХЪ
								ПреобразоватьВМассив(ТипыИлиМенеджеры);
	                    Если ЭтоУИД_ Тогда
	                        ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение_));
	                        Если Лев(Строка(ТекСсылка), 18) = "<Объект не найден>" Тогда
	                            ЭтоУИД_ = Ложь
	                        Иначе
	                            Результат = ТекСсылка
	                        КонецЕсли
	                    КонецЕсли;
	                    Если НЕ ЭтоУИД_ И (Менеджер <> Неопределено) Тогда
	                        Если ТипМенеджера = "ПеречислениеМенеджер" Тогда //"Перечисления"
	                            //Перечисления грузим особо
	                            Результат = Менеджер.ПустаяСсылка();
	                            Если НЕ ПустаяСтрока(Значение_) Тогда
	                                ЗначенияП = Результат.Метаданные().ЗначенияПеречисления;
	                                ЗначениеПеречисления = ЗначенияП.Найти(Значение_);
	                                Если ЗначениеПеречисления = Неопределено Тогда
	                                    Для каждого ЗначениеПеречисления Из ЗначенияП Цикл
	                                        Если ЗначениеПеречисления.Синоним = Значение_ Тогда
	                                            Прервать;
	                                        КонецЕсли; 
	                                    КонецЦикла; 
	                                КонецЕсли; 
	                                Если ЗначениеПеречисления <> Неопределено Тогда
	                                    Результат = Менеджер[ЗначениеПеречисления.Имя];
	                                КонецЕсли; 
	                            КонецЕсли; 
	                        Иначе
	                            Если ПоРеквизиту = "" Тогда
	                                ПоРеквизиту = ?((ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), "Номер",   //"БизнесПроцессы" "Документы" "Задачи"
	                                        ?((ТипМенеджера = "ПланОбменаМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"), "Код", "Наименование"))
	                            КонецЕсли;
	                            ИскатьПоНомеру = ?(ПоРеквизиту = "Номер", (ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
	                            ИскатьПоКоду = ?(ПоРеквизиту = "Код", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
	                                    (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер"), Ложь);
	                            ИскатьПоНаименованию = ?(ПоРеквизиту = "Наименование", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
	                                    (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
	                            ИскатьПоРодителю = ?(Родитель = Неопределено, Ложь, (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"));
	                            ИскатьПОВладельцу = ?(Владелец = Неопределено, Ложь, ТипМенеджера = "СправочникМенеджер");
	                            Нашлось = Неопределено;
	                            Если ИскатьПоНомеру Тогда
	                                Если ТипМенеджера = "ДокументМенеджер" Тогда
	                                    Нашлось = Менеджер.НайтиПоНомеру(Значение_, ?(Родитель = Неопределено, ТекущаяДатаСеанса(), Родитель))
	                                Иначе
	                                    Нашлось = Менеджер.НайтиПоНомеру(Значение_)
	                                КонецЕсли;
	                            ИначеЕсли ИскатьПоКоду Тогда
	                                Если ИскатьПоРодителю Тогда
	                                    Если ИскатьПоВладельцу Тогда
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель, Владелец)
	                                    ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель)
	                                    Иначе
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_, Родитель)
	                                    КонецЕсли
	                                Иначе
	                                    Если ИскатьПоВладельцу Тогда
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь,, Владелец)
	                                    ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь)
	                                    Иначе
	                                        Нашлось = Менеджер.НайтиПоКоду(Значение_)
	                                    КонецЕсли
	                                КонецЕсли
	                            ИначеЕсли ИскатьПоНаименованию Тогда
	                                Если ИскатьПоРодителю Тогда
	                                    Если ИскатьПоВладельцу Тогда
	                                        Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель, Владелец)
	                                    Иначе
	                                        Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель)
	                                    КонецЕсли
	                                ИначеЕсли ИскатьПоВладельцу Тогда
	                                    Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина,, Владелец)
	                                Иначе
	                                    Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина)
	                                КонецЕсли
	                            Иначе
	                                Если ИскатьПоРодителю Тогда
	                                    Если ИскатьПоВладельцу Тогда
	                                        Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель, Владелец)
	                                    Иначе
	                                        Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель)
	                                    КонецЕсли
	                                ИначеЕсли ИскатьПоВладельцу Тогда
	                                    Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_,, Владелец)
	                                Иначе
	                                    Попытка
	                                        Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_)
	                                    Исключение
	                                        Нашлось = Ложь;
	                                    КонецПопытки;
	                                КонецЕсли
	                            КонецЕсли;
	                            Если ЗначениеЗаполнено(Нашлось) Тогда
	                                Результат = Нашлось;
	                            КонецЕсли; 
	                        КонецЕсли
	                    КонецЕсли;
	                    Если Результат <> Значение_ Тогда
	                        Распознан = Истина;
	                        Прервать
	                    КонецЕсли; 
                	#КонецОбласти
                КонецЕсли;
            КонецЦикла; 
        КонецЕсли;
        Если НЕ Распознан Тогда
            //Возвращается простое значение. Сначала - отработка насильственных типов
            Если (ВРЕГ_ = "ДА" ИЛИ ВРЕГ_ = "ИСТИНА") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
                Результат = Истина;
            ИначеЕсли (ВРЕГ_ = "НЕТ" ИЛИ ВРЕГ_ = "ЛОЖЬ") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
                Результат = Ложь;
            Иначе
                УстановитьБезопасныйРежим(Истина);
                Если ЭтоУниверсал Тогда
                    //@skip-check empty-except-statement
                    Попытка
                        Результат = Вычислить(Значение_);
                        Распознан = Истина;
                    Исключение
                    КонецПопытки;
                КонецЕсли;
                Если НЕ Распознан Тогда
                    Если ЭтоУниверсал ИЛИ ЭтоДата Тогда
                        //@skip-check empty-except-statement
                        Попытка
                            ЭтоТолькоВремя = Сред(Значение_, 2, 1) = ":" ИЛИ Сред(Значение_, 3, 1) = ":";
                            СтрокаДатаВремя = СтрЗаменить(Значение_, " ", Символы.ПС);
                            СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ":", Символы.ПС);
                            СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, "/", Символы.ПС);
                            СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ".", Символы.ПС);
                            Если ЭтоТолькоВремя Тогда
                                День    = 1;
                                Месяц   = 1;
                                Год     = 1;
                                Час     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
                                Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 1, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2))), 0);
                                Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 2, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3))), 0);
                            Иначе
                                День    = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
                                Месяц   = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2)));
                                Год     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3)));
                                Час     = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 3, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 4))), 0);
                                Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 4, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 5))), 0);
                                Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 5, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 6))), 0);
                            КонецЕсли;
                            НовДата = ДобавитьМесяц(Дата(1, 1, 1), (Год - 1) * 12 + Месяц - 1) + (День * 24 + Час - 24) * 3600 + Минута * 60 + Секунда;
                            Если ЗначениеЗаполнено(НовДата)  Тогда
                                Если Год < 100 И НЕ ЭтоТолькоВремя Тогда
                                    НовДата = ДобавитьМесяц(НовДата, Цел(Год(ТекущаяДатаСеанса()) / 100) * 1200);
                                КонецЕсли
                            КонецЕсли;
                            Результат = НовДата;
                            Распознан = Истина;
                        Исключение
                        КонецПопытки
                    КонецЕсли;
                    Если НЕ Распознан Тогда
                        Если ЭтоУниверсал ИЛИ ЭтоЧисло Тогда
                            //@skip-check empty-except-statement
                            Попытка
                                Результат = Число(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение_, " ", ""), " ", ""), ",", "."));
                                Распознан = Истина;
                            Исключение
                            КонецПопытки;
                        КонецЕсли;
                        Если НЕ Распознан Тогда
                            Если ЭтоСтрока Тогда
                                Результат = Строка(Значение_);
                            ИначеЕсли ЭтоБулево Тогда
                                Результат = НЕ ПустаяСтрока(Значение_);
                            Иначе
                                Если
                                		?(НеРаспознаватьУИДБезТипа,
                                			Ложь,
                                			//КлиентСерверХЪ
                                			ЭтоУИД(Значение_)) Тогда
                                    Результат = UUIDToСсылка(Значение_);
                                КонецЕсли;
                            КонецЕсли;
                        КонецЕсли; 
                    КонецЕсли; 
                КонецЕсли; 
            КонецЕсли
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции //РаспознатьЗначение

#КонецОбласти 

#Область 		РЕКВИЗИТЫ_ОБЪЕКТОВ
    
// Возвращает структуру реквизитов регистра, где ключ - имя реквизита, а значение - вид реквизита
// Параметры:
//  Регистр  - Строка - Строка вида "РегистрыСведений.АдресныеСведения" или объект регистра, по которому нужна структура.
//  Фильтр  - Строка - "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты" (по умолчанию) или только часть её в том же формате.
//  РазделятьВиды  - Булево - При Истина ключами будут "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", а значениями = структуры с ключами=именами м значениями=видами,
//          а при ЛОЖЬ (по умолчанию) - одна структура с ключами=именами и значениями=видами.
//  ЗначениеКлючей  - Произвольный - Значение, которое будет подставляться вместо видов. Если NULL или не обозначено - см.РазделятьВиды.
// Возвращаемое значение:
//   Структура   - Структура с ключами - имена реквизитов.
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-ref-link
&НаСервереБезКонтекста
Функция СтруктураЗаписиРегистра(Регистр, Фильтр = "", РазделятьВиды = Ложь, ЗначениеКлючей = NULL) Экспорт
    Результат = Новый Структура;
    УстановитьБезопасныйРежим(Истина);
    МетаДашка = Метаданные;
//    МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
//    МетаМесяцРР = Неопределено;
    МетаДашка = Вычислить("МетаДашка." + Регистр);
    СтруктураВозврата = Новый Структура(?(Фильтр = "", "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", Фильтр));
    Для каждого КиЗ Из СтруктураВозврата Цикл
        Для каждого Реквизит Из МетаДашка[КиЗ.Ключ] Цикл
            Результат.Вставить(Реквизит.Имя, ?(ЗначениеКлючей = NULL, КиЗ.Ключ, ЗначениеКлючей));
        КонецЦикла;
        Если РазделятьВиды Тогда
            СтруктураВозврата[КиЗ.Ключ] = Результат;
            Результат = Новый Структура;
        КонецЕсли;
    КонецЦикла;
    Если РазделятьВиды Тогда
        Результат = СтруктураВозврата;
    КонецЕсли;
    Возврат Результат
КонецФункции // СтруктураЗаписиРегистра

// Загоняет в структуру все реквизиты объекта
// Параметры:
//  Чьих  - ЛюбаяСсылка - ссылка на объект для чтения в структуру
//  Табчасти  - Булево - считывать ли табчасти
//  ТабчастиПредставлением  - Булево - Вставлять в результат вместо ТЧ строку "Табличная часть". По умолчанию ЛОЖЬ = возвращается табчасть.
//  Общие  - Булево - Включать в результат общие реквизиты.
// Возвращаемое значение:
//   Структура   - ключ - имя реквизита, значение - значение реквизита. Если Чьих не ссылка - ключ "Предмет", а значение - Чьих.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СформироватьСтруктуруВсехРеквизитов(Чьих, Табчасти = Ложь, ТабчастиПредставлением = Ложь, Общие = Истина) Экспорт
    Попытка
        МетаХ = Чьих.Метаданные();
    Исключение
        МетаХ = Неопределено;
    КонецПопытки;
    Если МетаХ = Неопределено Тогда
        Возврат Новый Структура("Предмет", Чьих);
    Иначе
        Результат = Новый Структура;
        Для каждого Реквизит Из МетаХ.Реквизиты Цикл
            Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
        КонецЦикла; 
        Для каждого Реквизит Из МетаХ.СтандартныеРеквизиты Цикл
            Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
        КонецЦикла;
        Если Общие Тогда
            МетаВсё = Метаданные;
            МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
            ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
            РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
            АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
            ИнфоОР = Неопределено;
            Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
                //ЭлементР = Реквизит.Состав.Найти(МетаХ);
                Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
                    //?(ЭлементР = Неопределено, Ложь, (ЭлементР.Использование = ИОР.Авто) ИЛИ (ЭлементР.Использование = ИОР.Использовать)) Тогда
                    Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
                КонецЕсли; 
            КонецЦикла;
        КонецЕсли;
        Если ТабЧасти Тогда
            Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
                Результат.Вставить(ТЧ.Имя, ?(ТабчастиПредставлением, "Табличная часть", Чьих[ТЧ.Имя]));
            КонецЦикла; 
        КонецЕсли; 
    КонецЕсли;
    Возврат Результат;
КонецФункции //  СформироватьСтруктуруВсехРеквизитов()

#Область 			РеквизитыОбъектаПоТипамИлиЗначениям
    
// Возвращает соответствие, где ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
// Параметры:
//  Источник  - Объект или ссылка, допускающие применение Метаданные() - Объект, в котором ищутся типы или значения
//  ТипыИлиЗначения  - Массив из Произвольный - Типы или значения, которые ищутся.
//  ИскатьВСтандартных  - Булево - Надо ли искать в стандартных реквизитах. По умолчанию Истина.
//  ИскатьВОбщих  - Булево - Надо ли искать в общих реквизитах. По умолчанию Истина.
//  ИскатьВТабЧастях  - Булево - Надо ли искать в табчастях. По умолчанию Истина.
// Возвращаемое значение:
//   Соответствие из Массив из Строка - ключ = тип (или иное значение), а значение = массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
&НаСервере
Функция РеквизитыОбъектаПоТипамИлиЗначениям(
		Источник,
		ТипыИлиЗначения,
		ИскатьВСтандартных = Истина,
		ИскатьВОбщих = Истина,
		ИскатьВТабЧастях = Истина) Экспорт
    ТипТип = Тип("Тип");
    Результат = Новый Соответствие;
    Для каждого ТекЗнч Из ТипыИлиЗначения Цикл
        Результат.Вставить(ТекЗнч, Новый Массив);
    КонецЦикла; 
    МетаХ = Источник.Метаданные();
    РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.Реквизиты, ТипТип);
    Если ИскатьВСтандартных Тогда
        РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.СтандартныеРеквизиты, ТипТип);
    КонецЕсли;
    Если ИскатьВОбщих Тогда
        МетаВсё = Метаданные;
        МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
        ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
        РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
        АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
        ИнфоОР = Неопределено;
        Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
            Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
		        РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(
                		Результат,
                		Источник,
                		//КлиентСервер
                		ПреобразоватьВМассив(Реквизит),
                		ТипТип);
            КонецЕсли; 
        КонецЦикла;
    КонецЕсли;
    Если ИскатьВТабЧастях Тогда
        Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
            РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ТЧ.Реквизиты, ТипТип, ТЧ.Имя + ".");
        КонецЦикла; 
    КонецЕсли; 
    Возврат Результат
КонецФункции // РеквизитыОбъектаПоТипамИлиЗначениям
 
//Вспомогательная для РеквизитыОбъектаПоТипамИлиЗначениям
// Параметры:
//  Приёмник  - Соответствие - Ключ = обрабатываемое значение, значение - массив имён реквизитов, найденных по значению
//  Источник  - СправочникОбъект, СправочникСсылка - или иной объект или ссылка = Объект, в котором ищутся значения
//  МетаКоллекция  - КоллекцияОбъектовМетаданных - Коллекция, по которой ищутся типы или значения
//  ТипТип  - Тип - Тип("Тип") - уже вычисленный
//  Префикс  - Строка - префикс имени реквизита (путь к родителю)
//@skip-check doc-comment-type
//@skip-check doc-comment-collection-item-type
&НаСервереБезКонтекста
Процедура РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(
		Приёмник,
		Источник,
		МетаКоллекция,
		ТипТип,
		Префикс = "")
    Для каждого Реквизит Из МетаКоллекция Цикл
        Для каждого КиЗ Из Приёмник Цикл
            ТекЗнч = КиЗ.Ключ;
            ЭтоТип = ТекЗнч = ТипТип;
            Если ?(ЭтоТип, Реквизит.Тип.СодержитТип(ТекЗнч), Источник[Реквизит.Имя] = ТекЗнч) Тогда
                КиЗ.Значение.Добавить(Префикс + Реквизит.Имя);
            КонецЕсли;
        КонецЦикла; 
    КонецЦикла;
КонецПроцедуры // РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям

// Возвращает, применяется ли общий реквизит для объекта метаданных
// Параметры:
//  МетаХ  - ОбъектМетаданных - для которого проверяется использование общего реквизита
//  ОРеквизит  - ОбъектМетаданныхОбщийРеквизит - для которого проверяется использование общего реквизита
//  ИспользованияОР  - Соответствие - Соответствие, где ключ - ОР, а значение - соответствие, где ключ - метаданные, а значение - булево, использование. Если Неопределено, рассчитывается и возвращается при необходимости.
//  ИОР  - Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  АИОРИ  - Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  РДОРР  - Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
// Возвращаемое значение:
//   Булево   - Истина, если реквизит используется
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-collection-item-type
//@skip-check doc-comment-type
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ОбщийРеквизитИспользуется(
		МетаХ,
		ОРеквизит,
		ИспользованияОР = Неопределено,
		ИОР = Неопределено,
        АИОРИ = Неопределено,
        РДОРР = Неопределено) Экспорт
    Если (РДОРР = Неопределено) ИЛИ (ИОР = Неопределено) ИЛИ (АИОРИ = Неопределено) Тогда
        МСО = Метаданные.СвойстваОбъектов;
        РДОРР = МСО.РазделениеДанныхОбщегоРеквизита.Разделять;
        ИОР = МСО.ИспользованиеОбщегоРеквизита;
        АИОРИ = МСО.АвтоИспользованиеОбщегоРеквизита.Использовать;
    КонецЕсли; 
    Если ИспользованияОР = Неопределено Тогда
        ИспользованияОР = Новый Соответствие;
    КонецЕсли; 
    Получен = Ложь;
    Использование_ = ИспользованияОР[ОРеквизит];
    Если Использование_ = Неопределено Тогда
        Использование_ = Новый Соответствие;
        ИспользованияОР.Вставить(ОРеквизит, Использование_);
        Результат = Неопределено;
    Иначе
        Результат = Использование_[МетаХ];
        Получен = Результат <> Неопределено;
    КонецЕсли;
    Если НЕ Получен Тогда
        ЭлементР = ОРеквизит.Состав.Найти(МетаХ);//Замедляет!!!!!! 40% при 250 тыс. запусках (а откуда столько? 250К Общих реквизитов????)
        Результат = Ложь;
        Если ЭлементР <> Неопределено Тогда
            ТекИсп = ЭлементР.Использование;
            Если ТекИсп = ИОР.Авто Тогда
                Если ОРеквизит.АвтоИспользование = АИОРИ Тогда //200000 запусков
                    Результат = Истина;
                КонецЕсли; 
            ИначеЕсли ТекИсп = ИОР.Использовать Тогда
                Результат = Истина;
            КонецЕсли; 
            Если ОРеквизит.РазделениеДанных = РДОРР Тогда
                Если Строка(ОРеквизит.УсловноеРазделение) <> "" Тогда
                    //@skip-check empty-except-statement
                    Попытка
                        Результат = Результат И Константы[ОРеквизит.УсловноеРазделение.Имя].Получить();
                    Исключение
                        
                    КонецПопытки;
                КонецЕсли; 
            КонецЕсли; 
        КонецЕсли; 
    КонецЕсли; 
    Использование_.Вставить(МетаХ, Результат);
    Возврат Результат
КонецФункции // ОбщийРеквизитИспользуется

#КонецОбласти 
 
#КонецОбласти 

#Область 		СКД
    
//Возвращает элементы структуры настроек схемы компоновки данных по их именам
//Параметры:
//  СтруктураСКД  - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - головной элемент структуры СКД (структура, таблица, строки или колонки),  в которой будет поиск
//  Имена  - Строка, Массив из Строка - (массив изменяется в процессе!) = Через запятую или в массиве - имена элементов, которые надо найти. Имена у искомых элементов д.б. настроены в конфигураторе.
//  Результат  - Структура - Если структура уже есть, и в неё надо добавить элементы, то она передаётся в этом параметре. Она же будет возвращена.
//Возвращаемое значение:
//   Структура   - ключи - переданные имена, разобранные из строки, значения - найденные элементы
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция НайтиЭлементыСтруктурыКДПоИменам(СтруктураСКД, Имена, Результат = Неопределено) Экспорт
    Если Результат = Неопределено Тогда
        Результат = Новый Структура;
    КонецЕсли;
    МассивХ = ?(ТипЗнч(Имена) = Тип("Массив"), Имена, СтрРазделить(Имена, ",", Ложь));
    Для каждого СтрокаСтруктуры Из СтруктураСКД Цикл
        Индех = МассивХ.Найти(СтрокаСтруктуры.Имя);
        Если Индех <> Неопределено Тогда
            Результат.Вставить(СтрокаСтруктуры.Имя, СтрокаСтруктуры);
            МассивХ.Удалить(Индех);
        КонецЕсли; 
        //Если Флаги.Свойство(СтрокаСтруктуры.Идентификатор) Тогда
        //  СтрокаСтруктуры.Использование = Флаги[СтрокаСтруктуры.Идентификатор];
        //КонецЕсли;
        Если МассивХ.Количество() Тогда
            Тест = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
            ЗаполнитьЗначенияСвойств(Тест, СтрокаСтруктуры);
            НайтиЭлементыСтруктурыКДПоИменам(Тест.Колонки, МассивХ, Результат);
            НайтиЭлементыСтруктурыКДПоИменам(Тест.Строки, МассивХ, Результат);
            НайтиЭлементыСтруктурыКДПоИменам(Тест.Структура, МассивХ, Результат);
        КонецЕсли; 
    КонецЦикла; 
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // НайтиЭлементыСтруктурыКДПоИменам
 
#Область 			КОПИРОВАНИЕ_ГРУППИРОВКИ_СКД
    
//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию выбранных полей
//Параметры:
//  СтруктураПриёмник - ВыбранныеПоляКомпоновкиДанных - Коллекция-приёмник;
//  Элемент - ВыбранноеПолеКомпоновкиДанных, АвтоВыбранноеПолеКомпоновкиДанных, ГруппаВыбранныхПолейКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//  Тип как у Элемент - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
//@skip-check doc-comment-return-section-type
&НаСервереБезКонтекста
Функция ДобавитьВыбранныеПоля(СтруктураПриёмник, Элемент) Экспорт
    Если Тип(Элемент) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Заголовок = Элемент.Заголовок; 
        НовЭлемент.Использование = Элемент.Использование; 
        НовЭлемент.Поле = Элемент.Поле; 
    ИначеЕсли Тип(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Использование = Элемент.Использование; 
    ИначеЕсли Тип(Элемент) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Заголовок = Элемент.Заголовок; 
        НовЭлемент.Использование = Элемент.Использование; 
        НовЭлемент.Расположение = Элемент.Расположение; 
        НовЭлемент.Поле = Элемент.Поле; 
        Для каждого Элемент Из Элемент.Выбор.Элементы Цикл 
            ДобавитьВыбранныеПоля(НовЭлемент.Выбор.Элементы, Элемент); 
        КонецЦикла; 
    КонецЕсли; 
    Возврат НовЭлемент
КонецФункции 

//Переносит свойства переданного элемента в соответствующий элемент параметров вывода приёмника.
//Параметры:
//  СтруктураПриёмник - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных - Коллекция-приёмник;
//  Элемент - ЗначениеПараметраКомпоновкиДанных, ЗначениеПараметраНастроекКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//  Тип как у Элемент - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-return-section-type
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция ДобавитьПараметрыВывода(СтруктураПриёмник, Элемент) Экспорт 
    НовЭлемент = СтруктураПриёмник.Найти(Строка(Элемент.Параметр)); 
    НовЭлемент.Значение = Элемент.Значение; 
    НовЭлемент.Использование = Элемент.Использование; 
    Для каждого Элемент Из Элемент.ЗначенияВложенныхПараметров Цикл 
        ДобавитьПараметрыВывода(НовЭлемент.ЗначенияВложенныхПараметров, Элемент); 
    КонецЦикла; 
    Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию отборов
//Параметры:
//  СтруктураПриёмник - ОтборКомпоновкиДанных - Коллекция-приёмник;
//  Элемент - ЭлементОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//  Тип как у Элемент - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-return-section-type
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция ДобавитьОтбор(СтруктураПриёмник, Элемент) Экспорт 
    Если Тип(Элемент) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.ВидСравнения = Элемент.ВидСравнения; 
        НовЭлемент.Использование = Элемент.Использование; 
        НовЭлемент.ЛевоеЗначение = Элемент.ЛевоеЗначение; 
        НовЭлемент.ПравоеЗначение = Элемент.ПравоеЗначение; 
        НовЭлемент.Представление = Элемент.Представление; 
        НовЭлемент.Применение = Элемент.Применение; 
        НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
    ИначеЕсли Тип(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Использование = Элемент.Использование; 
        НовЭлемент.Представление = Элемент.Представление; 
        НовЭлемент.Применение = Элемент.Применение; 
        НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
        НовЭлемент.ТипГруппы = Элемент.ТипГруппы; 
        Для каждого ЭлементОтбора Из Элемент.Элементы Цикл 
            ДобавитьОтбор(НовЭлемент.Отбор.Элементы, ЭлементОтбора); 
        КонецЦикла; 
    КонецЕсли; 
    Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию условного оформления
//Параметры:
//  СтруктураПриёмник - УсловноеОформлениеКомпоновкиДанных - Коллекция-приёмник;
//  Элемент - ЭлементУсловногоОформленияКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//  Тип как у Элемент - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-return-section-type
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция ДобавитьУсловноеОформление(СтруктураПриёмник, Элемент) Экспорт 
    НовЭлемент = СтруктураПриёмник.Добавить(); 
    НовЭлемент.Представление = Элемент.Представление; 
    НовЭлемент.Использование = Элемент.Использование; 
    //отбор 
    Для каждого ЭлементОтбор Из Элемент.Отбор.Элементы Цикл 
        ДобавитьОтбор(НовЭлемент.Отбор.Элементы,ЭлементОтбор); 
    КонецЦикла; 
    //оформление 
    Для каждого ЭлементОформление Из Элемент.Оформление.Элементы Цикл 
        ДобавитьПараметрыВывода(НовЭлемент.Оформление.Элементы,ЭлементОформление); 
    КонецЦикла; 
    //поля 
    Для каждого ЭлементПоле Из Элемент.Поля.Элементы Цикл 
        НовЭлементПоле = НовЭлемент.Поля.Элементы.Добавить(); 
        НовЭлементПоле.Использование = ЭлементПоле.Использование; 
        НовЭлементПоле.Поле = ЭлементПоле.Поле; 
    КонецЦикла; 
    Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию порядка
//Параметры:
//  СтруктураПриёмник - ПорядокКомпоновкиДанных - Коллекция-приёмник;
//  Элемент - ЭлементПорядкаКомпоновкиДанных, АвтоЭлементПорядкаКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//  Тип как у Элемент - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
//@skip-check doc-comment-return-section-type
&НаСервереБезКонтекста
Функция ДобавитьПорядок(СтруктураПриёмник, Элемент) Экспорт 
    Если Тип(Элемент) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Использование = Элемент.Использование; 
        НовЭлемент.Поле = Элемент.Поле; 
        НовЭлемент.ТипУпорядочивания = Элемент.ТипУпорядочивания; 
    ИначеЕсли Тип(Элемент) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда 
        НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
        НовЭлемент.Использование = Элемент.Использование; 
    КонецЕсли; 
    Возврат НовЭлемент
КонецФункции

//Копирует элемент структуры СКД в другую (или эту же) структуру СКД.
//Содрана https://forum.infostart.ru/forum9/topic47305/
//Параметры:
//  СтруктураПриёмник - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных, КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - куда будет помещён новый элемент
//  ЭлементИсточник - ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных, ГруппировкаТаблицыКомпоновкиДанных,	ДиаграммаКомпоновкиДанных, НастройкиВложенногоОбъектаКомпоновкиДанных - Копируемый элемент структуры настроек СКД.
//          Для некоторых типов м.б. не проверено :(
//  ОткудаУдалитьНаСтаромМесте - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных, КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - Коллекция, из которой надо удалять старый элемент (Неопределено по умолчанию - не удалять).
//Возвращаемое значение:
//  Того же типа, что и ЭлементИсточник - Добавленный элемент
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-return-section-type
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция СкопироватьЭлементВСтруктуруСКД(СтруктураПриёмник, ЭлементИсточник, ОткудаУдалитьНаСтаромМесте = Неопределено) Экспорт 
    
    ЭтоВТаблице = ТипЗнч(СтруктураПриёмник) = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных");
    Результат = ?(ЭтоВТаблице, СтруктураПриёмник.Добавить(), СтруктураПриёмник.Добавить(ТипЗнч(ЭлементИсточник)));
    
    //выбор 
    Для каждого Элемент Из ЭлементИсточник.Выбор.Элементы Цикл 
        ДобавитьВыбранныеПоля(Результат.Выбор.Элементы, Элемент) 
    КонецЦикла; 
    //использование 
    Результат.Использование = ЭлементИсточник.Использование; 
    //имя 
    Результат.Имя = ЭлементИсточник.Имя; 
    //отбор 
    Для каждого Элемент Из ЭлементИсточник.Отбор.Элементы Цикл 
        ДобавитьОтбор(Результат.Отбор.Элементы, Элемент); 
    КонецЦикла; 
    // параметры вывода 
    Для каждого Элемент Из ЭлементИсточник.ПараметрыВывода.Элементы Цикл 
        ДобавитьПараметрыВывода(Результат.ПараметрыВывода.Элементы,Элемент); 
    КонецЦикла; 
    //поля группировки 
    Для каждого Элемент Из ЭлементИсточник.ПоляГруппировки.Элементы Цикл 
        Если ТипЗнч(Элемент) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда 
            НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
            НовЭлемент.Использование = Элемент.Использование; 
            НовЭлемент.КонецПериода = Элемент.КонецПериода; 
            НовЭлемент.НачалоПериода = Элемент.НачалоПериода; 
            НовЭлемент.Поле = Элемент.Поле; 
            НовЭлемент.ТипГруппировки = Элемент.ТипГруппировки; 
            НовЭлемент.ТипДополнения = Элемент.ТипДополнения; 
        ИначеЕсли ТипЗнч(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
            НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
            НовЭлемент.Использование = Элемент.Использование; 
        КонецЕсли; 
    КонецЦикла; 
    //порядок 
    Для каждого Элемент Из ЭлементИсточник.Порядок.Элементы Цикл 
        ДобавитьПорядок(Результат.Порядок.Элементы, Элемент); 
    КонецЦикла; 
    //условное оформление 
    Для каждого Элемент Из ЭлементИсточник.УсловноеОформление.Элементы Цикл 
        ДобавитьУсловноеОформление(Результат.УсловноеОформление.Элементы, Элемент); 
    КонецЦикла; 
    
    //обход структуры рекурсивно 
    ТМП = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
    ЗаполнитьЗначенияСвойств(ТМП, ЭлементИсточник);
    Для каждого Подчинённый Из ТМП.Структура Цикл 
        СкопироватьЭлементВСтруктуруСКД(Результат.Структура, Подчинённый) 
    КонецЦикла; 
    Для каждого Подчинённый Из ТМП.Строки Цикл 
        СкопироватьЭлементВСтруктуруСКД(Результат.Строки, Подчинённый) 
    КонецЦикла; 
    Для каждого Подчинённый Из ТМП.Колонки Цикл 
        СкопироватьЭлементВСтруктуруСКД(Результат.Колонки, Подчинённый) 
    КонецЦикла; 
    
    Если ОткудаУдалитьНаСтаромМесте <> Неопределено Тогда
        ОткудаУдалитьНаСтаромМесте.Удалить(ЭлементИсточник);
    КонецЕсли;
    Возврат Результат
КонецФункции 

#КонецОбласти 

#КонецОбласти

#Область 		ССЫЛКИ_УИДЫ
    
//Возвращает ссылку по строке УИД
//Параметры:
//  УУИД - Строка - 36 значный УИД
//  НайтиВсе - Булево - Найти все ссылки и вернуть массив. При Ложь будет возвращена первая найденная.
//Возвращаемое значение:
//  Массив из ЛюбаяСсылка, ЛюбаяСсылка, Неопределено - Если НайтиВсе - будет массив, иначеесли найдена ссылка - найденная ссылка, если не найдено ничего - неопределено.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция UUIDToСсылка(УУИД, НайтиВсе = Ложь) Экспорт
    Результат = Новый Массив;
    ГдеИщем = Новый Соответствие;
    ГдеИщем.Вставить(Справочники, Метаданные.Справочники);
    ГдеИщем.Вставить(Документы, Метаданные.Документы);
    ГдеИщем.Вставить(ПланыВидовХарактеристик, Метаданные.ПланыВидовХарактеристик);
    ГдеИщем.Вставить(ПланыСчетов, Метаданные.ПланыСчетов);
    ГдеИщем.Вставить(ПланыВидовРасчета, Метаданные.ПланыВидовРасчета);
    ГдеИщем.Вставить(БизнесПроцессы, Метаданные.БизнесПроцессы);
    ГдеИщем.Вставить(Задачи, Метаданные.Задачи);
    ГдеИщем.Вставить(ПланыОбмена, Метаданные.ПланыОбмена);
    НУИД = Новый УникальныйИдентификатор(УУИД);
    Для Каждого ВидМетаданных Из ГдеИщем Цикл
        Для каждого л_Менеджер из ВидМетаданных.Значение Цикл
            л_Ссылка = ВидМетаданных.Ключ[л_Менеджер.Имя].ПолучитьСсылку(НУИД);
            //Элементы.ГруппаСсылки.Заголовок = ТипЗнч(л_Ссылка);
            Если л_Ссылка.ПолучитьОбъект() <> Неопределено Тогда
                Если НайтиВсе Тогда
                    Результат.Добавить(л_Ссылка);
                Иначе
                    Возврат л_Ссылка
                КонецЕсли; 
            КонецЕсли
        КонецЦикла
    КонецЦикла;
    Возврат ?(НайтиВсе, Результат, Неопределено)
КонецФункции

// Возвращает ссылки по УИД, но поиск происходит только по заданным типам
// Параметры:
//  УИДы  - Строка, Массив из Строка - УИДы, по которым надо найти ссылку
//  ГдеИскать  - Массив из Тип - Допустимые типы ссылки
// Возвращаемое значение:
//   Массив из ЛюбаяСсылка - Найденные ссылки или Неопределено
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СсылкиЗаданногоТипаПоУИД(УИДы, ГдеИскать) Экспорт
	ЧтоИскать =
			//КлиентСерверХЪ
			ПреобразоватьВМассив(УИДы);
    МГдеИскать = Новый Массив;
    Для каждого ТекТип Из ГдеИскать Цикл
        мГдеИскать.Добавить(ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер").Менеджер);//ВОЛНА_ОбщегоНазначенияПовтИспСеансВызовСервера.
    КонецЦикла;
    Результат = Новый Массив;
    Для каждого УИД Из ЧтоИскать Цикл
        ТекСсылка = Неопределено;
        Для каждого Менеджер Из мГдеИскать Цикл
            ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИД));
            Если ТекСсылка <> Неопределено Тогда
                Прервать;
            КонецЕсли;
            Результат.Добавить(ТекСсылка);
        КонецЦикла; 
    КонецЦикла;
    Возврат Результат
КонецФункции // СсылкиЗаданногоТипаПоУИД()
 
#КонецОбласти 

#Область 		СТРОКОВЫЕ

//Создаёт тестер маски.
//Параметры:
//  Маска - Строка - Маска для проверки. По умолчанию - маска проверки даты. Описание синтаксиса маски в функции ПроверитьСтроку
//Возвращаемое значение:
//   ЗначениеXDTO - для тестирования строки по маске
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЗначениеXDTOдляПроВеркиСтроки(Маска = "\d{2}\.\d{2}\.\d{4}") Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Маска + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
КонецФункции // XDTOдляПроВеркиСтроки()
 
// Возврщает дерево процедур и функций модуля с учётом областей.
// Параметры:
//  ТекстМодуля - Строка - Текст модуля, в котором ищутся методы. Считается, что структурирован: не содержит ошибок, заголоврк и ркончание процедур и функций в отдельных строках с начала, ЭКСПОРТ не с новой строки. 
//  ТолькоЭкспорт - Булево - Выбирать только экспортные процедуры
//  ОбластьРодитель - Строка - Имя области, внутри которой ищутся процедуры. Допускается, что в модуле м.б. несколько областей с этим именем. Сам родитель в дерево не попадает. По умолчанию "" - обрабатывается весь модуль.
//  ТегМеню - Строка - Префикс строки (после знака комментария), идентифицирующий в модуле строку представления в дереве. Эта строка может быть в любом месте метода и не включается в другие тексты. По умолчанию "МЕНЮ:".
//  Приёмник - ДеревоЗначений, СтрокаДереваЗначений - приёмник для дотройки ветви по модулю.
// Возвращаемое значение:
//   ДеревоЗначений, СтрокаДереваЗначений, Неопределено   - Список методов модуля с колонками
//      *Представление = для представления в дереве = имя или из строчки с ТегМеню
//      *Имя = Имя метода
//      *Описание = Начальный комментарий до Параметров
//      *ПолноеОписание = Весь начальный комментарий и заголовок метода с параметрами.
//      *Текст = текст метода от заголовка
//      *Вид = Функция или Процедура
//      *Экспорт = Булево
//      *Параметры = Список параметров в составе заголовка
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
//@skip-check module-region-empty
&НаСервереБезКонтекста
Функция ДеревоМетодовМодуля(ТекстМодуля, ТолькоЭкспорт = Истина, ОбластьРодитель = "", ТегМеню = "МЕНЮ:", Приёмник = Неопределено) Экспорт
    Результат = ?(Приёмник = Неопределено, Новый ДеревоЗначений, Приёмник);
    #Область КОЛОНКИ
        Если Результат.Колонки.Найти("Представление") = Неопределено Тогда
            Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("ПолноеОписание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
            Результат.Колонки.Добавить("Экспорт", Новый ОписаниеТипов("Булево")); 
            Результат.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
        КонецЕсли;
    #КонецОбласти
    Стек = Новый Массив;
    Коммент = Ложь; //Строка в теле комментария перед функцией
    Сброс = Истина; //Перед обработкой следующей строки обнулить данные записи
    Тело = Ложь; //Строка в теле функции
    СложныйКоммент = ""; //Комментарий, включающий область
    Заголовок = 0; //0 - это не заголовок, 1 - обработка заголовка до первой скобки, 2 - до второй скобки, 3 - после второй скобки
    Ветка = Результат;
    ДлТМ = СтрДлина(ТегМеню);
    РазрешеноЧтение = ОбластьРодитель = ""; //Строка внутри разрешённой области-родителя
	ИменаКолонок =
			//СерверХЪ
			Список_Колонок(Результат);
    #Область ОПИСАНИЕ
        //Вне тела и заголовка метода:
        //  чтение построчно;
        //  [Nпс]// - в начале строки включает режим комментария до конца строки. Включает и продолжает режим описания.
        //  [Nпс]//[Nпс]Параметры отключает режим краткого описания, режим полного остаётся.
        //  [Nпс]& игнорируются.
        //  [Nпс]#Область - прерывают режим описания с отменой. Добавляют уровень подменю.
        //  [Nпс]#КонецОбласти - прерывают режим описания с отменой. Переводят в подменю на уровень выше.
        //  [Nпс][Асинх|][Nпс]Процедура|Функция[Nпс][ИМЯ]( - прерывают режим описаний с принятием. Переводят в режим чтения заголовка, имени и параметров.
        //  Прочие - прерывают режим описания с отменой. Потом игнорируются.
        //В заголовке метода:
        //  чтение посимвольно;
        //  // - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
        //  " - включает/выключает ре.жим текста. В режиме текста ищется только ", а запись заголовка продолжается.
        //  ) - Закрывает чтение заголовка и параметров. Проверяется )[Nпс]Экспорт[Nпс].Включает режим тела процедуры/ функции. Не работает в режиме текста
        //В теле метода:
        //  Чтение поиском.
        //  [N*][Nпс]КонецПроцедуры|КонецФункции[Nпс] - завершает запись текста и режим тела метода и переводит в режим "Вне".
        //          Не работает, если внутри режима тела нечёт двойных кавычек вне комментариев. Не работает после символов комментария вне текста.
        //  " - включает/выключает режим текста. В режиме текста ищется только ", а запись текста продолжается.
        //  // - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
    #КонецОбласти
    Для Ё = 1 По СтрЧислоСтрок(ТекстМодуля) Цикл
        Если Сброс Тогда
            Сброс = Ложь;
            Тело = Ложь;
            Заготовка = Новый Структура(ИменаКолонок);
            //Если СложныйКоммент <> "" Тогда
                Заготовка.Вставить("ПолноеОписание", СложныйКоммент);
            //КонецЕсли;
            Заготовка.Вставить("Текст", "");
            Заготовка.Вставить("Экспорт", Ложь);
            СложныйКоммент = "";
        КонецЕсли;
        ТекСтрока = СокрЛП(СтрПолучитьСтроку(ТекстМодуля, Ё));
        НРегСтрока = НРег(ТекСтрока);
        Готово = Ложь; //Создать строку дерева после обработки строки модуля
        ВТекст = Ложь; //Вставить строку в текст метода
        ВКоммент = Ложь; // Вставить строку в текст комментария
        Если Лев(ТекСтрока, 2) = "//" Тогда
            ТекКоммент = СокрЛП(Сред(ТекСтрока, 3));
            Если Лев(ТекКоммент, ДлТМ) = ТегМеню Тогда
                Заготовка.Вставить("Представление", Сред(ТекКоммент, ДлТМ + 1));
            ИначеЕсли НЕ Тело Тогда
                Если НЕ Коммент Тогда
                    Коммент = Истина;
                    Заготовка.Вставить("ПолноеОписание", "");
                КонецЕсли;
                Если Лев(ТекКоммент, 9) = "Параметры" Тогда
                    Заготовка.Вставить("Описание", Сред(Заготовка.ПолноеОписание, 2));
                КонецЕсли;
                ВКоммент = Истина;
            Иначе
                ВТекст = Истина;
            КонецЕсли; 
        ИначеЕсли Лев(ТекСтрока, 1) = "&" Тогда
            ВТекст = Тело;
        //ИначеЕсли Тело Тогда
        //  ВТекст = Тело;
        Иначе
            Если Лев(НРегСтрока, 5) = "асинх" И Не ЗначениеЗаполнено(Сред(НРегСтрока, 6, 1)) Тогда
                ТекСтрока = СокрЛП(Сред(ТекСтрока, 7));
                НРегСтрока = СокрЛП(Сред(НРегСтрока, 7));
            КонецЕсли;
            ЭтоПроц = Лев(НРегСтрока, 9) = "процедура";
            ЭтоФ = Лев(НРегСтрока, 7) = "функция";
            ЭтоОбл = Лев(НРегСтрока, 8) = "#область";
            ЭтоКОбл = Лев(НРегСтрока, 13) = "#конецобласти";
            ЭтоКПроц = Лев(НРегСтрока, 14) = "конецпроцедуры";
            ЭтоКФ = Лев(НРегСтрока, 12) = "конецфункции";
            Если ЭтоПроц ИЛИ ЭтоФ ИЛИ (Заголовок > 0) Тогда
                Тело = Истина;
                Если ЭтоПроц Или ЭтоФ Тогда
                    Заготовка.Вставить("Текст", ТекСтрока);
                    Заготовка.Вставить("Вид", ?(ЭтоФ, "Функция", "Процедура"));
                    Квант = СокрЛП(Сред(ТекСтрока, ?(ЭтоФ, 9, 11)));
                    Заголовок = 1;
                    ПроверитьДругиеВарианты = Ложь;
                Иначе
                    ПроверитьДругиеВарианты = Заголовок = 3; //Новая строка после скобки может быть новым оператором
                    ВТекст = Истина;
                    Квант = ТекСтрока;
                КонецЕсли;
                ВКоммент = НЕ ПроверитьДругиеВарианты; //Если нет других вариантов - это заголовок метода, он должен попадать в полный коммент
                //Имя метода
                Если Заголовок = 1 Тогда
                    ПСкобки = СтрНайти(Квант, "(");
                    Если ПСкобки = 0 Тогда
                        Если НЕ ПустаяСтрока(Квант) Тогда
                            Сброс = Истина;
                        КонецЕсли;
                    Иначе
                        Заготовка.Вставить("Имя", Лев(Квант, ПСкобки - 1));
                        Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
                        Заголовок = 2;
                        Заготовка.Вставить("Параметры", "");
                    КонецЕсли;
                КонецЕсли;
                Если Заголовок = 2 Тогда
                    ПСкобки = СтрНайти(Квант, ")");
                    Если ПСкобки = 0 Тогда
                        Заготовка.Вставить("Параметры", Заготовка.Параметры + Квант + Символы.ПС);
                    Иначе
                        Заготовка.Вставить("Параметры", Заготовка.Параметры + Лев(Квант, ПСкобки - 1));
                        Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
                        Заголовок = 3;
                    КонецЕсли;
                КонецЕсли;
                Если Заголовок = 3 Тогда
                    Заголовок = 0;
                    Заготовка.Вставить("Экспорт", НРег(Лев(Квант, 7)) = "экспорт");
                КонецЕсли;
            Иначе
                ПроверитьДругиеВарианты = Истина;
            КонецЕсли;
            Если ПроверитьДругиеВарианты Тогда
                ВТекст = Тело;
                Если ЭтоОбл И НЕ Тело Тогда
                    Сброс = Истина;
                    Готово = РазрешеноЧтение;
                    Заготовка.Вставить("Вид", "Подменю");
                    Заготовка.Вставить("Имя", СокрЛП(Сред(ТекСтрока, 10)));
                    Если (Заготовка.Имя = ОбластьРодитель) И (ОбластьРодитель <> "") Тогда
                        РазрешеноЧтение = Истина;
                    КонецЕсли;
                ИначеЕсли ЭтоКОбл И НЕ Тело Тогда
                    Сброс = Истина;
                    Если Стек.Количество() = 0 Тогда
                        РазрешеноЧтение = Ложь;
                    Иначе
                        Колво = Ветка.Строки.Количество();
                        УдалитьПодменю = (Колво = 0) ИЛИ ((Колво = 1) И ТолькоЭкспорт);
                        УдаляемоеПодменю = Ветка;
                        КомментВнутриОбласти = Заготовка.ПолноеОписание;
                        Ветка = Стек[Стек.ВГраница()];
                        Стек.Удалить(Стек.ВГраница());
                        Если УдалитьПодменю Тогда
                            СложныйКоммент = "" + УдаляемоеПодменю.ПолноеОписание + Символы.ПС + "#Область" + УдаляемоеПодменю.Имя + Символы.ПС + КомментВнутриОбласти + Символы.ПС + ТекСтрока;
                            Если Колво = 1 Тогда
                                ЗаполнитьЗначенияСвойств(Ветка.Строки.Добавить(), УдаляемоеПодменю.Строки[0]);
                            КонецЕсли;
                            Ветка.Строки.Удалить(УдаляемоеПодменю);
                        КонецЕсли;
                    КонецЕсли; 
                ИначеЕсли ЭтоКПроц ИЛИ ЭтоКФ Тогда
                    Готово = Истина;
                    Сброс = Истина;
                КонецЕсли;
            КонецЕсли;
            Если Коммент И НЕ Тело Тогда
                Заготовка.Вставить("ПолноеОписание", "");
                Заготовка.Вставить("Описание", "");
            КонецЕсли;
            Коммент = Ложь;
        КонецЕсли;
        Если ВКоммент Тогда
            Заготовка.Вставить("ПолноеОписание", Заготовка.ПолноеОписание + Символы.ПС + ТекСтрока);
        КонецЕсли;
        Если ВТекст Тогда
            Заготовка.Вставить("Текст", Заготовка.Текст + Символы.ПС + ТекСтрока);
        КонецЕсли;
        Если Готово Тогда
            Если РазрешеноЧтение Тогда
                ЭтоПодменю = Заготовка.Вид = "Подменю";
                Если ЭтоПодменю ИЛИ Заготовка.Экспорт ИЛИ НЕ ТолькоЭкспорт Тогда
                    Если ПустаяСтрока(Заготовка.Представление) Тогда
                        Заготовка.Вставить("Представление", Заготовка.Имя);
                    КонецЕсли;
                    НоваяСтрока = Ветка.Строки.Добавить();
                    ЗаполнитьЗначенияСвойств(НоваяСтрока, Заготовка);
                    Если ЭтоПодменю Тогда
                        Стек.Добавить(Ветка);
                        Ветка = НоваяСтрока;
                    КонецЕсли;
                КонецЕсли;
            КонецЕсли;
            Готово = Ложь;
        КонецЕсли;
    КонецЦикла; 
    Возврат Результат
КонецФункции // ДеревоМетодовМодуля

#КонецОбласти

#Область 		ТАБЛИЧНЫЙ_ДОКУМЕНТ

// Получает табличный документ из двоичных данных Excel или Excel или ODS или MXL
// Параметры:
//  ДДилиФайл  - ДвоичныеДанные, Строка - ДД, полученные, например, из хранилища или макета/путь к файлу
//  Расширение  - Строка - расширение Excel (нужно только для ДД), по умолчанию xlsx
//  СпособЧтения  - СпособЧтенияЗначенийТабличногоДокумента - как читать. По умолчанию Значение.
// Возвращаемое значение:
//   ТабличныйДокумент   - Прочитанный из Excel
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТДизExcel(ДДилиФайл, Расширение = "xlsx", СпособЧтения = Неопределено) Экспорт
	Если СпособЧтения = Неопределено Тогда
		СпособЧтения = СпособЧтенияЗначенийТабличногоДокумента.Значение;
	КонецЕсли;
    ТекТип = ТипЗнч(ДДилиФайл);
    ЭтоДД = ТекТип = Тип("ДвоичныеДанные");
    ИзПотока = Ложь;
    Если ТекТип = Тип("Строка") Тогда
        ПутьКФайлуИсточнику = ДДилиФайл;
    ИначеЕсли ЭтоДД Тогда
    	ЭтоООФис = Расширение = "ODS";
    	Если ЭтоООФис ИЛИ Расширение = "MXL" Тогда
    		ИзПотока = Истина;
    		ПутьКФайлуИсточнику = ДДилиФайл.ОткрытьПотокДляЧтения();
    	Иначе
	    	//Увы, чтение из потока не поддерживает Excel
	        ПутьКФайлуИсточнику = ПолучитьИмяВременногоФайла(Расширение);
	        ДДилиФайл.Записать(ПутьКФайлуИсточнику);
    	КонецЕсли;
    Иначе
        ПутьКФайлуИсточнику = ДДилиФайл;
    КонецЕсли;
    Результат = Новый ТабличныйДокумент;
    Если ИзПотока Тогда
        Результат.Прочитать(ПутьКФайлуИсточнику, СпособЧтения, ?(ЭтоООФис, ТипФайлаТабличногоДокумента.ODS, ТипФайлаТабличногоДокумента.MXL));
    ИначеЕсли ЗначениеЗаполнено(ПутьКФайлуИсточнику) Тогда
        Результат.ИспользуемоеИмяФайла = ПутьКФайлуИсточнику;
        Результат.Прочитать(ПутьКФайлуИсточнику, СпособЧтения);
    КонецЕсли;
    Если ЭтоДД Тогда
        УдалитьФайлы(ПутьКФайлуИсточнику);
    КонецЕсли;
    Возврат Результат
КонецФункции // ТДизExcel

#Область 			РАСШИФРОВКА

// Возвращает структуру полей расшифровки ячейки
// Параметры:
//  ИР_  - Число - Идентификатор расшифровки КД для получения данных
//  ДанныеРасшифровки  - Строка, ДанныеРасшифровкиКомпоновкиДанных - Адрес данных расшифровки КД во временном хранилище/сами данные = Источник получения данных
//  ВключитьНастройки  - Булево - Включить в объект ключ Настройки_ = Структура настроек пасшифровки. Включает только верхний уровень.
//  ВключитьДРО  - Булево - Включить в объект ключ ДРО_ = Данные расшифровки
// Возвращаемое значение:
//  Структура   - Ключи = имена полей, значения = значения полей 
//@skip-check export-method-in-command-form-module
&НаСервере
Функция ПоляТекущейРасшифровки(
		ИР_,
		ДанныеРасшифровки,
		ВключитьНастройки = Истина,
		ВключитьДРО = Ложь) Экспорт
    Результат_ = Новый Структура;
    Если ИР_ <> Неопределено Тогда
       	ДРО_ = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки);
        ЭлДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки).Элементы[ИР_];
		//СерверХЪ
		ПоляРасшифровкиВСтруктуруРекурсивно(Результат_, ЭлДРО);
        Если ЭлДРО.ПолучитьПоля()[0].Поле = "Результат" Тогда
            Для каждого Родитель_ Из ЭлДРО.ПолучитьРодителей() Цикл
                Для каждого ПолеРодителя Из Родитель_.ПолучитьПоля() Цикл
                    Результат_.Вставить(ПолеРодителя.Поле, ПолеРодителя.Значение);
                КонецЦикла;
            КонецЦикла;
        КонецЕсли;
        Если ВключитьДРО Тогда
            Результат_.Вставить("ДРО_", ДРО_);
        КонецЕсли;
        Если ВключитьНастройки Тогда
            ТекНастройки = Новый Структура;
            Для каждого ТекЭлемент Из ДРО_.Настройки.ПараметрыДанных.Элементы Цикл
                ТекНастройки.Вставить(СокрЛП(ТекЭлемент.Параметр), ТекЭлемент.Значение);
            КонецЦикла;
            Результат_.Вставить("Настройки_", ТекНастройки);
        КонецЕсли;
    КонецЕсли;
    //@skip-check constructor-function-return-section
    Возврат Результат_
КонецФункции // ДанныеТекущейРасшифровки

#КонецОбласти
    
#КонецОбласти 

#Область ТИПЫ

//Возвращает описание типов "любая ссылка"
//Параметры:
//  ВключитьСписокЗначений - Булево - При Истина (по умолчанию) результат включает список значений
//Возвращаемое значение:
//  ОписаниеТипов - любая ссылка + Булево + Дата + Число + Строка + (Опционально) Список значений
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВсеСсылочныеИПростыеТипы(ВключитьСписокЗначений = Истина) Экспорт
    МассивТипов = Новый Массив();
    МассивТипов.Добавить(Тип("Строка"));
    МассивТипов.Добавить(Тип("Число"));
    МассивТипов.Добавить(Тип("Дата"));
    МассивТипов.Добавить(Тип("Булево"));
    Если ВключитьСписокЗначений Тогда
        МассивТипов.Добавить(Тип("СписокЗначений"));
    КонецЕсли; 
    Возврат Новый ОписаниеТипов(ВсеСсылочныеТипы(), МассивТипов,, Новый КвалификаторыЧисла(31, 7, ДопустимыйЗнак.Любой),
            Новый КвалификаторыСтроки(2000, ДопустимаяДлина.Переменная), Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя),
            Новый КвалификаторыДвоичныхДанных(2000, ДопустимаяДлина.Переменная));
КонецФункции // ВсеСсылочныеИПростыеТипы()

//Возвращает описание типов "любая ссылка"
//Возвращаемое значение:
//  ОписаниеТипов - содержащее все ссылочные типы
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВсеСсылочныеТипы() Экспорт
    Результат = Новый ОписаниеТипов(Документы.ТипВсеСсылки(), Перечисления.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, Справочники.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, ПланыВидовРасчета.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, ПланыОбмена.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, ПланыСчетов.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылки().Типы());
    Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы());
    Возврат Новый ОписаниеТипов(Результат, Задачи.ТипВсеСсылки().Типы());
КонецФункции // ВсеСсылочныеТипы()

#КонецОбласти

#Область ЭТА_КОНФИГУРАЦИЯ
    
#Область 	ДЕРЕВО_МД
    
//Заполняет дерево метаданных по ветви метаданных.
//Параметры:
//  ВетвьДерева - СтрокаДереваЗначений, ДеревоЗначений - Заполняемый объект   
//  ВетвьМД - ОбъектМетаданных - Источник данных для заполнения    
//  Префикс - Строка - Указывается перед пользовательским представлением элемента   
//  СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента для кода или запроса.
//  Очищать - Булево - Очистить дерево перед заполненияем
//  ЗаполнятьВетви - Булево - При Истина заполняет на всю глубину, при Ложь - без вложенных ветвей (намного быстрее, по умолчанию). 
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ЗаполнитьДеревоМД(
		ВетвьДерева,
		ВетвьМД = Неопределено,
		Префикс = "",
		СброситьПрефикс = Ложь,
		Очищать = Ложь,
		ЗаполнятьВетви = Ложь) Экспорт
    ЭтоДуб = ТипЗнч(ВетвьДерева) = Тип("ДеревоЗначений");
    Если ЭтоДуб Тогда
        Если ВетвьДерева.Колонки.Найти("Представление") = Неопределено Тогда
            ВетвьДерева.Колонки.Добавить("Представление");
        КонецЕсли;
        Если ВетвьДерева.Колонки.Найти("ТекстДляКода") = Неопределено Тогда
            ВетвьДерева.Колонки.Добавить("ТекстДляКода");
        КонецЕсли;
        Если ВетвьДерева.Колонки.Найти("ТекстДляЗапроса") = Неопределено Тогда
            ВетвьДерева.Колонки.Добавить("ТекстДляЗапроса");
        КонецЕсли;
        Если ВетвьДерева.Колонки.Найти("МД") = Неопределено Тогда
            ВетвьДерева.Колонки.Добавить("МД",,, 0);
        КонецЕсли;
    КонецЕсли;
    Если Очищать Тогда
        ВетвьДерева.Строки.Очистить()
    КонецЕсли;
    Продолжать = (ВетвьДерева.Строки.Количество() = 0) ИЛИ НЕ ЭтоДуб;
    Если Продолжать Тогда
        Если ВетвьМД = Неопределено Тогда
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Справочники";
            НоваяСтрокаДерева.ТекстДляКода = "Справочники";
            НоваяСтрокаДерева.ТекстДляЗапроса = "Справочник";
            НоваяСтрокаДерева.МД = Метаданные.Справочники;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Справочники);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Документы";
            НоваяСтрокаДерева.ТекстДляКода = "Документы";
            НоваяСтрокаДерева.ТекстДляЗапроса = "Документ";
            НоваяСтрокаДерева.МД = Метаданные.Документы;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Документы);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Перечисления";
            НоваяСтрокаДерева.ТекстДляКода = "Перечисления";
            НоваяСтрокаДерева.ТекстДляЗапроса = "Перечисление";
            НоваяСтрокаДерева.МД = Метаданные.Перечисления;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Перечисления);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Планы счетов";
            НоваяСтрокаДерева.ТекстДляКода = "ПланыСчетов";
            НоваяСтрокаДерева.ТекстДляЗапроса = "ПланСчетов";
            НоваяСтрокаДерева.МД = Метаданные.ПланыСчетов;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыСчетов);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Планы видов расчетов";
            НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовРасчетов";
            НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовРасчетов";
            НоваяСтрокаДерева.МД = Метаданные.ПланыВидовРасчета;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовРасчета);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Планы обмена";
            НоваяСтрокаДерева.ТекстДляКода = "ПланыОбмена";
            НоваяСтрокаДерева.ТекстДляЗапроса = "ПланОбмена";
            НоваяСтрокаДерева.МД = Метаданные.ПланыОбмена;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыОбмена);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Планы видов характеристик";
            НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовХарактеристик";
            НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовХарактеристик";
            НоваяСтрокаДерева.МД = Метаданные.ПланыВидовХарактеристик;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовХарактеристик);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Регистры накопления";
            НоваяСтрокаДерева.ТекстДляКода = "РегистрыНакопления";
            НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрНакопления";
            НоваяСтрокаДерева.МД = Метаданные.РегистрыНакопления;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыНакопления);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Регистры бухгалтерии";
            НоваяСтрокаДерева.ТекстДляКода = "РегистрыБухгалтерии";
            НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрБухгалтерии";
            НоваяСтрокаДерева.МД = Метаданные.РегистрыБухгалтерии;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыБухгалтерии);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Регистры расчёта";
            НоваяСтрокаДерева.ТекстДляКода = "РегистрыРасчета";
            НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрРасчета";
            НоваяСтрокаДерева.МД = Метаданные.РегистрыРасчета;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыРасчета);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Регистры сведений";
            НоваяСтрокаДерева.ТекстДляКода = "РегистрыСведений";
            НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрСведений";
            НоваяСтрокаДерева.МД = Метаданные.РегистрыСведений;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыСведений);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Бизнес-процессы";
            НоваяСтрокаДерева.ТекстДляКода = "БизнесПроцессы";
            НоваяСтрокаДерева.ТекстДляЗапроса = "БизнесПроцесс";
            НоваяСтрокаДерева.МД = Метаданные.БизнесПроцессы;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.БизнесПроцессы);
            КонецЕсли; 
            НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
            НоваяСтрокаДерева.Представление = "Задачи";
            НоваяСтрокаДерева.ТекстДляКода = "Задачи";
            НоваяСтрокаДерева.ТекстДляЗапроса = "Задачи";
            НоваяСтрокаДерева.МД = Метаданные.Задачи;
            Если ЗаполнятьВетви Тогда
                ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Задачи);
            КонецЕсли; 
        Иначе
            Если ТипЗнч(ВетвьМД) <> Тип("КоллекцияОбъектовМетаданных") Тогда //ВетвьДерева.СПопыткой Тогда
                ПродолжитьЗаполнениеМД(ВетвьДерева, ВетвьМД);
            Иначе
                Для Каждого ОбъектМД Из ВетвьМД Цикл
                    Если ВетвьДерева.Строки.Найти(ОбъектМД, "МД") = Неопределено Тогда
                        НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
                        НоваяСтрокаДерева.Представление = ОбъектМД.Синоним;
                        Если ПустаяСтрока(НоваяСтрокаДерева.Представление) Тогда
                            НоваяСтрокаДерева.Представление = ОбъектМД.Имя
                        КонецЕсли;
                        НоваяСтрокаДерева.Представление = "" + Префикс + НоваяСтрокаДерева.Представление;
                        НоваяСтрокаДерева.ТекстДляКода = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляКода + ".") + ОбъектМД.Имя;
                        НоваяСтрокаДерева.ТекстДляЗапроса = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляЗапроса + "." + ОбъектМД.Имя);
                        НоваяСтрокаДерева.МД = ОбъектМД;
                        //НоваяСтрокаДерева.СПопыткой = Истина;
                        Если ЗаполнятьВетви Тогда
                            ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД);
                        КонецЕсли;
                    КонецЕсли;
                КонецЦикла;
            КонецЕсли; 
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры //ЗаполнитьДеревоМД

//Вспомогательная для ПродолжитьЗаполнениеМД, вспомогательной для ЗаполнитьДеревоМД. Заполняет ветвь дерева значений по реквизиту объекта метаданных.
//Параметры:
//  ВетвьДерева - СтрокаДереваЗначений, ДеревоЗначений - Заполняемый объект   
//  ОбъектМД - ОбъектМетаданных - Источник данных для заполнения   
//  ИмяМД - Строка - Имя реквизита объекта метаданных, по которому надо заполнить ветвь 
//  Префикс - Строка - Указывается перед пользовательским представлением элемента   
//  СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента для кода или запроса.
&НаСервереБезКонтекста
Процедура ВызватьЗаполнениеСПопыткой(ВетвьДерева, ОбъектМД, ИмяМД, Префикс = "", СброситьПрефикс = Ложь)
    Попытка
        Коллекция = ОбъектМД[ИмяМД];
    Исключение
        Коллекция = Неопределено
    КонецПопытки;
    Если Коллекция <> Неопределено Тогда
        ЗаполнитьДеревоМД(ВетвьДерева, Коллекция, Префикс, СброситьПрефикс,, Истина)
    КонецЕсли;
КонецПроцедуры
                
//Вспомогательная для ЗаполнитьДеревоМД. Заполняет строку дерева по объекту метаданных.
//Параметры:
//  НоваяСтрокаДерева - СтрокаДереваЗначений, ДеревоЗначений - Заполняемый объект   
//  ОбъектМД - ОбъектМетаданных - Источник данных для заполнения   
&НаСервереБезКонтекста
Процедура ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД)
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Реквизиты");
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "СтандартныеРеквизиты");
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ТабличныеЧасти", "#");
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Формы", "^", Истина);
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Макеты", "$", Истина);
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ЗначенияПеречисления");
    ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Команды", ">", Истина);
    НоваяСтрокаДерева.Строки.Сортировать("Представление", Ложь, Новый СравнениеЗначений)
КонецПроцедуры //ПродолжитьЗаполнениеМД

#КонецОбласти 

//Возвращает структуру с ключами ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО - есть ли 
//  регистр ВОЛНА_ДопКонстанты и справочники ДополнительныеОбработки, ВОЛНА_ПереопределяемыеПроцедуры и ВнешниеОтчеты.
//Возвращаемое значение:
//  Структура - ключи ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО, отражающие наличие объектов внешних обработок и значений разного типа.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЕстьДопОбработки() Экспорт
    ИмяТипаПП = "ВОЛНА_ПереопределяемыеПроцедуры";
    ИмяТипаВО = "ВнешниеОбработки";
    ИмяТипаДО = "ДополнительныеОтчетыИОбработки";
    ИмяТипаДК = "ВОЛНА_ДопКонстанты";
    //@skip-check structure-consructor-too-many-keys
    //@skip-check constructor-function-return-section
    Возврат Новый Структура("ЕстьДК,ЕстьДО,ЕстьПП,ЕстьВО,ИмяТипаДК,ИмяТипаДО,ИмяТипаПП,ИмяТипаВО",
            Метаданные.РегистрыСведений.Найти(ИмяТипаДК) <> Неопределено,
            Метаданные.Справочники.Найти(ИмяТипаДО) <> Неопределено,
            Метаданные.Справочники.Найти(ИмяТипаПП) <> Неопределено,
            Метаданные.Справочники.Найти(ИмяТипаВО) <> Неопределено,
            ИмяТипаДК,
            ИмяТипаДО,
            ИмяТипаПП,
            ИмяТипаВО)
КонецФункции // ЕстьДопОбработки()

// РежимыСовместимости
// Возвращаемое значение:
//   Структура   - Ключи Режим (значение - текущий режим) и Р835 (булево, Истина - мы в допотопном 835, до поддержки строковых функций.)
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция РежимСовместимости() Экспорт
    МетаК = Метаданные;
    Режим = МетаК.РежимСовместимости;
    МетаРС = Метаданные.СвойстваОбъектов.РежимСовместимости;
    Результат = Новый Структура("Режим,Р835",
    		Режим,
    		(Режим = МетаРС.Версия8_1) ИЛИ (Режим = МетаРС.Версия8_2_13)
    			ИЛИ (Режим = МетаРС.Версия8_2_16) ИЛИ (Режим = МетаРС.Версия8_3_1)
            	ИЛИ (Режим = МетаРС.Версия8_3_2) ИЛИ (Режим = МетаРС.Версия8_3_3)
            	ИЛИ (Режим = МетаРС.Версия8_3_4) ИЛИ (Режим = МетаРС.Версия8_3_5));
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // РежимСовместимости

//Возвращает версию БСП
//Возвращаемое значение:
//  Строка - версия библиотеки стандартных подсистем
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВерсияБСП() Экспорт
    Попытка
        //@skip-check server-execution-safe-mode
        Результат = Вычислить("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
    Исключение
        Результат = "Нет БСП";
    КонецПопытки;
    Возврат Результат
КонецФункции // ВерсияБСП()

//Возвращает информацию о наличии подсистемы
//Параметры:
//  ИмяПодсистемы - Строка - Имя искомой подсистемы
//Возвращаемое значение:
//  Булево - Подсистема есть
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЕстьПодсистема(ИмяПодсистемы) Экспорт
    Возврат Подсистемы_(Истина).Найти(ИмяПодсистемы) <> Неопределено
КонецФункции

// Возвращает линейный список подсистем
// Параметры:
//   Строки - Булево - Ложь = элементами являются метаданные (по умолчанию), а не строки
//   Родительская - ОбъектМетаданныхПодсистема - Внутри которой будет строиться список. Если не указана - корень.
// Возвращаемое значение:
//      - Массив из ОбъектМетаданныхПодсистема - подистем или их имён.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция Подсистемы_(Строки = Ложь, Родительская = Неопределено) Экспорт
	Если Родительская = Неопределено Тогда
        Родительская = Метаданные;
    КонецЕсли;
    Результат = Новый Массив;
    Для каждого ТекПодсистема Из Родительская.Подсистемы Цикл
        Результат.Добавить(?(Строки, ТекПодсистема.Имя, ТекПодсистема));
		Результат =
				//КлиентСерверХЪ
				СложитьМассивы(Результат, Подсистемы_(Строки, ТекПодсистема));
    КонецЦикла;
    Возврат Результат
КонецФункции // Подсистемы

//Возвращает список картинок библиотеки (из макета, иначе не знаю, как получить) - префикс #Б:
//и из общих картинок - префикс #О:. Результат помещается в список значений, где представление - имя картинки,
//значение - имя картинки с префиксом, а картинка - сама картинка.
//Параметры:
//  СписокКартинокБиблиотеки - Строка - Список картинок библиотеки картинок с разделителем ПС. Способа прочитать этот список программно не нашёл, приходится передавать параметром.
//          Если не задан (пустая строка), производится попытка чтения из макета "КартинкиБиблиотеки"
//  ВставлятьКартинки - Булево - Вставлять в список сами картинки.
//Возвращаемое значение:
//  СписокЗначений из Картинка - список картинок из параметра и из общих картинок.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ПолучитьСписокСтандартныхКартинок(СписокКартинокБиблиотеки = "", ВставлятьКартинки = Истина) Экспорт
    Результат = Новый СписокЗначений;
    Если СписокКартинокБиблиотеки = "" Тогда
        //@skip-check empty-except-statement
        Попытка
            //@skip-check server-execution-safe-mode
            СписокКартинокБиблиотеки = Вычислить("ПолучитьМакет(""КартинкиБиблиотеки"").ПолучитьТекст()");
        Исключение
        КонецПопытки;
    КонецЕсли; 
    Для Ё = 1 По СтрЧислоСтрок(СписокКартинокБиблиотеки) Цикл
        ИмяК = СтрПолучитьСтроку(СписокКартинокБиблиотеки, Ё);
        //@skip-check empty-except-statement
        Попытка
            ТКартинка = БиблиотекаКартинок[ИмяК];
            //@skip-check wrong-type-expression
            Результат.Добавить("#Б:" + ИмяК, ИмяК, Ложь, ?(ВставлятьКартинки, ТКартинка, ""));
        Исключение
        КонецПопытки;
    КонецЦикла; 
    Для каждого ТКартинка Из Метаданные.ОбщиеКартинки Цикл
        //@skip-check wrong-type-expression
        Результат.Добавить("#О:" + ТКартинка.Имя, ТКартинка.Синоним, Ложь, ?(ВставлятьКартинки, БиблиотекаКартинок[ТКартинка.Имя], ""));
    КонецЦикла; 
    Возврат Результат
КонецФункции // ПолучитьСписокСтандартныхКартинок()
 
#КонецОбласти

//Возвращает массив видов характеристик, содержащих заданный тип
//ПВХ - строка с именем ПВХ, Тип - Тип
//Параметры:
//  ПВХ - строка -  имя плана вида характеристик
//  Тип - Тип -  искомый тип
//Возвращаемое значение:
//  Массив из ПланВидовХарактеристикСсылка - виды характеристик, содержащие заданный тип.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВыбратьПВХСодержащиеТип(ПВХ, Тип) Экспорт
    Массив = Новый Массив;
    Запрос = Новый Запрос("ВЫБРАТЬ
    |   ОбъектыСвойств.Ссылка,
    |   ОбъектыСвойств.ТипЗначения
    |ИЗ
    |   ПланВидовХарактеристик." + ПВХ + " КАК ОбъектыСвойств");
    Выборка = Запрос.Выполнить().Выбрать();
    Пока Выборка.Следующий() Цикл
        Если Выборка.ТипЗначения.СодержитТип(Тип) Тогда
            Массив.Добавить(Выборка.Ссылка)
        КонецЕсли
    КонецЦикла;
    Возврат Массив
КонецФункции

// Формирует записи регистра сведений по переданной таблице значений.
// Параметры:
//  ИмяРегистра - Строка - Имя регистра сведений.
//  ТабЗнач  - ТаблицаЗначений - пригодная для загрузки в регистр. При вызове с клиента - массив структур.
//  Перезаписать  - Булево - при Истина регистр будет предварительно очищен, при Ложь (по умолчанию) - нет. При вызове с клиента только Ложь.
//  МаксКолвоДляЗаписиПоОдной  - Число - Оптимизационный параметр. При большом кол-ве записей быстрее записать весь регистр, чем писать записи по одной.
//      Границу определяет этот параметр. По умолчанию 50. При вызове с клиента должен быть больше числа записей - т.е. запись всего регистра вернёт ошибку.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ЗагрузитьРСИзТаблицы(ИмяРегистра, ТабЗнач, Перезаписать = Ложь, МаксКолвоДляЗаписиПоОдной = 50) Экспорт
    ТабДляЗаписи = ТабЗнач;
    Если Перезаписать Тогда
        ПоОдной = Ложь;
    Иначе
        ПоОдной = ТабЗнач.Количество() <= МаксКолвоДляЗаписиПоОдной;
        Если НЕ ПоОдной Тогда
			ТабДляЗаписи = 
					//СерверХЪ
					СоздатьЗапрос(
						"ВЫБРАТЬ Рег.* ИЗ РегистрСведений." + ИмяРегистра + " КАК Рег").Выполнить().Выгрузить();
			//СерверХЪ
			ДобавитьЗаписиИзТаблицыВТаблицу(ТабЗнач, ТабДляЗаписи);
        КонецЕсли;
    КонецЕсли;
    Если ПоОдной Тогда
        Для каждого СтрокаТ Из ТабДляЗаписи Цикл
            ТекЗапись = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
            ЗаполнитьЗначенияСвойств(ТекЗапись, СтрокаТ);
            ТекЗапись.Записать();
        КонецЦикла; 
    Иначе
        Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
        Набор.Загрузить(ТабДляЗаписи);
        Набор.Записать(Истина);
    КонецЕсли;
КонецПроцедуры // ЗагрузитьРСИзТаблицы

//!!!Похоже, не работает в модуле повтисп т.к. ругается на первый параметр (Тип):Несоответствие типов (параметр номер '1') (Неверный тип параметра. Допустимы только примитивные типы, ссылки, Структура)
//Функция продублирована сюда, но это по возможности надо исправить
//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//  Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//  Полностью - Булево, Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//      * ИмяТаблицы - Строка - Имя таблицы для запроса;
//      * Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//      * Метаданные - ОбъектМетаданных - соответствующий объекту
//      * Менеджер - СправочникМенеджер - или иной менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//      Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//      Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение:
//	ОбъектМетаданных, Структура, Строка, Неопределено -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-field-type-strict
&НаСервереБезКонтекста
Функция ИмяТаблицыОбъектаПоТипу(Тип_, Полностью = Ложь) Экспорт
    МетаХ = Метаданные.НайтиПоТипу(Тип_);
    Если МетаХ = Неопределено Тогда
        Результат = Неопределено
    ИначеЕсли Полностью = "Метаданные" Тогда
        Результат = МетаХ;
    Иначе
        ТекИмя = МетаХ.Имя;
        Полная = Новый Структура;
        НуженМенеджер = (СтрНайти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
        Если Метаданные.Документы.Содержит(МетаХ) Тогда
            СтрокаТипа = "Документ";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", Документы[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
            СтрокаТипа = "Справочник";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", Справочники[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.Перечисления.Содержит(МетаХ) Тогда
            СтрокаТипа = "Перечисление";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", Перечисления[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
            СтрокаТипа = "ПланВидовХарактеристик";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
            СтрокаТипа = "ПланСчетов";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
            СтрокаТипа = "ПланВидовРасчета";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
            СтрокаТипа = "БизнесПроцесс";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
            КонецЕсли; 
        ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
            СтрокаТипа = "Задача";
            Если НуженМенеджер Тогда
                Полная.Вставить("Менеджер", Задачи[ТекИмя]);
            КонецЕсли; 
        Иначе
            Результат = "";
        КонецЕсли; 
        Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, СтрНайти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
            Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
        КонецЕсли; 
        Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Текст,") > 0) Тогда
            Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
        КонецЕсли; 
        Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
            Полная.Вставить("Метаданные", МетаХ);
        КонецЕсли;
        Результат = Полная;
        Если Результат.Количество() = 1 Тогда
            Для каждого КиЗ Из Полная Цикл
                Результат = КиЗ.Значение;
            КонецЦикла; 
        КонецЕсли; 
    КонецЕсли; 
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

// Возвращает массив иерархии объекта. Первый элемент - сам объект, последний - высший родитель
// Скорее сего - неоптимально, следует использрвать ТОЛЬКОИЕРАРХИЯ, но это не сработает в псевдоиерархии и циклоссылках
// Параметры:
//  СсылочныйОбъект  - ЛюбаяСсылка с реквизитом Родитель - Объект, мерархию которого надо получить
// Возвращаемое значение:
//   Массив из ЛюбаяСсылка  - Ссылки на объект и по очереди все его родители
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция МассивИерархии(СсылочныйОбъект) Экспорт
    Результат = Новый Массив;
    //@skip-check module-unused-local-variable
    ИмяТаблицы = ИмяТаблицыОбъектаПоТипу(ТипЗнч(СсылочныйОбъект)); //ВОЛНА_ОбщегоНазначенияПовтИспСеансВызовСервера.
    Родитель = СсылочныйОбъект;
    Пока ЗначениеЗаполнено(Родитель) Цикл
        Результат.Добавить(Родитель);
        #Область ТЕКСТ_ЗАПРОСА
			ТекстЗапроса = 
	    			СтрЗаменить(
	    				"ВЫБРАТЬ Банки.Родитель ИЗ Справочник.Банки КАК Банки ГДЕ Банки.Ссылка = &Ссылка",
	    				"Справочник.Банки",
	    				ИмяТаблицы);
			//@skip-check query-in-loop
			Родитель =
					//СерверХЪ
					ПолучитьЕдинственноеЗначениеЗапроса(
							//СерверХЪ
							СоздатьЗапрос(
								ТекстЗапроса,
								Новый Структура("Ссылка", Родитель)));
        #КонецОбласти 
    КонецЦикла;
    Возврат Результат
КонецФункции // МассивИерархии

// Возвращает массив случайных целых чисел
// Параметры:
//  Сколько  - Число - Размер возвращаемого массива. По умолчанию 10.
//  Максимальное  - Число - Максимальное возможное число. Если не указано, то равно Сколько.
//  Минимальное  - Число - Минимальное возможное число. Если не указано, то ноль.
// Возвращаемое значение:
//   Массив из Число - случайные
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция МассивСлЧисПоВремени(Сколько = 10, Максимальное = Неопределено, Минимальное = 0) Экспорт
	Результат = Новый Массив;
	Если Максимальное = Неопределено Тогда
		Максимальное = Сколько;
	КонецЕсли;
    Для Ё = 1 По Сколько Цикл
        Результат.Добавить(ТекущаяУниверсальнаяДатаВМиллисекундах() % (Максимальное - Минимальное + 1) - 1 + Минимальное);
        //Для разброса
        //@skip-check module-unused-local-variable
        А = Log(ТекущаяУниверсальнаяДатаВМиллисекундах() % (ТекущаяУниверсальнаяДатаВМиллисекундах() / 100000));
	КонецЦикла;
	Возврат Результат
КонецФункции // МассивСлЧисПоВремени

//Сериализует заданное значение в XML
//Параметры:
//  Значение - Произвольный - Сериализуемое
// Возвращаемое значение:
//  Строка - XML текст
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ПолучитьXML(Значение) Экспорт
    Запись = Новый ЗаписьXML();
    Запись.УстановитьСтроку();
    СериализаторXDTO.ЗаписатьXML(Запись, Значение);
    Возврат Запись.Закрыть();
КонецФункции

//Определяет имя метаданных значения перечисления
//Параметры:
//  ЗначениеПеречисления - ПеречислениеСсылка - Ссылка, по которой надо вернуть имя
//Возвращаемое значение:
//  Строка - Имя МД значения перечисления
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ПолучитьИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
    ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
    ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
    Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя  
КонецФункции

//Копирует отбор набора записей в отбор другого НЗ того же регистра
//Параметры:
//  Приёмник - РегистрСведенийНаборЗаписей - или иной объект, содержащий Отбор = Объект для настройки отбора
//  Источник - РегистрСведенийНаборЗаписей - или иной объект, содержащий Отбор = Откуда берётся отбор для настройки
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура СкопироватьОтборы(Приёмник, Источник) Экспорт
    Для каждого ЭлементОтбора_ из Источник.Отбор Цикл
        ЭлементПриёмник = Приёмник.Отбор.Найти(ЭлементОтбора_.Имя);
        ЭлементПриёмник.Использование = ЭлементОтбора_.Использование;
        ЭлементПриёмник.ВидСравнения = ЭлементОтбора_.ВидСравнения;
        ЭлементПриёмник.Значение = ЭлементОтбора_.Значение;
        ЭлементПриёмник.ЗначениеС = ЭлементОтбора_.ЗначениеС;
        ЭлементПриёмник.ЗначениеПо = ЭлементОтбора_.ЗначениеПо
    КонецЦикла
КонецПроцедуры

//Возвращает список значений с именами временных таблиц МВТ.
// Параметры:
//	МВТ - МенеджерВременныхТаблиц - источник таблиц
// Возвращаемое значение:
//	СписокЗначений из Строка - полные имена таблиц
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СписокВременныхТаблиц(МВТ) Экспорт
    Результат = Новый СписокЗначений;
    Если ТипЗнч(МВТ) = Тип("МенеджерВременныхТаблиц") Тогда
        Для каждого ВТаб Из МВТ.Таблицы Цикл
            Результат.Добавить(ВТаб.ПолноеИмя, ВТаб.ПолноеИмя);
        КонецЦикла;
    КонецЕсли;
    Возврат Результат;
КонецФункции // СписокВременныхТаблиц()

#КонецОбласти

#Область 	БИБЛИОТЕКА_ФУНКЦИЙ_КЛИЕНТ

#Область 		ИНТЕРАКТИВ

#Область 			ВЫБРАТЬ_ФАЙЛ_И_ПРОДОЛЖИТЬ
	
// Открывает диалог выбора файла и передаёт выполнение в заданную процедуру
// Параметры:
//  ИмяПроцедуры  - Строка - Имя метода (процедуры) продолжения после выбора. Параметры 1 = Строка и 2 = Структура. Если при выборе произойдёт ошибка,
//			в третьем параметре будут ключи Ошибка__СтандартнаяОбработка и Ошибка__ИнфоОбОшибке, а результат будет пустой строкой.
//  ВызывающаяФорма  - ФормаКлиентскогоПриложения, Форма - Форма, из которой будет вызван обработчик оповещения
//			с параметрами ВыбранныеФайлы (массив полных имён выбранных файлов/Неопределено) и ДополнительныеПараметры (см.ПараметрыПродолжения)
//  ПараметрыПродолжения  - Структура - Второй параметр метода продолжения. В процессе выполнения дополняется параметрами Параметр_ИмяПроцедуры И Параметр_ВызывающаяФорма.
//  Фильтр  - Строка - Фильтр в формате "Описание расширения (*.Расширение)|*.Расширение|...". По умолчанию xlsx.
//  ИндексФильтра  - Число - Индекс главного фильтра в строке фильтров. По умолчанию 0.
//  МножественныйВыбор  - Булево - Возможность выбрать несколько файлов
//  Заголовок  - Строка - Заголовок диалога. Если не указан - сформируется автоматически.
//  Режим  - РежимДиалогаВыбораФайла - Режим диалога. По умолчанию Открытие.
//  Каталог  - Строка - Каталог, в котором откроется диалог
//  ПолноеИмяФайла  - Строка - Полное имя файла по умолчанию. Если не указано - сгенерирует ДляЗагрузки.
//  ПроверятьСуществованиеФайла  - Булево - Параметр диалога. По умолчанию ЛОЖЬ
//  ПредварительныйПросмотр  - Булево - Параметр диалога. По умолчанию ЛОЖЬ
//  Расширение  - Строка - Расширение файла. Если не указано - сформируется по главному фильтру.
//@skip-check method-too-many-params
&НаКлиенте
Процедура ВыбратьФайлИПродолжить(ИмяПроцедуры,
	    ВызывающаяФорма,
		ПараметрыПродолжения = Неопределено,
		Фильтр = "#АВТО",
		ИндексФильтра = 0,
		МножественныйВыбор = Истина,
		Заголовок = "#АВТО",
		Режим = Неопределено,
		Каталог = "#АВТО",
		ПолноеИмяФайла = "#АВТО",
		ПроверятьСуществованиеФайла = Ложь,
		ПредварительныйПросмотр = Ложь,
		Расширение = "#АВТО") Экспорт
	#Если ТонкийКлиент ИЛИ ВебКлиент ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ ТолстыйКлиентОбычноеПриложение Тогда
		#Область ИНИЦИАЛИЗАЦИЯ_ПАРАМЕТРОВ_ПО_УМОЛЧАНИЮ
			Если Режим = Неопределено Тогда
				Режим = РежимДиалогаВыбораФайла.Открытие;
			КонецЕсли;
			Если ПараметрыПродолжения = Неопределено Тогда
				ПараметрыПродолжения = Новый Структура;
			КонецЕсли;
			Если Фильтр = "#АВТО" Тогда
				Фильтр = НСтр("ru = 'Книга Excel|*.xlsx'");
			КонецЕсли;
			Если Расширение = "#АВТО" Тогда
				Расширение = СтрПолучитьСтроку(
						СтрЗаменить(
							СтрПолучитьСтроку(
								СтрЗаменить(Фильтр, "|", Символы.ПС),
								2 * ИндексФильтра + 1),
							".",
							Символы.ПС),
						2);
			КонецЕсли;
			Если Заголовок = "#АВТО" Тогда
				Заголовок = ?(Режим = РежимДиалогаВыбораФайла.Сохранение,
						НСтр("ru = 'Выбор пути сохранения'"),
						?(Режим = РежимДиалогаВыбораФайла.ВыборКаталога,
						НСтр("ru = 'Выбор каталога'"),
						НСтр("ru = 'Выбор открываемых файлов'")));
			КонецЕсли;
		#КонецОбласти
		#Область ИНИЦИАЛИЗАЦИЯ_ДИАЛОГА
			ДВФ = Новый ДиалогВыбораФайла(Режим);
			ДВФ.Заголовок = Заголовок;
			ДВФ.ИндексФильтра = ИндексФильтра;
			ДВФ.МножественныйВыбор = МножественныйВыбор;
			ДВФ.ПредварительныйПросмотр = ПредварительныйПросмотр;
			ДВФ.ПроверятьСуществованиеФайла = ПроверятьСуществованиеФайла;
			ДВФ.Расширение = Расширение;
			ДВФ.Фильтр = Фильтр;
		#КонецОбласти
		ПараметрыПродолжения.Вставить("ВызывающаяФорма", ВызывающаяФорма);
		ПараметрыПродолжения.Вставить("ИмяПроцедуры", ИмяПроцедуры);
		СтрПрм = Новый Структура("ДВФ,ПараметрыПродолжения,ПолноеИмяФайла",
				ДВФ, ПараметрыПродолжения, ПолноеИмяФайла);
		ВызватьПродолжение = Истина;
		Если Каталог = "#АВТО" Тогда
		    Если ?(ПолноеИмяФайла = "#АВТО", Ложь, ЗначениеЗаполнено(ПолноеИмяФайла)) Тогда
				Каталог = ИмяКаталога(ПолноеИмяФайла) + "\";
			Иначе
				НачатьПолучениеКаталогаДокументов(Новый ОписаниеОповещения("Выбрать_ФайлИПродолжить", ЭтотОбъект, СтрПрм, "Выбрать_Файл_Ошибка", ЭтотОбъект));
				ВызватьПродолжение = Ложь;
			КонецЕсли;
		КонецЕсли;
		Если ВызватьПродолжение Тогда
			Выбрать_ФайлИПродолжить(Каталог, СтрПрм);
		КонецЕсли;
	#КонецЕсли
КонецПроцедуры // ВыбратьФайлИПродолжить

// Служебная для ВыбратьФайлИПродолжить
// Параметры:
//  Результат  - Строка, Неопределено - Результат получения каталога
//  СтруктураПараметров  - Структура - Параметры, переданные из обрабочика
&НаКлиенте
Процедура Выбрать_ФайлИПродолжить(Результат, СтруктураПараметров = Неопределено) Экспорт
	ТекТип = ТипЗнч(Результат);
	Если ТекТип = Тип("Строка") И ?(СтруктураПараметров = Неопределено, Истина, НЕ СтруктураПараметров.Свойство("Ошибка__ИнфоОбОшибке")) Тогда
		Если СтруктураПараметров.ПолноеИмяФайла = "#АВТО" Тогда
			СтруктураПараметров.ПолноеИмяФайла = Результат + "ДляЗагрузки." + СтруктураПараметров.ДВФ.Расширение;
		КонецЕсли;
		СтруктураПараметров.ДВФ.Каталог = Результат;
		СтруктураПараметров.ДВФ.ПолноеИмяФайла = СтруктураПараметров.ПолноеИмяФайла;
		СтруктураПараметров.ДВФ.Показать(
				Новый ОписаниеОповещения(
					СтруктураПараметров.ПараметрыПродолжения.ИмяПроцедуры,
					СтруктураПараметров.ПараметрыПродолжения.ВызывающаяФорма,
					СтруктураПараметров.ПараметрыПродолжения,
					"Выбрать_Файл_Ошибка",
					ЭтотОбъект));
	ИначеЕсли Результат <> Неопределено Тогда
		КодКВыполнению = "СтруктураПараметров.ВызывающаяФорма." + СтруктураПараметров.ИмяПроцедуры + "(Результат, СтруктураПараметров)";
		#Если ВебКлиент Тогда
			О_О = Новый ОписаниеОповещения(СтруктураПараметров.ИмяПроцедуры, СтруктураПараметров.ВызывающаяФорма , СтруктураПараметров);
			ВыполнитьОбработкуОповещения(О_О, Истина);
		#Иначе
			Выполнить(КодКВыполнению);
		#КонецЕсли
	КонецЕсли;
КонецПроцедуры // Выбрать_ФайлИПродолжить

// Служебная для ВыбратьФайлИПродолжить
// Параметры:
//	ИнфоОбОшибке - Строка - Информация об ошибке
//	СтандартнаяОбработка - Булево - Вызов стандартного обработчика ошибки
//	ПараметрыПриОшибке - Структура - Параметры для повторного вызова
&НаКлиенте
Процедура Выбрать_Файл_Ошибка(ИнфоОбОшибке, СтандартнаяОбработка, ПараметрыПриОшибке = Неопределено) Экспорт
	Если ПараметрыПриОшибке = Неопределено Тогда
		ПараметрыПриОшибке = Новый Структура;
	КонецЕсли;
	ПараметрыПриОшибке.Вставить("Ошибка__СтандартнаяОбработка", СтандартнаяОбработка);
	ПараметрыПриОшибке.Вставить("Ошибка__ИнфоОбОшибке", ИнфоОбОшибке);
	Выбрать_ФайлИПродолжить("", ПараметрыПриОшибке);
	СтандартнаяОбработка = ПараметрыПриОшибке.Ошибка__СтандартнаяОбработка;
КонецПроцедуры // Выбрать_Файл_Ошибка

#КонецОбласти

// Предлагает выбрать реквизит заданного объекта и возвращает его имя
// Параметры:
//  ЧейРеквизит  - Произвольный - Объект, реквизит которого будет предложен к выбору
// Возвращаемое значение:
//   Строка   - Имя ТЧ и реквизита, например "Банк" или "Товары.Количество"
&НаКлиенте
Функция ИмяВыбранногоРеквизита(ЧейРеквизит) Экспорт
	Результат = "НЕ ГОТОВО";
	//Реализовать одним из двух вариантов:
	//А) открыть дерево МД в нужной ветке
	//Б) прочитать МД со значениями (для ТЧ и ТЗ - первой строки)
	//Также должны отрабатываться ситуации для таблицы значений, массива, списка значений, структуры и их фиксиков.
	Возврат Результат
КонецФункции // ИмяВыбранногоРеквизита()
 
// Возвращает ответ, данный пользователем несколько раз (для предотвращения случайных опаснх действий)
//
// Параметры:
//  Кнопки  - РежимДиалогаВопрос, СписокЗначений из Строка - параметр функции Вопрос, по умолчанию РежимДиалогаВопрос.ДаНет
//  КоличествоПовторов  - Число - Количество попыток (сколько раз спросить)
//  ТекстВопроса  -  Строка, ФорматированнаяСтрока - параметр функции Вопрос
//  ТаймАут  - Число - параметр функции Вопрос
//  КнопкаПоУмолчанию  - Произвольный - параметр функции Вопрос
//  Заголовок  - Строка, ФорматированнаяСтрока - параметр функции Вопрос
//  КнопкаТаймАута  - Произвольный - параметр функции Вопрос
//
// Возвращаемое значение:
//   Произвольный   - Если пользователь назвал во всех попытках одно значение - то оно, если нет - неопределено
//
//@skip-check method-too-many-params
&НаКлиенте
Асинх Функция СпроситьТрижды(Кнопки = Неопределено, КоличествоПовторов = 3, ТекстВопроса = "", ТаймАут = 0, КнопкаПоУмолчанию = Неопределено, Заголовок = "Хитрый вопрос", КнопкаТаймАута = Неопределено) Экспорт
	Если Кнопки = Неопределено Тогда
		Кнопки = РежимДиалогаВопрос.ДаНет;
	КонецЕсли;
	Результат = Неопределено;
	Для Ё = 1 По КоличествоПовторов Цикл
		Если ТипЗнч(Кнопки) = Тип("СписокЗначений") Тогда
			ПеремешатьСписок(Кнопки);	
		КонецЕсли; 
		Промежуточный = Ждать ВопросАсинх(ТекстВопроса, Кнопки, ТаймАут, КнопкаПоУмолчанию, Заголовок, КнопкаТаймАута);
		Если Результат = Неопределено Тогда
			Результат = Промежуточный;
		ИначеЕсли Результат <> Промежуточный Тогда
			Результат = Неопределено;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Возврат Результат;
КонецФункции // СпроситьТрижды()

#КонецОбласти 

#Область СОБРАТЬ_И_ПРОВЕРИТЬ_ФАЙЛЫ
	
// Собирает пути файлов из каталогов в массив, а для файлов только проверяет существование
// Параметры:
//  ФинальноеОповещение  - ОписаниеОповещения - ДополнительныеСвойства должны содержать ключ Результат = массив,
//  		куда будут возвращены пути к проверенным файлам. Процедура будет вызвана с результатом Неопределено после обработки всех путей.
//  ПутиИКаталоги  - Массив из Файл, Массив из Строка, Строка, Файл - Пути к файлам и каталогам
//  ПроверятьСуществование  - Булево - Требуется проверка, по умолчанию Истина
//  ПараметрыКаталогов  - Строка, Массив из Строка - Пути к файлам и каталогам
//@skip-check doc-comment-type
//@skip-check export-method-in-command-form-module
&НаКлиенте
Процедура СобратьИПроверитьФайлы(ФинальноеОповещение, ПутиИКаталоги, ПроверятьСуществование = Истина, ПараметрыКаталогов = Неопределено) Экспорт
	Если ПараметрыКаталогов = Неопределено Тогда
		ПараметрыКаталогов = Новый Соответствие;
		ПараметрыКаталогов.Вставить(Истина, Новый Структура("Маска,ИскатьВПодкаталогах", "", Истина));
	КонецЕсли;
	ТипФайл = Тип("Файл");
	МПути =
			//КлиентСерверХЪ
			ПреобразоватьВМассив(ПутиИКаталоги);
	СооПути = Новый Соответствие;
	ПостоянныеПараметры = Новый Структура("О_О,Пути", ФинальноеОповещение, СооПути);
	Для каждого ТекЭл Из МПути Цикл
		Если Тип(ТекЭл) = ТипФайл Тогда
			ТекФайл = ТекЭл;
			ТекПуть = ТекЭл.ПолноеИмя;
		Иначе
			ТекФайл = Новый Файл(ТекЭл);
			ТекПуть = ТекЭл;
		КонецЕсли;
		СооПути.Вставить(ТекПуть, Истина);
		ТекПараметры = Новый Структура("Постоянные", ПостоянныеПараметры);
		ТекПараметры.Вставить("Файл", ТекФайл);
		ТекПараметры.Вставить("ПараметрыКаталога", ?(ПараметрыКаталогов[ТекПуть] = Неопределено, ПараметрыКаталогов[Истина], ПараметрыКаталогов[ТекПуть]));
		Если ПроверятьСуществование Тогда
			СооПути.Вставить(ТекПуть, Истина);
			О_О = Новый ОписаниеОповещения("СобратьФайлы_ПослеПроверкиСуществования", ЭтотОбъект, ТекПараметры);
			ТекФайл.НачатьПроверкуСуществования(О_О);
		Иначе
			СобратьФайлы_ПослеПроверкиСуществования(Истина, ТекПараметры);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // СобратьИпроверитьФайлы

// Вспомогательная для СобратьИПроверитьФайлы. Проверяет окончание обработки и вызывает финальное оповещение
// Параметры:
//  Параметры_  - Структура - ключи Постоянные (Ключи О_О и Пути), ПараметрыКаталога (здесь не исп.) и Файл.
&НаКлиенте
Процедура СобратьФайлы_ЗавершитьОбработкуПути(Параметры_) Экспорт
	Параметры_.Постоянные.Пути[Параметры_.Файл.ПолноеИмя] = Ложь;
	Результат = Ложь;
	Для Каждого ЕщёВРаботе Из Параметры_.Постоянные.Пути Цикл
		Результат = ЕщёВРаботе.Значение;
		Если Результат Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Не Результат Тогда
		ВыполнитьОбработкуОповещения(Параметры_.Постоянные.О_О);
	КонецЕсли;
КонецПроцедуры // СобратьФайлы_ЗавершитьОбработкуПути

// Вспомогательная для СобратьИПроверитьФайлы
// Параметры:
//  РезультатПоиска  - Массив из Файл - Найденные в каталоге файлы
//  СтруктураПараметров  - Структура - ключи Постоянные (Ключи О_О и Пути), ПараметрыКаталога, Файл.
&НаКлиенте
Процедура СобратьФайлы_ПослеПоискаФайлов(РезультатПоиска, СтруктураПараметров) Экспорт
	Для Каждого ТекФайл Из РезультатПоиска Цикл
		СтруктураПараметров.Постоянные.О_О.ДополнительныеПараметры.Результат.Добавить(ТекФайл.ПолноеИмя);
	КонецЦикла;
	СобратьФайлы_ЗавершитьОбработкуПути(СтруктураПараметров);
КонецПроцедуры // СобратьФайлы_ЗавершитьОбработкуПути

// Вспомогательная для СобратьИПроверитьФайлы
// Параметры:
//  Результат  - Булево - Файл существует
//  СтруктураПараметров  - Структура - ключи Постоянные (Ключи О_О и Пути), ПараметрыКаталога, Файл.
&НаКлиенте
Асинх Процедура СобратьФайлы_ПослеПроверкиСуществования(Результат, СтруктураПараметров) Экспорт
	Если Результат Тогда
		Если Ждать СтруктураПараметров.Файл.ЭтоФайлАсинх() Тогда
			СтруктураПараметров.Постоянные.О_О.ДополнительныеПараметры.Результат.Добавить(СтруктураПараметров.Файл.ПолноеИмя);
			СобратьФайлы_ЗавершитьОбработкуПути(СтруктураПараметров);
		ИначеЕсли Ждать СтруктураПараметров.Файл.ЭтоКаталогАсинх() Тогда
			НачатьПоискфайлов(
					Новый ОписаниеОповещения("СобратьФайлы_ПослеПоискаФайлов", ЭтотОбъект , СтруктураПараметров),
					СтруктураПараметров.Файл.ПолноеИмя,
					СтруктураПараметров.ПараметрыКаталога.Маска,
					СтруктураПараметров.ПараметрыКаталога.ИскатьВПодкаталогах);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры // ПослеПроверкиСуществования

#КонецОбласти

// Отправляет файл в хранилище на сервер и возвращает адрес двоичных данных
// Параметры:
//  ПутьКФайлам  - Массив из Строка, Строка - Источник файлов (путь к файлу/файлам). Собрать файлы из каталога и
//  		проверить существование следует заранее в асинхронном режиме
//  УИДдляХранения  - УникальныйИдентификатор - УИД формы хранилища
//  ООХВ  - ОписаниеОповещения - для хода выполнения
//  ООПН  - ОписаниеОповещения - перед началом
// Возвращаемое значение:
//   Массив из ОписаниеПомещенногоФайла - Адреса в хранилище
//@skip-check method-too-many-params
&НаКлиенте
Асинх Функция ФайлыВХранилищеНаСервере(
		ПутьКФайлам,
		УИДдляХранения = Неопределено,
		ООХВ = Неопределено,
		ООПН = Неопределено) Экспорт
	МПути =
			//КлиентСерверХЪ
			ПреобразоватьВМассив(ПутькФайлам);
	МФайлыДляПомещенияНаСервер = Новый Массив;
	Для каждого ПутьКФайлуИсточнику Из МПути Цикл
		ОписаниеФайла = Новый ОписаниеПередаваемогоФайла;
		ОписаниеФайла.Имя = ПутьКФайлуИсточнику;
		мФайлыДляПомещенияНаСервер.Добавить(ОписаниеФайла);
	КонецЦикла;
	Результат = Ждать ПоместитьФайлыНаСерверАсинх(ООХВ, ООПН, мФайлыДляПомещенияНаСервер, УИДдляХранения);
	Возврат Результат
КонецФункции // Имя функции

#КонецОбласти

#Область 	БИБЛИОТЕКА_ФУНКЦИЙ_КЛИЕНТСЕРВЕР

#Область 		ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//  ТекстКодаПараметр - Строка - Выполняемый код
//  Прм - Произвольный, Структура - параметры, по умолчанию Неопределено
//  Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//          * При Истина к ТекстКода применяется Вычислить
//          * При Ложь - Выполнить, а возвращается значение переменной Результат.
//          По умолчанию Ложь
//  ПрямоеОбращение - Строка, Массив из Строка - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//          "-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//  Журнал - Булево - Выполнять в попытке и ошибку записать в журнал. Не используется на клиенте.
//  ИмяПроцесса - Строка - Параметр записи журнала. Не используется на клиенте.
//  ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке. Не используется на клиенте.
//  ВебКлиентПеренаправитьНаСервер - Булево - т.к. в веб-клиенте нет выполнить, идёт перенаправление на сервер, при Ложь (по умолчанию) - на клиент в обработке оповещения.
//  
//Возвращаемое значение:
//      Произвольный - то, что будет вычислено.
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-field-type
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ВыполнитьКод(
        ТекстКодаПараметр,
        Прм = Неопределено, 
        Результат = Неопределено,
        РежимВычисления = Ложь,
        ПрямоеОбращение = "-В",
        Журнал = Ложь,
        ИмяПроцесса = "",
        ПрефиксОшибки = "") Экспорт
    ТекстКода_ = ДобавитьПараметрыВВыполняемыйКод(?(РежимВычисления, "Результат = ", "") + ТекстКодаПараметр, Прм,, ПрямоеОбращение);
    ЭтоСервер = МестоВыполненияКода(Истина) = "Сервер";
    Если ЭтоСервер И Журнал Тогда
        Попытка
            //@skip-check server-execution-safe-mode
            //@skip-check unsupported-operator
            Выполнить(ТекстКода_);
        Исключение
            Результат = ОписаниеОшибки();
            //@skip-check server-execution-safe-mode
            //@skip-check unsupported-operator
            Выполнить("ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ПрефиксОшибки + Результат)");
        КонецПопытки;
    Иначе
        #Если ВебКлиент Тогда
        	//Передача на сервер
			ТекстКода_ = 
					//ВызовСервераХЪ
					ВыполнитьКодНаСервере(
						ТекстКода_,
						Прм,
						Результат,
						РежимВычисления,
						ПрямоеОбращение,
						Журнал,
						ИмяПроцесса,
						ПрефиксОшибки);
        #Иначе
	        //@skip-check server-execution-safe-mode
	        Выполнить(ТекстКода_);
        #КонецЕсли
    КонецЕсли;
    Возврат Результат
КонецФункции

// Добавляет в выполняемый код параметры из структуры для использования напрямую, как переменные
// Параметры:
//  ТекстКодаПараметр  - Строка - Выполняемый код
//	СтрПараметров - Структура - Параметры, добавляемые в код. Допускается использование строки таблицы значений,
//			но только если указан ДобавитьТолькоЭтиКлючи. Может содержать ключ СПарам - структуру, где спецключи
//			___ИменаКод и ___ИменаПрог, содержащие массивы ключей СПарам, которые содержат вычисляемый/выполняемый код.
//	ВКонцеВернутьКакБыло - Булево - В конце кода вернуть значения в структуру. По умолчанию Истина
//	ДобавитьТолькоЭтиКлючи - Строка, Массив из Строка  - Через запятую ключи, которые надо добавить. По умолчанию "-В" = Все ключи
// Возвращаемое значение:
//   Строка   - Исправленный код
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ДобавитьПараметрыВВыполняемыйКод(ТекстКодаПараметр, СтрПараметров, ВКонцеВернутьКакБыло = Истина, ДобавитьТолькоЭтиКлючи = "-В") Экспорт
	Результат = ТекстКодаПараметр;
	ТипПрм = ТипЗнч(СтрПараметров);
	ТипСтр = Тип("Структура");
	ТипФС = Тип("ФиксированнаяСтруктура");
	Если (ТипПрм = ТипСтр) ИЛИ (ТипПрм = ТипФС) ИЛИ Строка(ТипПрм) = "СтрокаТаблицыЗначений" Тогда
		Если СтрПараметров.Свойство("СПарам") Тогда
			ТипСПрм = ТипЗнч(СтрПараметров.СПарам);
			Если ТипСПрм = ТипСтр ИЛИ ТипСПрм = ТипФС Тогда
				Если СтрПараметров.СПарам.Свойство("___ИменаКод") Тогда
					Для Каждого Ключ_ Из СтрПараметров.СПарам.___ИменаКод Цикл
					    //@skip-check server-execution-safe-mode
						Результат = "СПарам." + Ключ_ + " = Вычислить(СПарам." + Ключ_ + ");" + Результат;
					КонецЦикла;
					Для Каждого Ключ_ Из СтрПараметров.СПарам.___ИменаПрог Цикл
						Результат = "ТМП___Хрюква = Результат; Результат = Неопределено;" + Символы.ПС
								+ "Выполнить(СПарам." + Ключ_ + ");" + Символы.ПС
								+  "СПарам." + Ключ_ + " = Результат; Результат = ТМП___Хрюква; ТМП___Хрюква = Неопределено;"
								+ Символы.ПС + Результат;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ДобавитьТолькоЭтиКлючи = "-В" Тогда
			МассивКлючей = Новый Массив;
			Для каждого КиЗ Из СтрПараметров Цикл
				МассивКлючей.Добавить(КиЗ.Ключ);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ДобавитьТолькоЭтиКлючи) = Тип("Массив") Тогда
			МассивКлючей = ДобавитьТолькоЭтиКлючи;
		Иначе
			МассивКлючей = СтрРазделить(ДобавитьТолькоЭтиКлючи, ",", Ложь);
		КонецЕсли;
		Для каждого Ключ_ Из МассивКлючей Цикл
			Результат = Ключ_ + " = Прм[""" + Ключ_ + """];" + Символы.ПС + Результат + Символы.ПС + ?(ВКонцеВернутьКакБыло, ";Прм[""" + Ключ_ + """] = " + Ключ_, ";");
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДобавитьПараметрыВВыполняемыйКод

// Удаляет из текста запроса уничтожение ВТ
// Параметры:
//  ТекстЗапроса  - Строка - Исходный текст запроса
//  Исключения  - Строка - Имена таблиц, уничтожение которых отменять не надо (через запятую). По умолчанию ""
// Возвращаемое значение:
//   Строка   - Текст запроса без уничтожений ВТ
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ОтменитьУничтожения(ТекстЗапроса, Исключения = "") Экспорт
    ВесьТекстЗагл = ВРег(ТекстЗапроса);
    ЭтоНачалоЗапроса = Истина;
    Результат = "";
    ДопустимыеСимволыИмени = СимволыГруппы("ДляПеремВсеЗагл");
    ДопустимыйПервый = СимволыГруппы("ДляПерем1Загл");
    ВзятьЭтуПодстроку = Истина;
    УсловноеНачало = "";
    //Цикл по строкам текста запроса
    Для СчСтрТ = 1 По СтрЧислоСтрок(ВесьТекстЗагл) Цикл
        ТекСтрокаЗапроса = СтрПолучитьСтроку(ТекстЗапроса, СчСтрТ);
        ТекСтрокаЗагл = СтрПолучитьСтроку(ВесьТекстЗагл, СчСтрТ);
        ПоложениеКоммента = СтрНайти(ТекСтрокаЗагл, "//");
        ДлинаТекСтроки = СтрДлина(ТекСтрокаЗагл);
        Если ПоложениеКоммента = 0 Тогда
            ПоложениеКоммента = ДлинаТекСтроки + 1;
        КонецЕсли; 
        ТекСтрокаЗагл = СтрЗаменить(Лев(ТекСтрокаЗагл, ПоложениеКоммента - 1), ";", Символы.ПС);
        СчДл = 0;
        РезультатПоСтроке = "";
        КолвоЗапросовВСтроке = СтрЧислоВхождений(ТекСтрокаЗагл, Символы.ПС) + 1;//Именно так! СтрЧислоСтрок(ТекСтрокаЗагл); даёт ошибку!
        СчЗапросов = 0;
        //Цикл по запросам (фрагментам между ;) внутри строки
        Пока СчЗапросов < КолвоЗапросовВСтроке Цикл
            СчЗапросов = СчЗапросов + 1;
            ЭтаПодстрока = СтрПолучитьСтроку(ТекСтрокаЗагл, СчЗапросов);// + ";";//?(СчЗапросов = КолвоЗапросовВСтроке, "", ";");
            ДлинаЭтойПодстроки = СтрДлина(ЭтаПодстрока);
            Если ДлинаЭтойПодстроки + СчДл >= ПоложениеКоммента Тогда
                ДлинаЭтойПодстроки = ПоложениеКоммента - 1 - СчДл;
                ЭтаПодстрока = Лев(ЭтаПодстрока, ДлинаЭтойПодстроки);
                КолвоЗапросовВСтроке = СчЗапросов; //Завершение цикла
            КонецЕсли;
            ПрошлаяСтрокаЗакончиласьПСПослеУничтожить = УсловноеНачало <> "";
            //Похоже, ЭтоНачалоЗапроса пытались убирать из этого условия. Это нельзя делать, иначе все ; пропадут
            //ВзятьЭтуПодстроку нужно, чтобы после УНИЧТОЖИТЬ не брались строки до конца запроса, когда будет СчЗапросов > 1.
            Если ВзятьЭтуПодстроку ИЛИ (СчЗапросов > 1) ИЛИ ПрошлаяСтрокаЗакончиласьПСПослеУничтожить ИЛИ ЭтоНачалоЗапроса Тогда
                ВзятьЭтуПодстроку = Истина;
                Если ПустаяСтрока(ЭтаПодстрока) Тогда
                    Если КолвоЗапросовВСтроке = 1 Тогда
                        Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
                            УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
                        КонецЕсли;
                    Иначе
                        ЭтоНачалоЗапроса = Истина;
                        Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
                            РезультатПоСтроке = РезультатПоСтроке + УсловноеНачало;
                            УсловноеНачало = "";
                        КонецЕсли;
                    КонецЕсли;
                Иначе
                    ДоУничтожитьЧисто = Ложь;
                    Если ЭтоНачалоЗапроса Тогда
                        ЕстьОтступПослеУничтожить = Ложь;//Скорректируется позже, это инициализация
                        ПолУн = СтрНайти(ЭтаПодстрока, "УНИЧТОЖИТЬ");
                        ДоУничтожитьЧисто = ПустаяСтрока(Лев(ЭтаПодстрока, ПолУн - 1));
                    ИначеЕсли ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
                        ДоУничтожитьЧисто = Истина;
                        ЕстьОтступПослеУничтожить = Истина;
                        ПолУн = - 9;
                    КонецЕсли;
                    Если ДоУничтожитьЧисто Тогда
                        ТекСимвол = "";
                        Для Ё = ПолУн + 10 По ДлинаЭтойПодстроки Цикл
                            ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
                            Если НЕ ПустаяСтрока(ТекСимвол) Тогда
                                Прервать;
                            КонецЕсли;
                            ЕстьОтступПослеУничтожить = Истина;
                        КонецЦикла;
                        Если ЕстьОтступПослеУничтожить Тогда
                            Если (Ё > ДлинаЭтойПодстроки) И (КолвоЗапросовВСтроке = СчЗапросов) Тогда
                                УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
                                ВзятьЭтуПодстроку = Ложь;
                            ИначеЕсли СтрНайти(ДопустимыйПервый, ТекСимвол) > 0 Тогда
                                ПозНачалаИмени = Ё;
                                Пока Истина Цикл
                                    Ё = Ё + 1;
                                    ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
                                    Если (ТекСимвол = "") ИЛИ (СтрНайти(ДопустимыеСимволыИмени, ТекСимвол) = 0) Тогда
                                        Прервать;
                                    КонецЕсли;
                                КонецЦикла;
                                Если ПустаяСтрока(Сред(ЭтаПодстрока, Ё, ДлинаЭтойПодстроки - Ё + 1)) Тогда
                                    ИмяВТ = Сред(ЭтаПодстрока, ПозНачалаИмени, Ё - ПозНачалаИмени);
                                    Если НайтиПодСтроку(Исключения, ИмяВТ) = 0 Тогда
                                        ВзятьЭтуПодстроку = Ложь;
                                        УсловноеНачало = "";
                                    КонецЕсли;
                                КонецЕсли;
                            КонецЕсли;
                        КонецЕсли;
                    КонецЕсли;
                    ЭтоНачалоЗапроса = КолвоЗапросовВСтроке > СчЗапросов;
                КонецЕсли;
            КонецЕсли;
            Если ВзятьЭтуПодстроку Тогда
                РезультатПоСтроке = РезультатПоСтроке + ";" + УсловноеНачало + Сред(ТекСтрокаЗапроса, СчДл, ДлинаЭтойПодстроки);// + ";"
            КонецЕсли;
            СчДл = СчДл + ДлинаЭтойПодстроки + 1;
        КонецЦикла;
        Результат = Результат + Символы.ПС + Сред(РезультатПоСтроке, 2) + Сред(ТекСтрокаЗапроса, ПоложениеКоммента, ДлинаТекСтроки);//после ПоложениеКоммента было -1 - убрал, должен же браться коммент
    КонецЦикла;
    Возврат Сред(Результат, 2)
КонецФункции // ОтменитьУничтожения
 
//Генерит ошибку для запуска конфигуратора
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура ПерейтиВКонфигуратор() Экспорт
    //@skip-check bsl-variable-name-invalid
    //@skip-check module-unused-local-variable
    Ы = 1/0
КонецПроцедуры

#Конецобласти

#Область 		ДАТЫ_И_ПЕРИОДЫ
    
// Возвращает граничную дату по варианту СДН или СП. Аналог обращений СтандартнаяДатаНачала.Дата или СтандартныйПериод.ДатаОкончания,
//но дляотсчёта от несегодня СДП и СДН неприменимы.
// Параметры:
//  ДатаОтсчёта  - Дата - Дата отсчёта для вычисления периода
//  Вариант - ВариантСтандартнойДатыНачала, ВариантСтандартногоПериода - вариант из СДП или СДН, применяемый к ДатаОтсчёта
//  Начало - Неопределено, Булево - При Истина возращается дата начала периода. При Ложь - возвращается конец.
//          По умолчанию Неопределено - возвращается структура с ключами Дата1 и Дата2.
//          Для СДН Конец = Дата-1, начало = Дата, т.е. Конец < Начало.
// Возвращаемое значение:
//   Дата, Структура  - Найденная граничная дата или структура с ключами:
//		Дата1 - Дата - Начало периода или дата стандартной даты
//		Дата2 - Дата - Конец периода или Дата1 - 1 для Стандартной даты
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ДатаПоВарианту(ДатаОтсчёта, Вариант, Начало = Неопределено) Экспорт
    Если Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоГода Тогда
        Дата1 = Дата(Год(ДатаОтсчёта) - 1, 1, 1);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоДня Тогда
        Дата1 = НачалоДня(ДатаОтсчёта - 24 * 3600);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоКвартала Тогда
        Дата1 = ДобавитьМесяц(НачалоКвартала(ДатаОтсчёта), -3);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоМесяца Тогда
        Дата1 = ДобавитьМесяц(НачалоМесяца(ДатаОтсчёта), -1);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоПолугодия Тогда
        Дата1 = НачалоГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) < 7 Тогда
            Дата1 = ДобавитьМесяц(Дата1, -6);
        КонецЕсли;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойДекады Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
        КонецЕсли;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойНедели Тогда
        Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоГода Тогда
        Дата2 = КонецГода(ДатаОтсчёта);
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоДня Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоКвартала Тогда
        Дата2 = КонецКвартала(ДатаОтсчёта);
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоМесяца Тогда
        Дата2 = КонецМесяца(ДатаОтсчёта);
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоПолугодия Тогда
        Дата2 = КонецГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) < 7 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -6);
        КонецЕсли;
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейДекады Тогда
        Дата2 = КонецМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
        КонецЕсли;
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейНедели Тогда
        Дата2 = КонецНедели(ДатаОтсчёта);
        Дата1 = Дата2 + 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоГода Тогда
        Дата1 = НачалоГода(ДатаОтсчёта);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоДня Тогда
        Дата1 = НачалоДня(ДатаОтсчёта);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоКвартала Тогда
        Дата1 = НачалоКвартала(ДатаОтсчёта);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоМесяца Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоПолугодия Тогда
        Дата1 = НачалоГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) > 6 Тогда
            Дата1 = ДобавитьМесяц(ДатаОтсчёта, 6);
        КонецЕсли;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойДекады Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) > 10 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
            Дата1 = Дата1 + 20 * 24 * 3600;
        КонецЕсли;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойНедели Тогда
        Дата1 = НачалоНедели(ДатаОтсчёта);
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.ПроизвольнаяДата Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = Дата1 - 1;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Вчера Тогда
        Дата2 = НачалоДня(ДатаОтсчёта) - 1;
        Дата1 = НачалоДня(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоГода Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецГода(ДатаОтсчёта);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоКвартала Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецКвартала(ДатаОтсчёта);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоМесяца Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецМесяца(ДатаОтсчёта);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоПолугодия Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) < 7 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -6);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойДекады Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойНедели Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = КонецНедели(ДатаОтсчёта);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Завтра Тогда
        Дата1 = КонецДня(ДатаОтсчёта) + 1;
        Дата2 = КонецДня(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Месяц Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = ДобавитьМесяц(Дата2, -1) + 1;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Последние7Дней Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = Дата2 + 1 - 7 * 24 * 3600;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод Тогда
        Дата1 = ДатаОтсчёта;
        Дата2 = ДатаОтсчёта;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекада Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата2 = Дата1 - 1;
            Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата2 = Дата1 + 10 * 24 * 3600 - 1;
        Иначе
            Дата1 = Дата1 + 10 * 24 * 3600;
            Дата2 = Дата1 + 10 * 24 * 3600 - 1;
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекадаДоТакогоЖеНомераДня Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
            Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата2 = Дата2 - 10 * 24 * 3600;
        Иначе
            Дата1 = Дата1 + 10 * 24 * 3600;
            Дата2 = Дата2 - 10 * 24 * 3600;
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделя Тогда
        Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
        Дата2 = КонецНедели(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделяДоТакогоЖеДняНедели Тогда
        Дата2 = КонецДня(ДатаОтсчёта) - 7 * 24 * 3600;
        Дата1 = НачалоНедели(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодие Тогда
        Дата1 = НачалоГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) < 7 Тогда
            Дата1 = ДобавитьМесяц(Дата1, -6);
        КонецЕсли;
        Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодиеДоТакойЖеДаты Тогда
        Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), -6);
        Дата1 = НачалоГода(Дата2);
        Если Месяц(Дата1) > 6 Тогда
            Дата1 = ДобавитьМесяц(Дата1, 6);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГод Тогда
        Дата2 = НачалоГода(ДатаОтсчёта) - 1;
        Дата1 = НачалоГода(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГодДоТакойЖеДаты Тогда
        Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -12));
        Дата1 = НачалоГода(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКвартал Тогда
        Дата2 = НачалоКвартала(ДатаОтсчёта) - 1;
        Дата1 = НачалоКвартала(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКварталДоТакойЖеДаты Тогда
        Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -3));
        Дата1 = НачалоКвартала(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяц Тогда
        Дата2 = НачалоМесяца(ДатаОтсчёта) - 1;
        Дата1 = НачалоМесяца(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяцДоТакойЖеДаты Тогда
        Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -1));
        Дата1 = НачалоМесяца(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Сегодня Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоДня(ДатаОтсчёта);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекада Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
            Дата2 = Дата1 + 10 * 24 * 3600 - 1;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата1 = Дата1 + 20 * 24 * 3600;
            Дата2 = КонецМесяца(ДатаОтсчёта);
        Иначе
            Дата2 = КонецМесяца(ДатаОтсчёта) + 10 * 24 * 3600 - 1;
            Дата1 = ДобавитьМесяц(Дата1, 1);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекадаДоТакогоЖеНомераДня Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
            Дата2 = Дата2 + 10 * 24 * 3600;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата1 = Дата1 + 20 * 24 * 3600;
            Дата2 = Дата2 + 10 * 24 * 3600;
        Иначе
            Дата1 = ДобавитьМесяц(Дата1, 1);
            Дата2 = ДобавитьМесяц(Дата2, 1) - 20 * 24 * 3600;
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделя Тогда
        Дата1 = КонецНедели(ДатаОтсчёта) + 1;
        Дата2 = КонецНедели(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделяДоТакогоЖеДняНедели Тогда
        Дата2 = КонецДня(ДатаОтсчёта) + 7 * 24 * 3600;
        Дата1 = НачалоНедели(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодие Тогда
        Дата2 = КонецГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) > 6 Тогда
            Дата2 = ДобавитьМесяц(Дата2, 6);
        КонецЕсли;
        Дата1 = ДобавитьМесяц(Дата1 + 1, -6);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодиеДоТакойЖеДаты Тогда
        Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 6);
        Дата1 = НачалоГода(Дата2);
        Если Месяц(Дата1) > 6 Тогда
            Дата1 = ДобавитьМесяц(Дата1, 6);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.Следующие7Дней Тогда
        Дата1 = НачалоДня(ДатаОтсчёта);
        Дата2 = Дата1 + 7 * 24 * 3600 - 1;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГод Тогда
        Дата1 = КонецГода(ДатаОтсчёта)+ 1;
        Дата2 = КонецГода(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГодДоТакойЖеДаты Тогда
        Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, 12));
        Дата1 = НачалоГода(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКвартал Тогда
        Дата1 = КонецКвартала(ДатаОтсчёта) + 1;
        Дата2 = КонецКвартала(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКварталДоТакойЖеДаты Тогда
        Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 3);
        Дата1 = НачалоКвартала(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяц Тогда
        Дата1 = КонецМесяца(ДатаОтсчёта) + 1;
        Дата2 = КонецМесяца(Дата1);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяцДоТакойЖеДаты Тогда
        Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 1);
        Дата1 = НачалоМесяца(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоГода Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоГода(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоКвартала Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоКвартала(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоМесяца Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоМесяца(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоПолугодия Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоГода(Дата2);
        Если Месяц(Дата1) > 6 Тогда
            Дата1 = ДобавитьМесяц(Дата1, 6);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойДекады Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
        Иначе
            Дата1 = Дата1 + 20 * 24 * 3600;
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойНедели Тогда
        Дата2 = КонецДня(ДатаОтсчёта);
        Дата1 = НачалоНедели(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаДекада Тогда
        Дата1 = НачалоМесяца(ДатаОтсчёта);
        Если День(ДатаОтсчёта) < 11 Тогда
            Дата2 = Дата1 + 10 * 24 * 3600 - 1;
        ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
            Дата1 = Дата1 + 10 * 24 * 3600;
            Дата2 = Дата1 + 10 * 24 * 3600 - 1;
        Иначе
            Дата1 = Дата1 + 20 * 24 * 3600;
            Дата2 = КонецМесяца(Дата1);
        КонецЕсли;
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаНеделя Тогда
        Дата2 = КонецНедели(ДатаОтсчёта);
        Дата1 = НачалоНедели(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтоПолугодие Тогда
        Дата1 = НачалоГода(ДатаОтсчёта);
        Если Месяц(ДатаОтсчёта) > 6 Тогда
            Дата1 = ДобавитьМесяц(Дата1, 6);
        КонецЕсли;
        Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотГод Тогда
        Дата2 = КонецГода(ДатаОтсчёта);
        Дата1 = НачалоГода(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотКвартал Тогда
        Дата2 = КонецКвартала(ДатаОтсчёта);
        Дата1 = НачалоКвартала(Дата2);
    ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотМесяц Тогда
        Дата2 = КонецМесяца(ДатаОтсчёта);
        Дата1 = НачалоМесяца(Дата2);
    Иначе
        Дата1 = ДатаОтсчёта;
        Дата2 = ДатаОтсчёта;
    КонецЕсли;
    //@skip-check constructor-function-return-section
    Возврат ?(Начало = Неопределено,
    		Новый Структура("Дата1,Дата2", Дата1, Дата2),
    		 ?(Начало, Дата1, Дата2));
КонецФункции // ДатаПоВарианту

// Возвращает текущую дату клиента или сервера
// Параметры:
//  Универсальная  - Булево - На сервере вернуть униврсальную дату. Ложь (по умолчанию) с сервера возвратит дату сеанса
// Возвращаемое значение:
//   Дата   - Текущая дата клиента или сервера
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЗасечьВремя(Универсальная = Ложь) Экспорт
    Если МестоВыполненияКода(Истина) = "Клиент" Тогда
        //@skip-check use-non-recommended-method
        Результат = ТекущаяДата();
    Иначе
        Если Универсальная Тогда
            Код = "ТекущаяУниверсальнаяДата()";
        Иначе
            Код = "ТекущаяДатаСеанса()";
        КонецЕсли;
        //@skip-check server-execution-safe-mode
        Результат = Вычислить(Код);
    КонецЕсли;
    Возврат Результат
КонецФункции // ЗасечьВремя

// Возвращает соответствие дня недели номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения первая заглавная), Истина = Ключи = Строки (ВРЕГ), строки всегда без предлогов
//   Формат_ - Строка -
//          *В среду
//          *Все (только для КлючСтрокаЗначениеЧисло = Истина)
//          *Все среды
//          *До среды
//          *К среде
//          *По средам
//          *Среда (по умолчанию)
// Возвращаемое значение:
//   Соответствие из Строка  - дней недели и их номеров
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СоответствиеДнейНедели(КлючСтрокаЗначениеЧисло = Ложь, Формат_ = "Среда") Экспорт
    Результат = Новый Соответствие;
    Если КлючСтрокаЗначениеЧисло Тогда
        Если Формат_ = "Среда" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
            Результат.Вставить("ВТОРНИК", 2);
            Результат.Вставить("СРЕДА", 3);
            Результат.Вставить("ЧЕТВЕРГ", 4);
            Результат.Вставить("ПЯТНИЦА", 5);
            Результат.Вставить("СУББОТА", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
        КонецЕсли;
        Если Формат_ = "По средам" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИКАМ", 1);
            Результат.Вставить("ВТОРНИКАМ", 2);
            Результат.Вставить("СРЕДАМ", 3);
            Результат.Вставить("ЧЕТВЕРГАМ", 4);
            Результат.Вставить("ПЯТНИЦАМ", 5);
            Результат.Вставить("СУББОТАМ", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЯМ", 7);
        КонецЕсли;
        Если Формат_ = "В среду" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
            Результат.Вставить("ВТОРНИК", 2);
            Результат.Вставить("СРЕДУ", 3);
            Результат.Вставить("ЧЕТВЕРГ", 4);
            Результат.Вставить("ПЯТНИЦУ", 5);
            Результат.Вставить("СУББОТУ", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
        КонецЕсли;
        Если Формат_ = "До среды" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИКА", 1);
            Результат.Вставить("ВТОРНИКА", 2);
            Результат.Вставить("СРЕДЫ", 3);
            Результат.Вставить("ЧЕТВЕРГА", 4);
            Результат.Вставить("ПЯТНИЦЫ", 5);
            Результат.Вставить("СУББОТЫ", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
        КонецЕсли;
        Если Формат_ = "К среде" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИКУ", 1);
            Результат.Вставить("ВТОРНИКУ", 2);
            Результат.Вставить("СРЕДЕ", 3);
            Результат.Вставить("ЧЕТВЕРГУ", 4);
            Результат.Вставить("ПЯТНИЦЕ", 5);
            Результат.Вставить("СУББОТЕ", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЮ", 7);
        КонецЕсли;
        Если Формат_ = "Все среды" ИЛИ Формат_ = "Все" Тогда
            Результат.Вставить("ПОНЕДЕЛЬНИКИ", 1);
            Результат.Вставить("ВТОРНИКИ", 2);
            Результат.Вставить("СРЕДЫ", 3);
            Результат.Вставить("ЧЕТВЕРГИ", 4);
            Результат.Вставить("ПЯТНИЦЫ", 5);
            Результат.Вставить("СУББОТЫ", 6);
            Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
        КонецЕсли;
    Иначе
        Если Формат_ = "Среда" Тогда
            Результат.Вставить(1, "Понедельник");
            Результат.Вставить(2, "Вторник");
            Результат.Вставить(3, "Среда");
            Результат.Вставить(4, "Четверг");
            Результат.Вставить(5, "Пятница");
            Результат.Вставить(6, "СУббота");
            Результат.Вставить(7, "Воскресенье");
        ИначеЕсли Формат_ = "По средам" Тогда
            Результат.Вставить(1, "Понедельникам");
            Результат.Вставить(2, "Вторникам");
            Результат.Вставить(3, "Средам");
            Результат.Вставить(4, "Четвергам");
            Результат.Вставить(5, "Пятницам");
            Результат.Вставить(6, "СУбботам");
            Результат.Вставить(7, "Воскресеньям");
        ИначеЕсли Формат_ = "В среду" Тогда
            Результат.Вставить(1, "Понедельник");
            Результат.Вставить(2, "Вторник");
            Результат.Вставить(3, "Среду");
            Результат.Вставить(4, "Четверг");
            Результат.Вставить(5, "Пятницу");
            Результат.Вставить(6, "СУбботу");
            Результат.Вставить(7, "Воскресенье");
        ИначеЕсли Формат_ = "До среды" Тогда
            Результат.Вставить(1, "Понедельника");
            Результат.Вставить(2, "Вторника");
            Результат.Вставить(3, "Среды");
            Результат.Вставить(4, "Четверга");
            Результат.Вставить(5, "Пятницы");
            Результат.Вставить(6, "СУбботы");
            Результат.Вставить(7, "Воскресенья");
        ИначеЕсли Формат_ = "К среде" Тогда
            Результат.Вставить(1, "Понедельнику");
            Результат.Вставить(2, "Вторнику");
            Результат.Вставить(3, "Среде");
            Результат.Вставить(4, "Четвергу");
            Результат.Вставить(5, "Пятнице");
            Результат.Вставить(6, "СУбботе");
            Результат.Вставить(7, "Воскресенью");
        ИначеЕсли Формат_ = "Все среды" Тогда
            Результат.Вставить(1, "Понедельники");
            Результат.Вставить(2, "Вторники");
            Результат.Вставить(3, "Среды");
            Результат.Вставить(4, "Четверги");
            Результат.Вставить(5, "Пятницы");
            Результат.Вставить(6, "СУбботы");
            Результат.Вставить(7, "Воскресенья");
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // СоответствиеМесяцев

// Возвращает соответствие месяца номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения Первая Заглавная), Истина = Ключи = Строки (ВРЕГ)
//   Родительный - Булево, Неопределено -
//          Неопределено (по умолч) = для КлючСтрокаЗначениеЧисло = Истина = оба, КлючСтрокаЗначениеЧисло = Ложь = аналогично Ложь;
//          Ложь = Строка в именительном падеже,
//          Истина = Строка в родительном падеже
// Возвращаемое значение:
//   Соответствие из Число  - месяцев и их номеров
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СоответствиеМесяцев(КлючСтрокаЗначениеЧисло = Ложь, Родительный = Неопределено) Экспорт
    Результат = Новый Соответствие;
    Если КлючСтрокаЗначениеЧисло Тогда
        Если Родительный <> Истина Тогда
            Результат.Вставить("ЯНВАРЬ",    1);
            Результат.Вставить("ФЕВРАЛЬ", 2);
            Результат.Вставить("МАРТ",  3);
            Результат.Вставить("АПРЕЛЬ",    4);
            Результат.Вставить("МАЙ",   5);
            Результат.Вставить("ИЮНЬ",  6);
            Результат.Вставить("ИЮЛЬ",  7);
            Результат.Вставить("АВГУСТ",    8);
            Результат.Вставить("СЕНТЯБРЬ", 9);
            Результат.Вставить("ОКТЯБРЬ", 10);
            Результат.Вставить("НОЯБРЬ",    11);
            Результат.Вставить("ДЕКАБРЬ", 12);
        КонецЕсли;
        Если Родительный <> Ложь Тогда
            Результат.Вставить("ЯНВАРЯ",    1);
            Результат.Вставить("ФЕВРАЛЯ", 2);
            Результат.Вставить("МАРТА",     3);
            Результат.Вставить("АПРЕЛЯ",    4);
            Результат.Вставить("МАЯ",   5);
            Результат.Вставить("ИЮНЯ",  6);
            Результат.Вставить("ИЮЛЯ",  7);
            Результат.Вставить("АВГУСТА",   8);
            Результат.Вставить("СЕНТЯБРЯ", 9);
            Результат.Вставить("ОКТЯБРЯ", 10);
            Результат.Вставить("НОЯБРЯ",    11);
            Результат.Вставить("ДЕКАБРЯ", 12);
        КонецЕсли;
    Иначе
        Если Родительный = Истина Тогда
            Результат.Вставить(1, "Января");
            Результат.Вставить(2, "Февраля");
            Результат.Вставить(3, "Марта");
            Результат.Вставить(4, "Апреля");
            Результат.Вставить(5, "Мая");
            Результат.Вставить(6, "Июня");
            Результат.Вставить(7, "Июля");
            Результат.Вставить(8, "Августа");
            Результат.Вставить(9, "Сентября");
            Результат.Вставить(10, "Октября");
            Результат.Вставить(11, "Ноября");
            Результат.Вставить(12, "Декабря");
        Иначе
            Результат.Вставить(1, "Январь");
            Результат.Вставить(2, "Февраль");
            Результат.Вставить(3, "Март");
            Результат.Вставить(4, "Апрель");
            Результат.Вставить(5, "Май");
            Результат.Вставить(6, "Июнь");
            Результат.Вставить(7, "Июль");
            Результат.Вставить(8, "Август");
            Результат.Вставить(9, "Сентябрь");
            Результат.Вставить(10, "Октябрь");
            Результат.Вставить(11, "Ноябрь");
            Результат.Вставить(12, "Декабрь");
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // СоответствиеМесяцев

#КонецОбласти

#Область 		ЗАПРОСЫ

#Область 			ТЕКСТЫ_ЗАПРОСОВ

// Возвращает текст запроса к таблице регистра с фильтрацией
// Параметры:
//  ИмяМенеджераРегистра  - Строка - Имя регистра в формате РегистрыСведений.АдресныеСведения
//  Фильтр  - Строка - Фильтр ТабРегистра с ГДЕ.
//  ИмяВТ  - Строка - Имя ВТ результата. По умолчанию выборка данных.
//  ПоляВзять  - Строка - Через запятую имена полей результата. По умолчанию все поля.
//  ПоляНеБрать  - Строка - Через запятую поля, исключаемые из результата. По умолчанию без исключений.
// Возвращаемое значение:
//   Строка   - Текст запроса
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ТекстЗапросаДанныеРегистра(
		ИмяМенеджераРегистра,
		Фильтр = "",
		ИмяВТ = "",
		ПоляВзять = "",
		ПоляНеБрать = "") Экспорт
    Результат = "ВЫБРАТЬ" + Символы.ПС;
    ПоляВсе = СтруктураЗаписиРегистра(ИмяМенеджераРегистра);
    ЕстьВзять = ЗначениеЗаполнено(ПоляВзять);
    ЕстьНеБрать = ЗначениеЗаполнено(ПоляНеБрать);
    Для каждого КиЗ_Поле Из ПоляВсе Цикл
        Если ЕстьВзять Тогда
            Если НайтиПодСтроку(ПоляВзять, КиЗ_Поле.Ключ) = 0 Тогда
                Продолжить;
            КонецЕсли;
        КонецЕсли;
        Если ЕстьНеБрать Тогда
            Если НайтиПодСтроку(ПоляНеБрать, КиЗ_Поле.Ключ) <> 0 Тогда
                Продолжить;
            КонецЕсли;
        КонецЕсли;
        Результат = Результат + "   ТабРегистра." + КиЗ_Поле.Ключ + "," + Символы.ПС;
    КонецЦикла;
    Результат = Лев(Результат, СтрДлина(Результат) - 2) + Символы.ПС + ?(ЗначениеЗаполнено(ИмяВТ), "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС, "")
            + "ИЗ " + СтрЗаменить(ИмяМенеджераРегистра, "Регистры", "Регистр") + " КАК ТабРегистра" + Символы.ПС + Фильтр;
    Возврат Результат
КонецФункции // ТекстЗапросаДанныеРегистра

// Создаёт текст запроса, возвращающего числа от А до Б включительно в ВТ Числа
// Параметры:
//  ЧислоА  - Число - Первое число возвращаемого интервала
//  ЧислоБ  - Число - Последнее число возвращаемого интервала
// Возвращаемое значение:
//   Строка   - Текст запроса
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ТекстЗапросаСчётчик(ЧислоА, ЧислоБ) Экспорт
    Чисел = ЧислоБ - ЧислоА + 1;
    Степень = Цел(Log10(Чисел)) + 1;
    Соединения = "Цифры" + Степень + Символы.ПС;
    Вычисления = "";
    Множитель = 1;
    
    Для Ё = 1 По Степень Цикл
        Вычисления = Вычисления + " + " + Множитель + " * Цифры" + Ё + ".Цифра";
        Множитель = Множитель * 10;
    КонецЦикла;
    Для Ё = 1 По Степень - 1 Цикл
        Соединения = Соединения + "ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры" + (Степень - Ё) + "
                |       ПО (ИСТИНА)
                |";
        Множитель = Множитель * 10;
    КонецЦикла;
    
    Результат = "ВЫБРАТЬ
                |   0 КАК Цифра
                |ПОМЕСТИТЬ Цифры
                |";
    Для Ё = 1 По 9 Цикл
        Результат = Результат + "ОБЪЕДИНИТЬ ВСЕ
                |
                |ВЫБРАТЬ
                |   " + Ё + "
                |
                |"
    КонецЦикла;
    Результат = Результат + ";
                |
                |////////////////////////////////////////////////////////////////////////////////
                |" + 
                СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
                "ВЫБРАТЬ
                |   &ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра КАК Число
                |ПОМЕСТИТЬ Числа
                |ИЗ
                |   (ВЫБРАТЬ
                |       Цифры.Цифра КАК Цифра
                |   ИЗ
                |       Цифры КАК Цифры
                |   ГДЕ
                |       Цифры.Цифра <= &ПерваяЦифраБ) КАК Цифры3
                |       ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
                |       ПО (ИСТИНА)
                |       ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
                |       ПО (ИСТИНА)
                |ГДЕ
                |   &ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра <= &ЧислоБ",
                "&ЧислоА", ЧислоА),
                "&ЧислоБ", ЧислоБ),
                "&ПерваяЦифраБ", Лев(Чисел, 1)),
                "Цифры3
                    |       ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
                    |       ПО (ИСТИНА)
                    |       ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
                    |       ПО (ИСТИНА)", Соединения),
                " + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра", Вычисления) +
                ";
                |
                |////////////////////////////////////////////////////////////////////////////////
                |УНИЧТОЖИТЬ Цифры
                |;";
    Возврат Результат
КонецФункции // ТекстЗапросаСчётчик

#КонецОбласти

#КонецОбласти

#Область 		КОЛЛЕКЦИИ

#Область 			ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
    
//Возвращает количество элементов коллекции-параметра, а если параметр - не коллекция, то
//  * -2, если значение - пустая ссылка
//  * -1 - иначе
//Параметры:
//  Коллекция - Произвольная коллекция - Кого посчитают :)
// Возвращаемое значение:
//	Число - Число элементов коллекции с учётом написанного выше
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
&НаКлиентеНаСервереБезКонтекста
Функция КоличествоКоллекции(Коллекция) Экспорт
    Попытка
        КолвоПараметров = Коллекция.Количество();
    Исключение
        КолвоПараметров = -1;
        //@skip-check empty-except-statement
        Попытка
            Если Коллекция.Пустая() Тогда КолвоПараметров = -2 КонецЕсли
        Исключение
        КонецПопытки;
    КонецПопытки;
    Возврат КолвоПараметров
КонецФункции

// Выгружает колонку коллекции (не обязательно ТЗ!) в строку с разделителями. Можно использовать, например, для получения строки для Свернуть.
// Параметры:
//  Коллекция       - ТаблицаЗначений - или любая коллекция с колонками (реквизитами строк) = источник данных
//  ИмяРеквизита    - строка - имя реквизита, из которого будет сформирована строка
//  Разделитель     - Произвольный - любое значение, преобразуемое в строку, разделитель для строки-результата
// Возвращаемое значение:
//   Строка   - строка с разделителями, содержащая представления заданного реквизита строк
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция КолонкуКоллекцииВСтрокуСРазделителями(Коллекция, ИмяРеквизита, Разделитель = ",") Экспорт
    Результат = "";
    Для каждого Строчка Из Коллекция Цикл
        Результат = Результат + Разделитель + Строчка[ИмяРеквизита];
    КонецЦикла;
    Возврат Сред(Результат, СтрДлина(Разделитель) + 1);
КонецФункции // КолонкуКоллекцииВСтрокуСРазделителями()
 
//Удаляет заданные элементы из коллекции
//Параметры:
//  ПроизвольнаяКоллекция - Произвольный - Произвольная коллекция, откуда удалить элементы
//  МассивЛишниеСтроки - Массив из Произвольный - Удаляемые элементы произвольной коллекции
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура УдалитьЛишниеСтроки(ПроизвольнаяКоллекция, МассивЛишниеСтроки) Экспорт
    Для каждого ТекСтрока Из МассивЛишниеСтроки Цикл
        ПроизвольнаяКоллекция.Удалить(ТекСтрока);
    КонецЦикла;
КонецПроцедуры

#КонецОбласти 

#Область 			МАССИВЫ

// Добавляет значение в массив, если его там нет
// Параметры:
//  Приёмник  - Массив из Произвольный - куда добавляется значение
//  Значение  - Произвольный - что добавляется в массив
//  Индекс  - Число - куда вставлять, -1 (по умолчанию) - в конец
// Возвращаемое значение:
//   Булево - Значение было добавлено
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ДобавитьВМассивЕслиЕщёНет(Приёмник, Значение, Индекс = -1) Экспорт
    Результат = Приёмник.Найти(Значение) = Неопределено;
    Если Результат Тогда
        Если Индекс = -1 Тогда
            Приёмник.Добавить(Значение);
        Иначе
            Приёмник.Вставить(Индекс, Значение);
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // ДобавитьВМассивЕслиЕщёНет

// Дополняет массив, добавляя элементы в заданную позицию
// Параметры:
//  Приемник - Массив из Произвольный - Приёмник. Если не задан - будет создан новый
//  Источник - Массив из Произвольный - Источник. Если не задан - ничего добавлено не будет
//  Позиция - Число - Позиция вставки элементов. Отрицательные = позиция с конца. Минус один (по умолчанию) = добавление.
//  БезДублей - Булево - По умолчанию Ложь. Уже существующие дубли не проверяются.
//  ОбратныйПорядок - Булево - зачения будут вставлены в обратном порядке
// Возвращаемое значение:
//   Массив из Произвольный   - из параметра Приёмник или новый
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ДополнитьМассив(
		Приемник = Неопределено,
		Источник = Неопределено,
		Позиция = -1,
		БезДублей = Ложь,
		ОбратныйПорядок = Ложь) Экспорт
    Результат = ?(Приемник = Неопределено, Новый Массив, Приемник);
    БылоЭлементов = Результат.Количество();
    ТекПозПриемника = ?(Позиция < 0, Макс(Позиция + БылоЭлементов + 1, 0), Мин(Позиция, БылоЭлементов));
    Если ЗначениеЗаполнено(Источник) Тогда
        МаксИндексИсточника = Источник.ВГраница();
        Для Сч = 0 По МаксИндексИсточника Цикл
            ТекПозИсточника = ?(ОбратныйПорядок, МаксИндексИсточника - Сч, Сч);
            Если Не БезДублей ИЛИ Результат.Найти(Источник[ТекПозИсточника]) = Неопределено Тогда
                Если ТекПозПриемника = БылоЭлементов Тогда
                    Результат.Добавить(Источник[ТекПозИсточника]);
                Иначе
                    Результат.Вставить(Источник[ТекПозИсточника], ТекПозПриемника);
                КонецЕсли;
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
    Возврат Результат
КонецФункции // ДополнитьМассив

//Аналог ВыгрузитьКолонку для коллекций, не поддерживающих ВыгрузитьКолонку
//Параметры:
//    Коллекция - Произвольный - коллекция, имеющая колонки у элементов, источник данных
//    ИмяВыгружаемойКолонки - Строка - Имя выгружаемой колонки
//Возвращаемое значение:
//    Массив из Произвольный - Значения из выгружаемой колонки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция КолонкуКоллекцииВМассив(Коллекция, ИмяВыгружаемойКолонки) Экспорт
    Результат = Новый Массив;
    Для каждого Элемент из Коллекция Цикл
        Результат.Добавить(Элемент[ИмяВыгружаемойКолонки])
    КонецЦикла;
    Возврат Результат
КонецФункции

//Проверяет, является ли параметр массивом, и если не является преобразует его в массив с единственным значением
//Параметры:
//  Что - Произвольный - источник данных
//  ПеределатьВМассивЕслиКоллекция - Булево - Если Истина, элементы коллекции из параметра Что будут добавлены в результат.
//      Д.б. установлена, если надо сложить два массива. При Ложь значение Что будет добавлено в конец массива. По умолчанию Ложь.
//  ПеременнаяДляПолученияРезультата - Произвольный - Переменная, в которую будет передано возвращаемое значение,
//      если невозможно исползовать как функцию. Сюда же передаётся начальный массив, к которому будут добавлены значения.
//      Если в эту переменную передать не массив, значение будет потеряно.
//  БратьЗначение - Булево - При Ложь (по умолчанию) в массив загружается весь элемент коллекции, при Истина - его значение
//Возвращаемое значение:
//  Массив из Произвольный - Массив из ПеременнаяДляПолученияРезультата, или новый массив
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ПреобразоватьВМассив(Что, ПеределатьВМассивЕслиКоллекция = Ложь, ПеременнаяДляПолученияРезультата = Неопределено, БратьЗначение = Ложь) Экспорт
    ТипМассив = Тип("Массив");
    Если ТипЗнч(ПеременнаяДляПолученияРезультата) <> ТипМассив Тогда
        ПеременнаяДляПолученияРезультата = Новый Массив;
    КонецЕсли;
    Результат = ПеременнаяДляПолученияРезультата;
    Если ПеределатьВМассивЕслиКоллекция Тогда
        Попытка
            Для каждого Элемент_ Из Что Цикл
                Результат.Добавить(?(БратьЗначение, Элемент_.Значение, Элемент_));
            КонецЦикла;
        Исключение
            Результат = Новый Массив;
            Результат.Добавить(Что);
        КонецПопытки;
    ИначеЕсли ТипЗнч(Что) = ТипМассив Тогда
        Результат = Что;
        ПеременнаяДляПолученияРезультата = Что;
    Иначе
        Результат.Добавить(Что);
    КонецЕсли;
    Возврат Результат
КонецФункции

// Разность Массивов
// Параметры:
//  Уменьшаемое  - Массив из Произвольный - Массив, значения из которого будут в разности, за исключением вычитаемого
//  Вычитаемое  - Массив из Произвольный - Массив, значения из которого будут исключены из результата
//  Разность  - Массив из Произвольный - Массив, то же самое, что и Результат. По умолчанию Неопределено (пустой). Для использования вызова без возвращаемого значения. Если непустой, значения будут добавлены к нему.
//  Свернуть  - Булево - Истина (по умолчанию) - из результата будут удалены дубли.
// Возвращаемое значение:
//   Массив из Произвольный - Значения из Уменьшаемого, кроме значений из Вычитаемого
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция РазностьМассивов(Уменьшаемое, Вычитаемое, Разность = Неопределено, Свернуть = Истина) Экспорт
    Если Разность = Неопределено Тогда
        Разность = Новый Массив;
    КонецЕсли;
    Если Разность = Уменьшаемое Тогда
        Свернуть = Истина;
    КонецЕсли;
    Для каждого ЭлементМ Из Уменьшаемое Цикл
        Если (Вычитаемое.Найти(ЭлементМ) = Неопределено) И ((НЕ Свернуть) ИЛИ (Разность.Найти(ЭлементМ) = Неопределено)) Тогда
            Разность.Добавить(ЭлементМ);
        КонецЕсли; 
    КонецЦикла; 
    Возврат Разность
КонецФункции // РазностьМассивов

//Удаляет дубли из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
//Параметры:
//  Массив - Массив из Произвольный - Исходный массив
//Возвращаемое значение:
//	Массив из Произвольный - без дублей. Он же в параметре Массив, что позволяет использовать функцию как процедуру.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СвернутьМассив(Массив) Экспорт
    Размер = Массив.Количество();
    Для Ё = 1 По Размер Цикл
        ТекИндекс = Размер - Ё;
        Если Массив.Найти(Массив[ТекИндекс]) <> ТекИндекс Тогда
            Массив.Удалить(ТекИндекс)
        КонецЕсли;
    КонецЦикла;
    Возврат Массив
КонецФункции

//Складывает два массива (добавляет в новый массив элементы сначала первого, потом втогрого), при необходимости - со свёрткой
//Параметры:
//  Массив1 - массив из Произвольный - первое слагаемое
//  Массив2 - массив из Произвольный - второе слагаемое
//  Свернуть - Булево - Удалить дубли
//  УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
//  РезультатВПервый - Булево - Не создавать новый массив, а всё сложить в первый
//Возвращаемое значение:
//  Массив из Произвольный - Элементы первого, за ними элементы второго массива. При свёртке из дублей попадает только первый.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СложитьМассивы(Массив1, Массив2, Свернуть = Истина, УдалитьПустые = Ложь, РезультатВПервый = Ложь) Экспорт
    Если РезультатВПервый Тогда
        Результат = ?(Свернуть, СвернутьМассив(Массив1), Массив1);
        Если УдалитьПустые Тогда
            УдалитьПустыеИзМассива(Результат); 
        КонецЕсли; 
    Иначе
        Результат = СложитьМассивы(Новый Массив, Массив1, Свернуть, УдалитьПустые, Истина);
    КонецЕсли; 
    Для Каждого Элемент Из Массив2 Цикл
        Если ?(?(УдалитьПустые, ЗначениеЗаполнено(Элемент), Истина), ?(Свернуть, Результат.Найти(Элемент) = Неопределено, Истина), Ложь) Тогда
            Результат.Добавить(Элемент);
        Конецесли
    КонецЦикла;
    Возврат Результат
КонецФункции

//Преобразует массив в список значений. В отличие от ЗагрузитьЗначения список не обнуляется.
//Параметры:
//  Массив - Массив из Произвольный - источник данных
//  Свернуть - Булево - при Истина будет взято только первое из повторяющихся значений.
//  ПометкаПоУмолчанию - Булево - Пометка для установки в элементы списка. По умолчанию Ложь.
//  КартинкаПоУмолчанию - Картинка, Неопределено - Картинка для установки в элементы списка. Если Неопределено (по умолчанию) - картинка не устанавливается.
//  Результат - СписокЗначений Из Произвольный, Неопределено - Необязательный. Переменная для возврата результата для работы. 
//          в режиме процедуры, когда список надо не присвоить, а разместить в существующий. При неопределено будет создан новый список.
//Результат - для работы  в режиме процедуры, когда список надо не присвоить, а разместить в существующий.
//Возвращаемое значение:
//  СписокЗначений Из Произвольный - где значение - элемент массива, представление - строковое представление элемента, картинка и пометка из параметров.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция СписокИзМассива(
		Массив,
		Свернуть = Истина,
		ПометкаПоУмолчанию = Ложь,
		КартинкаПоУмолчанию = Неопределено,
		Результат = Неопределено) Экспорт
    Если Результат = Неопределено Тогда
        Результат = Новый СписокЗначений;
    КонецЕсли; 
    Если КартинкаПоУмолчанию = Неопределено Тогда
        КартинкаПоУмолчанию = Новый Картинка
    КонецЕсли;
    Для каждого Элемент из Массив Цикл
        Если ?(Свернуть, Результат.НайтиПоЗначению(Элемент) = Неопределено, Истина) Тогда
            Результат.Добавить(Элемент, СокрЛП(Элемент), ПометкаПоУмолчанию, КартинкаПоУмолчанию)
        КонецЕсли
    КонецЦикла;
    Возврат Результат
КонецФункции

// Сравнивает массивы более корректно, чем БСП, где два массива с разными задвоями будут равными и нет вызова с клиента
// Параметры:
//  Массив1  - Массив из Произвольный - Один из сравниваемых
//  Массив2  - Массив из Произвольный - Второй из сравниваемых
// Возвращаемое значение:
//   Булево   - Массивы равны
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция МассивыРавны(Массив1, Массив2) Экспорт
    Результат = Истина;
    Тестер = Новый Соответствие;
    Для каждого элМ Из Массив1 Цикл
        Если Тестер[элМ] = Неопределено Тогда
            Тестер.Вставить(элМ, 1);
        Иначе
            Тестер[элМ] = Тестер[элМ] + 1;
        КонецЕсли;
    КонецЦикла;
    Для каждого элМ Из Массив2 Цикл
        Если Тестер[элМ] = Неопределено Тогда
            Результат = Ложь;
            Прервать;
        Иначе
            Тестер[элМ] = Тестер[элМ] - 1;
            Если Тестер[элМ] < 0 Тогда
                Результат = Ложь;
                Прервать;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Если Результат Тогда
        Для каждого КиЗ Из Тестер Цикл
            Если КиЗ.Значение <> 0 Тогда
                Результат = Ложь;
                Прервать;
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
    Возврат Результат
КонецФункции // МассивыРавны

// Удаляет незаполненные элементы из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
// Параметры:
//  Массив_  - Массив из Произвольный - Проверяемый массив
// Возвращаемое значение:
//   Массив из Произвольный - Тот же массив, что и был передан, но без пустых значений.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция УдалитьПустыеИзМассива(Массив_) Экспорт
    ВГр = Массив_.ВГраница();
    Для Ё = 1 По ВГр Цикл
        Если НЕ ЗначениеЗаполнено(Массив_[ВГр - Ё]) Тогда
            Массив_.Удалить(ВГр - Ё)
        КонецЕсли; 
    КонецЦикла; 
    Возврат Массив_
КонецФункции // УдалитьПустыеИзМассива
 
#КонецОбласти

#Область 			СООТВЕТСТВИЕ
	
// Возвращает иерархию соответствий - фактически аналог индекса
// Параметры:
//  Источник - ТаблицаЗначений, Массив из Структура, ДанныеФормыКоллекция - или иная коллекция с именованными свойствами
//  		элемента = Источник данных
//  Ключи - Массив из Структура - Ключи:
//          *Колонка - Строка - Имя реквизита элемента источника, откуда берутся ключи,
//          *ЭтоСтруктура - Булево - Истина = создавать структуру, Ложь = соответствие.
//          Иерархия строится в порядке элементов массива.
//  ИсточникЭлементаРезультата - Строка - Имя реквизита, из которого будет назначаться элемент результата (значение низа иерархии).
//          По умолчанию "#ВесьЭлемент" = берётся весь элемент источника
//  ТипЭлементаРезультата - Строка, Произвольный - возможные значения, описывающие тип и алгоритм получения нижнего уровня иерархии:
//          *"Массив" - Массив из Произвольный - (по умолчанию) = все новые значения, относящиеся к одному набору ключей, заносятся в элементы
//          *"Значение" - Произвольный - одно значение из элемента источника. Последующие значения перезаписываются поверх предыдущих
//          *ЛюбоеЗначение - Произвольный - Вернётся это переданное (фиксированниое) значение
//  ВзятьЭлементИсточникаИзРеквизита - Строка - Если надо брать элемент источника не из элемента коллекции, а из его реквизита (например, из значения КиЗ),
//          то указывается имя реквизита-источника. По умолчанию пустая строка = ключи берутся из реквизитов самого элемента.
//  ВзятьЭлементРезультатаИзРеквизита - Строка - аналогично ВзятьЭлементИсточникаИзРеквизита, но для ИсточникЭлементаРезультата.
// Возвращаемое значение:
//   Структура, Соответствие - Корень иерархии структур/соответствий
//@skip-check doc-comment-collection-item-type
//@skip-check doc-comment-field-name
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СоответствияИзКоллекции(
        Источник,
        Ключи,
        ИсточникЭлементаРезультата = "#ВесьЭлемент",
        ТипЭлементаРезультата = "Массив",
        ВзятьЭлементИсточникаИзРеквизита = "",
        ВзятьЭлементРезультатаИзРеквизита = "") Экспорт
    Результат  = Новый Структура("Результат");
    Если Ключи.Количество() <> 0 Тогда
        Если Источник.Количество() Тогда
            Для каждого ЭлементИсточника Из Источник Цикл
                Корень = Результат;
                ТекКлюч = "Результат";
                ТекЭтаж = Корень.Результат;
                ТекДанные = ?(ВзятьЭлементИсточникаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементИсточникаИзРеквизита]);
                //ИЕРАРХИЯ
                Для каждого ОписаниеКлюча Из Ключи Цикл
                    Если ТекЭтаж = Неопределено Тогда
                        ТекЭтаж = ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие);
                        Корень.Вставить(ТекКлюч, ТекЭтаж);
                    КонецЕсли;
                    ТекКлюч = ТекДанные[ОписаниеКлюча.Колонка];
                    Корень = ТекЭтаж;
                    Если ?(ОписаниеКлюча.ЭтоСтруктура, НЕ ТекЭтаж.Свойство(ТекКлюч), ТекЭтаж[ТекКлюч] = Неопределено) Тогда
                        ТекЭтаж = Неопределено;
                    Иначе
                        ТекЭтаж = ТекЭтаж[ТекКлюч];
                    КонецЕсли;
                КонецЦикла;
                #Область ЗАПИХНУТЬ_НИЖНИЙ_УРОВЕНЬ
                    #Область РАСЧЁТ_ЗНАЧЕНИЯ
                        ТекДанные = ?(ВзятьЭлементРезультатаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементРезультатаИзРеквизита]);
                        ТекЗначение = ?(ИсточникЭлементаРезультата = "#ВесьЭлемент", ТекДанные, ТекДанные[ИсточникЭлементаРезультата]);
                    #КонецОбласти
                    Если ТипЭлементаРезультата = "Массив" Тогда
                        Если ТекЭтаж = Неопределено Тогда
                            ТекЭтаж = Новый Массив;
                        КонецЕсли;
                        ТекЭтаж.Добавить(ТекЗначение);
                    ИначеЕсли ТипЭлементаРезультата = "Значение" Тогда
                        ТекЭтаж = ТекЗначение;
                    Иначе
                        ТекЭтаж = ТипЭлементаРезультата;
                    КонецЕсли;
                    Корень.Вставить(ТекКлюч, ТекЭтаж);
                #КонецОбласти
            КонецЦикла;
        Иначе
            Для каждого ОписаниеКлюча Из Ключи Цикл
                Результат.Вставить("Результат", ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие));
                Прервать;
            КонецЦикла;
        КонецЕсли;
    КонецЕсли;
    Возврат Результат.Результат
КонецФункции // СоответствияИзКоллекции

// Получает КиЗ соответствия по индексу
// Параметры:
//  Откуда  - Соответствие из Произвольный - Откуда получить КИЗ
//  Индекс  - Число - Индекс элемента
// Возвращаемое значение:
//   КлючИЗначение   - КиЗ с заданным индексом. Неопределено, если такого нет.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЭлементСоответствияПоИндексу(Откуда, Индекс) Экспорт
    Результат = Неопределено;
    ЕЙЦ = 0;
    Найден = Ложь;
    Для каждого КиЗ Из Откуда Цикл
        Если ЕЙЦ = Индекс Тогда
            Найден = Истина;
            Прервать;
        Иначе
            ЕЙЦ = ЕЙЦ + 1;
        КонецЕсли; 
    КонецЦикла;
    Если Найден Тогда
        Результат = КиЗ;
    КонецЕсли; 
    Возврат Результат
КонецФункции // ЭлементСоответствияПоИндексу

#КонецОбласти

#Область 			СПИСОК_ЗНАЧЕНИЙ
    
//Возвращает табличный документ, в который выведен список значений
//Параметры:
//    Список - СписокЗначений из Произвольный - Выводимый в таблицу
//Возвращаемое значение:
//    ТабличныйДокумент - Значения из выгружаемой колонки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ВывестиСписокВТабличныйДокумент(Список) Экспорт
    Результат = Новый ТабличныйДокумент;
    РазмерСписка = Список.Количество();
    Результат.Область(1, 1, РазмерСписка, 4).СодержитЗначение = Истина;
    Результат.Область(1, 1, РазмерСписка, 4).ШиринаКолонки = 70;
    Для Ё = 1 По РазмерСписка Цикл
        Элемент = Список[Ё - 1];
        Результат.Область(Ё, 1, Ё, 1).Значение = Элемент.Представление;
        Результат.Область(Ё, 1, Ё, 1).Расшифровка = Элемент.Значение;
        Результат.Область(Ё, 2, Ё, 2).Значение = Элемент.Пометка;
        Результат.Область(Ё, 3, Ё, 3).Значение = Элемент.Картинка
    КонецЦикла;
    Результат.ТолькоПросмотр = Истина;
    Результат.Защита = Истина;
    Возврат Результат
КонецФункции

// Перемешивает строки списка значений
// Параметры:
//  Список_  - СписокЗначений из Произвольный - строки которого надо перемешать
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура ПеремешатьСписок(Список_) Экспорт
    Колво = Список_.Количество() - 1;
	М_Случайных = МассивСлучайныхЧисел(Колво + 1);
    Для Ё = 0 По Колво Цикл
        Список_.Сдвинуть(Список_[Ё], М_Случайных[Ё] - Ё);
    КонецЦикла; 
КонецПроцедуры // ПеремешатьСписок()

// Возвращает помеченные элементы списка значений
// Параметры:
//  Список  - СписокЗначений  из Произвольный - Источник данных. Допустимо = ТЗ с колонками Пометка, Значение, Представление, Картинка (какие востребованы).
//  Пометка  - Булево - Искомое значение пометок. Неопределено - все пометки. По умолчанию Истина.
//  Контент  - Строка - Вид возвращаемых данных:
//          >Значения - Массив значений (по умолчанию)
//          >Наоборот - Соответствие, где ключ - значение, а значение - представление
//          >Представления - Массив представлений
//          >Соответствие - Соответствие, где ключ - представление, а значение - значение
//          >Список - Список значений
//          >Структура - Структура, где ключ - представление, а значение - значение
//          >ТЗ - таблица значений
//          >Картинка - Массив картинок
//          >Элементы - Массив элементов
// Возвращаемое значение:
//   Массив из Произвольный, Соответствие, Структура, СписокЗначений, ТаблицаЗначений - Отобранные по пометке значения
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-field-type
//@skip-check doc-comment-collection-item-type
&НаКлиентеНаСервереБезКонтекста
Функция Помеченные(Список, Пометка = Истина, Контент = "Значения") Экспорт
    #Область ВАРИАНТЫ_КОНТЕНТА
        Если Контент = "Наоборот" Тогда
            ТипР = "Структура";
            Результат = Новый Соответствие;
            Ключ = "Значение";
            Значение = "Представление";
        ИначеЕсли Контент = "Представления" Тогда
            ТипР = "Массив";
            Результат = Новый Массив;
            Ключ = "";
            Значение = "Представление";
        ИначеЕсли Контент = "Соответствие" Тогда
            ТипР = "Структура";
            Результат = Новый Соответствие;
            Ключ = "Представление";
            Значение = "Значение";
        ИначеЕсли Контент = "Список" Тогда
            ТипР = "СЗ_ТЗ";
            Результат = Новый СписокЗначений;
            Ключ = "Значение";
            Значение = "Представление";
        ИначеЕсли Контент = "Структура" Тогда
            ТипР = "Структура";
            Результат = Новый Структура;
            Ключ = "Представление";
            Значение = "Значение";
        ИначеЕсли Контент = "ТЗ" Тогда
            #Если Сервер Тогда
                ТипР = "СЗ_ТЗ";
                Результат = Новый ТаблицаЗначений;
                Результат.Колонки.Добавить("Значение");
                Результат.Колонки.Добавить("Представление");
                Результат.Колонки.Добавить("Картинка");
                Результат.Колонки.Добавить("Пометка");
            #КонецЕсли
            #Если Клиент Тогда
                ТипР = "Массив";
                Результат = Новый Массив;
            #КонецЕсли
            Ключ = "Элемент";
            Значение = "";
        ИначеЕсли Контент = "Картинка" Тогда
            ТипР = "Массив";
            Результат = Новый Массив;
            Ключ = "";
            Значение = "Картинка";
        ИначеЕсли Контент = "Элементы" Тогда
            ТипР = "Массив";
            Результат = Новый Массив;
            Ключ = "Элемент";
            Значение = "Элемент";
        Иначе
            ТипР = "Массив";
            Результат = Новый Массив;
            Ключ = "";
            Значение = "Значение";
        КонецЕсли;
    #КонецОбласти 
    Для каждого ЭлементС Из Список Цикл
        Если Пометка = Неопределено ИЛИ ЭлементС.Пометка = Пометка Тогда
            Если ТипР = "Массив" Тогда
                Результат.Добавить(?(Значение = "Элемент", ЭлементС, ЭлементС[Значение]));
            ИначеЕсли ТипР = "Структура" Тогда
                Результат.Вставить(ЭлементС[Ключ], ЭлементС[Значение]);
            ИначеЕсли ТипР = "СЗ_ТЗ" Тогда
                ЗаполнитьЗначенияСвойств(Результат.Добавить(), ЭлементС);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // Помеченные

// Дополняет список значений по структуре/соответствию
// Параметры:
//  Источник  - Структура, Соответствие из Произвольный - Источник данных
//  Приёмник  - СписокЗначений из Произвольный - Список-получатель
//  Пометка  - Булево - Значение пометки новых элементов
//  Режим  - Строка -
//      *ДобавитьСУчётомКлючей (по умолчанию) - добавить к существующим, заменив существующие ключи
//      *ДобавитьВсё - добавить к существующим без проверок
//      *ДобавитьНовые - добавить к существующим только новые ключи
//      *Очистить - предварительно очистить
//      *НеДобавлять - только заменить существующие ключи
//  Сортировать_ - Булево - Сортировка по представлению: Неопределено (По умолчанию) = по необходимости, Истина/Ложь - всега сортировать/нет
// Возвращаемое значение:
//   СписокЗначений из Произвольный - Дополненный из источника
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-field-in-description-suggestion
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция СписокИзСтруктуры(
		Источник,
		Приёмник = Неопределено,
		Пометка = Ложь,
		Режим = "ДобавитьСУчётомКлючей",
		Сортировать_ = Неопределено) Экспорт
    Если Источник = Неопределено Тогда
        Источник = Новый Структура;
    КонецЕсли;
    Если Приёмник = Неопределено Тогда
        Результат = Новый СписокЗначений;
        Вариант = "ДобавитьВсё";
    Иначе
        Результат = Приёмник;
        Вариант = Режим;
    КонецЕсли;
    Если Вариант = "Очистить" Тогда
        Результат.Очистить();
    КонецЕсли;
    РежимВсе = Режим = "Очистить" ИЛИ Режим = "ДобавитьВсё";
    Если ?(Сортировать_ = Неопределено, НЕ РежимВсе, Сортировать_) Тогда
        Результат.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
    КонецЕсли; 
    Для каждого КиЗ Из Источник Цикл
        Если РежимВсе Тогда
            НовЭл = Результат.Добавить();
        Иначе
            НовИндекс = ИндексПоловиннымДелением(КиЗ.Ключ, Приёмник, "Представление");
            НовЭл = Результат[НовИндекс];
            Если НовЭл.Представление = КиЗ.Ключ Тогда
                Если Режим = "ДобавитьНовые" Тогда
                    НовЭл = "";
                КонецЕсли;
            Иначе
                Если Режим = "НеДобавлять" Тогда
                    НовЭл = "";
                Иначе
                    НовЭл = Результат.Добавить();
                КонецЕсли;
            КонецЕсли; 
        КонецЕсли; 
        Если НовЭл <> "" Тогда
            НовЭл.Значение = КиЗ.Значение;
            НовЭл.Представление = КиЗ.Ключ;
            НовЭл.Пометка = Пометка;
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // СписокИзСтруктуры

// Дополняет структуру (или сздаёт её) / соответствие значениями из списка
// Параметры:
//  Список  - СписокЗначений из Произвольный - Источник данных
//  Исходная  - Структура, Соответствие из Произвольный - Приёмник данных
//  ВСоответствие  - Булево - Преобразовать в соответствие. Если ложь (по умолчанию) = будет тип как у Исходной, а при создании = Структура.
//  Скопировать  - Булево - Вернуть копию (аналог Знач). По умолчанию Ложь.
//  ВставлятьНеПомеченные  - Булево - Вставлять в структуру непомеченные элементы. По умолчанию Ложь.
// Возвращаемое значение:
//   Структура, Соответствие из Произвольный - Исходная + данные списка
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция СтруктураИзСпискаЗначений(
		Список,
		Исходная = Неопределено,
		ВСоответствие = Ложь,
		Скопировать = Ложь,
		ВставлятьНеПомеченные = Истина) Экспорт
    Если Исходная = Неопределено Тогда
        Исходная = Новый Структура;
    КонецЕсли;
    Результат = ?(Скопировать, ?(ВСоответствие, Новый Соответствие, Новый Структура), Исходная);
    Особый = ВСоответствие И ТипЗнч(Исходная) <> Тип("Соответствие") И НЕ Скопировать;
    Если Особый Тогда
        Результат = Новый Соответствие;
    КонецЕсли;
    Если Особый ИЛИ Скопировать Тогда
        Для каждого КиЗ Из Исходная Цикл
            Результат.Вставить(?(ВСоответствие, КиЗ.Ключ, СтрокуВИмяПеременной(СокрЛП(КиЗ.Ключ))), КиЗ.Значение);
        КонецЦикла;
    КонецЕсли;
    Для каждого ЭлементСЗ Из Список Цикл
        Если ВставлятьНеПомеченные ИЛИ ЭлементСЗ.Пометка Тогда
            Результат.Вставить(?(ВСоответствие, ЭлементСЗ.Представление, СтрокуВИмяПеременной(СокрЛП(ЭлементСЗ.Представление))), ЭлементСЗ.Значение);
        КонецЕсли;
    КонецЦикла;
    Если Особый Тогда
        Исходная = Результат
    КонецЕсли;
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // СтруктураИзСпискаЗначений

#КонецОбласти 

#Область 			СТРУКТУРА
    
// Добавляет КиЗы источника в приёмник ??? из БСП ???
// Параметры:
//  Приёмник - Структура, Неопределено - Одно из слагаемых. Если Неопределено, то возвращается копия источника независимо от РежимПроцедуры.
//  Источник  - Структура - Второе слагаемое
//  РежимПроцедуры - Булево - Если Истина, результат сложения окажется в Приёмнике, а вернётся Истина.
//      Если Ложь (по умолчанию), то Приёмник и Источник не изменятся, а результат будет возвращён.
// Возвращаемое значение:
//   Структура, Булево   - описание выше
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ДополнитьСтруктуру(Приёмник = Неопределено, Источник, РежимПроцедуры = Ложь) Экспорт
    Результат = ?(Приёмник = Неопределено, Новый Структура, ?(РежимПроцедуры, Приёмник, ДополнитьСтруктуру(Неопределено, Приёмник)));
    Для каждого КиЗ Из Источник Цикл
        Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
    КонецЦикла; 
    //@skip-check constructor-function-return-section
    Возврат ?(РежимПроцедуры, Истина, Результат)
КонецФункции // ДополнитьСтруктуру()

// Возвращает копию заданной структуры с теми же ключами и значениями Неопределено
// Параметры:
//  СтрКлючи  - Структура - Источник
// Возвращаемое значение:
//   Структура   - со сброшенными значениями
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СброситьСтруктуру(СтрКлючи) Экспорт
    Результат = Новый Структура;
    Для каждого КиЗ Из СтрКлючи Цикл
        Результат.Вставить(КиЗ.Ключ, Неопределено);
    КонецЦикла;
    Возврат Результат
КонецФункции // СброситьСтруктуру

// Удаляет из структуры ключи с пустыми значениями
// Параметры:
//  Очищаемая  - Структура - Из которой будут удалить ключи
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура УдалитьПустыеЗначенияИзСтруктуры(Очищаемая) Экспорт
    КУдалению = Новый Массив;
    Для каждого КиЗ Из Очищаемая Цикл
        Если НЕ ЗначениеЗаполнено(КиЗ.Значение) Тогда
            КУдалению.Добавить(КиЗ.Ключ);
        КонецЕсли;
    КонецЦикла;
    УдалитьЛишниеСтроки(Очищаемая, КУдалению);
КонецПроцедуры // УдалитьПустыеЗначенияИзСтруктуры

//Читает значение заданного ключа из структуры с проверками на наличие структуры и ключа.
//Параметры:
//  Структура_ - Структура - из которой будет прочитано значение.
//  ИмяСвойства - Строка - искомый ключ
//  ЗначениеЕслиНет - Произвольный -  Значение, возвращаемое, если прочитать не вышло
//  ПроверитьЧтоЭтоСтруктура - Булево - Если ложь, без проверки принимается, что тип параметра "Структура_" - структура.
//Возвращаемое значение:
//  Произвольный -  значение для ключа
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЧтСтрукт(Структура_, ИмяСвойства, ЗначениеЕслиНет = Неопределено, ПроверитьЧтоЭтоСтруктура = Ложь) Экспорт
    ТекТип = ТипЗнч(Структура_);
    Возврат ?(?(ПроверитьЧтоЭтоСтруктура, ТекТип = Тип("Структура") ИЛИ ТекТип = Тип("ФиксированнаяСтруктура"), Истина),
            ?(Структура_.Свойство(ИмяСвойства), Структура_[ИмяСвойства], ЗначениеЕслиНет), ЗначениеЕслиНет)
КонецФункции

#КонецОбласти 

#Область 			ТАБЛИЦА_ЗНАЧЕНИЙ
    
// Возвращает структуру/соответствие структур, сформированных из строк таблицы значений (массива структур)
// Параметры:
//  ТабИсточник  - ТаблицаЗначений, Массив из Структура - Откуда взять данные
//  КолонкиКлючей  - Строка - Имена колонок ключей через запятую. Значение одной колонки при возвращении соответствия берётся как есть, во всех остальных случаях ключ
//          получается объединением колонок с разделителем
//  Разделитель  - Строка - будет разделять значения из колонок ключей. По умолчанию ""
//  ВернутьСоответствие  - Булево - Результат будет соответствием. При Ложь(по умолчанию) = структурой.
//  КолонкиЗначений  - Строка - Имена колонок через запятую. Остальные колонки не войдут в результат. По умолчанию "". Для массива структур - обязателен.
//  ИсключаемыеКолонки  - Строка - Имена колонок через запятую. Эти колонки также не войдут в результат.
// Возвращаемое значение:
//   Структура, Соответствие из Произвольный  - Структура с определёнными ключами и значениями - структурами
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция СтруктураСтруктурИзТЗ(
		ТабИсточник,
		КолонкиКлючей = "ИД",
		Разделитель = "",
		ВернутьСоответствие = Ложь,
		КолонкиЗначений = "",
		ИсключаемыеКолонки = "") Экспорт
    Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
    Если ЗначениеЗаполнено(КолонкиЗначений) Тогда
        ИспользуемыеКолонки = "";
        МКолонок = СтрРазделить(КолонкиЗначений, ",", Ложь);
        Для каждого КолонкаТ Из мКолонок Цикл
            Если НайтиПодСтроку(ИсключаемыеКолонки, КолонкаТ) = 0 Тогда
                ИспользуемыеКолонки = ИспользуемыеКолонки + "," + КолонкаТ;
            КонецЕсли;
        КонецЦикла;
        ЭтоМассив = Ложь;
    Иначе
        ИспользуемыеКолонки = "";
        ЭтоМассив = ТипЗнч(ТабИсточник) = Тип("Массив");
        Если НЕ ЭтоМассив Тогда
	        //@skip-check unknown-method-property
	        Для каждого КолонкаТ Из ТабИсточник.Колонки Цикл
	            Если НайтиПодСтроку(ИсключаемыеКолонки, КолонкаТ.Имя) = 0 Тогда
	                ИспользуемыеКолонки = ИспользуемыеКолонки + "," + КолонкаТ.Имя;
	            КонецЕсли;
	        КонецЦикла;
        КонецЕсли;
    КонецЕсли;
    ИспользуемыеКолонки = Сред(ИспользуемыеКолонки, 2);
    МКлючи = СтрРазделить(КолонкиКлючей, ",", Ложь);
    ОдинКлюч = МКлючи.Количество() = 1;
    ДлинаРазделителя = СтрДлина(Разделитель);
    Для каждого СтрокаТ Из ТабИсточник Цикл
        Если ОдинКлюч Тогда
            ТекКлюч = ?(ВернутьСоответствие, СтрокаТ[КолонкиКлючей], СокрЛП(СтрокаТ[КолонкиКлючей]));
        Иначе
            ТекКлюч = "";
            Для каждого элКлюч Из МКлючи Цикл
                ТекКлюч = ТекКлюч + Разделитель + СтрокаТ[элКлюч];
            КонецЦикла;
            ТекКлюч = Сред(ТекКлюч, ДлинаРазделителя);
        КонецЕсли;
        Если ЭтоМассив Тогда
        	ТекЗначение = СтрокаТ;
        Иначе
	        ТекЗначение = Новый Структура(ИспользуемыеКолонки);
	        ЗаполнитьЗначенияСвойств(ТекЗначение, СтрокаТ);
        КонецЕсли;
        Результат.Вставить(ТекКлюч, ТекЗначение);
    КонецЦикла;
    Возврат Результат
КонецФункции // СтруктураСтруктурИзТЗ

#КонецОбласти

#КонецОбласти

#Область 		МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ

// Вспомогательная для РассчитатьМенеджерНаСервере.
// Добавляет переданную строку в ключ ОписаниеОшибки структуры параметров.
//Параметры:
//  Параметры_  - Структура - в ключ ОписаниеОшибки которой будет дописано сообщение;
//  Описание    - Строка - Текст описания ошибки, записываемый в структуру
&НаКлиентеНаСервереБезКонтекста
Процедура ДобавитьОшибку(Параметры_, Описание)
    Если Параметры_.Свойство("ОписаниеОшибки") Тогда
        Параметры_.ОписаниеОшибки = Параметры_.ОписаниеОшибки + "; " + Описание;
    Иначе
        Параметры_.Вставить("ОписаниеОшибки", Описание);
    КонецЕсли; 
КонецПроцедуры
    
// Запускает менеджер (обработчик) реквизита или события. При этом нераспознаваемые значения не будут приводить к вызову сервера.
// Параметры:
//  Менеджер  - Произвольный - Строка, СправочникСсылка.ДополнительныеОбработки, СправочникСсылка.ВнешниеОбработки,
//  		СправочникСсылка.ПереопределяемыеПроцедуры, Путь к файлу обработки или иное значение = Путь к менеджеру, код менеджера или иное.
//          В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//          в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//          Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//          СТРОКА обрабатывается в таком порядке:
//                  1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//                  2.Проверка на служебные префиксы:
//                      >"F:" - путь к файлу обработки для исполнения. ВАЖНО!!! В этом варианте при запуске с клиента в ПараметрыМенеджера
//                      		создаётся ключ "Перенесённые___Файлы", где значения соответствия - временные файлы на сервере, которые следует 
//                      		удалить после использования этой функции в цикле.
//                      >"Т:" (рус) - строка,
//                      >"В:" (рус) - вычисление,
//                      >"Р:" (рус) - распознавание,
//                  3.Попытка вычислить;
//                  4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой,
//                  		распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//                  5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Произвольный - Массив типов или менеджеров прикладного типа или менеджер прикладного типа
//  		или тип = ограничивает допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Строка - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Строка - Имя реквизита, по которому вести распознавание.
//  Родитель  - Произвольный - Родитель, внутри которого вести распознавание.
//  Владелец  - Произвольный - Владелец, внутри которого вести распознавание.
//  СообщатьСюда - Строка, Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
//  
// Возвращаемое значение:
//   Произвольный   - Результат, возвращаемый менеджером
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ЗапуститьМенеджер(
        Менеджер,
        ПараметрыМенеджера = Неопределено,
        ТипыДляРаспознавания = Неопределено,
        ОбработкаИсключения = "",
        ПоРеквизиту = "",
        Родитель = Неопределено,
        Владелец = Неопределено,
        СообщатьСюда = Неопределено) Экспорт
    Хрюква = СокрЛП(Новый УникальныйИдентификатор);
    Результат = Хрюква;
    ТипМенеджера = ТипЗнч(Менеджер);
    ЭтоОбработка = СтрНайти("Переопределяемые процедуры,Внешние обработки,Дополнительные отчеты и обработки", ТипМенеджера) <> 0;
    ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
    ТекстКода = "";
    Распознать = "";
    НовыйМенеджер = "";
    Если ПараметрыМенеджера = Неопределено Тогда
        ПараметрыМенеджера = Новый Структура; 
    КонецЕсли;
    НаСервер = Ложь;
    #Если Сервер Тогда
		УстановитьБезопасныйРежим(Истина);
    #КонецЕсли
    Если ЭтоОбработка Тогда
    	#Если Сервер ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
			ЕстьДопИнструменты =
					//ВызовСервераХЪ
					ЕстьДопОбработки();
		    Если ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьПП, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаПП), Неопределено) Тогда
		        //Это ПП
		        ТекстКода = "Результат = Справочники.ВОЛНА_ПереопределяемыеПроцедуры.ВычислитьФункцию(Менеджер,, ПараметрыМенеджера,
		                |?(ПараметрыМенеджера.Свойство(""ПолучитьСКД""), ПараметрыМенеджера.ПолучитьСКД, Ложь),
		                |?(ПараметрыМенеджера.Свойство(""ПолучитьНастройкиСКД""), ПараметрыМенеджера.ПолучитьНастройкиСКД, Ложь),
		                |?(ПараметрыМенеджера.Свойство(""ПолучитьПараметры""), ПараметрыМенеджера.ПолучитьПараметры, Ложь));"
		    ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьВО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаВО), Неопределено) Тогда
		        //Это ВО
		        Если БезопасныйРежим() Тогда
		            Результат = Неопределено;
		            ДобавитьОшибку(ПараметрыМенеджера, "В безопасном режиме нельзя прочитать временный файл и запустить внешнюю обработку!");
		        Иначе
		        	//Вариант фактически заблокирован, лучше так
		            ТекстКода = "ЭтоОбработка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Менеджер, ""ВидОбработки"") = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
		                    |Если ЭтоОбработка Тогда
		                    |   Попытка
		                    |       ИмяФайла = ПолучитьИмяВременногоФайла();
		                    |       ДвоичныеДанные = Менеджер.ХранилищеВнешнейОбработки.Получить();
		                    |       ДвоичныеДанные.Записать(ИмяФайла);
		                    |       Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, ПараметрыМенеджера);
		                    |   Исключение
		                    |       ООШ = ОписаниеОшибки();
		                    |       ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		                    |       Результат = Менеджер;
		                    |   КонецПопытки;
		                    |КонецЕсли;"
		        КонецЕсли; 
		    ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьДО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаДО), Неопределено) Тогда
		        //Это ДО
		        ТекстКода = "ПараметрыКоманды = Новый Структура(""ДополнительнаяОбработкаСсылка,ИдентификаторКоманды,ОбъектыНазначения"",
		                |       Менеджер, ?(ПараметрыМенеджера.Свойство(""ИмяКоманды""), ПараметрыМенеджера.ИмяКоманды, ""ЗапуститьМенеджер""),
		                |       ?(ПараметрыМенеджера.Свойство(""ОбъектыНазначения""), ПараметрыМенеджера.ОбъектыНазначения, Новый Массив));
		                |Если ПараметрыМенеджера.Свойство(""АдресВременногоХранилища"") Тогда
		                |   ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды, ПараметрыМенеджера.АдресВременногоХранилища);
		                |   Результат = ПолучитьИзВременногоХранилища(ПараметрыМенеджера.АдресВременногоХранилища);
		                |Иначе
		                |   ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды);
		                |   Результат = ПараметрыКоманды.Результат;
		                |КонецЕсли;
		                |Если ПараметрыКоманды.Свойство(""ОписаниеОшибки"") Тогда
		                |   ДобавитьОшибку(ПараметрыМенеджера, ПараметрыКоманды.ОписаниеОшибки);
		                |КонецЕсли";
		    ИначеЕсли ОбработкаИсключения <> "" Тогда
		        Попытка
		            ВыполнитьКод(ОбработкаИсключения, ПараметрыМенеджера, Результат);
		        Исключение
		            ООШ = ОписаниеОшибки();
		            ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		        КонецПопытки;
		    КонецЕсли;
    	#Иначе
    		НаСервер = Истина;
    		НовыйМенеджер = Менеджер;
    	#КонецЕсли
    Иначе
	    Если ТипМенеджера = Тип("Строка") Тогда
	        ТекПрефикс = Лев(Менеджер, 2);
	        Если ТекПрефикс = "Т:" Тогда
	            Результат = Сред(Менеджер, 3);//Получить строку без лишних заморочек
	        ИначеЕсли ТекПрефикс = "F:" Тогда
	            ИмяФайла = Сред(Менеджер, 3);
	            #Если Сервер ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
			        Результат =
			        		//ВызовСервераХЪ
			        		ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		    	#Иначе
		    		Если НЕ ПараметрыМенеджера.Свойство("Перенесённые___Файлы") Тогда
		    			ПараметрыМенеджера.Вставить("Перенесённые___Файлы", Новый Соответствие);
		    		КонецЕсли;
		    		ИмяФайлаНаСервере = ПараметрыМенеджера.Перенесённые___Файлы[ИмяФайла];
		    		Если ИмяФайлаНаСервере = Неопределено Тогда
		    			ТекАдрес = ФайлыВХранилищеНаСервере(ИмяФайла)[0].Адрес;
		    			Если ЗначениеЗаполнено(ТекАдрес) Тогда
		    				НаСервер = Истина;
		    				НовыйМенеджер = "А:" + ТекАдрес + "№№№" + ИмяФайла;
		    			КонецЕсли;
		    		Иначе
	    				НаСервер = Истина;
	    				НовыйМенеджер = ИмяФайлаНаСервере;
		    		КонецЕсли;
		    	#КонецЕсли
	        ИначеЕсли ТекПрефикс = "А:" Тогда
	        	//Служебный серверный вариант
	        	#Если Сервер Тогда
	        		Исходные = СтрЗаменить(Сред(Менеджер, 3), "№№№", Символы.ПС); 
		        	Попытка
			            ДД_ = ПолучитьИзВременногоХранилища(СтрПолучитьСтроку(Исходные, 1));
			            //@skip-check missing-temporary-file-deletion
			            НовоеИмя = ПолучитьИмяВременногоФайла("epf");
			            ДД_.Записать(НовоеИмя);
		        		ПараметрыМенеджера.Перенесённые___Файлы.Вставить(СтрПолучитьСтроку(Исходные, 2), НовоеИмя);
			            Результат = ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		        	Исключение
		        		ООШ = ОписаниеОшибки();
		        		ТекстОшибки = "Не удалось перенести обработку на сервер и выполнить: " + СтрПолучитьСтроку(Исходные, 2) + ООШ;
		        		ПараметрыМенеджера.Вставить("ОписаниеОшибки", ТекстОшибки);
		        	КонецПопытки;
	        	#КонецЕсли
	        ИначеЕсли ТекПрефикс = "В:" Тогда
	            Результат = ВыполнитьКод(СтрЗаменить(Сред(Менеджер, 3), Символ(10), " "), ПараметрыМенеджера,, Истина);
	        ИначеЕсли ТекПрефикс = "Р:" Тогда
	            Распознать = Сред(Менеджер, 3); 
	        ИначеЕсли Лев(Менеджер, 11) = "Результат =" Тогда
	            ТекстКода = Менеджер;
	        Иначе
	            ПрогКод = СтрЗаменить(Менеджер, Символ(10), " ");
	            Попытка
	                Результат = ВыполнитьКод(ПрогКод, ПараметрыМенеджера,, Истина);
	            Исключение
	                Распознать = Менеджер;
	            КонецПопытки;
	        КонецЕсли;
	    Иначе
	        Результат = Менеджер;
	    КонецЕсли;
	    Если Распознать <> "" Тогда
	        Результат =
	        		//ВызовСервераХЪ
	        		РаспознатьЗначение(Распознать, ТипыДляРаспознавания, ПоРеквизиту, Родитель, Владелец);
	    КонецЕсли;
    КонецЕсли;
    Если НаСервер Тогда
		ТекПараметры = "Менеджер,ПараметрыМенеджера,ТипыДляРаспознавания,ОбработкаИсключения,ПоРеквизиту,Родитель,Владелец,СообщатьСюда";
		ПараметрыМетода = СтрРазделить(ТекПараметры, ",");
		ПараметрыДляСервера = Новый Структура("ПараметрыМетода", ПараметрыМетода);
		Для Каждого Элт Из ПараметрыМетода Цикл
			ПараметрыДляСервера.Вставить(Элт, Вычислить(Элт));
		КонецЦикла;
		ПараметрыДляСервера.Менеджер = НовыйМенеджер;
		Результат =
				ВыполнитьКодНаСервере(
		        		//ВызовСервераХЪ
						"ЗапуститьМенеджер",
						ПараметрыДляСервера,,
						Истина);
    ИначеЕсли ТекстКода <> "" Тогда
        Попытка
            ВыполнитьКод(ТекстКода, ПараметрыМенеджера, Результат);
        Исключение
            ООШ = ОписаниеОшибки();
            ДобавитьОшибку(ПараметрыМенеджера, ООШ);
        КонецПопытки;
    КонецЕсли;
    Если ПараметрыМенеджера.Свойство("ОписаниеОшибки") Тогда
        ТекстСообщения = ПараметрыМенеджера.ОписаниеОшибки;
        Если ЕстьСтрокаТабло Тогда
            СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
        Иначе
        	Сообщение_ = Новый СообщениеПользователю;
        	Сообщение_.Текст = ТекстСообщения;
        	Сообщение_.Сообщить();
        КонецЕсли;      
        ПараметрыМенеджера.Вставить("ПоследняяОшибка", ПараметрыМенеджера.ОписаниеОшибки);
        ПараметрыМенеджера.Удалить("ОписаниеОшибки");
    КонецЕсли; 
    Если Результат = Хрюква Тогда
    	Результат = Менеджер;
    КонецЕсли;
    Возврат Результат
КонецФункции

#КонецОбласти

#Область 		РЕКВИЗИТЫ_ОБЪЕКТОВ
    
// Возращает, есть ли реквизит у объекта. При массивных данных в реквизите может притормозить выполнение.
// Параметры:
//  Реквизит  - Строка - Имя проверяемого реквизита
//  УКого  - Произвольный - Любое значение, имеющее реквизиты
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЕстьРеквизитОбъекта(Реквизит, УКого) Экспорт
    ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
    Проверятель = Новый Структура(Реквизит, ЛюбоеНедопустимоеЗначение);
    ЗаполнитьЗначенияСвойств(Проверятель, УКого);
    Возврат Проверятель[Реквизит] <> ЛюбоеНедопустимоеЗначение
КонецФункции // ЕстьРеквизитОбъекта()

// Возращает структуру с информацией, есть ли реквизиты у объекта. При массивных данных в реквизитах может притормозить выполнение.
// Параметры:
//  Реквизиты  - Строка - Имена проверяемоых реквизитов через запятую
//  УКого  - Произвольный - Любое значение, имеющее реквизиты
//  Режим  - Строка - 
//          *"Копирование" Останутся все перечисленные в Ревизиты со значениями реквизитов + ключ "Хрюква", его значение будет в отсутствующих реквизитах.
//          *"Пересечение" Включение режима, когда в результате останутся значения только имеющихся в УКого реквизитов.
//          *"Проверка" (По умолчанию) = Останутся все перечисленные в Ревизиты, а значения будут булевыми
// Возвращаемое значение:
//   Структура - Истина/значение реквизита, если реквизит есть, Ложь - если реквизита нет.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЕстьРеквизитыОбъекта(Реквизиты, УКого, Режим = "Проверка") Экспорт
    ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
    Проверятель = Новый Структура(Реквизиты);
    Для каждого КиЗ Из Проверятель Цикл
        Проверятель.Вставить(КиЗ.Ключ, ЛюбоеНедопустимоеЗначение);
    КонецЦикла;
    ЗаполнитьЗначенияСвойств(Проверятель, УКого);
    Если Режим = "Копирование" Тогда
        Результат = Проверятель;
        Результат.Вставить("Хрюква", ЛюбоеНедопустимоеЗначение);
    ИначеЕсли Режим = "Пересечение" Тогда
        Результат = Новый Структура;
        Для каждого КиЗ Из Проверятель Цикл
            Если КиЗ.Значение <> ЛюбоеНедопустимоеЗначение Тогда
                Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
            КонецЕсли;
        КонецЦикла;
    Иначе
        Результат = Новый Структура;
        Для каждого КиЗ Из Проверятель Цикл
            Результат.Вставить(КиЗ.Ключ, КиЗ.Значение <> ЛюбоеНедопустимоеЗначение);
        КонецЦикла;
    КонецЕсли;
    Возврат Результат
КонецФункции // ЕстьРеквизитОбъекта()

// Получает значение реквизита объекта без ошибки, если реквизита нет.
// Параметры:
//  Источник  - Произвольный - Любой объект, который может быть источником для ЗаполнитьЗначенияСвойств
//  ИмяРеквизита  - Строка - Имя читаемого реквизита
//  ЕслиНеНайден - Произвольный - возвращаемое значение, если реквизит не найден. По умолчанию NULL.
//  ПолученноеЗначение - Произвольный - Переменная, куда будет возвращено значение (для запуска как процедуры). По умолчанию NULL.
// Возвращаемое значение:
//   Произвольный   - Значение указанного реквизита
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция Получить(Источник, ИмяРеквизита, ЕслиНеНайден = NULL, ПолученноеЗначение = NULL) Экспорт
    Результат = Новый Структура(ИмяРеквизита, ЕслиНеНайден);
    ЗаполнитьЗначенияСвойств(Результат, Источник);
    Возврат Результат[ИмяРеквизита]
КонецФункции // Получить

// Сравнивает объекты пореквизитно (Истина - равны)
// Параметры:
//  Значение1  - Произвольный - значение с реквизитами = Первый объект сравнения
//  Значение2  - Произвольный - значение с реквизитами = Второй объект сравнения
//  МассивСвойств  - Массив из Строка - Имена реквизитов. Если не указан, предполагается, что первый объект - структура или соответствие,
//  		и сравнение идёт по его ключам
// Возвращаемое значение:
//   Булево   - Истина, если пореквизитное равенство
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ПореквизитноРавны(Значение1, Значение2, МассивСвойств = Неопределено) Экспорт
    Если МассивСвойств = Неопределено Тогда
        МассивСвойств = Новый Массив;
        Для каждого КиЗ Из Значение1 Цикл
            МассивСвойств.Добавить(КиЗ.Ключ);
        КонецЦикла; 
    КонецЕсли;
    Результат = Истина;
    Для каждого Имя Из МассивСвойств Цикл
        Если Значение1[Имя] <> Значение2[Имя] Тогда
            Результат = Ложь;
            Прервать
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // ПореквизитноРавны

#КонецОбласти 

#Область 		ССЫЛКИ_УИДЫ
    
//Переводит строку ГУИД в УИД
//Параметры:
//  GUID_ - Строка - 32 значный ГУИД
//Возвращаемое значение:
//  Строка - в формате УникальныйИдентификатор (36 символов)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция GUIDToUUID(GUID_) Экспорт

	Возврат Прав(GUID_, 8) + "-" + Сред(GUID_, 21, 4) + "-" + Сред(GUID_, 17, 4) + "-" + Лев(GUID_, 4) + "-" + Сред(GUID_, 5, 12);
 
КонецФункции

//Переводит строку УИД в ГУИД
//Параметры:
//  UUID_ - Строка - в формате УникальныйИдентификатор (36 символов)
//Возвращаемое значение:
//  Строка - 32 значный ГУИД
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция UUIDToGUID(UUID_) Экспорт
 
 Возврат Сред(UUID_, 20, 4) + Прав(UUID_, 12) + Сред(UUID_, 15, 4) + Сред(UUID_, 10, 4) + Лев(UUID_, 8);
 
КонецФункции

#КонецОбласти 

#Область 		СТРОКОВЫЕ

// Находит в строке дату/период и возвращает её (без времени).
// Параметры:
//  Строчка  - Строка - Строка, из которой надо попытаться сделать дату
//  ВПериодеВзятьКонец  - Булево - Если строка - период, то вернуть его конец. Иначе (по умолчанию - ложь) - начало.
// Возвращаемое значение:
//   Дата, НЕопределено   - Дата, вычисленная из строки. Неопределено, если не получается.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ДатаИзСтроки(Строчка, ВПериодеВзятьКонец = Ложь) Экспорт
    Результат = Неопределено;
    СтрокаРаспознания = СтрЗаменить(СтрЗаменить(СтрЗаменить(Строчка, "/", Символы.ПС), ".", Символы.ПС), " ", Символы.ПС);
    Сброс = Истина;
    Для Сч = 1 По СтрЧислоСтрок(СтрокаРаспознания) Цикл
        Если Сброс Тогда
            ГодДаты = 0;
            МесяцДаты = 0;
            ДеньДаты = 0;
            Сброс = Ложь;
        КонецЕсли;
        ТекСтр = ВРег(СтрПолучитьСтроку(СтрокаРаспознания, Сч));
        Если НЕ ПустаяСтрока(ТекСтр) Тогда
            Если ДеньДаты = 0 Тогда
                Если СтрДлина(ТекСтр) < 3 Тогда
                    //@skip-check empty-except-statement
                    Попытка
                        ДеньДаты = Число(ТекСтр);
                    Исключение
                    КонецПопытки;
                КонецЕсли;
                Если ДеньДаты = 0 Тогда
                    Если ТекСтр = "ЯНВАРЬ" Тогда
                        МесяцДаты = 1;
                    ИначеЕсли ТекСтр = "ФЕВРАЛЬ" Тогда
                        МесяцДаты = 2;
                    ИначеЕсли ТекСтр = "МАРТ" Тогда
                        МесяцДаты = 3;
                    ИначеЕсли ТекСтр = "АПРЕЛЬ" Тогда
                        МесяцДаты = 4;
                    ИначеЕсли ТекСтр = "МАЙ" Тогда
                        МесяцДаты = 5;
                    ИначеЕсли ТекСтр = "ИЮНЬ" Тогда
                        МесяцДаты = 6;
                    ИначеЕсли ТекСтр = "ИЮЛЬ" Тогда
                        МесяцДаты = 7;
                    ИначеЕсли ТекСтр = "АВГУСТ" Тогда
                        МесяцДаты = 8;
                    ИначеЕсли ТекСтр = "СЕНТЯБРЬ" Тогда
                        МесяцДаты = 9;
                    ИначеЕсли ТекСтр = "ОКТЯБРЬ" Тогда
                        МесяцДаты = 10;
                    ИначеЕсли ТекСтр = "НОЯБРЬ" Тогда
                        МесяцДаты = 11;
                    ИначеЕсли ТекСтр = "ДЕКАБРЬ" Тогда
                        МесяцДаты = 12;
                    КонецЕсли;
                    Если МесяцДаты > 0 Тогда
                        ДеньДаты = ?(ВПериодеВзятьКонец, -1, 1)
                    КонецЕсли;
                КонецЕсли; 
            ИначеЕсли МесяцДаты = 0 Тогда
                Попытка
                    МесяцДаты = Число(ТекСтр);
                Исключение
                    ТекСтр = ВРег(ТекСтр);
                    Если ТекСтр = "ЯНВАРЯ" Тогда
                        МесяцДаты = 1;
                    ИначеЕсли ТекСтр = "ФЕВРАЛЯ" Тогда
                        МесяцДаты = 2;
                    ИначеЕсли ТекСтр = "МАРТА" Тогда
                        МесяцДаты = 3;
                    ИначеЕсли ТекСтр = "АПРЕЛЯ" Тогда
                        МесяцДаты = 4;
                    ИначеЕсли ТекСтр = "МАЯ" Тогда
                        МесяцДаты = 5;
                    ИначеЕсли ТекСтр = "ИЮНЯ" Тогда
                        МесяцДаты = 6;
                    ИначеЕсли ТекСтр = "ИЮЛЯ" Тогда
                        МесяцДаты = 7;
                    ИначеЕсли ТекСтр = "АВГУСТА" Тогда
                        МесяцДаты = 8;
                    ИначеЕсли ТекСтр = "СЕНТЯБРЯ" Тогда
                        МесяцДаты = 9;
                    ИначеЕсли ТекСтр = "ОКТЯБРЯ" Тогда
                        МесяцДаты = 10;
                    ИначеЕсли ТекСтр = "НОЯБРЯ" Тогда
                        МесяцДаты = 11;
                    ИначеЕсли ТекСтр = "ДЕКАБРЯ" Тогда
                        МесяцДаты = 12;
                    ИначеЕсли ТекСтр = "КВАРТАЛ" Тогда
                    	Если ВПериодеВзятьКонец Тогда
	                        МесяцДаты = ДеньДаты * 3;
                    		ДеньДаты = -1;
                    	Иначе
                    		МесяцДаты = ДеньДаты * 3 - 2;
                    		ДеньДаты = 1;
                    	КонецЕсли;
                    Иначе
                        Сброс = Истина;
                    КонецЕсли;
                КонецПопытки;
            Иначе
                Попытка
                    ТекСтр = СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекСтр, "ГОДА", ""), "ГОД", ""), "Г", "");
                    ГодДаты = Число(ТекСтр);
                    Если ГодДаты < 100 Тогда
                        //@skip-check use-non-recommended-method
                        ТекГод = Год(ТекущаяДата());
                        ГодДаты = ГодДаты + ТекГод - ТекГод % 100;
                    КонецЕсли; 
                    Если (ГодДаты < 100) ИЛИ (ГодДаты > 3999) Тогда
                        Сброс = Истина;
                    Иначе
                        Прервать;
                    КонецЕсли; 
                Исключение
                    Сброс = Истина;
                КонецПопытки;
            КонецЕсли; 
        КонецЕсли; 
    КонецЦикла;
    //@skip-check empty-except-statement
    Попытка
        Результат = Дата(ГодДаты, МесяцДаты, ?(ДеньДаты = -1, 1, ДеньДаты));
        Если ДеньДаты = -1 Тогда
            Результат = КонецМесяца(Результат);
        КонецЕсли; 
    Исключение
    КонецПопытки;
    Возврат Результат
КонецФункции // ДатаИзСтроки
 
// Выполняет в строке ряд замен по соответствию
// Параметры:
//  Текст  - Строка - Где менять
//  Замены  - Соответствие из Строка - Что менять (ключ) и на что менять (значение).
//  		Если важен порядок замен, следует передать массив из структур с ключами "Ключ" и "Значениие"
//  		или массив из КлючИЗначение, где Ключ будет меняться на Значение.
// Возвращаемое значение:
//	Строка - после замен
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЗаменитьВТексте(Текст, Замены) Экспорт
    Результат = Текст;
    Для каждого КиЗ Из Замены Цикл
        Результат = СтрЗаменить(Результат, КиЗ.Ключ, КиЗ.Значение);
    КонецЦикла;
    Возврат Результат
КонецФункции // ЗаменитьВТексте
 
// Заменяет конец строки новым набором символов той же длины
// Параметры:
//  ГдеМенять  - Произвольный - Любое значение, преобразуемое в строку = Исходная строка;
//  НаЧтоМенять  - Произвольный - Любое значение, преобразуемое в строку = Новый конец строки;
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура ЗаменитьКонецСтроки(ГдеМенять, НаЧтоМенять)Экспорт
    ГдеМенять = Лев(ГдеМенять, СтрДлина(ГдеМенять) - СтрДлина(НаЧтоМенять)) + НаЧтоМенять
КонецПроцедуры

//Преобразует имя переменной в строку представления
//заменой заглавных букв на строчные с пробелом
// Параметры:
//  ИмяПеременной  - Произвольный - Любое значение, преобразуемое в строку = Исходная строка;
//  ПропуститьНедопустимые  - Булево - При Истина (по умолчанию) символы, недопустимые в имени переменной, будут заменены на пробел,
//          а следующий символ - на заглавный, при Ложь - будут обработаны как допустимый символ;
// Возвращаемое значение:
//   Строка   - Исходная строка с заменой:
//          >Обозначения (в Замены = см. далее)
//              а = строчный
//              А = заглавный
//              Ь = заглавный, подлежащий проверке в следующих комбинациях
//              % = любой небуквенный непустой и не _
//              _ = _
//              9 = цифра
//              Н = Первый в строке и заглавный
//              П = Пустой
//              п = пустой или _
//          >Замены:
//              >Первый символ кроме пустых - всегда как есть. Краевые пробелы и _ убираются.
//              >Последний символ любой комбинации участвует в следующей проверке.
//              п_А => "_А"
//              п_% => "_%"
//              п_п => " п"
//              п_а => " а"
//              пП => " "
//              пААп => " а а "
//              пАА% => " АА%"
//              пААА => " ЬЬЬ"
//              пААа => " а аа"
//              _Аа => " аа"
//              ПАа => " Аа"
//              пАп => " а "
//              пА% => " А%"
//              па => " а"
//              п% => "_%"
//              %ААп => "% а а "
//              %АА% => % АА%
//              %ААА => % ЬЬЬ
//              %ААа => % а аа
//              %Ап => "%А "
//              %А% => % А%
//              %Аа => % аа
//              %а => "% а"
//              АААа => АА аа
//              НАп => "НА "
//              НАа => Н аа
//              аААп => а АА
//              аАА% => а АА%
//              аААА => а ЬЬЬ
//              аААа => а а аа
//              аАп => "а А "
//              аА% => а А%
//              аАа => а аа
//@skip-check export-method-in-command-form-module
//@skip-check module-region-empty
&НаКлиентеНаСервереБезКонтекста
Функция ИмяПеременнойВСтроку(ИмяПеременной, ПропуститьНедопустимые = Истина) Экспорт
    #Область ИНИЦИАЛИЗАЦИЯ
        Заглавные = СимволыГруппы("БуквыЗагл");
        Строчные = СимволыГруппы("БуквыСтр");
        Допустимые = СимволыГруппы("СПиЦ");
        ТекДлина = СтрДлина(ИмяПеременной);
        Результат = "";
        КрайНеОк = Истина;
        ЭтоПервый = Истина;
        Пропустить = 0;
        ИсходноеИмя = ИмяПеременной;
    #КонецОбласти
    
    #Область КРАЕВЫЕ
        Пока КрайНеОк И ТекДлина > 0 Цикл
            КрайНеОк = Ложь;
            ТекБуква = Прав(ИсходноеИмя, 1);
            Если ТекБуква = "_" ИЛИ НЕ ЗначениеЗаполнено(ТекБуква) Тогда
                ТекДлина = ТекДлина - 1;
                ИсходноеИмя = Лев(ИсходноеИмя, ТекДлина);
                КрайНеОк = Истина;
            КонецЕсли;
            ТекБуква = Лев(ИсходноеИмя, 1);
            Если ТекБуква = "_" ИЛИ НЕ ЗначениеЗаполнено(ТекБуква) Тогда
                ТекДлина = ТекДлина - 1;
                ИсходноеИмя = Сред(ИсходноеИмя, 2);
                КрайНеОк = Истина;
            КонецЕсли;
        КонецЦикла;
    #КонецОбласти
    #Область ЗАМЕНЫ
        Для Ё = 1 По ТекДлина Цикл
            Если ЭтоПервый Тогда
                #Область РАСЧЁТ_БУКВЫ
                    ТекБуква = Лев(ИсходноеИмя, 1);
                    ТекБуква_ = ТекБуква = "_";
                    ТекБукваПустая = НЕ ЗначениеЗаполнено(ТекБуква);
                    ТекБукваЗаглавная = СтрНайти(Заглавные, ТекБуква) > 0;
                    ТекБукваСтрочная = СтрНайти(Строчные, ТекБуква) > 0;
                    ТекБукваДопустимая = СтрНайти(Допустимые, ТекБуква) > 0;
                    ТекБуква1 = Сред(ИсходноеИмя, 2, 1);
                    ТекБуква1_ = ТекБуква1 = "_";
                    ТекБуква1Пустая = НЕ ЗначениеЗаполнено(ТекБуква1);
                    ТекБуква1Заглавная = СтрНайти(Заглавные, ТекБуква1) > 0;
                    ТекБуква1Строчная = СтрНайти(Строчные, ТекБуква1) > 0;
                    ТекБуква1Допустимая = СтрНайти(Допустимые, ТекБуква1) > 0;
                    ТекБуква2 = Сред(ИсходноеИмя, 3, 1);
                    ТекБуква2_ = ТекБуква2 = "_";
                    ТекБуква2Пустая = НЕ ЗначениеЗаполнено(ТекБуква2);
                    ТекБуква2Заглавная = СтрНайти(Заглавные, ТекБуква2) > 0;
                    ТекБуква2Строчная = СтрНайти(Строчные, ТекБуква2) > 0;
                    ТекБуква2Допустимая = СтрНайти(Допустимые, ТекБуква2) > 0;
                    ТекБуква3 = Сред(ИсходноеИмя, 4, 1);
                    ТекБуква3_ = ТекБуква3 = "_";
                    ТекБуква3Пустая = НЕ ЗначениеЗаполнено(ТекБуква3);
                    ТекБуква3Заглавная = СтрНайти(Заглавные, ТекБуква3) > 0;
                    ТекБуква3Строчная = СтрНайти(Строчные, ТекБуква3) > 0;
                    ТекБуква3Допустимая = СтрНайти(Допустимые, ТекБуква3) > 0;
                #КонецОбласти
            Иначе
                #Область ИЗ_ПРЕД_ДАННЫХ
                    ТекБуква = ТекБуква1;
                    ТекБуква_ = ТекБуква1_;
                    ТекБукваПустая = ТекБуква1Пустая;
                    ТекБукваЗаглавная = ТекБуква1Заглавная;
                    ТекБукваСтрочная = ТекБуква1Строчная;
                    ТекБукваДопустимая = ТекБуква1Допустимая;
                    ТекБуква1 = ТекБуква2;
                    ТекБуква1_ = ТекБуква2_;
                    ТекБуква1Пустая = ТекБуква2Пустая;
                    ТекБуква1Заглавная = ТекБуква2Заглавная;
                    ТекБуква1Строчная = ТекБуква2Строчная;
                    ТекБуква1Допустимая = ТекБуква2Допустимая;
                    ТекБуква2 = ТекБуква3;
                    ТекБуква2_ = ТекБуква3_;
                    ТекБуква2Пустая = ТекБуква3Пустая;
                    ТекБуква2Заглавная = ТекБуква3Заглавная;
                    ТекБуква2Строчная = ТекБуква3Строчная;
                    ТекБуква2Допустимая = ТекБуква3Допустимая;
                    ТекБуква3 = Сред(ИсходноеИмя, Ё + 3, 1);
                    Если ТекБуква3 = "" Тогда
                        ТекБуква3 = "Х";
                    КонецЕсли;
                    ТекБуква3_ = ТекБуква3 = "_";
                    ТекБуква3Пустая = НЕ ЗначениеЗаполнено(ТекБуква3);
                    ТекБуква3Заглавная = СтрНайти(Заглавные, ТекБуква3) > 0;
                    ТекБуква3Строчная = СтрНайти(Строчные, ТекБуква3) > 0;
                    ТекБуква3Допустимая = СтрНайти(Допустимые, ТекБуква3) > 0;
                #КонецОбласти
            КонецЕсли;
            Если Пропустить > 0 Тогда
                Пропустить = Пропустить - 1;
            Иначе
                Если ТекБукваПустая Тогда
                    Если ТекБуква1_ Тогда
                        Если ТекБуква2Пустая ИЛИ ТекБуква2Строчная Тогда
                            ТекБуква1 = " "; 
                        Иначе
                            ТекБуква1 = "_"; 
                        КонецЕсли;
                    ИначеЕсли ТекБуква1Пустая Тогда
                        ТекБуква1 = " "; 
                    ИначеЕсли ТекБуква1Заглавная Тогда
                        Если ТекБуква2Заглавная Тогда
                            Если ТекБуква3Заглавная Тогда
                                Результат = Результат + " ";
                            ИначеЕсли ТекБуква3Строчная Тогда
                                Результат = Результат + " ";
                            ИначеЕсли ТекБуква3Пустая Тогда
                                Результат = Результат + " " + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
                                Пропустить = 2;
                            Иначе
                                Результат = Результат + " " + ТекБуква1 + ТекБуква2;
                                Пропустить = 2;
                            КонецЕсли;
                        ИначеЕсли ТекБуква2Строчная Тогда
                            Результат = Результат + " " + ?(ТекБуква_, НРег(ТекБуква1), ТекБуква1);
                            Пропустить = 1;
                        ИначеЕсли ТекБуква2Пустая Тогда
                            Результат = Результат + " " + НРег(ТекБуква1);
                            Пропустить = 1;
                        Иначе
                            Результат = Результат + " " + ТекБуква1;
                            Пропустить = 1;
                        КонецЕсли;
                    ИначеЕсли ТекБуква1Строчная Тогда
                        Результат = Результат + " "; 
                    Иначе
                        Результат = Результат + "_"; 
                    КонецЕсли;
                ИначеЕсли ТекБукваЗаглавная Тогда
                    Если ТекБуква1Заглавная Тогда
                        Если ТекБуква2Заглавная И ТекБуква3Строчная Тогда
                            Результат = Результат + ТекБуква + ТекБуква1 + " " + НРег(ТекБуква2);
                            Пропустить = 2;
                        ИначеЕсли ЭтоПервый И ТекБуква2Пустая Тогда
                            Результат = Результат + ТекБуква + ТекБуква1;
                            Пропустить = 1;
                        ИначеЕсли ЭтоПервый И ТекБуква2Строчная Тогда
                            Результат = Результат + ТекБуква + " " + НРег(ТекБуква1);
                            Пропустить = 1;
                        Иначе
                            Результат = Результат + ТекБуква;
                        КонецЕсли;
                    Иначе
                        Результат = Результат + ТекБуква;
                    КонецЕсли;
                ИначеЕсли ТекБукваСтрочная Тогда
                    Если ТекБуква1Заглавная Тогда
                        Если ТекБуква2Заглавная Тогда
                            Если ТекБуква3Заглавная Тогда
                                Результат = Результат + ТекБуква + " ";
                            ИначеЕсли ТекБуква3Строчная Тогда
                                Результат = Результат + ТекБуква + " " + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
                                Пропустить = 2;
                            Иначе
                                Результат = Результат + ТекБуква + " " + ТекБуква1 + ТекБуква2;
                                Пропустить = 2;
                            КонецЕсли;
                        ИначеЕсли ТекБуква2Строчная Тогда
                            Результат = Результат + ТекБуква + " " + НРег(ТекБуква1);
                            Пропустить = 1;
                        Иначе
                            Результат = Результат + ТекБуква + " " + ТекБуква1;
                            Пропустить = 1;
                        КонецЕсли;
                    Иначе
                        Результат = Результат + ТекБуква;
                    КонецЕсли;
                Иначе
                    Если ТекБукваДопустимая ИЛИ НЕ ПропуститьНедопустимые Тогда
                        Результат = Результат + ТекБуква;
                    КонецЕсли;
                    Если ТекБуква1Заглавная Тогда
                        Если ТекБуква2Заглавная Тогда
                            Результат = Результат + " ";
                            Если ТекБуква3Заглавная Тогда
                            ИначеЕсли ТекБуква3Пустая ИЛИ ТекБуква3Строчная Тогда
                                Результат = Результат + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
                                Пропустить = 2;
                            Иначе
                                Результат = Результат + ТекБуква1 + ТекБуква2;
                                Пропустить = 2;
                            КонецЕсли;
                        ИначеЕсли ТекБуква2Пустая ИЛИ ТекБуква2Строчная Тогда
                            Результат = Результат + ТекБуква1;
                            Пропустить = 1;
                        Иначе
                            Результат = Результат + " " + ТекБуква1;
                            Пропустить = 1;
                        КонецЕсли;
                    ИначеЕсли ТекБуква1Строчная Тогда
                        Результат = Результат + " ";
                    КонецЕсли;
                КонецЕсли;
            КонецЕсли;
            ЭтоПервый = Ложь;
        КонецЦикла;
    #КонецОбласти
    Возврат Результат
КонецФункции

// Заменяет в исходной строке все заданные значения на заданные значения замен с повторением,
// пока не исчезнут заменяемые значения. По умолчанию - для замены лишних пробелов.
// Параметры:
//  НачСтрока  - Произвольный - Любое значение, преобразуемое в строку = Исходная строка;
//  ПодстрокаЧтоМенять  - Произвольный - Любое значение, преобразуемое в строку = Строка, которую искоренить;
//  НаЧтоМенять  - Произвольный - Любое значение, преобразуемое в строку = Строка, на которую заменить;
// Возвращаемое значение:
//   Строка   - Строка без заменяемой подстроки (после всех замен)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ИскоренитьПодстроку(НачСтрока, ПодстрокаЧтоМенять = "  ", НаЧтоМенять = " ") Экспорт
    Результат = Строка(НачСтрока);
    Пока СтрНайти(Результат, ПодстрокаЧтоМенять) > 0 Цикл
        Результат = СтрЗаменить(Результат, ПодстрокаЧтоМенять, НаЧтоМенять);
    КонецЦикла;
    Возврат Результат
КонецФункции // ИскоренитьПодстроку()
 
//Находит число символов до заданной подстроки. Если подстроки нет, берётся вся строка.
// Параметры:
//  ГдеИскать - Строка - в которой ищем
//  ИскомыйТекст - Строка - которую ищем
// Возвращаемое значение:
//  Число - колво символов до подстроки. СлужебнаяНайтиКолвоСимволовДоВхождения("12345", "234") = 1
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция НайтиКолвоСимволовДоВхождения(ГдеИскать, ИскомыйТекст) Экспорт
    Результат = СтрНайти(ГдеИскать, ИскомыйТекст) - 1;
    Возврат ?(Результат < 0, СтрДлина(ГдеИскать), Результат)
КонецФункции // НайтиКолвоСимволовДоВхождения()

//Ищет строку в составе другой строки, но только как подстроку между разделителями без краевых пробелов
//Возвращает позицию найденной подстроки или 0
// Параметры:
//  ГдеИскать  - Произвольный - Любое значение, преобразуемое в строку = В которой будет поиск
//  ЧтоИскать  - Строка - Искомая строка
//  Разделитель  - Строка - Разделитель частей в ГдеИскать
// Возвращаемое значение:
//   Число   - Позиция начала подстроки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция НайтиПодСтроку(ГдеИскать, ЧтоИскать, Разделитель = ",") Экспорт
    Возврат СтрНайти(Разделитель + ГдеИскать + Разделитель, Разделитель + ЧтоИскать + Разделитель)
КонецФункции

// Возвращает типовой разделитель запросов
// Возвращаемое значение:
//   Строка   - Типовой разделитель запросов
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция РазделительЗапросов() Экспорт
    #Если Клиент  ИЛИ ВнешнееСоединение Тогда
	    Результат =
	            "
	            |;
	            |
	            |////////////////////////////////////////////////////////////////////////////////
	            |";
    #Иначе
    	ПростойЗапрос = "ВЫБРАТЬ
		    	|	1 КАК Х";
    	СхемаЗ = Новый СхемаЗапроса;
    	СхемаЗ.УстановитьТекстЗапроса(ПростойЗапрос + ";" + ПростойЗапрос);
    	Результат = СтрЗаменить(СхемаЗ.ПолучитьТекстЗапроса(), ПростойЗапрос, "");
    #КонецЕсли
    Возврат Результат
КонецФункции // РазделительЗапросов

//Проверяет строку на соответствие маске. Устареет после появления РВ в языке
//источник - инфостарт
//Параметры:
//  Строчка - Строка, Массив из Строка - проверяемые строки
//  Маска - Строка - шаблон, на соответствие которому проверяется. Синтаксис:
//			>. - любой символ
//			>+ - один или более раз, пример ".+" = один или более любой символ. Суффикс "ревнивого" квантификатора (аа в ааа найдёт только одно вхождение, т.к. вторая а уже участвовала в первом и не может быть использована повторно).
//			>* - ноль или более раз, пример ".*" = любое количество любых символов (даже ни одного).
//			>[n-m] - символ от m до n, пример: "[0-9]+" = одна или более цифр(а).
//			>\b - граница слова (первый или последний символ).
//			>\B - не граница слова.
//			>\d - цифра, пример \d+ = одна или более цифр(а).
//			>\D - не цифра.
//			>\G - Предыдущий успешный поиск (\Ga - первая позиция не с буквой а).
//			>\s - пробельный символ - ТАБ, пробел, перенос строки, возврат каретки и т.п.
//			>\S - непробельный символ.
//			>\w, [[:word:]] - буква, цифра, подчеркивание.
//			>\W - не буква, не цифра и не подчеркивание соответственно.
//			>^ - начало текста, например "^\d+" - строка начинается с цифры.
//			>$ - конец текста, например "\D+$" - строка заканчивается НЕ цифрой.
//			>{m,n} - шаблон для от m до n символов, например "\d{2,4}" = от двух до четырех цифр. Можно указать одну цифру для строгого соответвия или цифру с запятой для только одной границы (от/до бесконечности).
//			>\ - экранирует спецсимволы. Например, "\." = символ точки.
//			>| - ИЛИ.
//			>^ - НЕ, конец текста.
//			>$ - начало текста.
//			>\ - экранирует спецсимволы. Например, "\." - символ точки.
//			>() - границы, приоритет - как в выражениях.
//			>? - префикс - 0 или 1 повтор, суффикс - ленивого квантификатора (0*х найдёт в 0ААхх только 0ААх, но не 0ААхх).
//			>?>ШАБЛОН - ищет шаблон "жадно". ?>(2*)5 не найдёт 2225, т.к. найдёт 2225 по шаблону 2*, после чего 5 уже занято. Работает быстрее.
//		По умолчанию - маска проверки даты "\d{2}\.\d{2}\.\d{4}"
//  Тестер - ЗначениеXDTO - Тестер строки по маске. Если Неопределено => создаётся
//  
//Возвращаемое значение:
//		Булево - Строка соответствует шаблону или массив, если передан массив.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьСтроку(Строчка, Маска = "\d{2}\.\d{2}\.\d{4}", Тестер = Неопределено) Экспорт
    //@skip-check server-execution-safe-mode
    Если Тестер = Неопределено Тогда
        //@skip-check server-execution-safe-mode
        Тестер =
        //КлиентСерверХЪ
        ЗначениеXDTOдляПроВеркиСтроки(Маска);
    КонецЕсли;

    Результат = Новый Массив;
    Для каждого ТекЗначение Из ПреобразоватьВМассив(Строчка) Цикл
        Попытка
            Тестер.TestItem = ТекЗначение;
            Результат.Добавить(Истина);
        Исключение
            Результат.Добавить(Ложь);
        КонецПопытки;
    КонецЦикла; 
    Возврат ?(Результат.Количество() = 1, Результат[0], Результат)
КонецФункции

// Возвращает строку всех символов заданной группы
// Параметры:
//  Группа  - Строка - вид символов:
//      >Цифры
//      >БуквыРЛ
//      >БуквыРус
//      >БуквыЛат
//      >БуквыЗагл
//      >БуквыСтр
//      >БуквыРЗагл
//      >БуквыРСтр
//      >БуквыЛЗагл
//      >БуквыЛСтр
//      >ДляПеременной1
//      >ДляПеременнойВсе
//      >СПиЦ - символ подчёркивания и цифры
//      >АрифметикаДействия
// Возвращаемое значение:
//   Строка   - Все символы группы
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СимволыГруппы(Группа) Экспорт
    Результат = "";
    Если Группа = "АрифметикаДействия" Тогда
        Результат = "+-*/:^%";
    Иначе
        Цифры = "0123456789";
        БРЗ = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
        БЛЗ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        БРС = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
        БЛС = "abcdefghijklmnopqrstuvwxyz";
        СимП = "_";
        Если Группа = "БуквыЗагл" Тогда
            Результат = БЛЗ + БРЗ;
        ИначеЕсли Группа = "БуквыЛат" Тогда
            Результат = БЛЗ + БЛС;
        ИначеЕсли Группа = "БуквыЛЗагл" Тогда
            Результат = БЛЗ;
        ИначеЕсли Группа = "БуквыЛСтр" Тогда
            Результат = БЛС;
        ИначеЕсли Группа = "БуквыРЗагл" Тогда
            Результат = БРЗ;
        ИначеЕсли Группа = "БуквыРЛ" Тогда
            Результат = БЛЗ + БЛС + БРЗ + БРС;
        ИначеЕсли Группа = "БуквыРСтр" Тогда
            Результат = БРС;
        ИначеЕсли Группа = "БуквыРус" Тогда
            Результат = БРЗ + БРС;
        ИначеЕсли Группа = "БуквыСтр" Тогда
            Результат = БЛС + БРС;
        ИначеЕсли Группа = "ДляПерем1Загл" Тогда
            Результат = СимП + БЛЗ + БРЗ;
        ИначеЕсли Группа = "ДляПерем1Стр" Тогда
            Результат = СимП + БЛС + БРС;
        ИначеЕсли Группа = "ДляПеременной1" Тогда
            Результат = СимП + БЛЗ + БЛС + БРЗ + БРС;
        ИначеЕсли Группа = "ДляПеремВсеЗагл" Тогда
            Результат = СимП + Цифры + БЛЗ + БРЗ;
        ИначеЕсли Группа = "ДляПеремВсеСтр" Тогда
            Результат = СимП + Цифры + БЛС + БРС;
        ИначеЕсли Группа = "ДляПеременнойВсе" Тогда
            Результат = СимП + Цифры + БЛЗ + БЛС + БРЗ + БРС;
        ИначеЕсли Группа = "СПиЦ" Тогда
            Результат = СимП + Цифры;
        ИначеЕсли Группа = "Цифры" Тогда
            Результат = Цифры;
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // СимволыГруппы

//Возвращает сочетание клавиш по строковому обозначению   ??? Вызовет ошибку на сервере??? - надо проверить
//Параметры:
//  СтроковоеОбозначениеСочетания - Строка - Расшифровываемое сочетание
//Возвращаемое значение:
//  СочетаниеКлавиш - распознанное сочетание или Неопределено
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СочетаниеКлавишПоСтроке(СтроковоеОбозначениеСочетания) Экспорт
    Результат = Неопределено;
    Ктрл = Ложь;
    Шифт = Ложь;
    Алт = Ложь;
    Код = СтрЗаменить(СтроковоеОбозначениеСочетания, " ", "");
    
    ТекТекст = "Ctrl+";
    Поз = СтрНайти(Код, ТекТекст);
    Если Поз > 0 Тогда
        Ктрл = Истина;
        Код = СтрЗаменить(Код, ТекТекст, "");
    КонецЕсли; 
    
    ТекТекст = "Shift+";
    Поз = СтрНайти(Код, ТекТекст);
    Если Поз > 0 Тогда
        Шифт = Истина;
        Код = СтрЗаменить(Код, ТекТекст, "");
    КонецЕсли; 
    
    ТекТекст = "Alt+";
    Поз = СтрНайти(Код, ТекТекст);
    Если Поз > 0 Тогда
        Алт = Истина;
        Код = СтрЗаменить(Код, ТекТекст, "");
    КонецЕсли;
    
    Клав = Новый Структура("Код", "");
    ЗаполнитьЗначенияСвойств(Клав, Клавиша);
    Клав = Клав.Код;
    //Попытка
    //  Клав = Клавиша[Код];
    //Исключение
    //  Клав = "";
    //КонецПопытки;
    //
    Если Клав <> "" Тогда
        Результат = Новый СочетаниеКлавиш(Клав, Алт, Ктрл, Шифт);
    КонецЕсли; 
    Возврат Результат
КонецФункции // СочетаниеКлавишПоСтроке()

// СтрЗаменить, но без учёта регистра
// Параметры:
//  ГдеМенять  - Строка - в котрой надо сделать замены, например, аБабА
//  ЧтоМенять  - Строка - которую надо найти и обезвредить, например, АБА
//  НаЧтоМенять  - Строка - Которая появится вместо искомой, например, АА
// Возвращаемое значение:
//   Строка   - с заменами, в примере - ААБА
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СтрЗаменитьБезУчётаРегистра(ГдеМенять, ЧтоМенять, НаЧтоМенять) Экспорт
    НачСтрока = ГдеМенять;
    Результат = "";
    ДлинаЧтоЗаменять = СтрДлина(ЧтоМенять);
    Пока Истина Цикл
        ПозВхождения = СтрНайти(ВРег(НачСтрока), ВРег(ЧтоМенять));
        Если ПозВхождения = 0 Тогда
            Результат = Результат + НачСтрока;
            Прервать;
        КонецЕсли;
        Результат = Результат + Лев(НачСтрока, ПозВхождения - 1) + НаЧтоМенять;
        НачСтрока = Сред(НачСтрока, ПозВхождения + ДлинаЧтоЗаменять);
    КонецЦикла; 
    Возврат Результат;
КонецФункции // СтрЗаменитьБезУчётаРегистра()

//Преобразует строку представления в имя переменной
//заменой строчных букв с пробелом на заглавные
// Параметры:
//  Строка_  - Произвольный - Любое значение, преобразуемое в строку = Исходная строка;
// Возвращаемое значение:
//   Строка   - Строка без запретных символов и с заменой " символ" на ВРег(символ)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СтрокуВИмяПеременной(Строка_) Экспорт
    Результат = "";
    Источник = Строка_;
    ТекДопустимые = СимволыГруппы("ДляПеременной1");
    ДопустимыеВсе = СимволыГруппы("ДляПеременнойВсе");
    ФлВРег = Истина;
    Для Ё = 1 По СтрДлина(Источник) Цикл
        ТекСимв = Сред(Источник, Ё, 1);
        Если СтрНайти(ТекДопустимые, ТекСимв) > 0 Тогда
            Результат = Результат + ?(ФлВРег, ВРег(ТекСимв), ТекСимв);
            ТекДопустимые = ДопустимыеВсе;
            ФлВРег = Ложь;
        Иначе
            ФлВРег = Истина;
        КонецЕсли;
    КонецЦикла; 
    Возврат Результат
КонецФункции

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-export-function-return-section
//@skip-check doc-comment-parameter-section
&НаКлиентеНаСервереБезКонтекста
Функция СтрРазделить_(ЧтоДелим, Разделитель = ",", ВключатьПустые = Истина) Экспорт
    Хрюква = "/°|°\";
    ХрюкваР = "/°-|-°\";
    ИзувеченнаяСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(ЧтоДелим, Разделитель, ХрюкваР), Символы.ПС, Хрюква), ХрюкваР, Символы.ПС);
    Результат = Новый Массив;
    Для Ё = 1 По СтрЧислоСтрок(ИзувеченнаяСтрока) Цикл
        ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(ИзувеченнаяСтрока, Ё), Хрюква, Символы.ПС);
        Если ВключатьПустые ИЛИ НЕ ПустаяСтрока(ТекЗнч) Тогда
            Результат.Добавить(ТекЗнч);
        КонецЕсли; 
    КонецЦикла; 
    Возврат Результат
КонецФункции // СтрРазделить()

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-export-function-return-section
//@skip-check doc-comment-parameter-section
&НаКлиентеНаСервереБезКонтекста
Функция СтрСоединить_(ЧтоСоединяем, Разделитель = ",") Экспорт
    Результат = "";
    Для Ё = 0 По ЧтоСоединяем.ВГраница() Цикл
        Результат = Результат + Разделитель + ЧтоСоединяем[Ё]; 
    КонецЦикла; 
    Возврат Сред(Результат, СтрДлина(Разделитель) + 1)
КонецФункции // СтрРазделить()

// Преобразует текст в строковый литерал
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: добавлены символы переноса, удвоены кавычки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция Текст_ЗапросаВКод(Текст_) Экспорт
    Возврат СтрЗаменить(СтрЗаменить(Текст_, Символы.ПС, Символы.ПС + "|"), """", """""")
КонецФункции // Текст_ЗапросаВКод
 
// Преобразует строковый литерал в текст (например, текст запроса из кода в чистый текст запроса)
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: удалены символы переноса, раздвоены кавычки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция Текст_КодаВЗапрос(Текст_) Экспорт
    Возврат СтрЗаменить(СтрЗаменить(Текст_, "|",  ""), """""", """")
КонецФункции // Текст_КодаВЗапрос

// Выделяет числа из строки									
// Параметры:									
//  Источник  - Строка - Где искать число									
//  Разделитель  - Массив из Строка, Строка - Символы	 прекращающие поиск цифр числа. #ВСЕ	 #НЕТ	 #НЕПУСТЫЕ или заданная строка или массив разделителей. 					
//  Знак  - Строка - Что делать со знаками минус и плюс.									
//			> #Везде						
//			> #ПередПустымИЧислом						
//			> #ПередЧислом						
// Возвращаемое значение:									
//   Массив из Число   - Найденное. Если ничего не найдено	 вернётся комплексное i (шутка	 ноль).							
&НаКлиентеНаСервереБезКонтекста
Функция ЧислаИзСтроки(Источник, Разделитель = "#НЕТ", Знак = "#ПередПустымИЧислом") Экспорт							
	Результат = Новый Массив;								
	Цифры = СимволыГруппы("Цифры");								
	Длина = СтрДлина(Источник);								
	ТекЧисло = "";								
	МРазделителей = ПреобразоватьВМассив(Разделитель);								
	Для СчЦ = 1 По Длина Цикл								
		ТекСимвол = Сред(Источник, СчЦ, 1);					
		Если СтрНайти(Цифры, ТекСимвол) > 0 Тогда						
			ТекЧисло = ТекЧисло + ТекСимвол;						
		Иначе							
			#Область ПОИСК_РАЗДЕЛИТЕЛЕЙ						
				Разделять = Ложь;					
				ДлинаРазделителяМинус1 = 0;					
				Если Разделитель = "#НЕТ" Тогда					
				ИначеЕсли Разделитель = "#ВСЕ" Тогда					
					Разделять = Истина;				
				ИначеЕсли Разделитель = "#НЕПУСТЫЕ" Тогда					
					Разделять = ЗначениеЗаполнено(ТекСимвол);				
				Иначе					
					Для каждого Стоп Из МРазделителей Цикл				
						Если СтрНайти(Источник, Стоп, СчЦ) = СчЦ Тогда
							Разделять = Истина;		
							ДлинаРазделителяМинус1 = СтрДлина(Стоп) - 1;		
							Прервать;		
						КонецЕсли;			
					КонецЦикла;				
				КонецЕсли;					
			#КонецОбласти						
			Если Разделять Тогда						
				#Область РАЗДЕЛЕНИЕ					
					Если ТекЧисло <> "" И ТекЧисло <> "-" И ТекЧисло <> "+" Тогда				
						Результат.Добавить(Число(ТекЧисло));			
					КонецЕсли;				
					ТекЧисло = "";				
					СчЦ = СчЦ + ДлинаРазделителяМинус1;				
				#КонецОбласти					
			ИначеЕсли (ТекСимвол = "-" ИЛИ ТекСимвол = "+") И ТекЧисло = "" Тогда						
				#Область МИНУСЫ					
					ТекЧисло = ТекЧисло + ТекСимвол;				
				#КонецОбласти					
			ИначеЕсли (ТекЧисло = "+" ИЛИ ТекЧисло = "-") И (ЗначениеЗаполнено(ТекСимвол) ИЛИ Знак <> "#ПередПустымИЧислом") И НЕ Знак = "#Везде" Тогда						
				ТекЧисло = "";					
			КонецЕсли;						
		КонецЕсли;							
	КонецЦикла;								
	Если ТекЧисло <> "" И ТекЧисло <> "-" И ТекЧисло <> "+" Тогда								
		Результат.Добавить(Число(ТекЧисло));							
	КонецЕсли;								
	Возврат Результат								
КонецФункции // ЧислоИзСтроки									
									
// Возвращает строку с разделителями без заданных элементов, например "Коля ,Вася , Галя", " Вася" = > "Коля,Галя"
// Лишние пробелы будут устранены.
// Параметры:
//  СтрокаСРазделителями- Произвольный - Любое значение, преобразуемое в строку = Исходная строка
//  УдаляемыеЭлементы   - Произвольный - Любое значение, преобразуемое в строку = удаляемые элементы с разделителями
//  Разделитель         - Произвольный - Любое значение, преобразуемое в строку = Разделитель, общий для СтрокаСРазделителями и УдаляемыеЭлементы
// Возвращаемое значение:
//  Строка   - строка с разделителями без указанных элементов
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция УдалитьЭлементыИзСтрокиСРазделителями(СтрокаСРазделителями, УдаляемыеЭлементы, Разделитель = ",") Экспорт
	Хрюква = СокрЛП(Новый УникальныйИдентификатор);
    ЧтоУдалять = СтрЗаменить(СтрЗаменить(УдаляемыеЭлементы, Символы.ПС, Хрюква), Разделитель, Символы.ПС);
    Результат = СокрЛП(ИскоренитьПодстроку(ИскоренитьПодстроку(СтрокаСРазделителями,
            " " + Разделитель, Разделитель), Разделитель + " ", Разделитель));
    Для Ё = 1 По СтрЧислоСтрок(ЧтоУдалять) Цикл
        ЧтоМенять = СтрЗаменить(СтрПолучитьСтроку(ЧтоУдалять, Ё), Хрюква, Символы.ПС);
        Результат = СтрЗаменить(Результат, ЧтоМенять + Разделитель, "");
        Результат = СтрЗаменить(Результат, Разделитель + ЧтоМенять, "");
        Если Результат = ЧтоМенять Тогда
            Результат = "";
        КонецЕсли; 
    КонецЦикла; 
    Возврат Результат
КонецФункции // УдалитьЭлементыИзСтрокиСРазделителями()

//Проверяет, подойдёт ли строчка для преобразования в УИД
// Параметры:
//  Строчка  - Произвольный - юбое значение, преобразуемое в строку = Проверяемая строка.
// Возвращаемое значение:
//   Булево   - Истина, если подходит для УИД. Считаются подходящими символами "-", 0-9, a-f, A-F.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоУИД(Строчка) Экспорт
    Возврат ПроверитьСтроку(НРег(Строчка), "[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]");
КонецФункции // ЭтоУИД()
 
#КонецОбласти

#Область 		ТАБЛИЧНЫЙ_ДОКУМЕНТ

// Устанавливает границу и заливку области табличного документа
// Параметры:
//  Область  - ОбластьЯчеекТабличногоДокумента - Редактируемые ячейки
//  Заливка  - Цвет - устанавливаемый цвет фона. По умолчанию Наопределено - не устанавливается
//  ЦветРамки  - Цвет - устанавливаемый цвет рамки. По умолчанию Наопределено - не устанавливается
//  ЛинииРамки  - Линия, структура - Линия уставнавливается для всех границ, Структура может содержать поля "Лево", "Право", "Верх", "Низ" и/или "ГраницаСверху", "ГраницаСлева", "ГраницаСнизу" или "ГраницаСправа"
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура ГраницыИЗаливка(Область, Заливка = Неопределено, ЦветРамки = Неопределено, ЛинииРамки = Неопределено) Экспорт
    Если Заливка <> Неопределено Тогда
        Область.ЦветФона = Заливка;
    КонецЕсли;
    Если ЦветРамки <> Неопределено Тогда
        Область.ЦветРамки = ЦветРамки;
    КонецЕсли;
    Если ЛинииРамки = Неопределено Тогда
    ИначеЕсли ТипЗнч(ЛинииРамки) = Тип("Линия") Тогда
        Область.ГраницаСверху = ЛинииРамки;
        Область.ГраницаСлева = ЛинииРамки;
        Область.ГраницаСнизу = ЛинииРамки;
        Область.ГраницаСправа = ЛинииРамки;
    Иначе
        ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСверху", ЧтСтрукт(ЛинииРамки, "Верх"));
        Если ТекЦвет <> Неопределено Тогда
            Область.ГраницаСверху = ТекЦвет;
        КонецЕсли;
        ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСправа", ЧтСтрукт(ЛинииРамки, "Право"));
        Если ТекЦвет <> Неопределено Тогда
            Область.ГраницаСправа = ТекЦвет;
        КонецЕсли;
        ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСнизу", ЧтСтрукт(ЛинииРамки, "Низ"));
        Если ТекЦвет <> Неопределено Тогда
            Область.ГраницаСнизу = ТекЦвет;
        КонецЕсли;
        ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСлева", ЧтСтрукт(ЛинииРамки, "Лево"));
        Если ТекЦвет <> Неопределено Тогда
            Область.ГраницаСлева = ТекЦвет;
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры // ГраницыИЗаливка

// Ищет в составе табличного документа дату (26 январь 2005 г, 27.07.2011, и т.д.) и возвращает её
// Параметры:
//  ТабДок  - ТабличныйДокумент - в котором ищется дата
//  ВернутьСтрокой  - Булево - Тип возвращаемого значения. Ложь (по умолчанию) - дата, иначе - строка.
//  НомерВхождения  - Число - Номер вхождения даты от начала документа. Чтение идёт построчно слева направо.
//  ВЗначениях  - Булево - Необходимость поиска в значениях ячеек.
//  ВТексте  - Булево - Необходимость поиска в текстах ячеек.
//  Форматы  - Массив из ЗНачениеXDTO - массив тестеров, сформированных функцией ЗначениеXDTOдляПроВеркиСтроки = Формат
//  		даты, только в этом формате будет искаться дата в тексте. По умолчанию - неопределено = в форматах
//  		 dd.mm.yyyy, dd month yyyy и month yyyy.
//  Верх  - Число - Верх области поиска, по умолчанию - 1
//  Низ  - Число - Низ области поиска, по умолчанию - нижняя строка ТД
//  Лево  - Число - Номер крайней левой колонки области поиска, по умолчанию - 1
//  Право  - Число - Номер крайней правой колонки области поиска, по умолчанию - правая колонка ТД
//  
// Возвращаемое значение:
//   Дата, Строка   - Найденная в документе дата. Пустая, если ничего не найдено. Если найдена строка, которую невозможно преобразовать в дату, вернётся строка, даже если указано вернуть дату.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ДатаИзТД(
		ТабДок,
		ВернутьСтрокой = Ложь,
		НомерВхождения = 1,
		ВЗначениях = Истина,
		ВТексте = Истина,
		Форматы = Неопределено,
		Знач Верх = 1,
		Знач Низ = 0,
		Знач Лево = 1,
		Знач Право = 0) Экспорт
    Результат = ?(ВернутьСтрокой, "", '00000000');
    //@skip-check server-execution-safe-mode
    СчётчикВхождений = НомерВхождения;
    Если Низ = 0 Тогда
        Низ = ТабДок.ВысотаТаблицы;
    КонецЕсли; 
    Если Право = 0 Тогда
        Право = ТабДок.ШиринаТаблицы;
    КонецЕсли; 
    Если Верх = 0 Тогда //Бесконечные области!!!
        Верх = 1;
    КонецЕсли; 
    Если Лево = 0 Тогда
        Лево = 1;
    КонецЕсли; 
    ЭтоТиповыеФорматы = Ложь;
    Если Форматы = Неопределено Тогда
        СтрокиФорматов = Новый Массив;
        СтрокиФорматов.Добавить(".*\d{2}\.\d{2}\.\d{4}.*");
        СтрокиФорматов.Добавить(".*\d{1,2}\s+((Я|я)нваря|(Ф|ф)евраля|(М|м)арта|(М|м)ая|(А|а)преля|(И|и)ю(н|л)я|(А|а)вгуста|(С|с)ентября|(О|о)ктября|(Н|н)оября|(Д|д)екабря)\s+\d{4}.*");
        СтрокиФорматов.Добавить(".*\s+((Я|я)нварь|(Ф|ф)евраль|(М|м)арт|(М|м)ай|(А|а)прель|(И|и)ю(н|л)ь|(А|а)вгуст|(С|с)ентябрь|(О|о)ктябрь|(Н|н)оябрь|(Д|д)екабрь)\s+\d{4}.*");
        Форматы = Новый Массив;
        //@skip-check module-unused-local-variable
        Для каждого СтрочкаФ Из СтрокиФорматов Цикл
            //@skip-check server-execution-safe-mode
            Форматы.Добавить(
					//СерверХЪ
					ЗначениеXDTOдляПроВеркиСтроки(СтрочкаФ));
        КонецЦикла; 
        ЭтоТиповыеФорматы = Истина;
    КонецЕсли;
    #Область ПОИСК
        Для СчСтр = Верх По Низ Цикл
            Найдена = Неопределено;
            Для СчКол = Лево По Право Цикл
                Ячейка = ТабДок.Область(СчСтр, СчКол);
                Если ВЗначениях И Ячейка.СодержитЗначение Тогда
                    Если ТипЗнч(Ячейка.Значение) = Тип("Дата") Тогда
                        Найдена = Ячейка.Значение;
                    КонецЕсли; 
                КонецЕсли;
                Если (Найдена = Неопределено) И ВТексте И НЕ Ячейка.СодержитЗначение Тогда
                    ТекТекст = Ячейка.Текст;
                    Для СчМ = 0 По Форматы.ВГраница() Цикл
                        Если ПроверитьСтроку(ТекТекст,, Форматы[СчМ]) Тогда
                            Найдена = СчМ;
                            Прервать;
                        КонецЕсли; 
                    КонецЦикла; 
                КонецЕсли; 
                Если Найдена <> Неопределено Тогда
                    СчётчикВхождений = СчётчикВхождений - 1;
                КонецЕсли; 
                Если СчётчикВхождений = 0 Тогда
                    СчСтр = Низ;
                    Прервать;
                КонецЕсли; 
            КонецЦикла; 
        КонецЦикла;
    #КонецОбласти 
    //Теперь в Найдена либо сама дата, либо номер формата, по которому найдена строка
    #Область ВЫДЕЛЕНИЕ_ДАТЫ_ИЗ_ДЛИННОЙ_СТРОКИ_И_ПРЕОБРАЗОВАНИЕ_ФОРМАТА
        Если Найдена <> Неопределено Тогда
            ЭтоЧисло = ТипЗнч(Найдена) = Тип("Число");
            Если ЭтоТиповыеФорматы и ЭтоЧисло Тогда
                //Попытка вытащить дату из текста.
                ФорматНачало =
						//ВыЗовСервераХЪ
						ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3));
                ФорматОк =
						//ВыЗовСервераХЪ
						ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3, СтрДлина(СтрочкаФ) - 4));
                ДлТхт = СтрДлина(ТекТекст);
                ВсёОк = Ложь;
                Для СчНач = 1 По ДлТхт Цикл
                    Если ПроверитьСтроку(Сред(ТекТекст, СчНач),, ФорматНачало) Тогда
                        ВсёОк = Истина;
                        Прервать;
                    КонецЕсли; 
                КонецЦикла;
                Если ВсёОк Тогда
                    ВсёОк = Ложь;
                    Для СчДл = 1 По ДлТхт - СчНач + 1 Цикл
                        ТекстВЦикле = Сред(ТекТекст, СчНач, СчДл);
                        Если ПроверитьСтроку(ТекстВЦикле,, ФорматОк) Тогда
                            ВсёОк = Истина;
                            Прервать;
                        КонецЕсли; 
                    КонецЦикла; 
                    Если ВсёОк Тогда
                        ТекТекст = ТекстВЦикле;
                    КонецЕсли; 
                КонецЕсли; 
                Если НЕ ВернутьСтрокой Тогда
                    //Попытка преобразовать в дату
                    ДатаХ = ДатаИзСтроки(ТекТекст, Истина);
                    Если ДатаХ <> Неопределено Тогда
                        Найдена = ДатаХ;
                        ЭтоЧисло = Ложь;
                    КонецЕсли; 
                КонецЕсли; 
            КонецЕсли;
            Если ВернутьСтрокой И НЕ ЭтоЧисло Тогда
                //Преобразование даты в строку
                ТекТекст = Формат(Найдена, "ДФ=dd.MM.yyyy");
                ЭтоЧисло = Истина;
            КонецЕсли;
            Если ЭтоЧисло Тогда
                Результат = ТекТекст;
            Иначе
                Результат = Найдена;
            КонецЕсли; 
        КонецЕсли;
    #КонецОбласти 
    Возврат Результат
КонецФункции // ДатаИзТД

// Выполняет замены текста в табличном документе
// Параметры:
//  ТабДок  - ТабличныйДокумент - в котором будут замены текста
//  Замены  - ТаблицаЗначений, Массив из Структура - с колонками ЧтоМенять и НаЧтоМенять
//  Верх  - Число - Верх изменяемой области, по умолчанию - 1
//  Низ  - Число - Низ изменяемой области, по умолчанию - нижняя строка ТД
//  Лево  - Число - Номер крайней левой колонки изменяемой области, по умолчанию - 1
//  Право  - Число - Номер крайней правой колонки изменяемой области, по умолчанию - правая колонка ТД
//  ИскатьПоСтрокам  - Булево - Параметр поиска. Истина (поумолчанию) = поиск сначала в стрке, потом в следующей, Ложь = поиск в колонке.
//  ЯчейкаЦеликом  - Булево - Параметр поиска. По умолчанию Ложь.
//  ИскатьВперед  - Булево - Параметр поиска. По умолчанию Истина.
//  ИгнорироватьРегистр  - Булево - Параметр поиска. По умолчанию Ложь.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Процедура ЗаменитьТекстыВТД(
		ТабДок,
		Замены,
		Знач Верх = 1,
		Знач Низ = 0,
		Знач Лево = 1,
		Знач Право = 0,
		ИскатьПоСтрокам = Истина,
		ЯчейкаЦеликом = Ложь,
		ИскатьВперед = Истина,
		ИгнорироватьРегистр = Ложь) Экспорт
    Если Низ = 0 Тогда
        Низ = ТабДок.ВысотаТаблицы;
    КонецЕсли; 
    Если Право = 0 Тогда
        Право = ТабДок.ШиринаТаблицы;
    КонецЕсли; 
    Если Верх = 0 Тогда //Бесконечные области!!!
        Верх = 1;
    КонецЕсли; 
    Если Лево = 0 Тогда
        Лево = 1;
    КонецЕсли;
    #Область НОВЫЙ_ВАРИАНТ
        Обыскиваемая = ТабДок.Область(Верх, Лево, Низ, Право);
        Начало = Неопределено;//ТабДок.Область(Верх, Лево);
        БылТП = ТабДок.ТолькоПросмотр;
        Для каждого СтрЗамен Из Замены Цикл
            НачалоПоЗамене = Начало;
            Пока Истина Цикл
                НачалоПоЗамене = ТабДок.НайтиТекст(СтрЗамен.ЧтоМенять, НачалоПоЗамене, Обыскиваемая, ИскатьПоСтрокам, ЯчейкаЦеликом, ИскатьВперед, ИгнорироватьРегистр);
                Если НачалоПоЗамене = Неопределено Тогда
                    Прервать
                КонецЕсли;
                НачалоПоЗамене.Текст = СтрЗаменить(НачалоПоЗамене.Текст, СтрЗамен.ЧтоМенять, СтрЗамен.НаЧтоМенять);
            КонецЦикла;
        КонецЦикла;
        Если БылТП Тогда
            ТабДок.ТолькоПросмотр = Истина;
        КонецЕсли; 
    #КонецОбласти 
КонецПроцедуры // ЗаменитьТекстыВТД

//Возвращает реквизиты табличного документа, доступные для записи
// Параметры:
//	Группа - Строка -
//		>Копируемые (по умолчанию) - реквизиты, которые имеет смысл копировать при создании копии ТД.
//		>Изменяемые - прочие изменяемые, не входящие в Копируемые
//		>Фикс - только чтение
//Возвращаемое значение:
//	Строка - список через запятую реквизитов ТД, доступных для записи. Для использования в ЗаполнитьЗначенияСвойств.
//@skip-check export-method-in-command-form-module
//@skip-check module-region-empty
&НаКлиентеНаСервереБезКонтекста
Функция ИзменяемыеРеквизитыТД(Группа = "Копируемые") Экспорт
	#Область ОПИСАНИЕ
	    //В УП было:
	    //	АвтоМасштаб,Вывод,ДвусторонняяПечать,Защита,ИмяПараметровПечати,ИмяПринтера,ИспользуемоеИмяФайла,
	    //	КоличествоЭкземпляров,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	    //	ОтображатьСетку,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,
	    //	РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,
	    //	ЧерноБелаяПечать,ЧерноБелыйПросмотр,ЭкземпляровНаСтранице
	    //Копируются:
	    //АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,ИмяПараметровПечати,КлючПараметровПечати,КлючСохраненияПоложенияОкна,
	    //  КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	    //  ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,
	    //  РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,
	    //  ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы.
	    //НЕ копируются:
	    //	ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы.
	    //Преднамеренно НЕ копируются:
	    //	ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть.
	#КонецОбласти
    Если Группа = "Фикс" Тогда
    	Результат = "ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы";
    ИначеЕсли Группа = "Изменяемые" Тогда
    	Результат = "ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть"; 	
    Иначе
		//!ИмяПараметровПечати (оно же КлючПараметровПечати) обязательно первым!
        Результат = "ИмяПараметровПечати,АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,КлючПараметровПечати,КлючСохраненияПоложенияОкна,";
	    Результат = Результат + "КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,";
	    Результат = Результат + "ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,";
	    Результат = Результат + "ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы";
    КонецЕсли;
    Возврат Результат
КонецФункции // РеквизитыНастроекТД()

// Возвращает строку и столбец первой ячейки со значением или текстом
// Параметры:
//  ТаблДокумент  - ТабличныйДокумент - В котором ищем
//  МетодПоиска  - Строка - "ПоКолнкам" (по умолчанию), "ПоСтрокам" или "Радиально"
//  Строк  - Число - Сколько строк проверять. По умолчанию 10.
//  Колонок  - Число - Сколько колонок проверять. По умолчанию 10.
//  НачСтрока  - Число - С какой строки табдокумента проверять. По умолчанию 1.
//  НачКолонка  - Число - С какой колонки табдокумента проверять. По умолчанию 1.
// Возвращаемое значение:
//   Структура   - Ключи Строка,Колонка,Значение,Текст
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ПерваяЯчейка(ТаблДокумент, МетодПоиска = "ПоКолонкам", Строк = 10, Колонок = 10, НачСтрока = 1, НачКолонка = 1) Экспорт
    //@skip-check structure-consructor-too-many-keys
    Результат = Новый Структура("Строка,Колонка,Текст,Значение", 0);
    ЭтоРадиально = МетодПоиска = "Радиально";
    ЭтоНеПоКолонкам = МетодПоиска = "ПоСтрокам" ИЛИ ЭтоРадиально;
    Ширина = ?(Колонок = 0, ТаблДокумент.ШиринаСтраницы - НачКолонка + 1, Колонок);
    Высота = ?(Строк = 0, ТаблДокумент.ВысотаСтраницы - НачСтрока + 1, Строк);
    КонРадиус = Макс(Ширина, Высота); //если по строкам - высота
    НачРадиус = ?(ЭтоНеПоКолонкам, 1, КонРадиус);
    Для Радиус = НачРадиус По КонРадиус Цикл
        КонКол = ?(ЭтоРадиально, Мин(Ширина, Радиус), Ширина);
        Для НомКол = НачКолонка По КонКол + НачКолонка - 1 Цикл
            Если ЭтоНеПоКолонкам И НЕ (ЭтоРадиально И НомКол = Радиус) Тогда
                НачСтр = Радиус + НачСтрока - 1;
                КонСтр = НачСтр;
            Иначе
                НачСтр = НачСтрока;
                КонСтр = Высота + НачСтрока - 1;
            КонецЕсли;
            Для НомСтр = НачСтр По КонСтр Цикл
                ТекОбласть = ТаблДокумент.Область(НомСтр, НомКол);
                ТекТекст = ТекОбласть.Текст;
                ТекЗнч = ?(ТекОбласть.СодержитЗначение, ТекОбласть.Значение, Неопределено);
                Если ЗначениеЗаполнено(ТекТекст) ИЛИ ЗначениеЗаполнено(ТекЗнч) Тогда
                    Результат.Вставить("Строка", НомСтр);
                    Результат.Вставить("Колонка", НомКол);
                    Результат.Вставить("Текст", ТекТекст);
                    Результат.Вставить("Значение", ТекЗнч);
                    Возврат Результат;
                КонецЕсли;
            КонецЦикла;
        КонецЦикла;
    КонецЦикла;
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // ПерваяЯчейка

//Получает значение из области в структуру или иной аналогичный объект. Не распознаёт ссылки, из строк убирает одиночный апостроф.
//Параметры:
//  Приёмник            - Структура - Объект-приёмник
//  РеквизитПриёмника   - Строка - Имя реквизита, куда будет помещено значение
//  Источник            - ТабличныйДокумент - Откуда будет считано значение
//  НомерСтроки         - Число - Номер строки ячейки, из которой будет считано значение
//  НомерКолонки        - Число - Номер колонки ячейки, из которой будет считано значение. Для 0 возвращаются значения по умолчанию.
//  ТипДанных           - Строка - Тип данных, к оторому будет приведено значение (Булево/Строка/Число/Дата)
//  
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Процедура ПолучитьИзОбласти(
		Приёмник,
		РеквизитПриёмника,
		Источник,
		НомерСтроки,
		НомерКолонки,
		ТипДанных = "Строка") Экспорт
    ТДата =
			//ВызовСервераХЪ
			ВыполнитьКодНаСервере("ТекущаяДатаСеанса()",,, Истина);
    Если НомерКолонки = 0 Тогда
        Если ТипДанных = "Строка" Тогда
            Приёмник[РеквизитПриёмника] = "";
        ИначеЕсли ТипДанных = "Число" Тогда
            Приёмник[РеквизитПриёмника] = 0;
        ИначеЕсли ТипДанных = "Дата" Тогда
            Приёмник[РеквизитПриёмника] = ТДата;
        Иначе //Булево
            Приёмник[РеквизитПриёмника] = Ложь;
        КонецЕсли; 
    Иначе
        ТекОбласть = Источник.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
        НадоПриводитьКФормату = НЕ ТекОбласть.СодержитЗначение;
        Если НадоПриводитьКФормату И (ТипДанных <> "Строка") Тогда
            ТекстОбласти = ТекОбласть.Текст;
            Если ТипДанных = "Дата" Тогда
                //Из форматов "1.3.75" и "750301"
                ТекСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекстОбласти,
                        ".", Символы.ПС), "/", Символы.ПС), "-", Символы.ПС), "\", Символы.ПС), " ", Символы.ПС), ":", Символы.ПС);
                Если СтрЧислоСтрок(ТекСтрока) = 1 Тогда
                    Век = Лев(ТекСтрока, 2);
                    Если (Век <> "19") ИЛИ (Век <> "20") Тогда
                        ТекСтрока = "20" + ТекСтрока;
                    КонецЕсли; 
                    Попытка
                        НовоеЗначение = Дата(Число(Лев(ТекСтрока, 4)), Число(Сред(ТекСтрока, 5, 2)), Число(Сред(ТекСтрока, 7, 2)), Число(Сред(ТекСтрока, 9, 2)), Число(Сред(ТекСтрока, 11, 2)), Число(Прав(ТекСтрока, 2)));
                    Исключение
                        НовоеЗначение = ТДата;
                    КонецПопытки;
                Иначе
                    Попытка
                        ТГод = СтрПолучитьСтроку(ТекСтрока, 3);
                        Если ТГод = "" Тогда
                            ТГод = "0"
                        ИначеЕсли СтрДлина(ТГод) = 2 Тогда
                            ТГод = "20" + ТГод;
                        КонецЕсли; 
                        НовоеЗначение = Дата(Число(ТГод),
                                Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 2), "", "0")),
                                Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 1), "", "0")),
                                Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 4), "", "0")),
                                Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 5), "", "0")),
                                Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 6), "", "0")));
                    Исключение
                        НовоеЗначение = ТДата;
                    КонецПопытки;
                КонецЕсли; 
            ИначеЕсли ТипДанных = "Булево" Тогда
                ВРег_ = ВРЕГ(ТекстОбласти);
                НовоеЗначение = НЕ ((ВРег_ = "ЛОЖЬ") ИЛИ (ВРег_ = "НЕТ") ИЛИ ПустаяСтрока(ВРег_) ИЛИ (ВРег_ = "0"));
            Иначе //Число
                Попытка
                    НовоеЗначение = Число(ТекстОбласти);
                Исключение
                    НовоеЗначение = 0;
                КонецПопытки;
            КонецЕсли;
            Приёмник[РеквизитПриёмника] = НовоеЗначение;
        Иначе
            Приёмник[РеквизитПриёмника] = ?(НадоПриводитьКФормату, ТекОбласть.Текст, ТекОбласть.Значение);
        КонецЕсли; 
        Если ТипЗнч(Приёмник[РеквизитПриёмника]) = Тип("Строка") Тогда
            Приёмник[РеквизитПриёмника] = СокрЛП(Приёмник[РеквизитПриёмника]);
            Если Лев(Приёмник[РеквизитПриёмника], 1) = "'" Тогда
                Приёмник[РеквизитПриёмника] = Сред(Приёмник[РеквизитПриёмника], 2);
            КонецЕсли; 
        КонецЕсли; 
    КонецЕсли; 
КонецПроцедуры

// Копирует параметры документа - источника в документ-приёмник. При отсутствии приёмника создаётся новый документ.
// Параметры:
//  Приёмник  - ТабличныйДокумент - тот, в который будут скопированы параметры
//  Источник  - ТабличныйДокумент - или иной объект = тот, из которого будут скопированы параметры
//  ИсключаемыеСвойства  - Строка - Список свойств через запятую, которые не будут копироваться
// Возвращаемое значение:
//   ТабличныйДокумент   - Приёмник с параметрами источника
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция СкопироватьПараметрыТД(Приёмник = Неопределено, Источник, ИсключаемыеСвойства = "") Экспорт
    Результат = ?(Приёмник = Неопределено, Новый ТабличныйДокумент, Приёмник);
    Копируемые = ИзменяемыеРеквизитыТД();
    КПередаче = УдалитьЭлементыИзСтрокиСРазделителями(Копируемые, ИсключаемыеСвойства);
    ЕстьИПП = СтрНайти(КПередаче, "ИмяПараметровПечати") > 0 ИЛИ СтрНайти(КПередаче, "КлючПараметровПечати") > 0;
    КПередаче = УдалитьЭлементыИзСтрокиСРазделителями(Копируемые, "ИмяПараметровПечати,КлючПараметровПечати");
    ТМПСтр = Новый Структура(Копируемые);//Чтобы отсеять реквизиты, кроме указанных
    ЗаполнитьЗначенияСвойств(ТМПСтр, Результат);
    Если ИсключаемыеСвойства = "" Тогда
        ЗаполнитьЗначенияСвойств(ТМПСтр, Источник);
    Иначе
        ЗаполнитьЗначенияСвойств(ТМПСтр, Источник,, ИсключаемыеСвойства);
    КонецЕсли;
    Если ЕстьИПП Тогда
    	Результат.КлючПараметровПечати = Источник.КлючПараметровПечати; 
    КонецЕсли;
    //ПРОВЕРИТЬ!!!!ИмяПараметровПечати всё перезатирает!
    ЗаполнитьЗначенияСвойств(Результат, Источник, КПередаче);
    Возврат Результат
КонецФункции // СкопироватьПараметрыТД
 
// Возвращает список областей табличного документа
// Параметры:
//  ТабДок  - ТабличныйДокумент - имена областей которого будут выведены в список
//  СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
// Возвращаемое значение:
//   Массив из Строка   - Список областей ТД
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
&НаКлиентеНаСервереБезКонтекста
Функция СписокОбластейТД(ТабДок) Экспорт
    Результат = Новый Массив;
    Для каждого Область Из ТабДок.Области Цикл
        Результат.Добавить(Область.Имя);
    КонецЦикла; 
    Возврат Результат
КонецФункции // СписокОбластейТД

#КонецОбласти 

#Область 		ТИПЫ

//Создаёт "суммарное" описание типов из двух
//Параметры:
//  ОТ1 - ОписаниеТипов - слагаемое
//  ОТ2 - ОписаниеТипов - слагаемое
//Возвращаемое значение:
//  ОписаниеТипов - сумма
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ОбъединитьОписанияТипов(ОТ1, ОТ2) Экспорт
    ТипОТ = Тип("ОписаниеТипов");
    ОТ_Итог = Новый ОписаниеТипов;
    Если ТипЗнч(ОТ1) = ТипОТ Тогда
        Если ТипЗнч(ОТ2) = ТипОТ Тогда
            //ОТ2 = Новый ОписаниеТипов;
            //ОТ1 = Новый ОписаниеТипов;
            Менять = Ложь;
            Если ОТ1.КвалификаторыДаты.ЧастиДаты <> ОТ2.КвалификаторыДаты.ЧастиДаты Тогда
                КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
                Менять = Истина
            Иначе
                КвалификаторДаты = ОТ1.КвалификаторыДаты
            КонецЕсли;
            МенятьПрм1 = ОТ2.КвалификаторыДвоичныхДанных.Длина > ОТ1.КвалификаторыДвоичныхДанных.Длина;
            Размер = ?(МенятьПрм1, ОТ2.КвалификаторыДвоичныхДанных.Длина, ОТ1.КвалификаторыДвоичныхДанных.Длина);
            МенятьПрм2 = ((ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная) И НЕ (ОТ1.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная));
            МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
            Менять = Менять Или МенятьКвалификатор;
            Если МенятьКвалификатор Тогда
                КвалификаторДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Размер, ?(МенятьПрм2 или (ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная), ДопустимаяДлина.Переменная, ДопустимаяДлина.Фиксированная))
            Иначе
                КвалификаторДвоичныхДанных = ОТ1.КвалификаторыДвоичныхДанных
            КонецЕсли;
            МенятьПрм1 = ОТ2.КвалификаторыСтроки.Длина > ОТ1.КвалификаторыСтроки.Длина;
            Размер = ?(МенятьПрм1, ОТ2.КвалификаторыСтроки.Длина, ОТ1.КвалификаторыСтроки.Длина);
            МенятьПрм2 = ((ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная)
                    И НЕ (ОТ1.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная))
                    ИЛИ (ОТ2.КвалификаторыСтроки.Длина <> ОТ1.КвалификаторыСтроки.Длина);
            МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
            Менять = Менять Или МенятьКвалификатор;
            Если МенятьКвалификатор Тогда
                КвалификаторСтроки = Новый КвалификаторыСтроки(Размер,
                        ?(МенятьПрм2 или (ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная),
                            ДопустимаяДлина.Переменная,
                            ДопустимаяДлина.Фиксированная))
            Иначе
                КвалификаторСтроки = ОТ1.КвалификаторыСтроки
            КонецЕсли;
            МенятьПрм1 = ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
            МенятьПрм2 = ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
            ЗнакОТ2аЛюбой = (ОТ2.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
            ЗнакОТ1аЛюбой = (ОТ1.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
            МенятьКвалификатор = МенятьПрм1 или МенятьПрм2 или (ЗнакОТ2аЛюбой и НЕ ЗнакОТ1аЛюбой);
            Менять = Менять Или МенятьКвалификатор;
            Если МенятьКвалификатор Тогда
                РДЧ =?(МенятьПрм2, ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти, ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти); 
                КвалификаторЧисла = Новый КвалификаторыЧисла(
                        ?(МенятьПрм1, ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти,
                            ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти) + РДЧ,
                        РДЧ,
                        ?(ЗнакОТ2аЛюбой Или ЗнакОТ1аЛюбой, ДопустимыйЗнак.Любой, ДопустимыйЗнак.Неотрицательный))
            Иначе
                КвалификаторЧисла = ОТ1.КвалификаторыЧисла
            КонецЕсли;
            Типы = ОТ1.Типы();
            Для каждого Тип из ОТ2.Типы() Цикл
                Если Типы.Найти(Тип) = Неопределено Тогда
                    Менять = Истина;
                    Типы.Добавить(Тип)
                КонецЕсли
            КонецЦикла;
            Если Менять Тогда
                ОТ_Итог = Новый ОписаниеТипов(Типы, КвалификаторЧисла, КвалификаторСтроки, КвалификаторДаты, КвалификаторДвоичныхДанных)
            Иначе
                ОТ_Итог = ОТ1
            КонецЕсли
        Иначе
            ОТ_Итог = ОТ1;
        КонецЕсли;
    ИначеЕсли ТипЗнч(ОТ2) = ТипОТ Тогда
        ОТ_Итог = ОТ2;
    КонецЕсли;
    Возврат ОТ_Итог
КонецФункции //ОбъединитьОписанияТипов (ПодключитьОписаниеТипов)

//Возвращает объединённое описание типов всех значений коллекции
//Параметры:
//  Коллекция - Произвольный - коллекция, по элементам которой будет формироваться описание типов
//Возвращаемое значение:
//  ОписаниеТипов - сумма
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеТиповКоллекции(Коллекция) Экспорт
    Если Коллекция.Количество() = 0 Тогда
        Возврат ПолучитьОписаниеТипаЗначения(Неопределено)
    Иначе
        Результат = Неопределено;
        Для каждого Единица из Коллекция Цикл
            Результат = ОбъединитьОписанияТипов(Результат, ПолучитьОписаниеТипаЗначения(Единица))
        КонецЦикла;
        Возврат Результат
    КонецЕсли
КонецФункции

//Определяет ширину колонки для отображения типа. Для типов неопределённой длины берётся ширина 50.
//Ссылку пока ловит по представлению пустого, но правильнее, наверное, брать длину представления = это не сделано.
//Параметры:
//  Описание_Типов - ОписаниеТипов - для которого требуется определить ширину колонки
//Возвращаемое значение:
//  Число - Ширина колонки
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ОпределитьШиринуКолонкиПоТипу(Описание_Типов) Экспорт
    Если Описание_Типов.КвалификаторыДаты = Неопределено Тогда
        Результат = 0
    ИначеЕсли Описание_Типов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
        Результат = 8
    ИначеЕсли Описание_Типов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
        Результат = 10
    ИначеЕсли Описание_Типов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.ДатаВремя Тогда
        Результат = 19
    Иначе
        Результат = 0
    КонецЕсли;
    Если Описание_Типов.КвалификаторыДвоичныхДанных = Неопределено   Тогда
        Ширина_ = 0
    Иначе
        Ширина_ = Описание_Типов.КвалификаторыДвоичныхДанных.Длина;
        Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
            Ширина_ = 50
        КонецЕсли
    КонецЕсли;
    Результат = ?(Результат < Ширина_, Ширина_, Результат);
    Если Описание_Типов.КвалификаторыСтроки = Неопределено   Тогда
        Ширина_ = 0
    Иначе
        Ширина_ = Описание_Типов.КвалификаторыСтроки.Длина;
        Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
            Ширина_ = 50
        КонецЕсли
    КонецЕсли;
    Результат = ?(Результат < Ширина_, Ширина_, Результат);
    Если Описание_Типов.КвалификаторыЧисла = Неопределено    Тогда
        Ширина_ = 0
    Иначе
        Ширина_ = Описание_Типов.КвалификаторыЧисла.Разрядность;
        Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
            Ширина_ = 50
        КонецЕсли
    КонецЕсли;
    Результат = ?(Результат < Ширина_, Ширина_, Результат);
    Для каждого Тип из Описание_Типов.Типы() Цикл
        Если Строка(Тип) = "Булево" Тогда
            Ширина_ = 2
        ИначеЕсли Строка(Тип) = "Null" Тогда
            Ширина_ = 4
        ИначеЕсли Строка(Тип) = "Неопределено" Тогда
            Ширина_ = 1
        ИначеЕсли Строка(Тип) = "Число" Тогда
            Ширина_ = 10
        ИначеЕсли Строка(Тип) = "Строка" Тогда
            Ширина_ = 10
        ИначеЕсли Строка(Тип) = "Дата" Тогда
            Ширина_ = 10
        ИначеЕсли Строка(Тип) = "Тип" Тогда
            Ширина_ = 24
        Иначе
            Ширина_ = СтрДлина(Строка(Новый(Тип)))
        КонецЕсли;
        Результат = ?(Результат < Ширина_, Ширина_, Результат)
    КонецЦикла;
    Возврат Результат
КонецФункции //ОпределитьШиринуКолонкиПоТипу

//Определяет тип значения и формирует описание типа по нему.
//Параметры:
//  Значение_ - Произвольный - по которому надо сформировать ОписаниеТипа
//Возвращаемое значение:
//  ОписаниеТипов - которому принадлежит заданное значение
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьОписаниеТипаЗначения(Значение_) Экспорт
    Тип_ = ТипЗнч(Значение_);
    МассивТипов = Новый Массив;
    МассивТипов.Добавить(Тип_);
    Если Тип_ = Тип("Число") Тогда
        //Определить квалификатор числа
        ДоЗапятой = Макс(1, 1 + Цел(Log10(?(Значение_ > 0, Значение_, ?(Значение_ < 0, -Значение_, 1)))));
        ПослеЗапятой = СтрДлина(Значение_ - Цел(Значение_)) - 2;
        //Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
        Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой + ПослеЗапятой + 1, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
        Возврат Новый ОписаниеТипов(МассивТипов, Квалификатор_)
    ИначеЕсли Тип_ = Тип("Строка") Тогда
        //Определить квалификатор строки
        //Квалификатор_ = Новый КвалификаторыСтроки(СтрДлина(Значение_), ДопустимаяДлина.Фиксированная);
        ТекДлина = СтрДлина(Значение_);
        Квалификатор_ = Новый КвалификаторыСтроки(?(ТекДлина = 0, 1, ТекДлина), ДопустимаяДлина.Фиксированная); //Чтобы нулевая длина не стала неограниченной
        Возврат Новый ОписаниеТипов(МассивТипов, , Квалификатор_)
    ИначеЕсли Тип_ = Тип("Дата") Тогда
        //Определить квалификатор даты
        Квалификатор_ = Новый КвалификаторыДаты(?((Час(Значение_) = 0) И (Минута(Значение_) = 0) И (Секунда(Значение_) = 0), ЧастиДаты.Дата,
                ?((Год(Значение_) = 0) И (Месяц(Значение_) = 0) И (День(Значение_) = 0), ЧастиДаты.Время, ЧастиДаты.ДатаВремя)));
        Возврат Новый ОписаниеТипов(МассивТипов, , , Квалификатор_)
    ИначеЕсли Тип_ = Тип("ДвоичныеДанные") Тогда
        //Определить квалификатор двоичных данных
        Квалификатор_ = Новый КвалификаторыДвоичныхДанных(Значение_.Размер(), ДопустимаяДлина.Переменная);
        Возврат Новый ОписаниеТипов(МассивТипов, , , , Квалификатор_)
    Иначе
        Возврат Новый ОписаниеТипов(МассивТипов)
    КонецЕсли
КонецФункции

//Получает пустую ссылку по строке типа (результату метода ПолноеИмя)
//Параметры:
//    ТипОбъекта - Строка - полное имя метаданных
//Возвращаемое значение:
//    ЛюбаяСсылка - Пустая ссылка метаданных
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьПустуюСсылкуТипа(ТипОбъекта) Экспорт
    СтрокаСсылки = СтрЗаменить(ТипОбъекта, ".", "Ссылка.");
    Возврат Новый(Тип(СтрокаСсылки)) 
КонецФункции //ПолучитьПустуюСсылкуТипа

// Возвращает примерное значение указанного типа. Для строки, даты  и числа это будет значение указанной квалификации, состоящее из единиц,
//      для ссылки - пустая ссылка, для остальных = приведение единицы к описанию типа.
// Параметры:
//  Источник  - Тип - Значение которого надо получить
//  КвалификаторЧисла  - КвалификаторыЧисла - Квалификатор типа
//  КвалификаторСтроки  - КвалификаторыСтроки - Квалификатор типа
//  КвалификаторДаты  - КвалификаторыДаты - Квалификатор типа
//  Строкой  - Булево - Представить значение в виде строки для текста запроса
// Возвращаемое значение:
//  Произвольный   - Примерное значение указанного типа
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ПримерноеЗначение(Источник, КвалификаторЧисла = "", КвалификаторСтроки = "", КвалификаторДаты = "", Строкой = Истина) Экспорт
    Результат = Новый Соответствие;
    Если Источник = Тип("Число") Тогда
        Если КвалификаторЧисла = "" ИЛИ КвалификаторЧисла.Разрядность = 0 Тогда
            Результат = 1;
        Иначе
            Результат = 0;
            Исходная = 1;
            Для ЁХ = 1 По КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
                Исходная = Исходная / 10;
                Результат = Результат + Исходная;
            КонецЦикла;
            Исходная = 1;
            Для ЁХ = 1 По КвалификаторЧисла.Разрядность - КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
                Результат = Результат + Исходная;
                Исходная = Исходная * 10;
            КонецЦикла;
            Если КвалификаторЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой Тогда
                Результат = - Результат;
            КонецЕсли;
        КонецЕсли;
        Если Строкой Тогда
            Результат = СтрЗаменить(ФОРМАТ(Результат, "ЧГ=0"), ",", ".");
        КонецЕсли;
    ИначеЕсли Источник = Тип("Булево") Тогда
        Если Строкой Тогда
            Результат = "ИСТИНА";
        Иначе
            Результат = Истина;
        КонецЕсли;
    ИначеЕсли Источник = Тип("Строка") Тогда
        Результат = "";
        Если КвалификаторСтроки <> "" Тогда
            Для ЁХ = 1 По КвалификаторСтроки.Длина Цикл
                Результат = Результат + "1";
            КонецЦикла;
        КонецЕсли;
        Если Строкой Тогда
            Результат = """" + Результат + """";
        КонецЕсли;
    ИначеЕсли Источник = Тип("Дата") ИЛИ Источник = Тип("СтандартнаяДатаНачала") ИЛИ Источник = Тип("СтандартныйПериод") Тогда
        Результат = '11111111111111';
        МТипов = Новый Массив;
        МТипов.Добавить(Тип("Дата"));
        ТекОТ = ?(КвалификаторСтроки = "", Новый ОписаниеТипов(МТипов), Новый ОписаниеТипов(МТипов,,, КвалификаторДаты));
        ИсхДата = ТекОТ.ПривестиЗначение(Результат);
        Если Источник = Тип("СтандартнаяДатаНачала") Тогда
            Результат = Новый СтандартнаяДатаНачала;
            Результат.Дата = ИсхДата;
            Если Строкой Тогда
                Результат = Неопределено;
            КонецЕсли;
        ИначеЕсли Источник = Тип("СтандартныйПериод") Тогда
            Результат = Новый СтандартныйПериод;
            Результат.ДатаНачала = ИсхДата;
            Результат.ДатаОкончания = ИсхДата;
            Если Строкой Тогда
                Результат = Неопределено;
            КонецЕсли;
        Иначе
            Результат = ИсхДата;
            Если Строкой Тогда
                ТекГод = Год(Результат);
                ТекМес = Месяц(Результат);
                ТекДень = День(Результат);
                ТекЧас = Час(Результат);
                ТекМин = Минута(Результат);
                ТекСек = Секунда(Результат);
                Результат = "ДАТАВРЕМЯ("
                        + ?(ТекГод = 0, 1, Формат(ТекГод, "ЧГ=0")) + "," +
                        + ?(ТекМес = 0, 1, ТекМес) + "," +
                        + ?(ТекДень = 0, 1, ТекДень) + "," +
                        + ?(ТекЧас = 0, 1, ТекЧас) + "," +
                        + ?(ТекМин = 0, 1, ТекМин) + "," +
                        + ?(ТекСек = 0, 1, ТекСек) + ")";
            КонецЕсли;
        КонецЕсли;
    Иначе
        Если Строкой Тогда
        	//@skip-check server-execution-safe-mode
            Результат =
            		//ВызовСервераХЪ
            		ИмяТаблицыОбъектаПоТипу(Источник);
            Если Результат = Неопределено Тогда
                Результат = "НЕОПРЕДЕЛЕНО";
            Иначе
                Результат = "ЗНАЧЕНИЕ(" + Результат + ".ПустаяСсылка)"
            КонецЕсли;
        Иначе
            мТипов = Новый Массив;
            мТипов.Добавить(Источник);
            ТекОТ = Новый ОписаниеТипов(мТипов);
            Результат = ТекОТ.ПривестиЗначение(1);
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // ПримерноеЗначение

// Разбивает массив на несколько массивов однотипных значений, помещаемых в Соответствие
// Параметры:
//  ИсходныйМассив  - Массив из Произвольный - Массив разнотипных объектов
// Возвращаемое значение:
//   Соответствие из Тип  - ключи = типы, значения = массивы однотипных значений
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция РазбитьПоТипам(ИсходныйМассив) Экспорт
    СоответствиеТипов = Новый Соответствие;
    Если ТипЗнч(ИсходныйМассив) = Тип("Массив") Тогда
        Для каждого Док Из ИсходныйМассив Цикл
            ТекТип = ТипЗнч(Док);
            Если СоответствиеТипов[ТекТип] = Неопределено Тогда
                СоответствиеТипов.Вставить(ТекТип, Новый Массив);
            КонецЕсли;
            СоответствиеТипов[ТекТип].Добавить(Док);
        КонецЦикла;
    Иначе
        СоответствиеТипов.Вставить(ТипЗнч(ИсходныйМассив), ПреобразоватьВМассив(ИсходныйМассив));
    КонецЕсли;
    Возврат СоответствиеТипов;
КонецФункции // РазбитьПоТипам()

//Возвращает булево, равен ли тип значения обозначенному строкой.
//Параметры:
//   Значение - Произвольный - проверяемое значение
//   СтрокаОбозначенияТипа - Строка - строковое обозначение типа, например, СправочникСсылка.Банки
//Возвращаемое значение:
//   Булево - Истина = тип значения совпадает с типом, полученным по строке
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ТипРавен(Значение, СтрокаОбозначенияТипа) Экспорт
    Результат = Ложь;
    //@skip-check empty-except-statement
    Попытка
        Результат = ТипЗнч(Значение) = Тип(СтрокаОбозначенияТипа)
    Исключение
    КонецПопытки;
    Возврат Результат
КонецФункции //ТипРавен

#КонецОбласти

#Область 		УПРАВЛЯЕМАЯ_ФОРМА

// Находит первую строку по структуре (Аналогично НайтиСтроку) в ДанныеФормыДерево
// Параметры:
//  ДФД  - ДанныеФормыДерево - Где искать
//  Критерии - Структура - Отбор поиска, аналогично НайтиСтроки
// Возвращаемое значение:
//   Число   - Идентификатор найденной строки. 0, если не найдена.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция НайтиВ_ДФД(ДФД, Критерии) Экспорт
    Результат = 0;
    Для каждого СтрокаДЗ Из ДФД.ПолучитьЭлементы() Цикл
        Совпали = Истина;
        Для каждого КиЗ Из Критерии Цикл
            Если КиЗ.Значение <> СтрокаДЗ[КиЗ.Ключ] Тогда
                Совпали = Ложь;
                Прервать;
            КонецЕсли;
        КонецЦикла;
        Если Совпали Тогда
            Результат = СтрокаДЗ.ПолучитьИдентификатор();
            Прервать;
        Иначе
            Результат = НайтиВ_ДФД(СтрокаДЗ.Строки, Критерии);
            Если Результат > 0 Тогда
                Прервать;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // НайтиВ_ДФД

// Устанавливает флаг в таблице формы в нужное значение
// Параметры:
//  Форма  - ФормаКлиентскогоПриложения - Форма, где меняются флаги
//  ТаблицаФормы_  - ТаблицаФормы - содержащая изменяемую колонку
//  ИмяПоля - Строка - на клиенте - путь к данным;
//          на сервере - список полей через запятую. Изменяется текущее, если оно в списке или список пуст.
//          Если текущее не найдено в списке - изменяется первое, если оно задано. По умолчанию "Пометка"
//  НовоеЗначение - Булево, Неопределено - Устанавливаемое значение. По умолчанию Истина.
//          В рехиме инвертирования - значение, подставляемое вместо Истина:
//			>Неопределено - Истина ==> Неопределено ==> Ложь ==> Истина; 
//          >Ложь - Истина ==> Ложь ==> Неопределено ==> Истина; 
//          >Истина - Истина ==> Ложь ==> Истина; 
//          >0 - 1 ==> 0 ==> 2 ==> 1; 
//          >1 - 1 ==> 0 ==> 1; 
//          >2 - 1 ==> 2 ==> 0 ==> 1; 
//  Инвертировать - Булево - режим инвертирования флагов. По умолчанию Ложь.
//  ИмяДанныхТаблицы - Строка - Имя данных формы, соответствующих таблице. По умолчанию "" - автоопределение.
//  МассивСтрокКИзменению - Массив из СтрокаТаблицыЗначений - массив строк таблицы/дерева (ДанныеФормыЭлементДерева),
//  		в которых будет меняться флаг.
//          По умолчанию Неопределено = выделенные строки или (если выделена одна строка или ничего не выделено) = все строки.
// Возвращаемое значение:
//		Массив из ДанныеФормыЭлементКоллекции - Строки данных формы с изменёнными флагами.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция УстановитьФлаги(
		Форма,
		ТаблицаФормы_,
		ИмяПоля = "Пометка",
		НовоеЗначение = Истина,
		Инвертировать = Ложь,
		ИмяДанныхТаблицы = "",
		МассивСтрокКИзменению = Неопределено) Экспорт
    Результат = Новый Массив;
    ИмяДанныхПоляВТаблице = СтрЗаменить(ИмяПоля, " ", "");
    #Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
        ДопустимыеПоля = ИмяДанныхПоляВТаблице;
        ИмяДанныхПоляВТаблице = СтрЗаменить(ТаблицаФормы_.ТекущийЭлемент.ПутьКДанным, ".", Символы.ПС);
        ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(ИмяДанныхПоляВТаблице, СтрЧислоСтрок(ИмяДанныхПоляВТаблице));
        Если ИмяПоля <> "" Тогда
            Если СтрНайти("," + ДопустимыеПоля + ",", "," + ИмяДанныхПоляВТаблице + ",") = 0 Тогда
                ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(СтрЗаменить(ДопустимыеПоля, ",", Символы.ПС), 1);
            КонецЕсли;
        КонецЕсли; 
    #КонецЕсли
    #Область СТРОКИ_ДЛЯ_ФЛАГОВ
        МассивВЧёмМенять = Новый Массив;
        Если МассивСтрокКИзменению = Неопределено Тогда
            Если ИмяДанныхТаблицы = "" Тогда
                #Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
                    ИмяДанныхТаблицы = ТаблицаФормы_.ПутьКДанным;
                #Иначе
                    ИмяДанныхТаблицы = "";
                    ТестСтр = Новый Структура("Объект," + ТаблицаФормы_.Имя);
                    ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
                    Если ТестСтр[ТаблицаФормы_.Имя] = Неопределено Тогда
                        Если ТестСтр.Объект <> Неопределено Тогда
                            ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
                            Если ТестСтр[ТаблицаФормы_.Имя] <> Неопределено Тогда
                                ИмяДанныхТаблицы = "Объект." + ТаблицаФормы_.Имя;
                            КонецЕсли;
                        КонецЕсли;
                    Иначе
                        ИмяДанныхТаблицы = ТаблицаФормы_.Имя;
                    КонецЕсли;
                #КонецЕсли
            КонецЕсли;
            Если ЗначениеЗаполнено(ИмяДанныхТаблицы) Тогда
                Колво = ТаблицаФормы_.ВыделенныеСтроки.Количество();
                //@skip-check server-execution-safe-mode
                ДанныеТаблицы = Вычислить("Форма." + ИмяДанныхТаблицы);
                Все = (Колво < 2) ИЛИ (Колво = ДанныеТаблицы.Количество());
                Если Все Тогда
                    МассивВЧёмМенять = ДанныеТаблицы;
                Иначе
                    Для каждого ВСтрока Из ТаблицаФормы_.ВыделенныеСтроки Цикл
                        МассивВЧёмМенять.Добавить(ДанныеТаблицы.НайтиПоИдентификатору(ВСтрока));
                    КонецЦикла;
                КонецЕсли;
            КонецЕсли;
        Иначе
            МассивВЧёмМенять = МассивСтрокКИзменению;
        КонецЕсли;
    #КонецОбласти
    Для каждого СтрокаЗамены Из МассивВЧёмМенять Цикл
        ТекЗнч = СтрокаЗамены[ИмяДанныхПоляВТаблице];
        Если НЕ Инвертировать Тогда
            Если (ТекЗнч = Неопределено) ИЛИ (ТекЗнч = Истина) ИЛИ (ТекЗнч = Ложь) ИЛИ (ТекЗнч = 0) ИЛИ (ТекЗнч = 1) ИЛИ (ТекЗнч = 2) Тогда
                Если ТекЗнч <> НовоеЗначение Тогда
                    Результат.Добавить(СтрокаЗамены);
                    СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение;
                КонецЕсли;
            КонецЕсли;
        Иначе
            Результат.Добавить(СтрокаЗамены);
            Если ТекЗнч = Неопределено Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение <> Неопределено;
            ИначеЕсли ТекЗнч = Истина Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Истина, Ложь, НовоеЗначение);
            ИначеЕсли ТекЗнч = Ложь Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Ложь, Неопределено, Истина);
            ИначеЕсли ТекЗнч = 2 Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 2, 0, 1);
            ИначеЕсли ТекЗнч = 1 Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 1, 0, НовоеЗначение);
            ИначеЕсли ТекЗнч = 0 Тогда
                СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 0, 2, 1);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // УстановитьФлаги
    
#КонецОбласти

#Область 		ФАЙЛОВАЯ_СИСТЕМА

//Получает из полного имени файла имя собственно файла (с расширением)
//Параметры:
//  Путь - Строка - Полное имя файла
//Возвращаемое значение:
//  Строка - имя файла (подстрока после последнего разделителя пути)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ИмяФайла(Путь) Экспорт
    #Если Клиент Тогда
        РПути = ПолучитьРазделительПутиКлиента();
    #Иначе
        РПути = ПолучитьРазделительПутиСервера();
    #КонецЕсли 
    СпецСтрока = СтрЗаменить(Путь, РПути, Символы.ПС);
    Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя каталога без завершающего слэша
//Параметры:
//  Путь - Строка - Полное имя файла
//Возвращаемое значение:
//  Строка - имя каталога (подстрока до последнего разделитля пути исключительно)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ИмяКаталога(Путь) Экспорт
    Возврат Лев(Путь, СтрДлина(Путь) - СтрДлина(ИмяФайла(Путь)) - 1)
КонецФункции

//Переименовывает файл, добавляя к его старому имени префикс
//Параметры:
//  Имя - Строка - полное имя файла. Возвращается новое полное имя.
//  Префикс - Строка - добавляется к имени файла после пути к каталогу и разделителя пути.
//@skip-check export-method-in-command-form-module
//@skip-check module-unused-method
&НаКлиентеНаСервереБезКонтекста
Процедура ДобавитьПрефиксИмениФайла(Имя, Префикс)
    СтароеИмяФайла = ИмяФайла(Имя);
    НовоеИмя = Лев(Имя, СтрДлина(Имя) - СтрДлина(СтароеИмяФайла)) + Префикс + СтароеИмяФайла;
    ПереместитьФайл(Имя, НовоеИмя);
    Имя = НовоеИмя
КонецПроцедуры

//Передаёт файл из сетевого каталога на ФТП.
//Параметры:
//  ПолноеИмяФайлаИсточника - Строка - путь к файлу с каталогом
//  ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//  УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//  ИмяФайлаПриёмника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//  УстановленноеСоединение - FTPСоединение - если Неопределено (по умолчанию) - будет создано новое.
//  FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//  Порт - число - порт для подключения
//  Логин - Строка - Логин для подключения
//  Пароль - Строка - порт для подключения
//  Прокси - Строка - имя проксисервера для подключения
//  ПассивноеСоединение - Булево - для подключения
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Процедура ЗаписатьФайлНаFTP(
		ПолноеИмяФайлаИсточника,
		ИмяПроцесса = "Выгрузка на FTP",
		УдалитьИсточник,
		ИмяФайлаПриёмника,
        УстановленноеСоединение = Неопределено,
        FTPСервер = "",
        Порт = 21,
        Логин = "Guest",
        Пароль = "",
        Прокси = Неопределено,
        ПассивноеСоединение = Ложь) Экспорт
	#Если ТонкийКлиент ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Сервер Тогда
	    FTPСоединение = ?(УстановленноеСоединение = Неопределено,
	            Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	    Попытка 
	        FTPСоединение.Записать(ПолноеИмяФайлаИсточника, ИмяФайлаПриёмника); 
	        Если УдалитьИсточник Тогда
	            УдалитьФайлы(ПолноеИмяФайлаИсточника);
	        КонецЕсли; 
	    Исключение
	        ООш = ОписаниеОшибки();
	        #Если Сервер Тогда
	            ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ООш);
	        #Иначе
	            Сообщение = Новый СообщениеПользователю;
	            Сообщение.Текст = "Ошибка записи файла  на ФТП:" + ООш;
	            Сообщение.Сообщить();
	        #КонецЕсли
	    КонецПопытки;
	#Иначе
		ИмяПроцесса = "НЕ ВЫПОЛНЕНО";
	#КонецЕсли
КонецПроцедуры

//Передаёт файл с ФТП в сетевой каталог
//Параметры:
//  ПолноеИмяФайлаПриёмника - Строка - путь к файлу с каталогом
//  ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//  УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//  ИмяФайлаИсточника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//  УстановленноеСоединение - FTPСоединение - если Неопределено (по умолчанию) - будет создано новое.
//  FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//  Порт - число - порт для подключения
//  Логин - Строка - Логин для подключения
//  Пароль - Строка - порт для подключения
//  Прокси - Строка - имя проксисервера для подключения
//  ПассивноеСоединение - Булево - для подключения
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Процедура ПолучитьФайлСFTP(
		ПолноеИмяФайлаПриёмника,
		ИмяПроцесса = "Выгрузка на FTP",
		УдалитьИсточник,
		ИмяФайлаИсточника,
        УстановленноеСоединение = Неопределено,
        FTPСервер = "",
        Порт = 21,
        Логин = "Guest",
        Пароль = "",
        Прокси = Неопределено,
        ПассивноеСоединение = Ложь) Экспорт
	#Если ТонкийКлиент ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Сервер Тогда
	    FTPСоединение = ?(УстановленноеСоединение = Неопределено,
	            Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	    Попытка     
	        FTPСоединение.Получить(ИмяФайлаИсточника, ПолноеИмяФайлаПриёмника);
	        Если УдалитьИсточник Тогда
	            FTPСоединение.Удалить(ИмяФайлаИсточника);
	        КонецЕсли; 
	    Исключение
	        ООш = ОписаниеОшибки();
	        #Если Сервер Тогда
	            ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ООш);
	        #Иначе
	            Сообщение = Новый СообщениеПользователю;
	            Сообщение.Текст = "Ошибка чтения файла  с ФТП:" + ООш;
	            Сообщение.Сообщить();
	        #КонецЕсли
	    КонецПопытки;
	#Иначе
		ИмяПроцесса = "НЕ ВЫПОЛНЕНО";
	#КонецЕсли
КонецПроцедуры

//Выделяет расширение из полного имени файла
//Параметры:
//  Путь - Строка - Полное имя файла
//Возвращаемое значение:
//  Строка - расширение файла (подстрока после последней точки)
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция РасширениеПути(Путь) Экспорт
    СпецСтрока = СтрЗаменить(Путь, ".", Символы.ПС);
    Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

// Возвращает существование файла по пути
// Параметры:
//  Путь  - Строка - Путь к предполагаемому файлу
// Возвращаемое значение:
//   Булево   - Существование файла
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ФайлСуществует(Путь) Экспорт
    Файл = Новый Файл(Путь);
    Результат = Файл.Существует();
    Возврат Результат
КонецФункции // ФайлСуществует

//Получает файл из заданного пути, проверяет, зашифрован ли он, если нет - зашифровывает,
//Затем помещает в заданный каталог
//Параметры:
//  ПутьКудаСохранить - Строка - Имя каталога, куда будет сохранён под тем же именем зашифрованный файл.
//  ПутьОткудаВзять - Строка - Полный путь к исходному файлу
//  Пароль - Строка - Пароль шифровки. По умолчанию "".
//  ПараметрыАрхивирования - Структура - ключи (все необязательны):
//  	*Кодировка - КодировкаИменФайловВZipФайле - По умолчанию Авто.
//  	*КомментарийАрхива - Строка - Комментарий, вставляемый в архив. По умолчанию пустой.
//  	*МетодСжатия - МетодСжатияZIP - По умолчанию Сжатие.
//  	*МетодШифрования - МетодШифрованияZIP - По умолчанию Zip20.
//  	*ОбработкаПодкаталогов - РежимОбработкиПодкаталоговZIP - По умолчанию неОбрабатывать.
//  	*СохранениеПутей - РежимСохраненияПутейZIP - Как сохранять имена файлов в архиве. По умолчанию НеСохранятьПути.
//  	*УровеньСжатия - УровеньСжатияZIP - По умолчанию Оптимальный.
//Возвращаемое значение:
//  Строка - при успешной зашифровке = пустая строка, при ошибке - сообщение.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ФайлыВАрхив(
		ПутьКудаСохранить,
		ПутьОткудаВзять,
		Пароль = "",
		ПараметрыАрхивирования = Неопределено) Экспорт
    #Если ВебКлиент Тогда
		Результат = "В настоящем режиме работы функция шифрования файла недоступна";
    #Иначе
    	#Область ИНИЦИАЛИЗАЦИЯ_ПАРАМЕТРОВ
	     	Если ПараметрыАрхивирования = Неопределено Тогда
	    		ПараметрыАрхивирования = Новый Структура;
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("КомментарийАрхива"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.КомментарийАрхива), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("КомментарийАрхива", "");
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("МетодСжатия"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.МетодСжатия), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("МетодСжатия", МетодСжатияZIP.Сжатие);
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("УровеньСжатия"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.УровеньСжатия), Истина) Тогда
	    		//@skip-check unknown-method-property
	    		ПараметрыАрхивирования.Вставить("УровеньСжатия", УровеньСжатияZIP.Оптимальный);
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("МетодШифрования"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.МетодШифрования), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("МетодШифрования", Неопределено);
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("Кодировка"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.Кодировка), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("Кодировка", КодировкаИменФайловВZipФайле.Авто);
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("СохранениеПутей"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.СохранениеПутей), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("СохранениеПутей", РежимСохраненияПутейZIP.НеСохранятьПути);
	    	КонецЕсли;
	    	Если ?(ПараметрыАрхивирования.Свойство("ОбработкаПодкаталогов"), НЕ ЗначениеЗаполнено(ПараметрыАрхивирования.ОбработкаПодкаталогов), Истина) Тогда
	    		ПараметрыАрхивирования.Вставить("ОбработкаПодкаталогов", РежимОбработкиПодкаталоговZIP.НеОбрабатывать);
	    	КонецЕсли;
		    Если ТипЗнч(ПутьОткудаВзять) = Тип("Строка") Тогда
		    	ПутиСохранения = СтрРазделить(ПутьОткудаВзять, ",");
		    Иначе
		    	ПутиСохранения = ПутьОткудаВзять;
		    КонецЕсли;
    	#КонецОбласти
		ЗаписьЗИП = Новый ЗаписьZipФайла(ПутьКудаСохранить, Пароль, ПараметрыАрхивирования.КомментарийАрхива,
				ПараметрыАрхивирования.МетодСжатия ,ПараметрыАрхивирования.УровеньСжатия,
				ПараметрыАрхивирования.МетодШифрования, ПараметрыАрхивирования.Кодировка);
    	Для Каждого Путь Из ПутиСохранения Цикл
    		ЗаписьЗИП.Добавить(Путь, ПараметрыАрхивирования.СохранениеПутей, ПараметрыАрхивирования.ОбработкаПодкаталогов);
    	КонецЦикла;
    	ЗаписьЗИП.Записать();
    	Результат = "";
    #КонецЕсли
    Возврат Результат
КонецФункции

//Читает файл, расшифровывает его в указанный
//Параметры:
//  ПутьКПриёмнику - Строка - Путь к расщифровываемому файлу
//  ПутьКАрхиву - Строка - Путь к расщифровываемому файлу
//  Пароль - Строка - Пароль ZIP файла
//  Элементы_ - Соответствие из Строка - Ключи = имена элементов, Значения = Пароли. По умолчанию = Неопределено = полная распаковка.
//  ВосстанавливатьКаталоги - РежимВосстановленияПутейФайловZIP - по умолчанию Восстанавливать.
//  УдалитьИсточник - Булево - по умолчанию Ложь
//Возвращаемое значение:
//  Булево - Удалось расшифровать файл
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ФайлИзАрхива(
		ПутьКПриёмнику,
		ПутьКАрхиву,
		Пароль = "",
		Элементы_ = Неопределено,
		ВосстанавливатьКаталоги = Неопределено,
		УдалитьИсточник = Ложь) Экспорт
    Результат = Ложь;
    #Если ВебКлиент Тогда
		Результат = "В настоящем режиме работы функция шифрования файла недоступна";
    #Иначе
	    КРасшифровке = Новый Файл(ПутьКАрхиву);
	    Если КРасшифровке.Существует() Тогда
	    	Зипка = Новый ЧтениеZipФайла(ПутьКАрхиву, Пароль);
	    	Если Элементы_ = Неопределено Тогда
	    		Зипка.ИзвлечьВсе(ПутьКПриёмнику, ВосстанавливатьКаталоги);
	    	Иначе
	    		Для Каждого Элемент_ Из Элементы_ Цикл
	    			Зипка.Извлечь(Элемент_.Ключ, ПутьКПриёмнику, ВосстанавливатьКаталоги, Элемент_.Значение);
	    		КонецЦикла;
	    	КонецЕсли;
	    	Зипка.Закрыть();
	    	Если УдалитьИсточник Тогда
	    		УдалитьФайлы(ПутьКАрхиву);
	    	КонецЕсли;
	        Результат = Истина;
	    КонецЕсли;
    #КонецЕсли
    Возврат Результат;
КонецФункции
 
#КонецОбласти

//Аналог ЕстьNull - чтобы писать формулу одной строкой и не делать доп.переменных
//Параметры:
//  Первое - Произвольный - Значение, сравниваемое с "нежелательным".
//  Второе - Произвольный - "Нежелательное" значение
//  Третье - Произвольный - Замена "нежелательному" значению.
//Возвращаемое значение:
//  Произвольный - Если Первое = Второму, то Третье, иначе - Первое.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЕслиПервоеВтороеРавныТоТретьеИначеПервое(Первое, Второе, Третье) Экспорт
    Возврат ?(Первое = Второе, Третье, Первое)
КонецФункции

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ЗначениеВСтрокуXML(Значение) Экспорт
    #Если ВебКлиент Тогда
		Результат = "НЕ ВЫПОЛНЕНО";
    #Иначе
	    ЗаписьXML = Новый ЗаписьXML;
	    ЗаписьXML.УстановитьСтроку();
	    СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
		Результат = ЗаписьXML.Закрыть();
    #КонецЕсли
    Возврат Результат
КонецФункции

// Возвращает индекс коллекции, соответствующий искомому значению
// Параметры:
//  Искомое  - Произвольный - Число, строка, иное значение, сравнимое на больше/меньше = значение, искомое в коллекции. Значения по умолчанию дают индекс для вставки.
//  Коллекция  - Массив из Произвольный, ТаблицаЗначений -  или иная коллекция = место поиска
//  ИмяРеквизита  - Строка - Имя колонки, в которой ищется Искомое. Для массива не используется. Коллекция должна быть отсортирована.
//  ЕслиНетРавного  - Произвольный - Что вернуть, если равное не найдено. "Меньший", "Больший"  (по умолчанию), "БлижайшийЕслиМежду_Меньший", "БлижайшийЕслиМежду_Больший", или значение, которое будет возвращено.
//  ЕслиМногоРавных  - Произвольный - Что вернуть, если равных несколько. "МеньшийИндекс" (по умолчанию), "БольшийИндекс", "Любой", или значение, которое будет возвращено.
//  СортировкаВозрастание  - Булево - Коллекция отсортирована по возрастанию.
//  Вектор  - Число - -1(по умолчанию) - считаем, что искомое ближе к началу коллекции, 1 - иначе.
// Возвращаемое значение:
//   Число   - Индекс найденного элемента коллекции
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Функция ИндексПоловиннымДелением(
		Искомое,
		Коллекция,
		ИмяРеквизита,
		ЕслиНетРавного = "Больший",
		ЕслиМногоРавных = "МеньшийИндекс",
		СортировкаВозрастание = Истина,
		Вектор = -1) Экспорт
    ЭтоМассив = ТипЗнч(Коллекция) = Тип("Массив");
    Индекс1 = 0;
    Граница = Коллекция.Количество();
    Индекс2 = Граница;
    Результат = 0;
    МеньшийИндекс = ЕслиМногоРавных = "МеньшийИндекс";
    БольшийИндекс = ЕслиМногоРавных = "БольшийИндекс";
    НайденРавный = Ложь;
    Пока Индекс1 < Индекс2 Цикл
        Результат = Индекс1 + ШагПоловинногоДеления(Индекс2 - Индекс1 + 1, Вектор) - 1;
        Показатель = ?(ЭтоМассив, Коллекция[Результат], Коллекция[Результат][ИмяРеквизита]);
        ЭтоРавный = Искомое = Показатель;
        Если ЭтоРавный И ЕслиМногоРавных = "Любой" Тогда
            Прервать;
        ИначеЕсли ЭтоРавный И НайденРавный И НЕ МеньшийИндекс И НЕ БольшийИндекс Тогда
            Результат = ЕслиМногоРавных;
            Прервать;
        ИначеЕсли ЭтоРавный И МеньшийИндекс ИЛИ (Искомое < Показатель) = СортировкаВозрастание Тогда
            Индекс2 = Результат;
        Иначе
            Индекс1 = Результат + 1;
            Результат = Индекс1;
        КонецЕсли;
        НайденРавный = НайденРавный ИЛИ ЭтоРавный;
    КонецЦикла;
    Если НЕ НайденРавный Тогда
        ЭтоМеждуБольший = ЕслиНетРавного = "БлижайшийЕслиМежду_Больший";
        Если ЕслиНетРавного = "Меньший" Тогда
            Результат = Результат - 1;
        ИначеЕсли ЕслиНетРавного = "Больший" Тогда
        ИначеЕсли (ЕслиНетРавного = "БлижайшийЕслиМежду_Меньший") ИЛИ ЭтоМеждуБольший Тогда
            Если Граница < 2 Тогда
                Результат = 0;
            ИначеЕсли Результат > 0 Тогда
                Контрольное = ?(ЭтоМассив,
                        Коллекция[Результат] + Коллекция[Результат - 1],
                        Коллекция[Результат][ИмяРеквизита] +  Коллекция[Результат - 1][ИмяРеквизита]);
                Если (2 * Искомое > Контрольное) <> СортировкаВозрастание И ((2 * Искомое <> Контрольное) ИЛИ НЕ ЭтоМеждуБольший) Тогда
                    Результат = Результат - 1;
                КонецЕсли;
            КонецЕсли;
        Иначе
            Результат = Результат - 1;
        КонецЕсли;
    ИначеЕсли ЕслиМногоРавных = "БольшийИндекс" Тогда
        Результат = Результат - 1;
    КонецЕсли;
    Возврат Результат
КонецФункции // ИндексПоловиннымДелением

// Возвращает код (программу) записи в структуру основных параметров
//  	ИменаКлючей - Строка - имена переменных, которые будут восстановлены из ключей, через запятую
//  	ИмяСтруктуры - Строка - имя приёмника =  структуры, в которую будут добавлены ключи. По умолчанию Прм.
// Возвращаемое значение:
//   Строка   - Исполняемый код
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-parameter-in-description-suggestion
//@skip-check module-unused-method
&НаКлиентеНаСервереБезКонтекста
Функция КодВосстановленияПараметровИзСтруктуры(ИменаКлючей, ИмяСтруктуры = "Прм")
    Результат = "";
    МКлючи = СтрРазделить(ИменаКлючей, ",", Ложь);
    Для каждого Ключ Из МКлючи Цикл
        Результат = Результат + Ключ + " = " + ИмяСтруктуры + "." + Ключ + ";" + Символы.ПС;
    КонецЦикла;
    Возврат Результат
КонецФункции // КодДобавленияПараметровВСтруктуру

// Возвращает код записи в структуру основных параметров
// Параметры:
//  ИменаКлючей - Строка - имена переменных, которые станут ключами, через запятую
//  ИмяСтруктуры - Строка - имя структуры, в которую будут добавлены ключи. По умолчанию Прм.
//  СоздатьСтруктуру - Булево - Структура будет предварительно создана
// Возвращаемое значение:
//   Строка   - Исполняемый код
//@skip-check export-method-in-command-form-module
//@skip-check module-unused-method
&НаКлиентеНаСервереБезКонтекста
Функция КодДобавленияПараметровВСтруктуру(ИменаКлючей, ИмяСтруктуры = "Прм", СоздатьСтруктуру = Ложь)
    Результат = ?(СоздатьСтруктуру, ИмяСтруктуры + " = Новый Структура;" + Символы.ПС, "");
    МКлючи = СтрРазделить(ИменаКлючей, ",", Ложь);
    Для каждого Ключ Из МКлючи Цикл
        Результат = Результат + ИмяСтруктуры + ".Вставить(""" + Ключ + """, " + Ключ + ");" + Символы.ПС;
    КонецЦикла;
    Возврат Результат
КонецФункции // КодДобавленияПараметровВСтруктуру

// Возвращает массив случайных целых чисел
// Параметры:
//  Сколько  - Число - Размер возвращаемого массива. По умолчанию 10.
//  Максимальное  - Число - Максимальное возможное число. Если не указано, то равно Сколько.
//  Минимальное  - Число - Минимальное возможное число. Если не указано, то ноль.
//  
// Возвращаемое значение:
//   Массив из Число - случайные
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция МассивСлучайныхЧисел(Сколько = 10, Максимальное = Неопределено, Минимальное = 0) Экспорт
	Результат = Новый Массив;
	Если Максимальное = Неопределено Тогда
		Максимальное = Сколько;
	КонецЕсли;
	#Если ВебКлиент Тогда
	    Результат =
	    		//ВызовСервера
	    		МассивСлЧисПоВремени(Сколько, Максимальное, Минимальное);
	#Иначе
	    СлуГен = Новый ГенераторСлучайныхЧисел();
	    Для Ё = 1 По Сколько Цикл
	        Результат.Добавить(СлуГен.СлучайноеЧисло(Минимальное, Максимальное));
		КонецЦикла;
	#КонецЕсли
	Возврат Результат
КонецФункции // Имя МассивСлучайныхЧисел

//"Клиент", "Сервер", и т.д. Старое название - РежимЗапуска
//Параметры:
//  КлиентИлиСерверВЦелом - Булево - Вернуть просто "Клиент" или "Сервер", не уточняя, какой именно. По умолчанию Ложь. 
//Возвращаемое значение:
//  Строка - Обозначение текущего места выполнения кода
//@skip-check export-method-in-command-form-module
//@skip-check code-never-compilied
&НаКлиентеНаСервереБезКонтекста
Функция МестоВыполненияКода(КлиентИлиСерверВЦелом = Ложь) Экспорт
    Результат = "Странный";
    Если КлиентИлиСерверВЦелом Тогда
        #Если Клиент Тогда
            Результат = "Клиент";
        #ИначеЕсли Сервер Тогда
            Результат = "Сервер";
        #КонецЕсли
    КонецЕсли;
    Если Результат = "Странный" Тогда
        #Если ТолстыйКлиентОбычноеПриложение Тогда
            Результат = "ТолстыйКлиентОбычноеПриложение";
        #ИначеЕсли МобильноеПриложениеКлиент Тогда
            Результат = "МобильноеПриложениеКлиент";
        #ИначеЕсли МобильноеПриложениеСервер Тогда
            Результат = "МобильноеПриложениеСервер";
        #ИначеЕсли ТолстыйКлиентУправляемоеПриложение Тогда
            Результат = "ТолстыйКлиентУправляемоеПриложение";
        #ИначеЕсли Сервер Тогда
            Результат = "Сервер";
        #ИначеЕсли ВнешнееСоединение Тогда
            Результат = "ВнешнееСоединение";
        #ИначеЕсли ТонкийКлиент Тогда
            Результат = "ТонкийКлиент";
        #ИначеЕсли ВебКлиент Тогда
            Результат = "ВебКлиент";
        #КонецЕсли
    КонецЕсли;
    Возврат Результат
КонецФункции // МестоВыполненияКода()

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  Коэффициенты - Массив из Число - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
// Возвращаемое значение:
//  Массив из Число - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Коэффициенты, Знач Точность = 2) Экспорт
    Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
        Возврат Неопределено;
    КонецЕсли;
    ИндексМаксимальногоКоэффициента = 0;
    МаксимальныйКоэффициент = 0;
    РаспределеннаяСумма = 0;
    СуммаКоэффициентов  = 0;
    Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
        Коэффициент = Коэффициенты[Индекс];
        АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
        Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
            МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
            ИндексМаксимальногоКоэффициента = Индекс;
        КонецЕсли;
        СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
    КонецЦикла;
    Если СуммаКоэффициентов = 0 Тогда
        Возврат Неопределено;
    КонецЕсли;
    Результат = Новый Массив(Коэффициенты.Количество());
    Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
        Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
        РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
    КонецЦикла;
    // Погрешности округления отнесем на коэффициент с максимальным весом.
    Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
        Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
    КонецЕсли;
    Возврат Результат;
КонецФункции

//Возвращает Истина, Если Значнние1 = Значение2 
//Параметры:
//  Значение1 - Произвольный - сериализуемое для сравнения
//  Значение2 - Произвольный - сериализуемое для сравнения
//  Возвращаемое значение:
//      Булево - равны ли параметры
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция УниверсальныеЗначенияСовпадают(Значение1, Значение2) Экспорт
    Если Значение1 = Неопределено Или Значение2 = Неопределено Тогда
        Возврат Ложь;
    КонецЕсли;
    
    Возврат Значение1 = Значение2
        Или ЗначениеВСтрокуXML(Значение1) = ЗначениеВСтрокуXML(Значение2);
КонецФункции

// Возвращает шаг половинного деления по длине отрезка. Предполагается, что ожидаемое значение в интервале задано нормальным распределением с пиком примерно в трети от одного из концов отрезка
// Параметры:
// ДлинаОтрезкаМасштабов   - Число - Длина отрезка
// Вектор   - Число - -1 или 1 или 0 (по умолчанию). 1 показывает, что пик распределения ближе к концу отрезка, -1 - что к началу, 0 - Строго пополам
// Возвращаемое значение:
//   Число   - Длина шага половинного деления (куда сделать ход). Например, для 7 возвратит 4.
//@skip-check export-method-in-command-form-module
&НаКлиентеНаСервереБезКонтекста
Функция ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор) Экспорт
    Возврат ?(Вектор = 0, Цел((ДлинаОтрезкаМасштабов + 1)/ 2), (1 + Вектор) * (ДлинаОтрезкаМасштабов + 1) / 2 - Вектор * Pow(2, Цел(Log(ДлинаОтрезкаМасштабов + 1) / Log(2))) / 2)
КонецФункции // ШагПоловинногоДеления
 
#КонецОбласти

#Область 	БИБЛИОТЕКА_ФУНКЦИЙ_СЕРВЕР
    
#Область 		ОТЛАДКА

//Читает набор записей и возвращает таблицу значений - его содержимое.
//Иногда может быть пригодна для чтения движений, уже записанных в базу.
//Параметры:
//  НаборЗаписей - РегистрыСведений.*.НаборЗаписей регистра - читаемый набор записей.
//  ВернутьКакБыло - Булево - читаемый набор записей.
// Возвращаемое значение:
// 		ТаблицаЗначений из Произвольный, Булево - Куда выгружен прочитанный НЗ. Ложь - если не удалось загрузить
//@skip-check export-method-in-command-form-module
//@skip-check doc-comment-type
&НаСервереБезКонтекста
Функция ПрочитатьНаборЗаписейДляОтладки(НаборЗаписей, ВернутьКакБыло = Истина) Экспорт
    Попытка
        Если ВернутьКакБыло Тогда
            ВремТЗ = НаборЗаписей.Выгрузить();
            НаборЗаписей.Прочитать();
            Результат = НаборЗаписей.Выгрузить();
            НаборЗаписей.Загрузить(ВремТЗ);
        Иначе
            НаборЗаписей.Прочитать();
            Результат = НаборЗаписей.Выгрузить();
        КонецЕсли; 
    Исключение
        Результат = Ложь;
    КонецПопытки;   
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции

#Конецобласти

#Область 		ЗАПИСЬ
    
// Записывает комплект в транзакции с попытками проведения и записи в разных режимах. Возвращает информацию по каждому объекту. Если хотя бы один не удалось записать никак - происходит откат транзакции.
// Параметры:
//  СооРежимыЗаписи  - Соответствие из Произвольный - Ключ = объект, значение = режим записи (Структура с ключами "Проведение", "Запись" и "ОДЗ" и булевыми значениями).
// Возвращаемое значение:
//   Соответствие из Произвольный   - Ключ = объект, значение = результат записи (см.ЗаписатьОбъект() + при Записан = Истина возможны
//          КакЗаписался = "НеМодифицирован" => запись не потребовалась + КакЗаписался = "ВнеРежима" => не был задан режим записи).
//          Может не содержать входящих объектов, если произошла ошибка и попытки записи были прекращены.           
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЗаписатьКомплектВТранзакции(СооРежимыЗаписи) Экспорт
    Результат = Новый Соответствие;
    НачатьТранзакцию();
    Неудача = Ложь;
    Для каждого КиЗ Из СооРежимыЗаписи Цикл
        Если КиЗ.Ключ.Модифицированность() Тогда
            ТекУровень = ?(КиЗ.Значение.Проведение, "Проведение", ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить")));
            ТекстОшибки = "";
            Для СчПоп = 1 По 4 Цикл
                #Область ФОРМИРОВАНИЕ_ВЫЗОВА
                    Если ТекУровень = "Проведение" Тогда
                        ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(КиЗ.Значение.Запись, ?(Киз.Значение.ОДЗ, "Все", Ложь), ?(Киз.Значение.ОДЗ, Истина, "НЕТ")),, Истина,, Ложь);
                    ИначеЕсли ТекУровень = "Запись" Тогда
                        ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(Киз.Значение.ОДЗ, "Все", Ложь),,,, Ложь);
                    ИначеЕсли ТекУровень = "ОДЗ" Тогда
                        ТекРез = ЗаписатьОбъект(КиЗ.Ключ, Истина,,,, Ложь);
                    Иначе
                        //@skip-check structure-consructor-too-many-keys
                        Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "Не задан режим записи", "ВнеРежима", ""));
                        Прервать;
                    КонецЕсли;
                #КонецОбласти
                Если ТекРез.Записан Тогда
                    ТекРез.Вставить("ТекстОшибки", ТекстОшибки + Символы.ПС + Текрез.ТекстОшибки);
                    Результат.Вставить(КиЗ.Ключ, ТекРез);
                    Прервать;
                Иначе
                    ТекстОшибки = ТекстОшибки + Символы.ПС + ТекРез.ТекстОшибки;
                    ОтменитьТранзакцию();
                    Если ТекРез.Стадия = "Проведение" Тогда
                        ТекУровень = ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить"));
                    ИначеЕсли ТекРез.Стадия = "Запись" Тогда
                        ТекУровень = ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить");
                    Иначе
                        Неудача = Истина;
                        Прервать;
                    КонецЕсли;
                    Если ТекУровень = "Прекратить" Тогда
                        Неудача = Истина;
                        Прервать;
                    КонецЕсли;
                    НачатьТранзакцию();
                    Для каждого Проведённый Из Результат Цикл
                        Если Проведённый.Значение.КакЗаписался <> "НеМодифицирован" И Проведённый.Значение.КакЗаписался <> "ВнеРежима" Тогда
                            ЗаписатьОбъект(Проведённый.Ключ,
                                    Проведённый.Значение.КакЗаписался = "Записан в режиме загрузки",,
                                    Проведённый.Значение.КакЗаписался = "Проведён");
                        КонецЕсли;
                    КонецЦикла;
                КонецЕсли;
            КонецЦикла;
        Иначе
            //@skip-check structure-consructor-too-many-keys
            Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "", "НеМодифицирован", ""));
        КонецЕсли;
        Если Неудача Тогда
            //@skip-check structure-consructor-too-many-keys
            Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Ложь, ТекстОшибки, "ОШИБКА", ТекРез.Стадия));
            Прервать;
        КонецЕсли;
    КонецЦикла;
    Если НЕ Неудача Тогда
        ЗафиксироватьТранзакцию();
    КонецЕсли;
    Возврат Результат
КонецФункции // ЗаписатьКомплектВТранзакции

//Запись объекта в базу в разных режимах
//Параметры:
//  Объект_             - ДокументОбъект        - Или иной объект для запис
//  РежимЗагрузки       - Булево,Строка         - Режим "Обмен данными - Загрузка" загрузки при записи.
//          *"Не менять" (по умолчанию) - оставить как есть,
//          *"Все" - попробовать без "загрузки", если не получится - то с "загрузкой".
//          *Булево - установить указанный режим
//          Другие значения приведут к отказу от записи (кроме режима проведения).
//          При попытке проведения "Загрузка" всегда сбрасывается, на выходе из функции - восстанавливается как был.
//  ОтключитьМеханизмРегистрацииОбъектов - Булево,Неопределено - Отключить программную регистрацию на типовых планах обмена. Неопределено - не менять режим отключения.
//  ПопытатьсяПровести  - Булево    - Попытаться провести объект. По умолчанию ЛОЖЬ.
//  ПроверитьЧтоДок     - Булево    - Перед попыткой проведения проверить, документ ли это.
//  Сообщать            - Булево,Неопределено - Выдавать сообщения. Неопределено (по умолчанию) - сообщать только об ошибках.
//  Блокировать         - Булево - Использовать для записи управляемые блокировки. По умолчанию Ложь.
//  ТолькоМодифицированный - Булево - Записывать только модифицированные объекты
//Возвращаемое значение:
//	 Структура - с ключами:
//      * Записан       - Булево - удалось ли записать объект.
//      * ТекстОшибки   - Строка - Текст ошибки при записи. "", если ошибки нет.
//      * КакЗаписался  - Строка - "Не записан", "Проведён", "Записан штатно" или "Записан в режиме загрузки".
//      * Стадия        - Строка - "Блокировка", "Проведение", "Запись", "ОДЗ" или "" = стадия последней ошибочной попытки.
//@skip-check doc-comment-field-in-description-suggestion
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЗаписатьОбъект(
        Объект_,
        РежимЗагрузки = "Не менять",
        ОтключитьМеханизмРегистрацииОбъектов = Неопределено,
        ПопытатьсяПровести = Ложь,
        ПроверитьЧтоДок = Ложь,
        Сообщать = Неопределено,
        Блокировать = Ложь,
        ТолькоМодифицированный = Истина) Экспорт
    НеЗаписан = Истина;
    ПолноеСообщение = "";
    КакЗаписался = "Не записан";
    Стадия = "";
    Если ТолькоМодифицированный И НЕ Объект_.Модифицированность() Тогда
        КакЗаписался = "НеМодифицирован";
        НеЗаписан = Ложь;
    Иначе
        ТекОДЗ = Объект_.ОбменДанными.Загрузка;
        Если ОтключитьМеханизмРегистрацииОбъектов = Неопределено Тогда
        ИначеЕсли ОтключитьМеханизмРегистрацииОбъектов Тогда
            Объект_.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
        ИначеЕсли Объект_.ДополнительныеСвойства.Свойство("ОтключитьМеханизмРегистрацииОбъектов") Тогда
            Объект_.ДополнительныеСвойства.Удалить("ОтключитьМеханизмРегистрацииОбъектов");
        КонецЕсли; 
        Проводить = ?(ПопытатьсяПровести, ?(ПроверитьЧтоДок, Метаданные.Документы.Найти(Объект_.Метаданные()), Истина), Ложь);
        ВыводитьОшибки = ?(Сообщать = Неопределено, Истина, Сообщать);
        ВыводитьВсё = ?(Сообщать = Неопределено, Ложь, Сообщать);
        ВнешняяТранзакция = ТранзакцияАктивна();
        Отказ = Ложь;
        #Область БЛОКИРОВКА
            Если Блокировать И НЕ Объект_.ЭтоНовый() Тогда
                НачатьТранзакцию();
                Попытка
                    Блокировка = Новый БлокировкаДанных;
                    ЭлементБлокировки = Блокировка.Добавить(Объект_.Метаданные().ПолноеИмя());
                    ЭлементБлокировки.УстановитьЗначение("Ссылка", Объект_.Ссылка);
                    Блокировка.Заблокировать();
                    ЗаблокироватьДанныеДляРедактирования(Объект_.Ссылка);
                Исключение
                    Отказ = Истина;
                    ООШ = ОписаниеОшибки();
                    Стадия = "Блокировка";
                    ПолноеСообщение = ПолноеСообщение + "ОШИБКА_БЛОКИРОВКИ:" + ООШ + Символы.ПС;
                    Если ВыводитьОшибки Тогда
                        Сообщение = Новый СообщениеПользователю;
                        Сообщение.Текст = "Не удалось заблокировать " + Объект_ + " по причине: " + ООШ;
                        Сообщение.Сообщить();
                    КонецЕсли;
                КонецПопытки;
            КонецЕсли;
        #КонецОбласти
        //Попытка проведения
        Если Проводить И НЕ Отказ Тогда
            Попытка
                Объект_.ОбменДанными.Загрузка = Ложь;
                Объект_.Записать(РежимЗаписиДокумента.Проведение);
                Если ВыводитьВсё Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "Проведён " + Объект_;
                	Сообщение.Сообщить();
                 КонецЕсли;
                НеЗаписан = Ложь;
                КакЗаписался = "Проведён";
            Исключение
                ООШ = ОписаниеОшибки();
                Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
                Стадия = "Проведение";
                ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОВЕДЕНИЯ:" + ООШ + Символы.ПС;
                Если ВыводитьОшибки Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "НЕ проведён " + Объект_ + " по причине: " + ООШ;
                	Сообщение.Сообщить();
                КонецЕсли;
            КонецПопытки;
        КонецЕсли;
        //Попытка обычной записи
        Если НеЗаписан И НЕ Отказ
                И (РежимЗагрузки = Ложь
                    ИЛИ РежимЗагрузки = "Все"
                    ИЛИ РежимЗагрузки = "Не менять" И НЕ ТекОДЗ) Тогда
            Объект_.ОбменДанными.Загрузка = Ложь;
            Попытка
                Объект_.Записать();
                НеЗаписан = Ложь;
                Если ВыводитьВсё Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "Записан в штатном режиме " + Объект_;
                	Сообщение.Сообщить();
                КонецЕсли;
                КакЗаписался = "Записан штатно";
            Исключение
                ООШ = ОписаниеОшибки();
                Стадия = "Запись";
                Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
                ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОСТОЙ_ЗАПИСИ:" + ООШ + Символы.ПС;
                Если ВыводитьОшибки Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "НЕ записан " + Объект_ + " по причине: " + ООШ;
                	Сообщение.Сообщить();
                КонецЕсли;
            КонецПопытки;
        КонецЕсли;
        //Попытка записи в режиме обмена данными
        Если НеЗаписан И НЕ Отказ
                И (РежимЗагрузки = Истина
                    ИЛИ РежимЗагрузки = "Все"
                    ИЛИ РежимЗагрузки = "Не менять" И ТекОДЗ) Тогда
            Объект_.ОбменДанными.Загрузка = Истина;
            Попытка
                Объект_.Записать();
                НеЗаписан = Ложь;
                Если ВыводитьВсё Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "Записан в режиме загрузки " + Объект_;
                	Сообщение.Сообщить();
                КонецЕсли;
                КакЗаписался = "Записан в режиме загрузки";
            Исключение
                ООШ = ОписаниеОшибки();
                Стадия = "ОДЗ";
                ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ЗАПИСИ_ЗАГРУЗКОЙ:" + ООШ + Символы.ПС;
                Если ВыводитьОшибки Тогда
                	Сообщение = Новый СообщениеПользователю;
                	Сообщение.Текст = "НЕ записан в режиме загрузки " + Объект_ + " по причине: " + ООШ;
                	Сообщение.Сообщить();
                КонецЕсли;
            КонецПопытки;
        КонецЕсли;
        //Завершение транзакции
        Если Блокировать Тогда
            Если НеЗаписан Тогда
                ОтменитьТранзакцию();
            Иначе
                ЗафиксироватьТранзакцию();
            КонецЕсли;
        КонецЕсли;
        Объект_.ОбменДанными.Загрузка = ТекОДЗ;
    КонецЕсли;
    //@skip-check structure-consructor-too-many-keys
    Возврат Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", НЕ НеЗаписан, ПолноеСообщение, КакЗаписался, Стадия)
КонецФункции

#КонецОбласти

#Область 		ЗАПРОСЫ

//Тексты запросов см. КлиентСервер

// Заполняет незаданные параметры запроса заданными значениями
// Параметры:
//  Запрос_  - Запрос - с установленным текстом, в котором будут проверяться и устанавливаться параметры
//  Значения  - Произвольный - значение, по которому будут задаваться параметры.
//      >Структура - Имя параметра с ключом будет заполнено значением (только для незаполненных). Ненайденные будут заполнены значением по умолчанию (из ключа "ОСТАЛЬНЫЕ" или общего)
//      >Любое другое значение - будет непосредственно помещено во все незаполненные параметры
//      >Строка "#№#№#" (по умолчанию) - во все параметры будет помещён пустой массив
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ЗаполнитьНезаполненныеПараметрыЗапроса(Запрос_, Значения = "#№#№#") Экспорт
    ПоУмолчанию = Новый Массив;
    Если Значения = "#№#№#" Тогда
        Значения = ПоУмолчанию;
        ТипСтр = Ложь;
    Иначе
        ТипЗн = ТипЗнч(Значения);
        ТипСтр = (ТипЗн = Тип("Структура")) ИЛИ (ТипЗн = Тип("ФиксированнаяСтруктура"));
    КонецЕсли;
    ПараметрыТекущегоЗапроса = Запрос_.НайтиПараметры();
    Для каждого ПараметрЗапроса Из ПараметрыТекущегоЗапроса Цикл
        ИмяПараметра =  ПараметрЗапроса.Имя;
        Если НЕ Запрос_.Параметры.Свойство(ИмяПараметра) Тогда
            Запрос_.УстановитьПараметр(ИмяПараметра, ?(ТипСтр, ?(Значения.Свойство(ИмяПараметра), Значения[ИмяПараметра], ?(Значения.Свойство("ОСТАЛЬНЫЕ"), Значения.ОСТАЛЬНЫЕ, ПоУмолчанию)), Значения));
        КонецЕсли; 
    КонецЦикла;
КонецПроцедуры // ЗаполнитьНезаполненныеПараметрыЗапроса

// Выполняет запрос, пока не будет соблюдено условие равенства нулю итога по заданной колонке.
// Параметры:
//  Запрос_  - Запрос - Запрос, повторяемый в цикле и готовый к выполнению.
//          Если ТабПараметр - строка, то в запросе д.б. задан МВТ.
//              В этом случае для ускорения  рекомендуется для контроля завершения использовать маленькую таблицу из одной строки, где итоги уже посчитаны запросом,
//              и указать её имя в следующем параметре. В запрос не имеет смысла помещать выборку данных - она не используется внутри функции.
//          Если ТабПараметр - таблица значений, МВТ не нужен, запрос должен содержать выборку данных, выгружающую контрольную таблицу.
//  ТабПараметр  - Строка, ТаблицаЗначений - Имя ВТ, выгружаемой для контроля завершения/Таблица, помещаемая в параметр (по ней же производится контроль завершения).
//  ИмяКонтрольнойКолонки  - Строка - Имя контрольной колонки. По умолчанию "НеГотово".  Цикл завершится, когда итог по колонке станет нулевым. 
//  ИмяПараметра  - Строка - Имя параметра, куда помещается таблица. По умолчанию "ТабПараметр". Не используется при работе с временной таблицей.
//  ОграничениеПовтора  - Число - Ограничение проходов цикла во избежание зацикливания. По умолчанию 100.
//Возвращаемое значение:
//  ТаблицаЗначений, Строка    - выгрузка результата запроса/контрольная таблица. Контрольная колонка не удаляется для контроля оверцикла.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ЗапросВЦикле(
		Запрос_,
		ТабПараметр = "ТабРезультат",
		ИмяКонтрольнойКолонки = "НеГотово",
		ИмяПараметра = "ТабПараметр",
		ОграничениеПовтора = 100) Экспорт
    ПройденоПовторов = 0;
    ЧерезВТ = ТипЗнч(ТабПараметр) = Тип("Строка");
    ТабКонтроль = ТабПараметр;
    Контроль = ?(ЧерезВТ, 1, ТабКонтроль.Итог(ИмяКонтрольнойКолонки));
    Пока (Контроль <> 0) И (ПройденоПовторов < ОграничениеПовтора) Цикл
        ПройденоПовторов = ПройденоПовторов + 1;
        Если ЧерезВТ Тогда
            //@skip-check query-in-loop
            Запрос_.Выполнить();
            ТабКонтроль = Запрос_.МенеджерВременныхТаблиц.Таблицы[ТабПараметр].ПолучитьДанные().Выгрузить();
        Иначе
            Запрос_.УстановитьПараметр(ИмяПараметра, ТабКонтроль);
            //@skip-check query-in-loop
            ТабКонтроль = Запрос_.Выполнить().Выгрузить();
        КонецЕсли;
        Контроль = ТабКонтроль.Итог(ИмяКонтрольнойКолонки);
    КонецЦикла;
    //@skip-check constructor-function-return-section
    Возврат ТабКонтроль
КонецФункции // ЗапросВЦикле
 
//Выполняет запрос и возвращает значение из первой его ячейки
//Параметры:
//  Запрос_ - Запрос - Готовый к выполнению запрос
//  ЕслиНеНайдено - Произвольный - Значение, возвращаемое, если запрос вернул пустой результат
//Возвращаемое значение:
//  Произвольный - значение из первой ячейки запроса
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ПолучитьЕдинственноеЗначениеЗапроса(Запрос_, ЕслиНеНайдено = Неопределено) Экспорт
    ТабХ = Запрос_.Выполнить().Выгрузить();
    Возврат ?(ТабХ.Количество() = 0, ЕслиНеНайдено, ТабХ[0][0])
КонецФункции

//Создаёт запрос с заданным текстом. Удобно для применения в длинных выражениях с точками, где Новый не прокатит
//Параметры:
//  ТекстЗапроса_ - строка - текст запроса
//  Параметры - структура - параметры запроса (необязательный)
//  МВТ - МенеджерВременныхТаблиц - для установки в запрос (необязательный)
//Возвращаемое значение:
//  Запрос - сформированный запрос.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СоздатьЗапрос(ТекстЗапроса_, Параметры = Неопределено, МВТ = Неопределено) Экспорт
    Результат = Новый Запрос(ТекстЗапроса_);
    Если НЕ (Параметры = Неопределено) Тогда
        Для Каждого КиЗ из Параметры Цикл
            Результат.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение)
        КонецЦикла
    КонецЕсли;
    Если НЕ (МВТ = Неопределено) Тогда
        Результат.МенеджерВременныхТаблиц = МВТ
    КонецЕсли;
    Возврат Результат
КонецФункции

// Возвращает по тексту запроса и параметрам запрос или готовый результат
// Параметры:
//  ТекстЗапроса_  - Строка, Запрос - Текст запроса или запрос
//  ОписаниеРезультата - Строка -
//      >Выборка - Выполнить запрос и вернуть выборку
//      >Выгрузка (по умолчанию) - Выполнить запрос и вернуть выгрузку
//      >Выполненный - Выполнить запрос и вернуть его
//      >Запрос - Создать запрос и вернуть без выполнения
//      >Значение - Вернуть первое значение из результата. При отсутствии - NULL.
//      >Массив - Вернуть выгрузку первой колонки
//      >Пакет - Вернуть результат выполнения пакета
//      >Результат - Вернуть результат запроса
//      >СПромежуточными - Вернуть ВыполнитьПакетСПромежуточнымиДанными.
//  Параметры - Структура - Параметры в запрос. Необязательный.
//  МВТ - МенеджерВременныхТаблиц - для вставки в запрос. По умолчанию Неопределено = Без ВТ
//  ЗагрузитьВТ - Строка - описывает дополнительную загрузку ВТ. ИМена создаваемых ВТ и параметров, из которых ВТ загружаются, будут совпадать.
//      >Загрузить - Создать тексты и фактически загрузить в запрос все таблицы значений из параметров. Текст запроса не менять.
//      >Ничего (по умолчанию) - Не менять текст запроса и не загружать ВТ. Если в тексте запроса уже есть загрузки, они будут выполнены при выпонении запроса в общем порядке.
//      >ТекстВЗапрос - Добавить в начало запроса загрузку ВТ
// Возвращаемое значение:
//   Произвольный - возможные типы:
//      >Запрос - сконструированный запрос
//      >Результат запроса - результат запроса после его выполнения
//      >Выборка из результата запроса - выборка из результата запроса после его выполнения
//      >Таблица значений - выгрузка из результата запроса после его выполнения
//      >Дерево значений - выгрузка из результата запроса после его выполнения
//      >Массив - выгрузка колонки таблицы значений, полученной из результата запроса после его выполнения, либо результат выполнения пакета
//      >Строка - описание ошибки
//      >Прочие значения - как единственное значение, полученное в результате запроса (NULL при пустом результате).
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция РезультатЗапроса(
		ТекстЗапроса_,
		ОписаниеРезультата = "Выгрузка",
		Параметры = Неопределено,
		МВТ = Неопределено,
		ЗагрузитьВТ = "Ничего") Экспорт
    Результат = NULL;
    Попытка
        СформироватьТекстыЗагрузчиков = (ЗагрузитьВТ = "Загрузить") ИЛИ (ЗагрузитьВТ = "ТекстВЗапрос");
        Если ТипЗнч(Параметры) = Тип("Структура") Тогда
            СтрПараметров = Параметры;
        Иначе
            стрПараметров = Новый Структура;
        КонецЕсли;
        ТипТЗ = Тип("ТаблицаЗначений");
        Запрос_= ?(ТипЗнч(ТекстЗапроса_) = Тип("Запрос"), ТекстЗапроса_, Новый Запрос(ТекстЗапроса_));
        Если МВТ <> Неопределено Тогда
            Запрос_.МенеджерВременныхТаблиц = МВТ;
        КонецЕсли;
        ТекстПредварительногоЗапроса = "";
        Для каждого КиЗ Из стрПараметров Цикл
            Если СформироватьТекстыЗагрузчиков И (ТипЗнч(КиЗ.Значение) = ТипТЗ) Тогда
                ТекстПредварительногоЗапроса = ТекстПредварительногоЗапроса + ТаблицуЗначенийВоВременнуюТаблицуТекст(КиЗ.Значение, КиЗ.Ключ,,, КиЗ.Ключ);
            КонецЕсли;
            Запрос_.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
        КонецЦикла;
        Если ЗагрузитьВТ = "Загрузить" Тогда
            Стек = Запрос_.Текст;
            Запрос_.Текст = ТекстПредварительногоЗапроса;
            Запрос_.Выполнить();
            Запрос_.Текст = Стек;
        ИначеЕсли ЗагрузитьВТ = "ТекстВЗапрос" Тогда
            Запрос_.Текст = ТекстПредварительногоЗапроса + Запрос_.Текст;
        КонецЕсли;
        Если ОписаниеРезультата = "Запрос" Тогда
            Результат = Запрос_;
        Иначе
            Результат = Запрос_.Выполнить();
            Если ОписаниеРезультата = "Выборка" Тогда
                Результат = Результат.Выбрать();
            ИначеЕсли ОписаниеРезультата = "Выполненный" Тогда
                Результат = Запрос_;
            ИначеЕсли ОписаниеРезультата = "Пакет" Тогда
                Результат = Запрос_.ВыполнитьПакет();
            ИначеЕсли ОписаниеРезультата = "Результат" Тогда
            ИначеЕсли ОписаниеРезультата = "СПромежуточными" Тогда
                Результат = Запрос_.ВыполнитьПакетСПромежуточнымиДанными();
            Иначе
                Результат = Результат.Выгрузить();
                Если ОписаниеРезультата = "Значение" Тогда
                    Если Результат.Количество() Тогда
                        Результат = Результат[0][0];
                    Иначе
                        Результат = NULL;
                    КонецЕсли;
                ИначеЕсли ОписаниеРезультата = "Массив" Тогда
                    Результат = Результат.ВыгрузитьКолонку(Результат.Колонки[0].Имя);
                КонецЕсли;
            КонецЕсли;
        КонецЕсли;
    Исключение
        ООШ = ОписаниеОшибки();
        Результат = "#ОШИБКА: " + ООШ;
    КонецПопытки;
    Возврат Результат
КонецФункции // РезультатЗапроса

//Помещает таблицу значений во временную таблицу
// Параметры:
//  Таблица - таблицаЗначений -
//  Менеджер - МенеджерВременныхТаблиц - Сюда и попадает таблица.
//  ИмяВТ - строка - имя временной таблицы
//  Выразить - Булево - Типизировать в запросе колонки таблицы. По умолчанию Ложь.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ТаблицуЗначенийВоВременнуюТаблицу(Таблица, Менеджер, ИмяВТ, Выразить = Ложь) Экспорт
    ТекстЗапроса = ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить, Ложь);
    Запрос = Новый Запрос(ТекстЗапроса);
    Запрос.МенеджерВременныхТаблиц = Менеджер;
    Запрос.УстановитьПараметр("ТабПараметр", Таблица);
    Запрос.Выполнить()
КонецПроцедуры

//Возвращает текст запроса, размещающего таблицу значений во временную таблицу
//Параметры:
//  Таблица - ТаблицаЗначений - источник данных.
//  ИмяВТ - строка - имя временной таблицы, куда будет загружена таблица
//  Выразить - Булево - Типизировать в запросе колонки таблицы. По умолчанию Ложь.
//  ВПакете - Булево - добавляет разделитель для вставки в пакет запросов, по умолчанию Истина
//  ИмяПараметра - Строка - Имя параметра, куда будет помещена таблица
//  
//Возвращаемое значение:
//  Строка - Текст запроса, помещающего таблицу значений во временную таблицу.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТаблицуЗначенийВоВременнуюТаблицуТекст(
		Таблица,
		ИмяВТ,
		Выразить = Ложь,
		ВПакете = Истина,
		ИмяПараметра = "ТабПараметр") Экспорт
    ТекстЗапроса = "";
    Для каждого Колонка из Таблица.Колонки Цикл
        ТекстЗапроса =
        		ТекстЗапроса + "," + Символы.ПС +
        		?(Выразить,
        			"  ВЫРАЗИТЬ(Таб." + Колонка.Имя + " КАК " + ТипДляЗапроса(
						//КлиентСерверХЪ
						ОписаниеТиповКоллекции(Таблица.ВыгрузитьКолонку(Колонка))) + ") КАК ",
                	"   Таб.") + Колонка.Имя
    КонецЦикла;
    КонецЗапроса =
    		?(ВПакете,
    			//КлиентСерверХЪ
    			РазделительЗапросов(),
    			"");
	Возврат "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + Символы.ПС + "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС + "ИЗ" +
            Символы.ПС + "  &ТабПараметр КАК Таб" + КонецЗапроса
КонецФункции

//Возвращает строку - имя типа в виде, подходящем для запроса. Если тип - сложный, возвращается описание первого.
//Параметры:
//  ОписаниеТипа - ОписаниеТипов -  по которому надо получить полное имя метаданных
//Возвращаемое значение:
//  Строка - Полное имя метаданных, пригодное для запроса
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТипДляЗапроса(ОписаниеТипа) Экспорт
    Если ТипЗнч(ОписаниеТипа) = Тип("ОписаниеТипов") Тогда
        Описание = ОписаниеТипа;
        Тип_ = ОписаниеТипа.Типы()[0];
        Если Тип_ = Тип("Строка") Тогда
            Возврат "СТРОКА(" + ОписаниеТипа.КвалификаторыСтроки.Длина + ")"
        ИначеЕсли Тип_ = Тип("Число") Тогда
            Возврат "ЧИСЛО(" + ОписаниеТипа.КвалификаторыЧисла.Разрядность + ", " + ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти + ")"
        КонецЕсли
    ИначеЕсли ТипЗнч(ОписаниеТипа) = Тип("Тип") Тогда
        МТипов = Новый Массив;
        МТипов.Добавить(ОписаниеТипа);
        Описание = Новый ОписаниеТипов(МТипов)
    Иначе
        Возврат Строка(ОписаниеТипа)
    КонецЕсли;
    Попытка
        Возврат Описание.ПривестиЗначение(0).Метаданные().ПолноеИмя()
    Исключение
        Возврат СокрЛП(ОписаниеТипа)
    КонецПопытки
КонецФункции

#КонецОбласти

#Область 		КОЛЛЕКЦИИ

#Область 			ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
    
// Копирует колонку без данных в приёмник. Возвращает имя добавленной или найденной колонки.
// Параметры:
//  Приёмник  - КоллекцияКолонокДереваЗначений, КоллекцияКолонокТаблицыЗначений - коллекция, в которую будут добавлены колонки
//  Колонка  - КолонкаДереваЗначений, КолонкаТаблицыЗначений - которую надо перенести
//  ИмяКолонкиВПриёмнике - Строка - Имя соответствующей колонки в приёмнике. По умолчанию "" - имена совпадают.
//  Метод   - Число:
//      > 0 или 3 - Не проверять наличие в приёмнике. Если колонка там есть, при добавлении будет ошибка.
//      > 1 - Проверять наличие в приёмнике. Если колонка там есть, считаем, что всё ок.
//      > 2 - Проверять наличие в приёмнике. Если колонка там есть, старая колонка приёмника будет удалена.
//      > 4 - Проверять наличие в приёмнике. Если колонка там есть, колонка будет добавлена под корректным сгенерированным именем.
//  Возвращаемое значение:
//      Строка - имя колонки (найденной или добавленной);
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СкопироватьКолонку(Приёмник, Колонка, ИмяКолонкиВПриёмнике = "", Метод = 3) Экспорт
    Результат = ?(ИмяКолонкиВПриёмнике = "", Колонка.Имя, ИмяКолонкиВПриёмнике);
    Если (Метод = 3) ИЛИ (Метод = 0) Тогда
        НадоДобавить = Истина;
    Иначе
        СчК = 0;
        НадоДобавить = Ложь;
        Пока НЕ НадоДобавить Цикл
            СтараяКолонка = Приёмник.Найти(Результат);
            Если СтараяКолонка = Неопределено Тогда
                НадоДобавить = Истина;
            ИначеЕсли Метод = 4 Тогда
                Результат = Колонка.Имя + СчК;
                СчК = СчК + 1;
            ИначеЕсли Метод = 2 Тогда
                Приёмник.Удалить(СтараяКолонка);
            Иначе
                Прервать
            КонецЕсли;
        КонецЦикла; 
    КонецЕсли;
    Если НадоДобавить Тогда
        Приёмник.Добавить(Результат, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
    КонецЕсли;
    Возврат Результат
КонецФункции// ДобавитьНедостающиеКолонки
 
#КонецОбласти 

#Область 			ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область 				ОПЕРАЦИИ_С_ДВУМЯ_ТЗ
    
//Добавляет записи из ТабИсточник в конец ТабПриёмник.
//Одноимённые поля скопируются автоматически. Если копируется что-то лишнее, можно подкорректировать структурами или исключением. Поля, не попавшие в структуры и исключения, копируются "один в один".
//Если объединяем несколько таблиц, или проблемы с типами (например, таблицы по результатам запроса), надо использовать ОбъединитьТаблицы
//Параметры:
//  ТабИсточник - ТаблицаЗначений - или иная коллекция, поддерживающая Добавить и  обращение к элементу коллекции через []
//  ТабПриёмник - ТаблицаЗначений - или иная коллекция, поддерживающая обращение к элементу коллекции через []
//  СтруктураКопируемыхКолонок - структура - описывающая копирование (Ключ - имя колонки приёмника, Значение - имя колонки источника). Необязательна.
//  СтруктураВычисляемыхКолонок - структура - поля приёмника (Ключ), которые вычисляются формулой для функции Вычислить (Значение); Можно применять имена Строка и СтрокаНовая, а также имена параметров процедуры. Необязательна.
//  ИсключаемыеПоля - Строка - список полей, не подлежащих копированию, через запятую. Необязательны.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ДобавитьЗаписиИзТаблицыВТаблицу(
		ТабИсточник,
		ТабПриёмник,
		СтруктураКопируемыхКолонок = Неопределено,
		СтруктураВычисляемыхКолонок = Неопределено,
		ИсключаемыеПоля = "") Экспорт
    ЕстьСКК = СтруктураКопируемыхКолонок <> Неопределено;
    ЕстьСВК = СтруктураВычисляемыхКолонок <> Неопределено;
    КолонкиПриёмника = ?(ЕстьСКК или ЕстьСВК, ТабПриёмник.Колонки, Неопределено);
    Если ЕстьСКК Тогда
        Для каждого КиЗ Из СтруктураКопируемыхКолонок Цикл
            Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
                КолонкиПриёмника.Добавить(КиЗ.Ключ);
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
    Если ЕстьСВК Тогда
        Для каждого КиЗ Из СтруктураВычисляемыхКолонок Цикл
            Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
                КолонкиПриёмника.Добавить(КиЗ.Ключ);
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
    УстановитьБезопасныйРежим(Истина);
    Для каждого Строка из ТабИсточник Цикл
        СтрокаНовая = ТабПриёмник.Добавить();
        ЗаполнитьЗначенияСвойств(СтрокаНовая, Строка,, ИсключаемыеПоля);
        Если ЕстьСКК Тогда
            Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
                СтрокаНовая[Колонка.Ключ] = Строка[Колонка.Значение]
            КонецЦикла;
        КонецЕсли;
        Если ЕстьСВК Тогда
            Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
                СтрокаНовая[Колонка.Ключ] = Вычислить(Колонка.Значение)
            КонецЦикла
        КонецЕсли;
    КонецЦикла
КонецПроцедуры //ДобавитьЗаписиИзТаблицыВТаблицу

// Возвращает массив имён общих колонок двух таблиц
// Параметры:
//  Таб1  - ТаблицаЗначений, ДеревоЗначений - или Структура с коллекцией объектов со строковым свойством "Имя" в ключе "Колонки" = Первая таблица
//  Таб2  - ТаблицаЗначений, ДеревоЗначений - или Структура с массивом строк в ключе "Колонки" = Вторая таблица
//  ВключатьНомерСтроки  - Булево - Обрабатывать колонку с именем "НомерСтроки". По умолчанию Ложь.
// Возвращаемое значение:
//   Массив из Строка  - Строки - имена общих колонкок таблиц
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ОбщиеКолонки(Таб1, Таб2, ВключатьНомерСтроки = Ложь) Экспорт
    Результат = Новый Массив;
    Для Каждого Колонка Из Таб1.Колонки Цикл
        ТекИмя = Колонка.Имя;
        Если (ТекИмя <> "НомерСтроки") ИЛИ ВключатьНомерСтроки Тогда
            Если Таб2.Колонки.Найти(ТекИмя) <> Неопределено Тогда
                Результат.Добавить(ТекИмя);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат Результат
КонецФункции // ОбщиеКолонки

//Формирует разность двух таблиц с одинаковыми структурами колонок. Колонки сопоставляются по порядку в таблице (НЕ по имени!).
//Параметры:
//  ТаблицаВычитаемое - ТаблицаЗначений - строки которой считаются "Вычитаемыми"
//  ТаблицаУменьшаемое - ТаблицаЗначений - строки которой считаются "Положительными"
//  Сортировка - Строка - Имена колонок для сортировки результата
//  КПлюс - Число - Значение, которое возвратится в колонке "Знак" "положительных" строк
//Возвращаемое значение:
//  ТаблицаЗначений    - включает строки, встречающиеся только один раз в одной таблице. В добавленной колонке "Знак" в строках из "Вычитаемой" таблицы будет 0, "Уменьшаемой" - параметр КПлюс.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция РазницаТаблицЗначений(
		ТаблицаВычитаемое,
		ТаблицаУменьшаемое,
		Сортировка,
		КПлюс = 1) Экспорт
    ВсеКолонки = Список_Колонок(ТаблицаУменьшаемое);
    Результат = ТаблицаУменьшаемое.Скопировать();    
    Результат.Колонки.Добавить("Знак", Новый ОписаниеТипов("Число"));
    Результат.ЗаполнитьЗначения(КПлюс, "Знак");
    Для Счетчик = 1 По ТаблицаВычитаемое.Количество() Цикл 
        Результат.Вставить(0) 
    КонецЦикла;
    Для Счетчик = 0 По ТаблицаВычитаемое.Колонки.Количество() - 1 Цикл 
        Результат.ЗагрузитьКолонку(ТаблицаВычитаемое.ВыгрузитьКолонку(Счетчик), Счетчик) 
    КонецЦикла;
    Результат.Колонки.Добавить("Счёт");
    Результат.ЗаполнитьЗначения(1, "Счёт");
    Результат.Свернуть(ВсеКолонки, "Знак, Счёт");
    Результат = Результат.Скопировать(Новый Структура("Счёт", 1), ВсеКолонки + ", Знак");
    Результат.Сортировать(Сортировка);
    Возврат Результат;
КонецФункции

// Распределяет суммы из строк таблицы пропорционально базе из другой таблицы. Общие колонки являются измерениями, по ним идёт поиск базы. Различные - ресурсы, все они будут присутствовать в финальной строке.
// Параметры:
//  Суммы  - ТаблицаЗначений - Таблица, содержащая распределяемые суммы
//  База  - ТаблицаЗначений - Таблица, содержащая значения базы
//  КолонкиСумм  - Массив из Строка, Строка - Массив имён колонок, содержащих распределяемые суммы. По умолчанию "Сумма".
//  КолонкаБазы  - Строка - Имя колонки, содержащей базу. По умолчанию "База".
//  Обработчик  - Произвольный - Менеджер" = Обработчик, выполняемый в момент, когда найдена строка и база к ней.
//          Использует ключи структуры Прм: РаспределяемаяСтрока (Строка из Суммы), КолонкиСумм,
//          База (отбранные строки из База), ПолнаяБаза (База), КолонкаБазы, Параметры.
//  ПараметрыОбработчика  - Структура, Неопределено - Параметры, доступные в обработчике. По умолчанию Неопределено.
//  ПоместитьЗначенияБазыВРезультат - Строка - Вариант переноса значения базы в результат. По умолчанию "Нет".
//          Возможные варианты:
//          >"Нет" - колонки КолонкаБазы в результате не будет
//          >"Пустая" - в колонку будут занесены нули.
//          >"КакЕсть" - в колонку будут занесены применённые коэффициенты, что будет наглядно. Итог по базе будет задублирован.
//          >Имя колонки сумм - Базу распределить пропорционально результату из указанной колонки. Медленнее, не наглядно, но итог по базе сойдётся.
//  ТочностьСумм - Число, Массив из Число - Число цифр после запятой в суммах. По умолчанию 2. 
//  ТочностьБазы - Число - Число цифр после запятой в базе. По умолчанию 3.
//  РаспределятьНаНулевуюБазуЕслиОднаСтрока - Булево - При нулевой базе всё распределится на единственное значение базы,
//  		при Ложь результат будет нулевой. 
//  
// Возвращаемое значение:
//   ТаблицаЗначений   - Таблица - Соединение со всеми колонками таблиц сумм и базы и с суммами, распределёнными пропорционально базе.
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция РаспределитьПоБазе(
		Суммы,
		База,
		КолонкиСумм = "Сумма",
		КолонкаБазы = "База",
		Обработчик = "",
        ПараметрыОбработчика = Неопределено,
        ПоместитьЗначенияБазыВРезультат = "Нет",
        ТочностьСумм = 2,
        ТочностьБазы = 3,
        РаспределятьНаНулевуюБазуЕслиОднаСтрока = Ложь) Экспорт

    #Область ИНИЦИАЛИЗАЦИЯ
        ЕстьОбработчик = ЗначениеЗаполнено(Обработчик);
        Если ТипЗнч(КолонкиСумм) = Тип("Строка") Тогда
            ИменаКолонокСумм = СтрРазделить(КолонкиСумм, ",");
        Иначе
            ИменаКолонокСумм =
            		//КлиентСерверХЪ
            		ПреобразоватьВМассив(КолонкиСумм, Истина,, Истина);
        КонецЕсли;
        Точности = Новый Структура;
        ПараметрТочностиМассивом = ТипЗнч(ТочностьСумм) = Тип("Массив");
        СЧКол = 0;
        Для каждого ИмяКС Из ИменаКолонокСумм Цикл
            Точности.Вставить(ИмяКС, ?(ПараметрТочностиМассивом, ТочностьСумм[СчКол], ТочностьСумм));
            СЧКол = СЧКол + 1;
        КонецЦикла;
        Результат = ВыгрузитьКолонкиГрупповая(Новый Структура("Таб1,Таб2", Суммы, База));
        ИменаКолонокСумм.Добавить(КолонкаБазы);//Временно
        ИзмеренияРезультата =
				//КлиентСерверХЪ
				РазностьМассивов(Список_Колонок(Результат, "Массив"), ИменаКолонокСумм);
        КолонкиПоиска =
				//КлиентСерверХЪ
				РазностьМассивов(ОбщиеКолонки(База, Суммы), ИменаКолонокСумм);
        ИменаКолонокСумм.Удалить(ИменаКолонокСумм.ВГраница());
        ПараметрыКПередачеВОбработчик = Новый Структура;
 		ПараметрыКПередачеВОбработчик.Вставить("РаспределяемаяСтрока", "");
		ПараметрыКПередачеВОбработчик.Вставить("КолонкиСумм", ИменаКолонокСумм);
		ПараметрыКПередачеВОбработчик.Вставить("База", "");
		ПараметрыКПередачеВОбработчик.Вставить("ПолнаяБаза", База);
		ПараметрыКПередачеВОбработчик.Вставить("КолонкаБазы", КолонкаБазы);
		ПараметрыКПередачеВОбработчик.Вставить("Параметры", ПараметрыОбработчика);
    #КонецОбласти 
    
    #Область РАСПРЕДЕЛЕНИЕ_СУММ
        ОбратноеСоответствие = Новый Соответствие;
        Для Каждого СтрокаСумм из Суммы Цикл
            СтруктураОтбора = Новый Структура;
            Для Каждого ИмяКолонки Из КолонкиПоиска Цикл
                Если ЗначениеЗаполнено(СтрокаСумм[ИмяКолонки]) Тогда
                    СтруктураОтбора.Вставить(ИмяКолонки, СтрокаСумм[ИмяКолонки]);
                КонецЕсли;
            КонецЦикла;
            ТекБаза = База.НайтиСтроки(СтруктураОтбора);
            Если ЕстьОбработчик Тогда
                ПараметрыКПередачеВОбработчик.Вставить("РаспределяемаяСтрока", СтрокаСумм);
                ПараметрыКПередачеВОбработчик.Вставить("База", ТекБаза);
                ВыполнитьКод(Обработчик, ПараметрыКПередачеВОбработчик);
            КонецЕсли; 
            МассивБазы = Новый Массив;
            Для каждого ТекСтр Из ТекБаза Цикл
                МассивБазы.Добавить(ТекСтр[КолонкаБазы]);
                Если ОбратноеСоответствие[ТекСтр] = Неопределено Тогда
                    ОбратноеСоответствие.Вставить(ТекСтр, Новый Массив);
                КонецЕсли;
            КонецЦикла;
            Распределённые = Новый Структура;
            Если РаспределятьНаНулевуюБазуЕслиОднаСтрока И (МассивБазы.Количество() = 1) И (МассивБазы[0] = 0) Тогда
                МассивБазы[0] = 1;
            КонецЕсли;
            Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
                Если СтрокаСумм[ИмяКолонкиСуммы] <> 0 Тогда
                    ТекРезультат =
                    		//КлиентСерверХЪ
                    		РаспределитьСуммуПропорциональноКоэффициентам(СтрокаСумм[ИмяКолонкиСуммы], МассивБазы, Точности[ИмяКолонкиСуммы]);
                    Если ТекРезультат = Неопределено Тогда
                        НоваяЗапись = Результат.Добавить();
                        ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
                        Для каждого ТекСтр Из ТекБаза Цикл
                            ОбратноеСоответствие[ТекСтр].Добавить(НоваяЗапись);
                        КонецЦикла;
                        Прервать;
                    Иначе
                        Распределённые.Вставить(ИмяКолонкиСуммы, ТекРезультат);
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла; 
            Если Распределённые.Количество() > 0 Тогда
                Для ЁЖЖ = 0 По Распределённые[ИменаКолонокСумм[0]].ВГраница() Цикл
                    НадоДобавитьЗапись = Ложь;
                    Для каждого КиЗ Из Распределённые Цикл
                        Если КиЗ.Значение[ЁЖЖ] <> 0 Тогда
                            НадоДобавитьЗапись = Истина;
                            Прервать;
                        КонецЕсли; 
                    КонецЦикла; 
                    Если НадоДобавитьЗапись Тогда
                        НоваяЗапись = Результат.Добавить();
                        ОбратноеСоответствие[ТекБаза[ЁЖЖ]].Добавить(НоваяЗапись); //ТекСтр
                        ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
                        ЗаполнитьЗначенияСвойств(НоваяЗапись, ТекБаза[ЁЖЖ]);
                        Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
                            НоваяЗапись[ИмяКолонкиСуммы] = 0;
                        КонецЦикла; 
                        Для каждого КиЗ Из Распределённые Цикл
                            НоваяЗапись[КиЗ.Ключ] = КиЗ.Значение[ЁЖЖ];
                        КонецЦикла; 
                    КонецЕсли;
                КонецЦикла;
            КонецЕсли; 
        КонецЦикла;
    #КонецОбласти 
    ИКСВсеСтрокой = СтрСоединить(ИменаКолонокСумм);
    #Область БАЗУ_В_РЕЗУЛЬТАТ
        ПоследнийРесурс = КолонкаБазы;
        //Базы заносятся отдельными строками, т.к. если заносить базы вместе с распределёнными суммами, то при повторном использовании строки базы её сумма попадёт в результат повторно.
        Если ПоместитьЗначенияБазыВРезультат = "КакЕсть" Тогда
        ИначеЕсли ПоместитьЗначенияБазыВРезультат = "Нет" Тогда
            //@skip-check wrong-type-expression
            Результат.Колонки.Удалить(КолонкаБазы);
            ПоследнийРесурс = "";
        Иначе
            Результат.ЗаполнитьЗначения(0, КолонкаБазы);
            Если ПоместитьЗначенияБазыВРезультат <> "Пустая" Тогда
                Для каждого КиЗ Из ОбратноеСоответствие Цикл
                    Если КиЗ.Ключ[КолонкаБазы] <> 0 Тогда
                        НужнаНоваяЗаписьРезультатаТолькоСБазой = Ложь;
                        Если КиЗ.Значение.Количество() = 0 Тогда
                            НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
                        Иначе
                            МассивБазы = Новый Массив;
                            Для каждого СтрСуммы Из КиЗ.Значение Цикл
                                МассивБазы.Добавить(СтрСуммы[ПоместитьЗначенияБазыВРезультат]);
                            КонецЦикла; 
                            //@skip-check server-execution-safe-mode
                            ТекРезультат =
									//КлиентСерверХЪ
									РаспределитьСуммуПропорциональноКоэффициентам(КиЗ.Ключ[КолонкаБазы], МассивБазы, ТочностьБазы);
                            Если ТекРезультат = Неопределено Тогда
                                НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
                                Прервать;
                            Иначе
                                Для СчХ = 0 По ТекРезультат.ВГраница() Цикл
                                    КиЗ.Значение[СчХ][КолонкаБазы] = КиЗ.Значение[СчХ][КолонкаБазы] + ТекРезультат[СчХ];
                                КонецЦикла;
                            КонецЕсли;
                        КонецЕсли;
                        Если НужнаНоваяЗаписьРезультатаТолькоСБазой Тогда
                            НоваяЗапись = Результат.Добавить();
                            ЗаполнитьЗначенияСвойств(НоваяЗапись, КиЗ.Ключ);
                        КонецЕсли;
                    КонецЕсли;
                КонецЦикла; 
            КонецЕсли;
        КонецЕсли;
    #КонецОбласти
    Результат.Свернуть(СтрСоединить(ИзмеренияРезультата), ИКСВсеСтрокой + ?((ИКСВсеСтрокой = "") ИЛИ (ПоследнийРесурс = ""), "", ",") + ПоследнийРесурс);
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // РаспределитьПоБазе

// Приводит колонки одной таблицы в соответствие другой.
// Параметры:
//  Приёмник  - ТаблицаЗначений, ДеревоЗначений - колонки которой меняются
//  Источник  - ТаблицаЗначений, ДеревоЗначений - колонки которой переносятся
//  Метод  - Число - метод переноса:
//          > 0 - Считать, что колонок источника заведомо нет в приёмнике и переносить без проверок;
//          > 1 - Добавить только недостающие колонки из источника;
//          > 2 - Удалить совпадающие по именам колонки в приёмнике и перенести все колонки источника;
//          > 3 - Удалить вообще все колонки приёмника и перенести все колонки источника. Используется, когда нельзя присвоить значение в источник (например, в реквизите формы).
//          > 4 - Проверять наличие колонки источника в приёмнике. Если колонка там есть, колонка источника будет добавлена под корректным сгенерированным именем.
//  НеДобавлятьКолонки  - Структура, Неопределено - Список колонок источника, не переносимых в приёмник. По умолчанию пустая строка.
//  СтруктураСоответствияКолонок  - Структура, Неопределено - Структура, в которой при Метод = 4 возвращается соответствие имён колонок (Ключ - имя в источнике, Значение - в приёмнике)
//  
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура СкоррелироватьКолонкиТаблиц(Приёмник, Источник, Метод = 3, НеДобавлятьКолонки = "", СтруктураСоответствияКолонок = Неопределено) Экспорт
    Если (Метод = 4) И (СтруктураСоответствияКолонок = Неопределено) Тогда
        СтруктураСоответствияКолонок = Новый Структура;
    КонецЕсли;
    Если Метод = 3 Тогда
        Приёмник.Колонки.Очистить();
    КонецЕсли;
    Для каждого Колонка Из Источник.Колонки Цикл
        Если
        		//КлиентСерверХЪ
        		НайтиПодстроку(НеДобавлятьКолонки, Колонка.Имя, ",") = 0 Тогда
            НовоеИмя = СкопироватьКолонку(Приёмник.Колонки, Колонка,, Метод);
            Если Метод = 4 Тогда
                СтруктураСоответствияКолонок.Вставить(Колонка.Имя, НовоеИмя);
            КонецЕсли;
        КонецЕсли; 
    КонецЦикла; 
КонецПроцедуры // СкоррелироватьКолонкиТаблиц()

#КонецОбласти 

#Область 				ПОЛУЧЕНИЕ_ТЗ

// Создаёт пустую таблицу значений с объединением колонок входящих
// Параметры:
//  СписокТаблиц  - СписокЗначений из Произвольный, Структура - а также Соответстввие из Произвольный, ТаблицаЗначений из Произвольный =
//  	Список соединяемых таблиц. ТЗ д.б. с колонкой Значение. В Значении содержатся объединяемые таблицы или деревья значений
//  ВернутьДерево  - Булево - При Истина возвращается ДеревоЗначений, при Ложь (по умолчанию) - ТаблицаЗначений
//  
// Возвращаемое значение:
//   ДеревоЗначений, ТаблицаЗначений из Произвольный - Пустой объект с объединением колонок
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВыгрузитьКолонкиГрупповая(СписокТаблиц, ВернутьДерево = Ложь) Экспорт
    Результат = ?(ВернутьДерево, Новый ДеревоЗначений, Новый ТаблицаЗначений);
    ОписаниеКолонок = Новый Структура;
    Для каждого Табличка Из СписокТаблиц Цикл
        Для каждого Колонка Из Табличка.Значение.Колонки Цикл
            Если ОписаниеКолонок.Свойство(Колонка.Имя) Тогда
                //@skip-check server-execution-safe-mode
                ОписаниеКолонок.Вставить(
                		Колонка.Имя,
                		Новый Структура("ТипЗначения,Заголовок,Ширина",
                			//КлиентСерверХЪ 
	                       	ОбъединитьОписанияТипов(
	                       		Колонка.ТипЗначения,
	                       		ОписаниеКолонок[Колонка.Имя].ТипЗначения),
	                        Колонка.Заголовок,
	                        Макс(Колонка.Ширина, ОписаниеКолонок[Колонка.Имя].Ширина)));
            Иначе
                ОписаниеКолонок.Вставить(Колонка.Имя, Новый Структура("ТипЗначения,Заголовок,Ширина", Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина));
            КонецЕсли; 
        КонецЦикла; 
    КонецЦикла; 
    Для каждого КиЗ Из ОписаниеКолонок Цикл
        Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение.ТипЗначения, КиЗ.Значение.Заголовок, КиЗ.Значение.Ширина);
    КонецЦикла; 
    Возврат Результат
КонецФункции // ВыгрузитьКолонкиГрупповая

//ЗагрузитьТаблицуЗначенийИзТабличногоДокумента и из файла - в КлиентСервере, т.к. возможен массив структур

// Создаёт таблицу значений с заданными колонками. Может использоваться во внешнем соединении.
// Параметры:
//  СтруктураКолонок  - Структура, Неопределено - Ключ = имя колонки, Значение = Тип колонки (Тип или ОписаниеТипов, если иное - колонка произвольного типа).
// Возвращаемое значение:
//  ТаблицаЗначений из Произвольный - Пустая, с заданными колонками (имена и типы)
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СоздатьТаблицуЗначений(СтруктураКолонок = Неопределено) Экспорт
    Результат = Новый ТаблицаЗначений;
    ТипТип = Тип("Тип");
    ТипОТ = Тип("ОписаниеТипов");
    Если СтруктураКолонок <> Неопределено Тогда
        Для Каждого КиЗ Из СтруктураКолонок Цикл
            ТекТип = ТипЗнч(КиЗ.Значение);
            Если ТекТип = ТипОТ Тогда
                Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение)
            ИначеЕсли ТекТип = ТипТип Тогда
                МассивТ = Новый Массив;
                МассивТ.Добавить(КиЗ.Значение);
                Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МассивТ))
            Иначе
                Результат.Колонки.Добавить(КиЗ.Ключ)
            КонецЕсли
        КонецЦикла
    КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьТаблицуЗначений()

// Создаёт таблицу значений с заданными строками колонками и значениями. Может использоваться во внешнем соединении.
// Параметры:
//  ИменаКолонок  - Строка - Имена колонок с разделителем ","
//  ТекстыЗначений - Строка - тексты значений колонок с разделителем
//  Разделитель - Строка - разделитель значений
//  ПрефиксФормулы - Строка - значение, начинающееся с этой строки, считается формулой.
//  ПараметрыВычисления  - Структура - Параметры, используемые при вычислении.
//Возвращаемое значение:
//  ТаблицаЗначений - Рассчитанная таблица значений. Например,
//      СоздатьТаблицуЗначенийИзСтрок("Кол1,Кол2", "1,Истина,17,СМОЛА,,ЧЕЛОВЕК") = ТЗ:
//      Кол1    Кол2
//      "1"     "Истина"
//      "17"    "СМОЛА"
//      ""      "ЧЕЛОВЕК"
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СоздатьТаблицуЗначенийИзСтрок(
		ИменаКолонок,
		ТекстыЗначений = "",
		Разделитель = ",",
		ПрефиксФормулы = "FRML",
		ПараметрыВычисления = Неопределено) Экспорт
    Результат = Новый ТаблицаЗначений;
    СтрокаКолонок = СтрЗаменить(ИменаКолонок, ",", Символы.ПС);
    ЧКол = СтрЧислоСтрок(СтрокаКолонок);
    Если ЧКол > 0 Тогда
        Для Ё = 1 По ЧКол Цикл
            Результат.Колонки.Добавить(СтрПолучитьСтроку(СтрокаКолонок, Ё))
        КонецЦикла;
        СимволХрюквы = "##ХРЮКВА__№";
        СтрокаЗначений = СтрЗаменить(СтрЗаменить(ТекстыЗначений, Символы.ПС, СимволХрюквы), Разделитель, Символы.ПС);
        ЧЗнч = СтрЧислоСтрок(СтрокаЗначений);
        ТекКол = Чкол;
        Для Ё = 1 По ЧЗнч Цикл
            Если ТекКол = ЧКол Тогда
                НоваяСтрока = Результат.Добавить();
                ТекКол = 0
            КонецЕсли;
            ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(СтрокаЗначений, Ё), СимволХрюквы, Символы.ПС);
            Если Лев(ТекЗнч, СтрДлина(ПрефиксФормулы)) = ПрефиксФормулы Тогда
                ТекстКода =  Сред(ТекЗнч, СтрДлина(ПрефиксФормулы) + 1);
                НачТекст = "Результат =";
                Если Лев(ТекстКода, СтрДлина(НачТекст))<> НачТекст Тогда
                    ТекстКода = НачТекст + ТекстКода;
                КонецЕсли;
                НоваяСтрока[ТекКол] = ВыполнитьКод(ТекстКода, ПараметрыВычисления, ТекстКода);
            Иначе
                НоваяСтрока[ТекКол] = ТекЗнч;
            КонецЕсли;
            ТекКол = ТекКол + 1
        КонецЦикла
    КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьТаблицуЗначенийИзСтрок()

// Формирует Таблицу значений из Дерева значений
// Параметры:
//  Дерево  - ДеревоЗначений - Источник
//  Таблица  - ТаблицаЗначений - Приёмник. Можно не указывать, тогда вернёт созданную заново.
//  ИмяКолонкиИД  - Строка - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы, начиная с 1
//  ИмяКолонкиРодителя  - Строка - Имя колонки, куда будет помещён ИД родителей. По умолчанию "Родитель". Если колонки с таким именем нет, она не создаётся и все строки попадут на один уровень.
//  ЗначениеРодителя    - Число - Значение, указываемое в создаваемых подстроках текущей ветви как ИД родителя.
//  
// Возвращаемое значение:
//   ТаблицаЗначений, Неопределено - сформированная из дерева
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ТаблицаЗначенийИзДерева(
		Дерево,
		Таблица = Неопределено,
		ИмяКолонкиИД = "",
		ИмяКолонкиРодителя = "Родитель",
		ЗначениеРодителя = 0) Экспорт
    Если Таблица = Неопределено Тогда
        Таблица = Новый ТаблицаЗначений;
        Если ТипЗнч(Дерево) = Тип("ДеревоЗначений") Тогда
            СкоррелироватьКолонкиТаблиц(Таблица, Дерево, 3);
        Иначе
            Таблица.Колонки.Добавить("Значение",
            		//ВызовСервераХЪ
            		ВсеСсылочныеИПростыеТипы());
        КонецЕсли;
        Таблица.Колонки.Вставить(0, ИмяКолонкиРодителя);
        Если ИмяКолонкиИД <> "" Тогда
            Таблица.Колонки.Вставить(0, ИмяКолонкиИД);
        КонецЕсли; 
    КонецЕсли; 
    НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
    НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
    Для каждого Строчка Из Дерево.Строки Цикл
        НоваяСтрока = Таблица.Добавить();
        ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка);//Колонки ИД и родителя отсутствуют в приёмнике
        Если НЕ НетКолонкиРодителя Тогда
            НоваяСтрока.Родитель = ЗначениеРодителя;
        КонецЕсли;
        Попытка
            ТекИД = Строчка[ИмяКолонкиИД];
        Исключение
            ТекИД = Таблица.Количество();
            Если НЕ НетКолонкиИД Тогда
                НоваяСтрока[ИмяКолонкиИД] = ТекИД;
            КонецЕсли;
        КонецПопытки;
        ТаблицаЗначенийИзДерева(Строчка, Таблица, ИмяКолонкиИД, ИмяКолонкиРодителя, ТекИД);
    КонецЦикла;
    Возврат Таблица
КонецФункции // ТаблицаЗначенийИзДерева()

// Преобразует массив структур в таблицу значений. Не работает, если в первой строке есть значения "Тип" или "Описания типов" (как данные таблицы).
// Параметры:
//  ФМассив  - Массив из Структура - или ФиксированныйМассив = Массив строк ТЗ или структур, соответствующих строкам новой таблицы
//  ВзятьДанныеНачинаяСИндекса  - Число - Индекс элемента массива, начиная с которого идут загружаемые данные. Например, если в первой структуре - типы колонок, то надо указать 1. По умолчанию 0.
//  Типизация  - Строка, ТаблицаЗначений - Вариант типизации колонок:
//      >ПоТипамСодержащимсяВПервой - по умолчанию, также любое иное значение = Типы берутся из значений первой структуры (первая строка должна содержать типы);
//      >ПоТипамЗначенийПервой - Типы определяются как типы значений первой (с индексом ВзятьДанныеНачинаяСИндекса) структуры;
//      >ПоВсем - Типы определяются по значениям ключа из всех структур, начиная с ВзятьДанныеНачинаяСИндекса;
//      >Нет - не типизируется;
//      >ТаблицаЗначений - переменная для помещения результата. Если содержит таблицу, записи будут добавлены в конец только в части уже имеющихся реквизитов
//  ДлинаСтрок  - Число - Длина строк для типизации ПоТипамЗначенийПервой:
//      >-2 - По фактическим значениям
//      >-1 - Не ограничивать (По умолчанию)
//      >Прочее - устанавливается заданное значение.
// Возвращаемое значение:
//   ТаблицаЗначений   - собранная из массива
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТЗизМассиваСтруктур(ФМассив, ВзятьДанныеНачинаяСИндекса = 0, Типизация = "ПоЗначениямПервой", ДлинаСтрок = -1) Экспорт
    Колво = ФМассив.Количество();
    ТТЗ = ТипЗнч(Типизация) = Тип("ТаблицаЗначений");
    Если Колво = 0 Тогда
        Результат = ?(ТТЗ, Типизация, Новый ТаблицаЗначений);
    Иначе
        НачИндекс = ВзятьДанныеНачинаяСИндекса;
        ЕстьДанные = Колво > ВзятьДанныеНачинаяСИндекса;
        ТПоПервой = Типизация = "ПоТипамЗначенийПервой";
        ТПоВсем = Типизация = "ПоВсем";
        ТНет = Типизация = "Нет";
        Если ЕстьДанные И ТПоПервой Тогда
            Результат = ТЗизСтруктуры(ФМассив[НачИндекс], Истина, ДлинаСтрок);
            НачИндекс = НачИндекс + 1;
        ИначеЕсли ЕстьДанные И ТПоВсем Тогда
            СТипы = Новый Структура;
            Для каждого КиЗ Из ФМассив[НачИндекс] Цикл
                СТипы.Вставить(
                		КиЗ.Ключ,
						//КлиентСерверХЪ
                		ПолучитьОписаниеТипаЗначения(КиЗ.Значение));
            КонецЦикла;
            Для СчСтр = НачИндекс + 1 По Колво - 1 Цикл
                Для каждого КиЗ Из ФМассив[СчСтр] Цикл
                    СТипы.Вставить(
                    		КиЗ.Ключ,
							//КлиентСерверХЪ
                    		ОбъединитьОписанияТипов(
								//КлиентСерверХЪ
                            	ПолучитьОписаниеТипаЗначения(КиЗ.Значение),
                            	СТипы[КиЗ.Ключ]));
                КонецЦикла;
            КонецЦикла;
            МТипы = Новый Массив;
            МТипы.Добавить(СТипы);
            Результат = ТЗизМассиваСтруктур(МТипы, 1);
        ИначеЕсли ЕстьДанные И ТНет Тогда
            Результат = ТЗизСтруктуры(ФМассив[НачИндекс]);
            НачИндекс = НачИндекс + 1;
        ИначеЕсли ТТЗ Тогда
            Результат = Типизация;
        ИначеЕсли ТНет ИЛИ ТПоПервой ИЛИ ТПоВсем Тогда
            Результат = ТЗизСтруктуры(ФМассив[0]);
            Результат.Удалить(Результат[0]);
        Иначе
            ПерваяСтрока = ФМассив[0];
            Результат = СоздатьТаблицуЗначений(ПерваяСтрока);
        КонецЕсли;
        Для СчСтр = НачИндекс По Колво - 1 Цикл
            ЗаполнитьЗначенияСвойств(Результат.Добавить(), ФМассив[СчСтр]);
        КонецЦикла;
    КонецЕсли;
    //@skip-check constructor-function-return-section
    Возврат Результат
КонецФункции // ТЗизМассиваСтруктур

// Формирует таблицу значений из списка значений ячеек
// Параметры:
//  СписокЯчеек  - ТаблицаЗначений - Колонки НомерСтроки, ИмяКолонки, ЗначениеЯчейки.
//      Или, если такие имена не заданы = берутся три первые колонки в указанном порядке. Если нет только колонки НомерСтроки, то все данные грузятся в одну строку.
//  МэппингИмёнКолонок  - Соответствие из Тип, Структура, Неопределено - соответствие имён колонок значениям из колонки
//  	ИмяКолонки. Если задано, в результате будут только колонки из значений соответствия.
// Возвращаемое значение:
//   ТаблицаЗначений   - Содержит все колонки, перечисленные в ИмяКолонки, и столько строк, сколько разных значений в колонке НомерСтроки.
//      Если в колонке НомерСтроки найдены нечисловые значения, то в результате будет и колонка НомерСтроки, по значениям которой будут отсортированы строки.
//      Отсутствующие в исходной таблице значения в результате будут представлены как Неопределено
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТЗизСпискаЯчеек(СписокЯчеек, МэппингИмёнКолонок = Неопределено) Экспорт
    #Область КОЛОНКИ_ИСТОЧНИКА
        //Результат области: имена колонок источника в КолонкаНС, КолонкаИК, КолонкаЗЯ, если колонки НС нет, то ПервойНет = Истина
        КолонкиСписка = СписокЯчеек.Колонки;
        ПервыеТри = Ложь;
        ПервойНет = Ложь;
        КолонкаИК = КолонкиСписка.Найти("ИмяКолонки");
        КолонкаЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки");
        НетКИК = КолонкиСписка.Найти("ИмяКолонки") = Неопределено;
        НетКЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки") = Неопределено;
        Если НетКИК Тогда
            ИндексИК = -1;
            ПервыеТри = Истина;
        Иначе
            ИндексИК = КолонкиСписка.Индекс(КолонкаИК);
            КолонкаИК = "ИмяКолонки";
        КонецЕсли;
        Если НетКЗЯ Тогда
            ИндексЗЯ = -1;
            ПервыеТри = Истина;
        Иначе
            ИндексЗЯ = КолонкиСписка.Индекс(КолонкаЗЯ);
            КолонкаЗЯ = "ЗначениеЯчейки";
        КонецЕсли;
        Если ПервыеТри Тогда
            ИндексНС = ?(ИндексИК = 0 ИЛИ ИндексЗЯ = 0, ?(ИндексИК = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
            КолонкаНС = КолонкиСписка[ИндексНС].Имя;
            Если ИндексИК = -1 Тогда
                ИндексИК = ?(КолонкаНС = 0 ИЛИ ИндексЗЯ = 0, ?(КолонкаНС = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
                КолонкаИК = КолонкиСписка[ИндексИК].Имя;
            КонецЕсли;
            Если ИндексЗЯ = -1 Тогда
                КолонкаЗЯ = КолонкиСписка[?(КолонкаНС = 0 ИЛИ ИндексИК = 0, ?(КолонкаНС = 1 ИЛИ ИндексИК = 1, 2, 1), 0)].Имя;
            КонецЕсли;
        Иначе
            Если КолонкиСписка.Найти("НомерСтроки") = Неопределено Тогда
                ПервойНет = Истина;
            Иначе
                КолонкаНС = "НомерСтроки";
            КонецЕсли;
        КонецЕсли;
    #КонецОбласти 
    
    Результат = Новый ТаблицаЗначений;
    #Область СТРОКИ_И_КОЛОНКИ
        Если ПервойНет Тогда
            ЕдинственнаяСтрока = Результат.Добавить();
        Иначе
            ИменаСтрок = СписокЯчеек.Скопировать(, КолонкаНС);
            ИменаСтрок.Свернуть(КолонкаНС);
            СтрокиРезультата = Новый Соответствие;
            Результат.Колонки.Добавить(КолонкаНС);
            Для каждого ИмяСтроки Из ИменаСтрок Цикл
                СтрокиРезультата.Вставить(ИмяСтроки[КолонкаНС], Результат.Добавить());
                СтрокиРезультата[ИмяСтроки[КолонкаНС]].НомерСтроки = ИмяСтроки[КолонкаНС];
            КонецЦикла;
        КонецЕсли;
         
        ИменаКолонок = СписокЯчеек.Скопировать(, КолонкаИК);
        ИменаКолонок.Свернуть(КолонкаИК);
        Если МэппингИмёнКолонок = Неопределено Тогда
            КолонкиРезультата = Новый Соответствие;
            Для каждого ИмяКолонки Из ИменаКолонок Цикл
                Результат.Колонки.Добавить(ИмяКолонки[КолонкаИК]);
                КолонкиРезультата.Вставить(ИмяКолонки[КолонкаИК], ИмяКолонки[КолонкаИК]);
            КонецЦикла;
        Иначе
            КолонкиРезультата = МэппингИмёнКолонок;
            Для каждого КиЗ Из КолонкиРезультата Цикл
                Результат.Колонки.Добавить(КиЗ.Значение);
            КонецЦикла;
        КонецЕсли;
    #КонецОбласти
    
    #Область ЗНАЧЕНИЯ_ЯЧЕЕК
        Для каждого СтрЗЯ Из СписокЯчеек Цикл
            ТекИК = КолонкиРезультата[СтрЗЯ[КолонкаИК]];
            Если ТекИК <> Неопределено Тогда
                Если ПервойНет Тогда
                    ТекСтр = ЕдинственнаяСтрока;
                Иначе
                    ТекСтр = СтрокиРезультата[СтрЗЯ[КолонкаНС]];
                КонецЕсли;
                ТекСтр[КолонкиРезультата[СтрЗЯ[КолонкаИК]]] = СтрЗЯ[КолонкаЗЯ];
            КонецЕсли; 
        КонецЦикла;
    #КонецОбласти 
    Если НЕ ПервойНет Тогда
        Результат.Сортировать(КолонкаНС);
        Результат.Колонки.Удалить(КолонкаНС);
    КонецЕсли; 
    
    Возврат Результат
КонецФункции // ТЗизСпискаЯчеек

// Создаёт однострочную таблицу значений из структуры
// Параметры:
//  Источник  - Структура, Соответствие из Произвольный - Источник данных, ключи - имена колонок
//  Типизировать  - Булево - Истина - колонки типизируются (по умолчанию Ложь)
//  ДлинаСтрок  - Число - Ограничение длин строк (12 = Пофакту; -1 = Не ограничивать(По умолчанию))
// Возвращаемое значение:
//   ТаблицаЗначений   - Первая строка содержит значения из структуры
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ТЗизСтруктуры(Источник, Типизировать = Ложь, ДлинаСтрок = -1) Экспорт
    Результат = Новый ТаблицаЗначений;
    ТипСтрока = Тип("Строка");
    Если Типизировать Тогда
        Для каждого КиЗ Из Источник Цикл
            МТипы = Новый Массив;
            ТекТип = ТипЗнч(КиЗ.Значение);
            МТипы.Добавить(ТекТип);
            Если ТекТип = ТипСтрока И ДлинаСтрок <> -1 Тогда
                Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы,, Новый КвалификаторыСтроки(?(ДлинаСтрок = -2, СтрДлина(КиЗ.Значение), ДлинаСтрок))));
            Иначе
                Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы));
            КонецЕсли;
        КонецЦикла;
    Иначе
        Для каждого КиЗ Из Источник Цикл
            Результат.Колонки.Добавить(КиЗ.Ключ);
        КонецЦикла;
    КонецЕсли;
    ЗаполнитьЗначенияСвойств(Результат.Добавить(), Источник);
    Возврат Результат
КонецФункции // ТЗизСтруктуры

#КонецОбласти

#Область 				ПРОЦЕДУРА_ОБЪЕДИНИТЬ_ТАБЛИЦЫ
    
//Вспомогательная к следующей экспортной процедуре
&НаСервереБезКонтекста
Процедура ЗаполнитьСтрокиПоСтруктурам(ТабПриёмник, ТабИсточник, СтруктураКопируемыхКолонок, СтруктураВычисляемыхКолонок)
    Для каждого СтрокаИсточник из ТабИсточник Цикл
        СтрокаПриёмник = ТабПриёмник.Добавить();
        Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
            СтрокаПриёмник[Колонка.Ключ] = СтрокаИсточник[Колонка.Значение]
        КонецЦикла;
        Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
            //@skip-check server-execution-safe-mode
            СтрокаПриёмник[Колонка.Ключ] = Вычислить(Колонка.Значение)
        КонецЦикла
    КонецЦикла
КонецПроцедуры

//Вспомогательная к следующей экспортной процедуре
&НаСервереБезКонтекста
Функция ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, Ключ, ТипНовой, ШиринаНовой = 0, ЭтоВычисляемая = Ложь, ВызывающаяФорма = Неопределено)
    Если КолонкиРезультата.Свойство(Ключ) Тогда
        Если НЕ ЭтоВычисляемая Тогда
            КолонкиРезультата[Ключ].ТипЗначения =
					//КлиентСерверХЪ
            		ОбъединитьОписанияТипов(КолонкиРезультата[Ключ].ТипЗначения, ТипНовой);
            Если КолонкиРезультата[Ключ].Ширина <> 0 Тогда
                КолонкиРезультата[Ключ].Ширина = Макс(КолонкиРезультата[Ключ].Ширина, ШиринаНовой);
            КонецЕсли;
        КонецЕсли; 
        Возврат Истина;
    Иначе
        Если ЭтоВычисляемая Тогда
            КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ,, 0));
        Иначе
            КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ, ТипНовой, ШиринаНовой));
        КонецЕсли; 
        Возврат Ложь;
    КонецЕсли; 
КонецФункции

// Объединяет несколько таблиц в одну с учётом типов колонок
// Параметры:
//  СтруктураТаблиц - Массив из Структура, Структура, ФиксированнаяСтруктура - возможно СписокЗначений из Структура =
//  		или Соответствие из Структура =
//  		Состоит из структур или ФС с информацией об объединяемых таблицах с полями:
//              >Таблица - сама таблица (таблица значений или табличная часть);
//              >СтруктураКопируемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - имя источника
//              >СтруктураВычисляемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - формула с возможностью
//                      применения переменных СтрокаИсточник, СтрокаПриёмник, ТабИсточник и ТабПриёмник;
//              >ОсобыеПоля - строка с именами колонок через ПС или запятую;
//              >ВзятьОсобые - Булево. Если Истина, то переносятся Особые поля и поля из СКК и СВК. Если ложь или не указан - переносятся поля из СКК и СВК, а также все поля, не перечисленные в Особых.
//          Если этот параметр - не массив, тогда структуры находятся в значениях.
// Возвращаемое значение:
//   ТаблицаЗначений   - Таблица, содержащая объединение таблиц по заданным правилам. Например, чтобы перенести все колонки "один в один", достаточно заполнить ключ "Таблица".
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ОбъединитьТаблицы(СтруктураТаблиц) Экспорт
    Результат = Новый ТаблицаЗначений;

    #Область ФОРМИРОВАНИЕ_МАССИВА_ОПИСАНИЙ_ТАБЛИЦ
    ТипПараметра = ТипЗнч(СтруктураТаблиц);
    Если (ТипПараметра = Тип("Структура")) ИЛИ (ТипПараметра = Тип("ФиксированнаяСтруктура"))
            ИЛИ (ТипПараметра = Тип("Соответствие")) ИЛИ (ТипПараметра = Тип("ФиксированноеСоответствие")) ИЛИ (ТипПараметра = Тип("СписокЗначений")) Тогда
        МассивТаблиц = Новый Массив;
        Для каждого КиЗ Из СтруктураТаблиц Цикл
            МассивТаблиц.Добавить(КиЗ.Значение);
        КонецЦикла; 
    ИначеЕсли (ТипПараметра = Тип("Массив")) ИЛИ (ТипПараметра = Тип("ФиксированныйМассив")) Тогда
        МассивТаблиц = СтруктураТаблиц;
    Иначе
        МассивТаблиц = Новый Массив;
    КонецЕсли;
    #КонецОбласти

    #Область Формирование_описаний_колонок
    //определяются для квалификаторов:
    //ЧастиДаты,Длина,ДопустимаяДлина,ЧислоРазрядов,ЧислоРазрядовДробнойЧасти,ДопустимыйЗнак,ДлинаСтроки,ДопустимаяДлина 
    КолонкиРезультата = Новый Структура;
    Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
        Если ОписаниеТаблицы.Свойство("ВзятьОсобые") Тогда
            Если ТипЗнч(ОписаниеТаблицы.ВзятьОсобые) <> Тип("Булево") Тогда
                ОписаниеТаблицы.ВзятьОсобые = Ложь;
            КонецЕсли;
        Иначе
            ОписаниеТаблицы.Вставить("ВзятьОсобые", Ложь);
        КонецЕсли;
        Если НЕ ОписаниеТаблицы.Свойство("ОсобыеПоля") Тогда
            ОписаниеТаблицы.Вставить("ОсобыеПоля", "");
        КонецЕсли;
        Если ОписаниеТаблицы.Свойство("СтруктураКопируемыхКолонок") Тогда
            Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураКопируемыхКолонок Цикл
                КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ОписаниеКолонки.Значение);
                Если КолонкаИсточник = Неопределено Тогда
                    ОписаниеТаблицы.СтруктураКопируемыхКолонок.Удалить(ОписаниеКолонки.Ключ);
                Иначе
                    ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, КолонкаИсточник.ТипЗначения, КолонкаИсточник.Ширина);
                    Если (НЕ ОписаниеТаблицы.ВзятьОсобые) И (СтрНайти(ОписаниеТаблицы.ОсобыеПоля, ОписаниеКолонки.Значение) = 0) Тогда
                        //Иначе колонка задублируется под другим именем
                        ОписаниеТаблицы.ОсобыеПоля = ОписаниеТаблицы.ОсобыеПоля + Символы.ПС + ОписаниеКолонки.Значение;
                    КонецЕсли; 
                КонецЕсли; 
            КонецЦикла;
        Иначе
            ОписаниеТаблицы.Вставить("СтруктураКопируемыхКолонок", Новый Структура);
        КонецЕсли; 
        Если ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок") Тогда
            //Вычисляемая колонка не меняет типа колонки, если он ранее задан, а если колонка новая - то тип будет произвольный.
            Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураВычисляемыхКолонок Цикл
                ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, Неопределено,, Истина);
            КонецЦикла;
        КонецЕсли; 
        Если ОписаниеТаблицы.ВзятьОсобые Тогда
            СтрокаПолей = СтрЗаменить(ОписаниеТаблицы.ОсобыеПоля, ",", Символы.ПС);
            Для Ё = 1 По СтрЧислоСтрок(СтрокаПолей) Цикл
                ТекИмя = СтрПолучитьСтроку(СтрокаПолей, Ё);
                КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ТекИмя);
                Если КолонкаИсточник <> Неопределено Тогда
                    ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
                    ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
                КонецЕсли; 
            КонецЦикла;
            ОписаниеТаблицы.ОсобыеПоля = "";
        Иначе
            Для каждого КолонкаИсточник Из ОписаниеТаблицы.Таблица.Колонки Цикл
                ТекИмя = КолонкаИсточник.Имя;
                Если (СтрНайти(ОписаниеТаблицы.ОсобыеПоля, ТекИмя) = 0) Тогда
                    ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
                    ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
                КонецЕсли; 
            КонецЦикла; 
        КонецЕсли; 
    КонецЦикла;
    #КонецОбласти 
    
    Для каждого ОписаниеКолонки Из КолонкиРезультата Цикл
        Результат.Колонки.Добавить(ОписаниеКолонки.Ключ, ОписаниеКолонки.Значение.ТипЗначения, ОписаниеКолонки.Значение.Заголовок, ОписаниеКолонки.Значение.Ширина)
    КонецЦикла; 
    
    Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
        ЗаполнитьСтрокиПоСтруктурам(Результат, ОписаниеТаблицы.Таблица, ОписаниеТаблицы.СтруктураКопируемыхКолонок,
                ?(ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок"), ОписаниеТаблицы.СтруктураВычисляемыхКолонок, Новый Структура));
    КонецЦикла;
    
    Возврат Результат
КонецФункции // ОбъединитьТаблицы()
 
#КонецОбласти 

#Область 				ПРЕОБРАЗОВАНИЯ_В_ДРУГИЕ_ТИПЫ
    
// Записывает файл Excel с данными из таблицы значений.
// Параметры:
//  ИмяФайла_  - Строка - Имя записываемого файла
//  ТабЗн  - ТаблицаЗначений - Данные для записи
//  ВыводитьЗаголовки  - Булево - 
// Возвращаемое значение:
//   Строка   - Описание ошибки. Пустое, если ошибки нет
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ExcelИзТаблицыЗначений(ИмяФайла_, ТабЗн, ВыводитьЗаголовки = Истина) Экспорт
    Результат = "";
    ТабДокумент = Новый ТабличныйДокумент;
    Попытка
        Если ВыводитьЗаголовки Тогда
            СчКол = 1;
            Для каждого Колонка Из ТабЗн.Колонки Цикл
                ТабДокумент.Область(1, СчКол, 1, СчКол).Текст = СокрЛП(Колонка.Имя);
                СчКол = СчКол + 1;
            КонецЦикла; 
        КонецЕсли;
        СчСтр = 1;
        Для каждого Строчка Из ТабЗн Цикл
            СчКол = 1;
            СчСтр = СчСтр + 1;
            Для каждого Колонка Из ТабЗн.Колонки Цикл
                ТабДокумент.Область(СчСтр, СчКол, СчСтр, СчКол).Текст = СокрЛП(Строчка[Колонка.Имя]);
                СчКол = СчКол + 1;
            КонецЦикла; 
        КонецЦикла;
        ТабДокумент.Записать(ИмяФайла_, ТипФайлаТабличногоДокумента.XLSX);
    Исключение
        Результат = ОписаниеОшибки();
    КонецПопытки;
    Возврат Результат
КонецФункции // ExcelИзТаблицыЗначений()

// Выгружает свёрнутую колонку таблицы значений
// Параметры:
//  ТЗначений  - ТаблицаЗначений - Откуда выгружать колонку
//  ИмяКолонки  - Строка - Имя выгружаемой колонки
//  УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
// Возвращаемое значение:
//   Массив из Произвольный  - выгруженная свёрнутая колонка
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ВыгрузитьСвёрнутуюКолонку(ТЗначений, ИмяКолонки, УдалитьПустые = Ложь) Экспорт
    ВремТаб = ТЗначений.Скопировать(, ИмяКолонки);
    ВремТаб.Свернуть(ИмяКолонки);
    Если УдалитьПустые Тогда
        Результат = Новый Массив();
        Для каждого Строчка Из ВремТаб Цикл
            Если ЗначениеЗаполнено(Строчка[0]) Тогда
                Результат.Добавить(Строчка[0]);
            КонецЕсли; 
        КонецЦикла; 
    Иначе
        Результат = ВремТаб.ВыгрузитьКолонку(ИмяКолонки);
    КонецЕсли; 
    Возврат Результат
КонецФункции // ВыгрузитьСвёрнутуюКолонку()

// Формирует дерево значений из таблицы значений
// Параметры:
//  Таблица  - ТаблицаЗначений - Источник
//  ВетвьРодитель  - СтрокаДереваЗначений - любое другое значение будет преобразовано в дерево значений = Ветвь дерева, в которую будут добавляться строки
//  ИмяКолонкиИД  - Строка, Соответствие из Число - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы. Может быть передано соответствие, где ключ - строка таблицы значений, а значение - её номер.
//  ИмяКолонкиРодителя  - Строка - Имя колонки, содержащей ИД родителей. По умолчанию "Родитель". Если колонки не обнаружено, все строки попадут в корень дерева.
//  ЗначениеРодителя  - Произвольный - ИД родителя, по которому будут искаться строки в таблице.
//  СтрокаЗапрещённыхПолей  - Строка    - Имена полей через запятую, которые не должны переноситься. Следует учитывать, что в дереве "Родитель" и "Строки" - реквизиты, и при наличии таких полей в источнике их надо запретить.
//  
// Возвращаемое значение:
//   ДеревоЗначений, СтрокаДереваЗначений, Неопределено - ВетвьРодитель = Дерево значений или его строка (ветвь).
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ДеревоИзТаблицыЗначений(
		Таблица,
		ВетвьРодитель = Неопределено,
		ИмяКолонкиИД = "",
		ИмяКолонкиРодителя = "Родитель",
		ЗначениеРодителя = "",
		СтрокаЗапрещённыхПолей = "") Экспорт
    Если ВетвьРодитель = Неопределено Тогда
        //Инициализация дерева
        ВетвьРодитель = Новый ДеревоЗначений;
        ПозКолРодителя = 
					//КлиентСерверХЪ
    	            НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиРодителя);
    	 ПозКолИД =
					//КлиентСерверХЪ
    	            НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиИД);
         СкоррелироватьКолонкиТаблиц(
        		ВетвьРодитель,
        		Таблица,
        		3,
                ?(ПозКолРодителя = 0, "", ИмяКолонкиРодителя) + ",",
                ?(ПозКолИД = 0, "", ИмяКолонкиИД));
    КонецЕсли; 
    Если ТипЗнч(ИмяКолонкиИД) = Тип("Соответствие") Тогда
        НетКолонкиИД = Истина;
        СоответствиеНомеровСтрок = ИмяКолонкиИД;
    Иначе
        НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
        Если НетКолонкиИД Тогда
            СоответствиеНомеровСтрок = Новый Соответствие;
            НСТ = 1;
            Для каждого Строчка Из Таблица Цикл
                СоответствиеНомеровСтрок.Вставить(Строчка, НСТ);
                НСТ = НСТ + 1;
            КонецЦикла; 
        КонецЕсли; 
    КонецЕсли;
    НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
    //Обработка незаписываемых реквизитов дерева
    Если СтрокаЗапрещённыхПолей = "" Тогда
        Если Таблица.Колонки.Найти("Родитель") = Неопределено Тогда
            Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
                СтрокаЗапрещённыхПолей = "";
            Иначе
                СтрокаЗапрещённыхПолей = "Строки";
            КонецЕсли; 
        Иначе
            Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
                СтрокаЗапрещённыхПолей = "Родитель";
            Иначе
                СтрокаЗапрещённыхПолей = "Родитель,Строки";
            КонецЕсли; 
        КонецЕсли; 
    КонецЕсли; 
    Источник = ?(НетКолонкиРодителя, Таблица, Таблица.НайтиСтроки(Новый Структура(ИмяКолонкиРодителя, ЗначениеРодителя)));
    Для каждого Строчка Из Источник Цикл
        НоваяСтрока = ВетвьРодитель.Строки.Добавить();
        ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка,, СтрокаЗапрещённыхПолей);//Колонки ИД и родителя отсутствуют в приёмнике
        Если НЕ НетКолонкиРодителя Тогда
            Если НетКолонкиИД Тогда
                ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, СоответствиеНомеровСтрок, ИмяКолонкиРодителя, СоответствиеНомеровСтрок[Строчка]);
            Иначе
                ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, ИмяКолонкиИД, ИмяКолонкиРодителя, Строчка[ИмяКолонкиИД]);
            КонецЕсли; 
        КонецЕсли; 
    КонецЦикла;
    Возврат ВетвьРодитель
КонецФункции // ДеревоИзТаблицыЗначений()
 
// Преобразует таблицу значений в фиксированный массив фиксированных структур.
// Для обычных массивов и структур следует использовать ОбщегоНазначения.
// Параметры:
//  ТЗначений  - ТаблицаЗначений - Преобразуемая таблица
//  ТипыКолонок  - Булево - В первом элементе возвращаемого массива структура типов колонок. По умолчанию Ложь (первый элемент - обычная строка).
// Возвращаемое значение:
//   ФиксированныйМассив из Структура - Фиксированные структуры, соответствующие строкам
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция МассивСтруктурИзТаблицы(ТЗначений, ТипыКолонок = Ложь) Экспорт
    Результат = Новый Массив;
    Заголовки = Список_Колонок(ТЗначений);
    Если ТипыКолонок Тогда
        Эмулятор = Новый Структура;
        Для каждого Колонка Из ТЗначений.Колонки Цикл
            Эмулятор.Вставить(Колонка.Имя, Колонка.ТипЗначения);
        КонецЦикла;
        Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
    КонецЕсли;
    Для каждого Строчка Из ТЗначений Цикл
        Эмулятор = Новый Структура(Заголовки);
        ЗаполнитьЗначенияСвойств(Эмулятор, Строчка);
        Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
    КонецЦикла;
    Возврат Новый ФиксированныйМассив(Результат)
КонецФункции // МассивСтруктурИзТаблицы

// Возвращает структуру, полученную из таблицы значений
// Параметры:
//  ТабЗНач - ТаблицаЗначений - (табличная часть или массив строк) = источник данных
//  ИмяКолонкиКлючей - Строка - имя колонки,значения которой будут ключами (по умолчанию первая колонка).
//          Если указаны имена нескольких колонок через запятую, то ключом будет объединение строковых представлений колонок.
//  ИмяКолонкиЗначений - Строка - имя колонки,значения которой будут значениями (по умолчанию вторая (а если второй нет - первая) колонка).
//          м.б. "#ВсяСтрока" - значением будет вся строка.
//  ВернутьСоответствие - Булево - тип результата (Истина = Соответствие, Ложь(по умолчанию) = Структура). Автоопределений нет.
//  Колонки_ - КоллекцияКолонокТаблицыЗначений - колонки ТабЗнач. Если Неопределено (по умолчанию) - получаются из ТабЗнач.
// Возвращаемое значение:
//  Структура, Соответствие из Произвольный - структура с ключами из колонки ключей и значениями из колонки значений
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СтруктураИзКолонокТаблицы(
		ТабЗНач,
		ИмяКолонкиКлючей = "",
		ИмяКолонкиЗначений = "",
		ВернутьСоответствие = Ложь,
		Колонки_ = Неопределено) Экспорт
    Если Колонки_ = Неопределено Тогда
        Колонки_ = ТабЗнач.Колонки;
    КонецЕсли; 
    Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
    Колонок = Колонки_.Количество();
    Если Колонок = 0 Тогда
        Возврат Результат
    КонецЕсли;
    Если Не ЗначениеЗаполнено(ИмяКолонкиКлючей) Тогда
        ИмяКолонкиКлючей_ = Колонки_[0].Имя;
        КлючСтрока = НЕ ВернутьСоответствие;
    Иначе
        ИмяКолонкиКлючей_ = ИмяКолонкиКлючей;
        КлючСтрока = (СтрНайти(ИмяКолонкиКлючей, ",") > 0) ИЛИ НЕ ВернутьСоответствие;
    КонецЕсли;
    ИменаКолонокКлючей = СтрРазделить(ИмяКолонкиКлючей_, ",", Ложь);
    ИмяКолонкиЗначений_ = ?(Не ЗначениеЗаполнено(ИмяКолонкиЗначений),
            ?(Колонок = 1, Колонки_[0].Имя, Колонки_[1].Имя), ИмяКолонкиЗначений);
    ЭтоВсяСтрока = ИмяКолонкиЗначений_ = "#ВсяСтрока";
    Для Каждого Строчка Из ТабЗНач Цикл
        Если КлючСтрока Тогда
            Ключ = "";
            Для каждого ТекКлюч Из ИменаКолонокКлючей Цикл
                Ключ = Ключ + Строчка[ТекКлюч];
            КонецЦикла;
        Иначе
            Ключ = Строчка[ИмяКолонкиКлючей_];
        КонецЕсли;
        Результат.Вставить(Ключ, ?(ЭтоВсяСтрока, Строчка, Строчка[ИмяКолонкиЗначений_]))
    КонецЦикла;
    Возврат Результат
КонецФункции

// Возвращает структуру, созданную по строке таблицы значений
// Параметры:
//  Источник - ТаблицаЗначений - Таблица, значения заданной строки которой будут перенесены в структуру
//  ИндексСтроки - Число - Индекс строки, преобразуемой в структуру. Если превышает пределы таблицы = будет возвращена пустая структура
//  Ключи - Строка - Список имён колонок, преобразуемых в ключи
// Возвращаемое значение:
//   Структура   - преобразованная строка таблицы
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СтруктураИзСтрокиТЗ(Источник, ИндексСтроки = 0, Ключи = "") Экспорт
    Результат = Новый Структура(Ключи);
    Если Источник.Количество() > ИндексСтроки Тогда
        Если Ключи = "" Тогда
            Для каждого Колонка Из Источник.Колонки Цикл
                Результат.Вставить(Колонка.Имя, Источник[ИндексСтроки][Колонка.Имя]);
            КонецЦикла;
        Иначе
            ЗаполнитьЗначенияСвойств(Результат, Источник[ИндексСтроки]);
        КонецЕсли; 
    КонецЕсли;
    Возврат Результат
КонецФункции // СтруктураИзСтрокиТЗ

#КонецОбласти 

#Область 				ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
    
//Изменяет тип колонки таблицы значений и заполняет её заданным значением
//Параметры:
//   ТабЗнач    - ТаблицаЗначений - В которой будет заполнена колонка
//   Значение   - Произвольный - Которым будет заполнена колонка
//   ИмяКолонки - Строка - имя заполняемой колонки
//  
//Возвращаемое значение:
//  ТаблицаЗначений - с заплненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЗаполнитьЗначениеВКолонку(ТабЗнач, Значение, ИмяКолонки) Экспорт
    Если ТабЗнач.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
        ТабЗнач.Колонки.Удалить(ИмяКолонки)
    КонецЕсли;
    ТабЗнач.Колонки.Добавить(
    		ИмяКолонки,
    		//КлиентСерверХЪ 
    		ПолучитьОписаниеТипаЗначения(Значение));
    ТабЗнач.ЗаполнитьЗначения(Значение, ИмяКолонки);
    Возврат ТабЗнач
КонецФункции

//Приводит сумму колонки таблицы к нужному значению
//Параметры:
//  Таблица - ТаблицаЗначений, КоллекцияСтрокДереваЗначений - коллекция, по колонке которой надо перераспределит сумму
//  Реквизит - Строка - Имя колонки, по которой распределяется сумма
//  Сумма - Число - распределяемая сумма
//  Точность - Число - количество знаков после запятой в рассчитанных суммах
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ПривестиТабКСумме(Таблица, Реквизит, Сумма, Знач Точность = 2) Экспорт
    Если Сумма = 0 Тогда
        Таблица.ЗаполнитьЗначения(Сумма, Реквизит);
    ИначеЕсли Таблица.Итог(Реквизит) <> 0 Тогда
        Таблица.ЗагрузитьКолонку(
    			//КлиентСерверХЪ 
        		РаспределитьСуммуПропорциональноКоэффициентам(Сумма, Таблица.ВыгрузитьКолонку(Реквизит), Точность),
        		Реквизит);
    КонецЕсли;
КонецПроцедуры

// Возвращает таблицу значений с пронумерованными строками. Может использоваться как процедура.
// Параметры:
//  Таблица  - ТаблицаЗначений - подлежит нумерации
//  ИмяКолонки  - Строка - Имя колонки с номером
//  ПервыйНомер  - Число - номер первой строки
// Возвращаемое значение:
//   ТаблицаЗначений   - Та же, что и передана, но с колонкой номера строки.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ПронумероватьТаблицуЗначений(Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1) Экспорт
    Результат = Таблица;
    Результат.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число"));
    Нумератор_ = ПервыйНомер;
    Для каждого СтрокаТ Из Результат Цикл
        СтрокаТ[ИмяКолонки] = Нумератор_;
        Нумератор_ = Нумератор_ + 1;
    КонецЦикла; 
    Возврат Результат
КонецФункции // ПронумероватьТаблицуЗначений

// Объединяет "смежные" интервалы дат из таблицы значений. Считается, что в таблице есть колонки начала периода, конца периода и измерения
// Параметры:
//  ТабЗн - ТаблицаЗначений - С колонками дат и измерений
//  ИмяКолонкиНачалаПериода - Строка - Имя колонки, в которой содержатся начала периодов
//  ИмяКолонкиОкончанияПериода - Строка - Имя колонки, в которой содержатся начала периодов
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура СвернутьПериоды(ТабЗн, ИмяКолонкиНачалаПериода, ИмяКолонкиОкончанияПериода) Экспорт
    ИменаКолонок = Список_Колонок(ТабЗн, "Массив");
    Индекс_ = ИменаКолонок.Найти(ИмяКолонкиНачалаПериода);
    Если Индекс_ <> Неопределено Тогда
        ИменаКолонок.Удалить(Индекс_);
    КонецЕсли;
    Индекс_ = ИменаКолонок.Найти(ИмяКолонкиОкончанияПериода);
    Если Индекс_ <> Неопределено Тогда
        ИменаКолонок.Удалить(Индекс_);
    КонецЕсли;
    Имена_Колонок = СтрСоединить(ИменаКолонок, ",");
    ТабЗн.Сортировать(?(Имена_Колонок = "", "", Имена_Колонок + ",") + ИмяКолонкиНачалаПериода);
    ПрошлаяСтрока = ТабЗн[0];
    МассивКУдалению = Новый Массив;
    Для Ё = 1 По ТабЗн.Количество() - 1 Цикл
        ЭтаСтрока = ТабЗн[Ё];
        Если
	    		//КлиентСерверХЪ 
    			ПореквизитноРавны(ПрошлаяСтрока, ЭтаСтрока, ИменаКолонок)
    			И (ПрошлаяСтрока.Дата2 >= ЭтаСтрока.Дата1 - 1) Тогда
            Если ПрошлаяСтрока.Дата2 < ЭтаСтрока.Дата2 Тогда
                ПрошлаяСтрока.Дата2 = ЭтаСтрока.Дата2;
            КонецЕсли;
            МассивКУдалению.Добавить(ЭтаСтрока);
        Иначе
            ПрошлаяСтрока = ЭтаСтрока;
        КонецЕсли;
    КонецЦикла;
    //КлиентСерверХЪ 
	УдалитьЛишниеСтроки(ТабЗн, МассивКУдалению);
КонецПроцедуры // СвернутьПериоды

//Возвращает свёрнутую таблицу значений (удобно использовать, когда нужна именно функция, а также при автоопределении измерений и ресурсов)
//Параметры:
//   Табличка   - ТаблицаЗначений - Которая будет свёрнута
//   Измерения  - Строка - Имена колонок измерений через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, не имеющие в составе типов Число
//          (или (Если НеопределённыйТип = "Проверить") с неопределённым типом и имеющими хотя бы одно значение, не являющееся числом).
//   Ресурсы    - Строка - Имена колонок ресурсов через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, имеющие в составе типов Число
//          (или (Если НеопределённыйТип = "Проверить") с неопределённым типом и значениями типа только Число).
//   НеопределённыйТип  - Строка - Имеет смысл только для автоопределения ресурсов и измерений.
//          *"Измерение" - Колонки с неопределённым типом считаются измерениями (по умолчанию)
//          *"Исключить" - Колонки с неопределённым типом не входят ни в измерения, ни в ресурсы
//          *"Проверить" - Колонки с неопределённым типом автоопределяются
//   Исключаемые    - Строка - Список колонок, исключаемых из измерений и ресурсов.
//Возвращаемое значение:
//  ТаблицаЗначений - (Табличка) с заполненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СвернутьТаблицуЗначений(
		Табличка,
		Измерения = Неопределено,
		Ресурсы = Неопределено,
		НеопределённыйТип = "Измерение",
		Исключаемые = "") Экспорт
    АвтоИзмерения = Измерения = Неопределено;
    АвтоРесурсы = Ресурсы = Неопределено;
    МИсключаемые = СтрРазделить(Исключаемые, ",");
    Если АвтоИзмерения Тогда
        ТекИзмерения = ",";
    Иначе
        ТекИзмерения = "," + Измерения + ",";
        Для каждого Исключение_ Из мИсключаемые Цикл
            ТекИзмерения = СтрЗаменить(ТекИзмерения, "," + Исключение_ + ",", ",");
        КонецЦикла;
    КонецЕсли; 
    Если АвтоРесурсы Тогда
        ТекРесурсы = ",";
    Иначе
        ТекРесурсы = "," + Ресурсы + ",";
        Для каждого Исключение_ Из мИсключаемые Цикл
            ТекРесурсы = СтрЗаменить(ТекРесурсы, "," + Исключение_ + ",", ",");
        КонецЦикла;
    КонецЕсли; 
    Если АвтоИзмерения ИЛИ АвтоРесурсы Тогда
        Для каждого Колонка Из Табличка.Колонки Цикл
            ТипЧисло = Тип("Число");
            ТекИмя = Колонка.Имя;
            Это_Изм_Рес = "";
            Если (мИсключаемые.Найти(ТекИмя) = Неопределено)
                    И ?(АвтоИзмерения, ИСТИНА, СтрНайти(ТекИзмерения, "," + ТекИмя + ",") = 0)
                    И ?(АвтоРесурсы, ИСТИНА, СтрНайти(ТекРесурсы, "," + ТекИмя + ",") = 0)
                    Тогда
                ТекТип = Колонка.ТипЗначения;
                Если ТекТип.Типы().Количество() = 0 Тогда
                    Если НеопределённыйТип = "Проверить" Тогда
                        Это_Изм_Рес = "Р";
                        Для каждого Строчка Из Табличка Цикл
                            Если ТипЗнч(Строчка[ТекИмя]) <> ТипЧисло Тогда
                                Это_Изм_Рес = "И";
                                Прервать;
                            КонецЕсли; 
                        КонецЦикла;
                    ИначеЕсли НеопределённыйТип = "Измерение" Тогда
                        Это_Изм_Рес = "И";
                    КонецЕсли;
                ИначеЕсли ТекТип.СодержитТип(ТипЧисло) Тогда
                    Это_Изм_Рес = "Р";
                Иначе
                    Это_Изм_Рес = "И";
                КонецЕсли; 
            КонецЕсли;
            Если Это_Изм_Рес = "Р" Тогда
                Если АвтоРесурсы Тогда
                    ТекРесурсы = ТекРесурсы + ТекИмя + ",";
                КонецЕсли;
            ИначеЕсли Это_Изм_Рес = "И" Тогда
                Если АвтоИзмерения Тогда
                    ТекИзмерения = ТекИзмерения + ТекИмя + ",";
                КонецЕсли;
            КонецЕсли;
        КонецЦикла; 
    КонецЕсли;
    ТекИзмерения = Сред(ТекИзмерения, 2, СтрДлина(ТекИзмерения) - 2);
    ТекРесурсы = Сред(ТекРесурсы, 2, СтрДлина(ТекРесурсы) - 2);
    Табличка.Свернуть(ТекИзмерения, ТекРесурсы);
    Возврат Табличка
КонецФункции // ()

// Свёртывает таблицу значений с расширенными возможностями агрегатных функций. Колонки ресурса должны допускать тип результата агрегирования.
// ВОЗМОЖНО, ТРЕБУЕТ ОПТИМИЗАЦИИ АЛГОРИТМА! (Например, запрос на максимум - делать один сразу по всем строкам сворачиваемой группы)
// В реквизитах остаётся одно из значений, в неопознанных ресурсах - Неопределено.
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Сворачиваемая таблица
//  КолонкиИзмерений  - Строка - Колонки измерений через запятую
//  КолонкиРесурсов  - Структура - Ключи = Имена колонок, значения = агрегатные функции:
//          >ЗНАЧЕНИЯ - Упаковка в значения списка значений
//          >МАКСИМУМ - Максимум
//          >МАССИВ - Упаковка значений в массив
//          >МИНИМУМ - Минимум
//          >ПРОИЗВ - Произведение
//          >Результат =  - Выполнение произввольного кода с переменными:
//              >ВсеИтоги (структура с текущими значениями итогов и ключами - именами ресурсов),
//              >Результат - текущий итог текущего ресурса. Стартовый итог = Неопределено.
//              >ТекЗначение - Текущее значение текущего ресурса строки таблицы,
//              >СтрокаТЗ - текущая строка таблицы значений.
//          >СООТВЕТСТВИЕ - Упаковка в ключи соответствия
//          >СТРУКТУРА - Упаковка в ключи структуры
//          >Структура - ключи Число,Ограничение,Разделитель,КонецОбрезанный - конкатенация указанного числа символов строк
//              (отрицательное - правых, ноль - полностью), общая длина на больше Ограничение, обрезанная итоговая строка заканчивается на указанный конец
//          >СУМКВ - Сумма квадратов
//          >СУММ - Сумма
// Возвращаемое значение:
//   ТаблицаЗначений   - Параметр1 свёрнутый
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СвернутьТабЗначенийРасширенно(ТабЗн, КолонкиИзмерений, КолонкиРесурсов) Экспорт
    Результат = ТабЗн;
    Итоги = Новый Структура;
    Колво = Результат.Количество();
    КУдалению = Новый Массив;
    КУдалению.Добавить(Результат.Добавить());//Техническая строка
    МИзмерения = СтрРазделить(КолонкиИзмерений, ",", Ложь);
    ТипСтруктура = Тип("Структура");
    ТипЧисло = Тип("Число");
    ЭтоДубль = Ложь;
    Результат.Сортировать(КолонкиИзмерений);
    Для каждого КиЗ Из КолонкиРесурсов Цикл
        Итоги.Вставить(КиЗ.Ключ, Неопределено);
    КонецЦикла;
    ТекСтрока = 0;
    Для Сч = 0 По Колво Цикл
        ПрошлаяСтрока = ТекСтрока;
        ТекСтрока = Результат[Сч];
        //ЗАПИСЬ АГРЕГАТОВ
        Если ЭтоДубль Тогда
            Если Сч = Колво Тогда
                ЭтоДубль = Ложь;
            Иначе
                Для каждого Измерение Из мИзмерения Цикл
                    Если ТекСтрока[Измерение] <> ПрошлаяСтрока[Измерение] Тогда
                        ЭтоДубль = Ложь;
                        Прервать;
                    КонецЕсли; 
                КонецЦикла;
            КонецЕсли; 
            Если ЭтоДубль Тогда
                КУдалению.Добавить(ПрошлаяСтрока);
            Иначе
                Для каждого КиЗ Из Итоги Цикл
                    ПрошлаяСтрока[КиЗ.Ключ] = КиЗ. Значение;
                    Итоги[КиЗ.Ключ] = Неопределено;
                КонецЦикла;
            КонецЕсли; 
        КонецЕсли;
        //АГРЕГИРОВАНИЕ
        Для каждого КиЗРесурс Из КолонкиРесурсов Цикл
            Если КиЗРесурс.Значение = "ЗНАЧЕНИЯ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = Новый СписокЗначений;
                КонецЕсли;
                Итоги[КиЗ.Ключ].Добавить().Значение = ТекСтрока[КиЗ.Ключ];
            ИначеЕсли ТипЗнч(КиЗРесурс.Значение) = ТипСтруктура Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = "";
                КонецЕсли;
                Если КиЗРесурс.Значение.Число = 0 Тогда
                    Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + ТекСтрока[КиЗ.Ключ];
                ИначеЕсли КиЗРесурс.Значение.Число < 0 Тогда
                    Итоги[КиЗ.Ключ] = Прав(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число) + КиЗРесурс.Значение.Разделитель + Итоги[КиЗ.Ключ];
                Иначе
                    Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + Лев(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число);
                КонецЕсли;
                Если СтрДлина(Итоги[КиЗ.Ключ]) > КиЗРесурс.Значение.Ограничение Тогда
                    Итоги[КиЗ.Ключ] = Лев(Итоги[КиЗ.Ключ], КиЗРесурс.Значение.Ограничение - СтрДлина(КиЗРесурс.Значение.КонецОбрезанный)) + КиЗРесурс.Значение.КонецОбрезанный;
                КонецЕсли;
            ИначеЕсли КиЗРесурс.Значение = "МАССИВ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = Новый Массив;
                КонецЕсли;
                Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ]);
            ИначеЕсли КиЗРесурс.Значение = "МАКСИМУМ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = NULL;
                КонецЕсли;
                #Область ТЕКСТ_ЗАПРОСА
                    Запрос = Новый Запрос(
                            "ВЫБРАТЬ ПЕРВЫЕ 1
                            |   &Итог КАК Поле
                            |
                            |ОБЪЕДИНИТЬ ВСЕ
                            |
                            |ВЫБРАТЬ
                            |   &ТекЗначение
                            |
                            |УПОРЯДОЧИТЬ ПО
                            |   Поле УБЫВ");
                #КонецОбласти 
                Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
                Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
                //@skip-check query-in-loop
                Выборка = Запрос.Выполнить().Выбрать();
                Выборка.Следующий();
                Итоги[КиЗ.Ключ] = Выборка.Поле;
            ИначеЕсли КиЗРесурс.Значение = "МИНИМУМ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = ТекСтрока[КиЗ.Ключ];
                КонецЕсли;
                #Область ТЕКСТ_ЗАПРОСА
                    Запрос = Новый Запрос(
                            "ВЫБРАТЬ ПЕРВЫЕ 1
                            |   &Итог КАК Поле
                            |
                            |ОБЪЕДИНИТЬ ВСЕ
                            |
                            |ВЫБРАТЬ
                            |   &ТекЗначение
                            |
                            |УПОРЯДОЧИТЬ ПО
                            |   Поле");
                #КонецОбласти 
                Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
                Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
                //@skip-check query-in-loop
                Выборка = Запрос.Выполнить().Выбрать();
                Выборка.Следующий();
                Итоги[КиЗ.Ключ] = Выборка.Поле;
            ИначеЕсли КиЗРесурс.Значение = "ПРОИЗВ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = 1;
                КонецЕсли;
                Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] * ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 1);
            ИначеЕсли КиЗРесурс.Значение = "СУММ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = 1;
                КонецЕсли;
                Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 0);
            ИначеЕсли КиЗРесурс.Значение = "СУМКВ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = 1;
                КонецЕсли;
                Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ] * ТекСтрока[КиЗ.Ключ], 0);
            ИначеЕсли КиЗРесурс.Значение = "СООТВЕТСТВИЕ" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = Новый Соответствие;
                КонецЕсли;
                Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
            ИначеЕсли КиЗРесурс.Значение = "СТРУКТУРА" Тогда
                Если Итоги[КиЗ.Ключ] = Неопределено Тогда
                    Итоги[КиЗ.Ключ] = Новый Структура;
                КонецЕсли;
                Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
            ИначеЕсли Лев(КиЗРесурс.Значение, 12) = "Результат = " Тогда
                Итоги[КиЗ.Ключ] = ВыполнитьКод(КиЗРесурс.Значение, Новый Структура("ВсеИтоги,ТекЗначение,СтрокаТЗ", Итоги, ТекСтрока[КиЗ.Ключ], ТекСтрока), Итоги[КиЗ.Ключ]);
            КонецЕсли;
        КонецЦикла;
        ЭтоДубль = Истина;
    КонецЦикла;
	//КлиентСерверХЪ 
	УдалитьЛишниеСтроки(Результат, КУдалению);
    Возврат Результат
КонецФункции // СвернутьТабЗначенийРасширенно

//Возвращает свёрнутую с использованием запросных аггрегатных функций таблицу значений.
//Параметры:
//  ТабЗн - ТаблицаЗначений - сворачиваемая таблица, типизированная под запрос
//  КолонкиИзмерений - Строка - Список имён колонок измерений с разделителем строго "," или ", "
//  КолонкиРесурсов - Строка - Список имён колонок всех ресурсов с разделителем строго "," или ", "
//  КолонкиМаксимум - Строка - Список имён колонок ресурсов, аггрегируемых максимумом,
//          с разделителем ",". По умолчанию "".
//  КолонкиМинимум - Строка - Список имён колонок ресурсов, аггрегируемых минимумом,
//          с разделителем ",". По умолчанию "".
//  КолонкиКоличество - Строка - Список имён колонок ресурсов, аггрегируемых количеством,
//          с разделителем ",". По умолчанию "".
//  КолонкиКР - Строка - Список имён колонок ресурсов, аггрегируемых количеством различных,
//          с разделителем ",". По умолчанию "".
//  КолонкиСреднее - Строка - Список имён колонок ресурсов, аггрегируемых средним,
//          с разделителем ",". По умолчанию "". Остальные ресурсы будут аггрегированы суммой.
//Возвращаемое значение:
//  ТаблицаЗначений - свёрнутая.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция СвернутьТЗЗапросом(
		ТабЗн,
		КолонкиИзмерений,
		КолонкиРесурсов,
		КолонкиМаксимум = "",
		КолонкиМинимум = "",
		КолонкиКоличество = "",
		КолонкиКР = "",
		КолонкиСреднее = "") Экспорт
    СтрокаИзмерений = ?(КолонкиИзмерений = "", """ИТОГ""",
            "Источник." + СтрЗаменить(СтрЗаменить(КолонкиИзмерений,
            ", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
    СтрокаРесурсов = ?(КолонкиРесурсов = "", "0",
            "Источник." + СтрЗаменить(СтрЗаменить(КолонкиРесурсов,
            ", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
	#Область АГГРЕГАТЫ_ПО_КОЛОНКАМ
		СтрокаАггрегированныхРесурсов = "";
		ТМП = СтрЗаменить(КолонкиРесурсов, ",", Символы.ПС);
	    Для Ё = 1 По СтрЧислоСтрок(ТМП) Цикл
	        ТекИмя = СтрПолучитьСтроку(ТМП, Ё);
			Если
	        		//КлиентСерверХЪ
	        		НайтиПодСтроку(КолонкиМаксимум, ТекИмя) > 0 Тогда
	        	Аггрегат = "МАКСИМУМ(";
			ИначеЕсли
	        		//КлиентСерверХЪ
	        		НайтиПодСтроку(КолонкиМинимум, ТекИмя) > 0 Тогда
	        	Аггрегат = "МИНИМУМ(";
			ИначеЕсли
	        		//КлиентСерверХЪ
	        		НайтиПодСтроку(КолонкиКР, ТекИмя) > 0 Тогда
	        	Аггрегат = "КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ";
			ИначеЕсли
	        		//КлиентСерверХЪ
	        		НайтиПодСтроку(КолонкиКоличество, ТекИмя) > 0 Тогда
	        	Аггрегат = "КОЛИЧЕСТВО(";
			ИначеЕсли
	        		//КлиентСерверХЪ
	        		НайтиПодСтроку(КолонкиСреднее, ТекИмя) > 0 Тогда
	        	Аггрегат = "СРЕДНЕЕ(";
			Иначе
	        	Аггрегат = "СУММА((";
	        КонецЕсли;
	        СтрокаАггрегированныхРесурсов = СтрокаАггрегированныхРесурсов + "," + Символы.ПС + Аггрегат + "Источник." + ТекИмя + ") КАК " + ТекИмя;
	    КонецЦикла; 
	#КонецОбласти
	#Область ТЕКСТ_ЗАПРОСА
	    Запрос = Новый Запрос(
	    		СтрЗаменить(
	    			СтрЗаменить(
	    				СтрЗаменить(
				            "ВЫБРАТЬ
				            |   Источник.Измерение1,
				            |   Источник.Измерение2,
				            |   Источник.Ресурс1 КАК Ресурс1,
				            |   Источник.Ресурс2 КАК Ресурс2
				            |ПОМЕСТИТЬ ВТ__Источник
				            |ИЗ
				            |   &Источник КАК Источник
				            |;
				            |
				            |////////////////////////////////////////////////////////////////////////////////
				            |ВЫБРАТЬ
				            |   Источник.Измерение1,
				            |   Источник.Измерение2,
				            |   СУММА(Источник.Ресурс1) КАК Ресурс1,
				            |   СУММА(Источник.Ресурс2) КАК Ресурс2
				            |ИЗ
				            |   ВТ__Источник КАК Источник
				            |
				            |СГРУППИРОВАТЬ ПО
				            |   Источник.Измерение1,
				            |   Источник.Измерение2
				            |;
				            |
				            |////////////////////////////////////////////////////////////////////////////////
				            |УНИЧТОЖИТЬ ВТ__Источник",
				             "Источник.Измерение1,
	            			|   Источник.Измерение2",
	            			СтрокаИзмерений),
	            		"СУММА(Источник.Ресурс1) КАК Ресурс1,
	            		|   СУММА(Источник.Ресурс2) КАК Ресурс2",
	            		 Сред(СтрокаАггрегированныхРесурсов, 3)),
	            	"Источник.Ресурс1 КАК Ресурс1,
	            	|   Источник.Ресурс2 КАК Ресурс2",
	            	СтрокаРесурсов));
	#КонецОбласти
    Запрос.УстановитьПараметр("Источник", ТабЗн);
    Возврат Запрос.Выполнить().Выгрузить();
КонецФункции // СвернутьТЗЗапросом

//Устанавливает на заданную колонку тип по всем её значениям
//(допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//  ТабЗн - ТаблицаЗначений - содержащая колонку
//  ИмяКолонки - Строка - Имя типизируемой колонки
//  ИмяКолонкиТипов - Строка - Имя колонки, по значениям которой определяются типы. По умолчанию "", в этом случае тип определяется по колонке данных
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ТипизироватьКолонку(ТабЗн, Знач ИмяКолонки, ИмяКолонкиТипов = "") Экспорт
    Если ТабЗн.Количество() > 0 Тогда
        Если ИмяКолонкиТипов = "" Тогда
            ИмяКолонкиТипов = ИмяКолонки;
        КонецЕсли;
        ЭтиКолонки = ТабЗн.Колонки;
        МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонкиТипов);
        НоваяКолонка = ЭтиКолонки.Добавить("Временное__Имя__Этой__Колонки",
        		//КлиентСерверХЪ
                ОписаниеТиповКоллекции(МВыгрузка),
                ЭтиКолонки[ИмяКолонки].Заголовок,
                ЭтиКолонки[ИмяКолонки].Ширина);
        Если ИмяКолонкиТипов <> ИмяКолонки Тогда
            МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонки);
        КонецЕсли;
        ТабЗн.ЗагрузитьКолонку(МВыгрузка, "Временное__Имя__Этой__Колонки");
        ЭтиКолонки.Удалить(ИмяКолонки);
        НоваяКолонка.Имя = ИмяКолонки
    КонецЕсли
КонецПроцедуры

//Типизирует колонки таблицы значений по содержимому (допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//  ТабЗн - ТаблицаЗначений - типизируемая таблица
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ТипизироватьТаблицу(ТабЗн) Экспорт
    МассивКолонок = Новый Массив;
    Для Каждого Колонка Из ТабЗн.Колонки Цикл
        МассивКолонок.Добавить(Колонка.Имя);
    КонецЦикла;
    Для Каждого Колонка Из МассивКолонок Цикл
        ТипизироватьКолонку(ТабЗн, Колонка)
    КонецЦикла;
КонецПроцедуры

#КонецОбласти 

//Возвращает список имён колонок таблицы или дерева значений через запятую
//Параметры:
//  ТабИлиДерево - ТаблицаЗначений - также ВременнаяТаблица или дерево значений = Источник данных
//  СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
//  Разделитель - Строка - раделитель для результата-строки. По умолчанию ",".
//Возвращаемое значение:
//  Строка, Массив из Строка - возможно СписокЗначений = Список имён колонок. Строка = через запятую, список = с заголовками
//		в представлениях.
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция Список_Колонок(ТабИлиДерево, СтрокаМассивСписок = "Строка", Разделитель = ",") Экспорт
    Если СтрокаМассивСписок = "Массив" Тогда
        Результат = Новый Массив;
        Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
            Результат.Добавить(Колонка.Имя);
        КонецЦикла; 
    ИначеЕсли СтрокаМассивСписок = "Список" Тогда
        Результат = Новый СписокЗначений;
        Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
            Результат.Добавить(Колонка.Имя, Колонка.Заголовок);
        КонецЦикла; 
    Иначе
        Результат = "";
        Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
            Результат = Результат + Разделитель + Колонка.Имя;
        КонецЦикла; 
        Результат = Сред(Результат, СтрДлина(Разделитель) + 1);
    КонецЕсли;
    Возврат Результат
КонецФункции // Список_Колонок()
 
#КонецОбласти 

// Дополняет стандартное дерево меню после восстановления пользовательских настроек
// Параметры:
//  Приёмник - ДеревоЗначений - Дополняемое
//  Источник - ДеревоЗначений - Дерево - источник новых строк. Все строки этого дерева будут перенесены в Источник: либо добавлены, либо с перезаписью существующих
//  ИменаКлючевыхКолонок - Строка - Имена колонок, по которым идентифицируются строки. Если не заполнен = строки будут всегда добавляться
//  ИменаКопируемыхКолонок - Строка - Имена колонок, значения которых будут переноситься в приёмник. Если не заполнен - переносятся все, имеющиеся в приёмнике.
//  ПерезаписыватьПустыеПоля - Булево - При Ложь переносятся только непустые значения. По умолчанию Истина.
&НаСервереБезКонтекста
Процедура ДополнитьДерево(Приёмник, Источник, ИменаКлючевыхКолонок = "", ИменаКопируемыхКолонок = "", ПерезаписыватьПустыеПоля = Истина)
    ИменаКолонокККопированию = ?(ЗначениеЗаполнено(ИменаКопируемыхКолонок), ИменаКопируемыхКолонок, Список_Колонок(Приёмник));
    ЕстьКлючи = ЗначениеЗаполнено(ИменаКлючевыхКолонок);
    Если ЕстьКлючи Тогда
        СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
    КонецЕсли;
    Для каждого Сучок Из Источник.Строки Цикл
        ЗаполнитьЗначенияСвойств(СтруктураПоиска, Сучок);
        Если ЕстьКлючи Тогда
            Получатели = Приёмник.Строки.НайтиСтроки(СтруктураПоиска);
        Иначе
            Получатели = Новый Массив;
        КонецЕсли;
        Если Получатели.Количество() = 0 Тогда
            Получатели.Добавить(Приёмник.Строки.Добавить());
        КонецЕсли;
        Почтальон = Новый Структура(ИменаКолонокККопированию);
        ЗаполнитьЗначенияСвойств(Почтальон, Сучок);
        Если НЕ ПерезаписыватьПустыеПоля Тогда
            //КлиентСерверХЪ
            УдалитьПустыеЗначенияИзСтруктуры(Почтальон);
        КонецЕсли;
        Для каждого Получатель Из Получатели Цикл
            ЗаполнитьЗначенияСвойств(Получатель, Почтальон);
            ДополнитьДерево(Получатель, Сучок, ИменаКлючевыхКолонок, ИменаКолонокККопированию, ПерезаписыватьПустыеПоля);
        КонецЦикла;
    КонецЦикла;
КонецПроцедуры

// Подводит итоги по строкам ветки дерева
// Параметры:
//  Ёлка  - СтрокаДереваЗначений - Ветка, строки которой надо итожить
//  Колонки  - Структура - Ключи = колонки, Значения = агрегатные функции:
//          >КОЛИЧЕСТВОНЕПУСТЫХ
//          >КОЛИЧЕСТВОРАЗЛИЧНЫХ
//          >МИНИМУМ
//          >МАКСИМУМ
//          >ПРОИЗВ
//          >СУММА
//          >СУММКВ
//      По умолчанию 1 колонка с именем = "Флаг" и значением = "Минимум"
//  ИтожитьПодчинённые - Булево - подводить итог подчинённых строк. По умолчанию Истина
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ИтогСтрокДерева(Ёлка, Колонки = Неопределено, ИтожитьПодчинённые = Истина) Экспорт
    Если Ёлка.Строки.Количество() Тогда
        Если ИтожитьПодчинённые Тогда
            Для каждого Дочка Из Ёлка.Строки Цикл
                ИтогСтрокДерева(Дочка, Колонки, Истина);
            КонецЦикла;
        КонецЕсли;
        Если Колонки = Неопределено Тогда
            Колонки = Новый Структура("Флаг", "МИНИМУМ");
        КонецЕсли;
        Для каждого КиЗ Из Колонки Цикл
            Если КиЗ.Значение = "КОЛИЧЕСТВОНЕПУСТЫХ" Тогда
                Ёлка[КиЗ.Ключ] = 0;
                Для каждого Дочка Из Ёлка.Строки Цикл
                    Если ЗначениеЗаполнено(Дочка[КиЗ.Ключ]) Тогда
                        Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + 1;
                    КонецЕсли;
                КонецЦикла;
            ИначеЕсли КиЗ.Значение = "КОЛИЧЕСТВОРАЗЛИЧНЫХ" Тогда
                ТМП = Новый Соответствие;
                Для каждого Дочка Из Ёлка.Строки Цикл
                    ТМП.Вставить(Дочка[КиЗ.Ключ], 0);
                КонецЦикла;
                Ёлка[КиЗ.Ключ] = ТМП.Количество();
            ИначеЕсли КиЗ.Значение = "МИНИМУМ" ИЛИ КиЗ.Значение = "МАКСИМУМ" Тогда
                Порядок_ = ?(КиЗ.Значение = "МАКСИМУМ", " УБЫВ", "");
                Умолчание = NULL;
                ТМП = Новый ТаблицаЗначений;
                ТМП.Колонки.Добавить("Первая");
                Для каждого Дочка Из Ёлка.Строки Цикл
                    ТМП.Добавить().Первая = Дочка[КиЗ.Ключ];
                КонецЦикла;
                ТМП.Сортировать("Первая" + Порядок_);
                Ёлка[КиЗ.Ключ] = ?(ТМП.Количество(), ТМП[0].Первая, Умолчание);
            ИначеЕсли КиЗ.Значение = "ПРОИЗВ" Тогда
                Ёлка[КиЗ.Ключ] = 1;
                Для каждого Дочка Из Ёлка.Строки Цикл
                    Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
                КонецЦикла;
            ИначеЕсли КиЗ.Значение = "СУММА" Тогда
                Ёлка[КиЗ.Ключ] = 0;
                Для каждого Дочка Из Ёлка.Строки Цикл
                    Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ];
                КонецЦикла;
            ИначеЕсли КиЗ.Значение = "СУММКВ" Тогда
                Ёлка[КиЗ.Ключ] = 0;
                Для каждого Дочка Из Ёлка.Строки Цикл
                    Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
                КонецЦикла;
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
КонецПроцедуры // ИтогСтрокДерева

// Копирует содержимое одного дерева в другое, существующее
// Параметры:
//  Приёмник  - ДеревоЗначений - Дерево значений, в которое будут добавлены новые данные
//  Источник  - ДеревоЗначений - Дерево значений, из которого будут взяты данные
//  ИменаКлючевыхКолонок  - Строка - Имена колонок для поиска соответствующих строк. Если пустая (по умолчанию), считается, что соответствующих строк нет. Если найдено несколько строк, первая считается найденной.
//  СкоррелироватьКолонки  - Булево - Надо приводить в соответстввие колонки. По умолчанию Истина. Для ветвей приёмника и источника обязательно Ложь.
//  ИменаВсехКолонок  - Строка - Имена всех колонок через запятую. Если не указан = вычисляется.
//  УсловиеОтбора  - Строка - Условие, только при соблюдении которого строки перенесутся. По умолчанию "" = перенос всех.
//          На уровне самого источника не проверяется, только в его строках и ниже. Переменные = имена колонок и СтрокаДЗ. Результат вычисления = Результат.
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Процедура СкопироватьДерево(
		Приёмник,
		Источник,
		ИменаКлючевыхКолонок = "",
		СкоррелироватьКолонки = Истина,
		ИменаВсехКолонок = "",
		УсловиеОтбора = "") Экспорт
    Если СкоррелироватьКолонки Тогда
        СкоррелироватьКолонкиТаблиц(Приёмник, Источник, 1);
    КонецЕсли;
    ЭтиСтроки = Приёмник.Строки;
    Если ЗначениеЗаполнено(УсловиеОтбора) И НЕ ЗначениеЗаполнено(ИменаВсехКолонок) Тогда
        ИменаВсехКолонок = Список_Колонок(?(ТипЗнч(Источник) = Тип("ДеревоЗначений"), Источник, Источник.Владелец()));
    КонецЕсли;
    Для каждого СтрокаДЗ Из Источник.Строки Цикл
        СтрокаПриёмник = "";
        Если ЗначениеЗаполнено(УсловиеОтбора) Тогда
            СтрПрм = Новый Структура(ИменаВсехКолонок);
            ЗаполнитьЗначенияСвойств(СтрПрм, СтрокаДЗ);
            СтрПрм.Вставить("СтрокаДЗ", СтрокаДЗ);
            СтрокаОк = ВыполнитьКод(УсловиеОтбора, СтрПрм, Ложь);
        Иначе
            СтрокаОк = Истина;
        КонецЕсли;
        Если СтрокаОк Тогда
            Если ИменаКлючевыхКолонок <> "" Тогда
                СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
                ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаДЗ);
                МассивНайденныхСтрок = ЭтиСтроки.НайтиСтроки(СтруктураПоиска);
                Если МассивНайденныхСтрок.Количество() > 0 Тогда
                    СтрокаПриёмник = МассивНайденныхСтрок[0];
                КонецЕсли; 
            КонецЕсли; 
            Если СтрокаПриёмник = "" Тогда
                СтрокаПриёмник = ЭтиСтроки.Добавить();
            КонецЕсли;
            ЗаполнитьЗначенияСвойств(СтрокаПриёмник, СтрокаДЗ);
            СкопироватьДерево(СтрокаПриёмник, СтрокаДЗ, ИменаКлючевыхКолонок, Ложь, ИменаВсехКолонок, УсловиеОтбора);
        КонецЕсли;
    КонецЦикла; 
КонецПроцедуры // СкопироватьДерево

#КонецОбласти

#Область 		РЕКВИЗИТЫ_ОБЪЕКТОВ
    
// Возвращает запрос с временной таблицей, содержащей заданные колонки
// Параметры:
//  МассивОбъектов  - Произвольный - возможно Массив или соответствие = У кого брать реквизиты. Соответствие д.б. в формате (Тип -> Массив объектов)
//  СписокКолонок_  - Строка, Массив из Строка - строка с разделителем "," или Массив = список имён колонок таблицы-результата
//  Мэппинг  - Соответствие из Строка, Строка - (Тип -> Структура(Имя колонки таблицы -> ИмяРеквизита) или Текст запроса
//  		для объекта заданного типа). ИмяРеквизита м.б. в формате "ЗНАЧ = [Фиксированное значение или параметр]"
//  ДопПараметры  - Структура - Будет добавлена к параметрам запроса, по умолчанию Неопределено - параметры не добавляются.
// Возвращаемое значение:
//   Запрос   - Запрос со сформированной временной таблицей ВТ_Ответ
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция РеквизитыРазнотипныхОбъектов(МассивОбъектов, СписокКолонок_ = "Номер,Дата", Мэппинг = Неопределено, ДопПараметры = Неопределено) Экспорт
    СоответствиеТипов =
    		?(ТипЗнч(МассивОбъектов) = Тип("Соответствие"),
    			МассивОбъектов,
    			//КлиентСерверХЪ
    			РазбитьПоТипам(
 		   			//КлиентСерверХЪ
    				ПреобразоватьВМассив(МассивОбъектов)));
    Колонки = ?(ТипЗнч(СписокКолонок_) = Тип("Строка"), СтрРазделить(СписокКолонок_, ",", Ложь), СписокКолонок_);
    ТекстЗапроса = "";
    Для каждого ИмяКолонки Из Колонки Цикл
        ТекстЗапроса = ТекстЗапроса + "," + Символы.ПС + "NULL КАК " + ИмяКолонки;
    КонецЦикла; 
    ТекстЗапроса = "ВЫБРАТЬ" + Сред(ТекстЗапроса, 3) + " ПОМЕСТИТЬ ВТ_Ответ ГДЕ ЛОЖЬ" + Символы.ПС;
    Запрос = Новый Запрос(ТекстЗапроса);
    СчПараметров = 0;
    Для каждого КиЗ Из СоответствиеТипов Цикл
        Попытка
            МетаХ = КиЗ.Значение[0].Метаданные();
            //@skip-check server-execution-safe-mode
            ТипОбъекта = ?(Вычислить("ОбщегоНазначения.ЭтоДокумент(МетаХ)"), "Документ", ?(Вычислить("ОбщегоНазначения.ЭтоСправочник(МетаХ)"), "Справочник", ?(Вычислить("ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаХ)"), "ПланВидовХарактеристик", "Прочее")));
        Исключение
            МетаХ = Неопределено;
            ТипОбъекта = "Прочее";
            //ЭтоДокумент = Ложь;
        КонецПопытки;
        ТекМэппинг = ?(Мэппинг = Неопределено, Неопределено, Мэппинг[ТипЗнч(КиЗ.Значение[0])]);
        Если ТипЗнч(ТекМэппинг) = Тип("Строка") Тогда
            ИмяПараметра = "Параметр_" + СчПараметров;
            ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ " + СтрЗаменить(ТекМэппинг, "[СсылкиНаОбъекты]", ИмяПараметра) + Символы.ПС;
            Запрос.УстановитьПараметр(ИмяПараметра, КиЗ.Значение);
            СчПараметров = СчПараметров + 1;
        ИначеЕсли ТипОбъекта = "Прочее" Тогда
            Если ТекМэппинг = Неопределено Тогда
                Если Колонки.Найти("Ссылка") <> Неопределено Тогда
                    Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
                        ЧастныйТекст = "";
                        Для каждого Колонка Из Колонки Цикл
                            Если Колонка = "Ссылка" Тогда
                                ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
                                Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение);
                                СчПараметров = СчПараметров + 1;
                            Иначе
                                ЧастныйТекст = ЧастныйТекст + ", NULL";
                            КонецЕсли; 
                        КонецЦикла; 
                        ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
                    КонецЦикла; 
                КонецЕсли; 
            Иначе
                Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
                    ЧастныйТекст = "";
                    Для каждого Колонка Из Колонки Цикл
                        Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
                            ЧастныйТекст = ЧастныйТекст + ", NULL";
                        ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
                            ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
                        Иначе
                            ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
                            Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение[ТекМэппинг[Колонка]]);
                            СчПараметров = СчПараметров + 1;
                        КонецЕсли; 
                    КонецЦикла; 
                    ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
                КонецЦикла; 
            КонецЕсли; 
        Иначе
            ЧастныйТекст = "";
            Для каждого Колонка Из Колонки Цикл
                Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
                    ЧастныйТекст = ЧастныйТекст + ", Док." + Колонка;
                ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
                    ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
                Иначе
                    ЧастныйТекст = ЧастныйТекст + ", Док." + ТекМэппинг[Колонка];
                КонецЕсли; 
            КонецЦикла; 
            ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2) + " ИЗ " + ТипОбъекта + "." + МетаХ.Имя + " КАК Док ГДЕ Док.Ссылка В(&Параметр_" + СчПараметров + ")" + Символы.ПС;
            Запрос.УстановитьПараметр("Параметр_" + СчПараметров, КиЗ.Значение);
            СчПараметров = СчПараметров + 1;
        КонецЕсли;
    КонецЦикла;
    Запрос.Текст = ТекстЗапроса;
    Если ДопПараметры <> Неопределено Тогда
        Для каждого КиЗ Из ДопПараметры Цикл
            Запрос.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
        КонецЦикла; 
    КонецЕсли; 
    Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
    Запрос.Выполнить();
    Возврат Запрос
КонецФункции // РеквизитыРазнотипныхОбъектов()

#КонецОбласти 

#Область 		СКД
    
//Возвращает таблицу значений - результат выполнения СКД
//Параметры:
//  СКД - СхемаКомпоновкиДанных - СхемаКомпоновкиДанных
//  НастройкиСКД - НастройкиКомпоновкиДанных - применяемые при выполнении 
//  ВозможностьПрерыванияПользователем - Булево - Параметр запуска процессора вывода, разрешающий прерывание пользователем
//  НаборыОбъекты - Структура - Источники данных для подстановки в НаборДанныхОбъект. По умолчанию Неопределено.
//  МВТ - МенеджерВременныхТаблиц - Для процессора компоновки. По умолчанию Неопределено.
//Возвращаемое значение:
//  ТаблицаЗначений - Результат выполнения СКД
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ТаблицаСКД(
		СКД,
		НастройкиСКД = Неопределено,
		ВозможностьПрерыванияПользователем = Ложь,
		НаборыОбъекты = Неопределено,
		МВТ = Неопределено) Экспорт
    Если НастройкиСКД = Неопределено Тогда
        НастройкиСКД = СКД.НастройкиПоУмолчанию;
    КонецЕсли; 
    КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
    МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиСКД,,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
    ПроцессорКомпоновкиДанных_ = Новый ПроцессорКомпоновкиДанных;
    ПроцессорКомпоновкиДанных_.Инициализировать(МакетКомпоновки, НаборыОбъекты,,Истина,, МВТ);
    ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
    Результат = Новый ТаблицаЗначений;
    ПроцессорВывода.УстановитьОбъект(Результат);
    ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных_, ВозможностьПрерыванияПользователем);
    Возврат Результат
КонецФункции

#КонецОбласти

#Область 		ССЫЛКИ_УИДЫ
    
#Область 			ЗАМЕНА_ССЫЛОК

//Вспомогательная для функций замены. Выводит сообщение об ошибке.
//Параметры:
//  Информация - Соответствие из Строка - с ключом Описание или Причина.Описание
//  Контекст - Произвольный - Дополнение для вывода после описания причины.
&НаСервереБезКонтекста
Процедура СообщитьОбОшибкеПриЗаписи(Информация, Контекст)
    Причина = ?(Информация.Причина = Неопределено, Информация, Информация.Причина);
    Сообщение = Новый СообщениеПользователю;
    Сообщение.Текст = Причина.Описание + Контекст;
    Сообщение.Сообщить();
КонецПроцедуры

//Вспомогательная для следующей экспортной процедуры. Выполняет разовую замену.
//Параметры:
//  ГдеМенять - Произвольный - поддерживающий изменяемые реквизиты = Объект, в котором будет произведена замена
//  Реквизит - Строка - Имя реквизита, в котором будет произведена замена
//  Замены - Соответствие из Произвольный - [Фиксированное] Соответствие правильных значений (значения) заменяемым (ключи)
//  Лог - Строка - Комментарий о проделанной работе. По умолчанию "-" = не комментировать
//Возвращаемое значение:
//  Произвольный - значение после замены
&НаСервереБезКонтекста
Функция ЗаменитьСсылку(ГдеМенять, Реквизит, Замены, Лог = "-")
    ТекЗнч = ГдеМенять[Реквизит];
    ПравильныйЭлемент = Замены[ТекЗнч];
    Если ПравильныйЭлемент <> Неопределено Тогда
        ГдеМенять[Реквизит] = ПравильныйЭлемент;
        Если Лог <> "" Тогда
            Попытка
                ГдеМенятьСтрокой = "" + ГдеМенять;
            Исключение
                ГдеМенятьСтрокой = "" + ТипЗнч(ГдеМенять);
            КонецПопытки;
            Лог = Лог + "В " + Реквизит + " объекта " + ГдеМенятьСтрокой + " " + ТекЗнч + " заменён на " + ПравильныйЭлемент;
        КонецЕсли; 
    КонецЕсли;
    Возврат ПравильныйЭлемент
КонецФункции // ЗаменитьСсылку()
 
//Заменяет значения по таблице замен и помечает на удаление заменяемые значения.
//Параметры:
//  ЗаменяемыеЗначения - ТаблицаЗначений - с колонками ЧтоЗаменять, НаЧтоЗаменять, Пометка (флаг необходимости замены) и ПометитьНаУдаление.
//  НайденныеСсылки - ТаблицаЗначений - с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//                                      и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//  ВТранзакции - Булево - Выполнять в единой транзакции все замены.
//  БезКонтроля - Булево - Включает режим записи "Загрузка", отменяющий многие контроли при записи и ускоряющий её.
//  ОтменитьРегистрациюВОбменах - Булево - Устанавливает у объектов допсвойство, в типовых конфигурациях блокирующее регистрацию в планах обмена.
//  Лог             -   Строка  -   отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//  Булево - Замена завершена без ошибок
//@skip-check method-too-many-params
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление(
		ЗаменяемыеЗначения,
		НайденныеСсылки,
		ВТранзакции = Истина,
		БезКонтроля = Ложь,
		ОтменитьРегистрациюВОбменах = Истина,
		Лог = "-") Экспорт
    Заменяемые = Новый Соответствие;
    Для каждого Стр Из ЗаменяемыеЗначения Цикл
        Если Стр.Пометка Тогда
            Заменяемые.Вставить(Стр.ЧтоЗаменять, Стр.НаЧтоЗаменять);
        КонецЕсли;
    КонецЦикла;
    БезОшибок = ЗаменитьСсылкиПоСоответствию(Заменяемые, НайденныеСсылки, ВТранзакции, БезКонтроля, ОтменитьРегистрациюВОбменах, Лог);
    Для каждого Стр Из ЗаменяемыеЗначения Цикл
        Если Стр.ПометитьНаУдаление Тогда
            Объект_ = Стр.ЧтоЗаменять.ПолучитьОбъект();
            Если НЕ Объект_.ПометкаУдаления Тогда
                Объект_.ПометкаУдаления = Истина;
                Объект_.ОбменДанными.Загрузка = БезКонтроля;
                Попытка
                    Объект_.Записать();
                    Если Лог <> "-" Тогда
                        Лог = Лог + "Помечен на удаление " + Объект_;
                    КонецЕсли; 
                Исключение
                    СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при пометке на удаление)");
                    БезОшибок = Ложь;
                КонецПопытки;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат БезОшибок
КонецФункции // ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление()

//Заменяет ссылки из таблицы по заданным соответствиям
//Параметры:
//  Заменяемые		- Соответствие из Произвольный -   Ключ = заменяемое, Значение = замещающее значение
//  ТаблицаСсылок	- ТаблицаЗначений	-   с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//                                      и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//  ВыполнятьВТранзакции        -   Булево  -   Если Истина (по умолчанию), то одна общая транзакция,
//                                      >Ложь = транзакции по каждому объекту данных.
//                                      >Истина = быстрее и сохраняет целостность, Ложь = помехоустойчивей и надёжнее.
//  ОтключатьКонтрольЗаписи     -   Булево  -   Записывать в режиме загрузки. По умолчанию Истина.
//  ОтменитьРегистрациюВОбменах -   Булево  -   Записывать без регистрации в обменах данных. По умолчанию Истина.
//  Лог             -   Строка  -   отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//  Булево - Замены выполнены без ошибок
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ЗаменитьСсылкиПоСоответствию(
		Заменяемые,
		ТаблицаСсылок,
		ВыполнятьВТранзакции = Истина,
		ОтключатьКонтрольЗаписи = Истина,
		ОтменитьРегистрациюВОбменах = Истина,
		Лог = "-") Экспорт
    МетаВсё = Метаданные;
    МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
    Непериод = МетаСвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
    ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
    РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
    АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
    БылиИсключения = Ложь;
    МетаРБ = МетаВсё.РегистрыБухгалтерии;
    МетаРС = МетаВсё.РегистрыСведений;
    //МетаРР = МетаВсё.РегистрыРасчета;
    МетаРН = МетаВсё.РегистрыНакопления;
    МетаСпр = МетаВсё.Справочники;
    МетаДок = МетаВсё.Документы;
    МетаПВХ = МетаВсё.ПланыВидовХарактеристик;
    МетаПВР = МетаВсё.ПланыВидовРасчета;
    МетаПСЧ = МетаВсё.ПланыСчетов;
    //МетаПОБ = МетаВсё.ПланыОбмена;
    МетаБПР = МетаВсё.БизнесПроцессы;
    МетаЗад = МетаВсё.Задачи;
    МетаКон = МетаВсё.Константы;
    МетаПос = МетаВсё.Последовательности;
    МетаОРе = МетаВсё.ОбщиеРеквизиты;
    Если ВыполнятьВТранзакции Тогда
        НачатьТранзакцию();
    КонецЕсли;
    ПараметрыХ = Новый Структура;
    Для Каждого РегистрБухгалтерии ИЗ МетаРБ Цикл
        ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Субконто", РегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто);
        ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Корреспонденция", РегистрБухгалтерии.Корреспонденция);        
    КонецЦикла;
    //ПараметрыХ.Вставить("Объект", Неопределено);  
    ТабЗамен = ТаблицаСсылок.Скопировать(ТаблицаССылок.НайтиСтроки(Новый Структура("Включено", Истина)), "Данные,Ссылка");
    ТабЗамен.Свернуть("Данные,Ссылка");
    ТабЗамен.Сортировать("Данные,Ссылка");
    ТабЗамен.Индексы.Добавить("Данные,Ссылка");
    ТабДанных = ТабЗамен.Скопировать(,"Данные");
    ТабДанных.Свернуть("Данные");
    ИнфоМД = Новый Соответствие;
    ИнфоОР = Новый Соответствие;
    Данных = ТабДанных.Количество();
    СчСтрок = 0;
    Для каждого СтрокаДанных Из ТабДанных Цикл
        Если Лог <> "-" Тогда
            СчСтрок = СчСтрок + 1;
			Лог = Лог + "Строка " + СчСтрок + " из " + Данных;
        КонецЕсли; 
        Замены = ТабЗамен.НайтиСтроки(Новый Структура("Данные", СтрокаДанных.Данные));
        //Построить соответствие замен для конкретных данных
        ТекЗамены = Новый Соответствие;
        Для каждого СтрокаЗамен Из Замены Цикл
            ТекЗамены.Вставить(СтрокаЗамен.Ссылка, Заменяемые[СтрокаЗамен.Ссылка]);
        КонецЦикла;
        //И перебор по реквизитам данных
        СтроковыйТип = СтрЗаменить(СтрокаДанных.Данные, ".", Символы.ПС);
        МетаХ = ?(СтрПолучитьСтроку(СтроковыйТип, 1) = "РегистрСведенийКлючЗаписи",
                МетаРС.Найти(СтрПолучитьСтроку(СтроковыйТип, 2)), СтрокаДанных.Данные.Метаданные());
        ИнфоЭтиМД = ИнфоМД[МетаХ];
        Если ИнфоЭтиМД = Неопределено Тогда
            ИнфоЭтиМД = Новый Структура;
            ИнфоЭтиМД.Вставить("ЭтоСпр",  МетаСпр.Содержит(МетаХ));
            ИнфоЭтиМД.Вставить("ЭтоДок",  МетаДок.Содержит(МетаХ));
            ИнфоЭтиМД.Вставить("ЭтоБПлан",  МетаПВХ.Содержит(МетаХ)
                      ИЛИ МетаПСЧ.Содержит(МетаХ)
                      ИЛИ МетаПВР.Содержит(МетаХ)
                      ИЛИ МетаБПР.Содержит(МетаХ));
            ИнфоЭтиМД.Вставить("ЭтоЗадача",  МетаЗад.Содержит(МетаХ));
            ИнфоЭтиМД.Вставить("ЭтоРС",  МетаРС.Содержит(МетаХ));
            ИнфоЭтиМД.Вставить("ЭтоКонст",  МетаКон.Содержит(МетаХ));
            ИнфоПослед = Новый Соответствие;
            ИнфоЭтиМД.Вставить("Послед", ИнфоПослед);
            ИнфоЭтиМД.Вставить("Движения", Новый Соответствие);
        Иначе
            ИнфоПослед = ИнфоЭтиМД.Послед;
        КонецЕсли; 
        Если ИнфоЭтиМД.ЭтоКонст Тогда
            Константы[МетаХ.Имя].Установить(Заменяемые[ТекЗамены[0].Ссылка]);
        ИначеЕсли ИнфоЭтиМД.ЭтоРС Тогда
            СтруктураИзмерений = Новый Структура;
            НаборЗаписей = РегистрыСведений[МетаХ.Имя].СоздатьНаборЗаписей();
            Для Каждого Измерение ИЗ МетаХ.Измерения Цикл
                НаборЗаписей.Отбор[Измерение.Имя].Установить(СтрокаДанных.Данные[Измерение.Имя]);
                СтруктураИзмерений.Вставить(Измерение.Имя);
            КонецЦикла;
            Если МетаХ.ПериодичностьРегистраСведений <> Непериод Тогда
                НаборЗаписей.Отбор["Период"].Установить(СтрокаДанных.Данные.Период);
            КонецЕсли;
            НаборЗаписей.Прочитать();
            Если НаборЗаписей.Количество() = 0 Тогда
                Продолжить;
            КонецЕсли;
            ТаблицаНабора = НаборЗаписей.Выгрузить();
            НаборЗаписей.Очистить();
            Если ОтключатьКонтрольЗаписи Тогда
                НаборЗаписей.ОбменДанными.Загрузка = Истина;
            КонецЕсли;
            Если Не ВыполнятьВТранзакции Тогда
                НачатьТранзакцию();
            КонецЕсли;
            Попытка
                НаборЗаписей.Записать();
                Для каждого СтрокаНабора Из ТаблицаНабора Цикл
                    Для Каждого Колонка ИЗ ТаблицаНабора.Колонки Цикл
                        ПравильныйЭЛемент = ЗаменитьСсылку(СтрокаНабора, Колонка.Имя, ТекЗамены, Лог);
                        Если СтруктураИзмерений.Свойство(Колонка.Имя) И (ПравильныйЭЛемент <> Неопределено) Тогда
                            НаборЗаписей.Отбор[Колонка.Имя].Установить(ПравильныйЭЛемент);
                        КонецЕсли;
                    КонецЦикла; 
                КонецЦикла;
                НаборЗаписей.Загрузить(ТаблицаНабора);
                НаборЗаписей.Записать();
                Если Не ВыполнятьВТранзакции Тогда
                    ЗафиксироватьТранзакцию();
                КонецЕсли; 
            Исключение
                СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи регистра сведений)");
                БылиИсключения = Истина;
                Если ВыполнятьВТранзакции Тогда
                    Прервать; //На откат
                Иначе
                    ОтменитьТранзакцию();
                КонецЕсли;
            КонецПопытки;
        ИначеЕсли ИнфоЭтиМД.ЭтоСпр ИЛИ ИнфоЭтиМД.ЭтоДок ИЛИ ИнфоЭтиМД.ЭтоБПлан ИЛИ ИнфоЭтиМД.ЭтоЗадача Тогда
            ИсключенияВДанных = Ложь;
            Попытка
                ТекОбъект = СтрокаДанных.Данные.ПолучитьОбъект();
                Если ОтменитьРегистрациюВОбменах Тогда
                    ТекОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
                КонецЕсли; 
                //Для каждого Замена Из Заменяемые Цикл //ТекЗамены Цикл
                //  Ссылка = Замена.Ключ;
                //  ПравильныйЭлемент = Замена.Значение;
                Если ИнфоЭтиМД.ЭтоСпр Тогда //А здесь 80000
                    //Если МетаХ.Владельцы.Содержит(Ссылка.Метаданные()) И ТекОбъект.Владелец = Ссылка Тогда
                    ЗаменитьСсылку(ТекОбъект, "Владелец", ТекЗамены, Лог);
                    Если МетаХ.Иерархический Тогда
                        ЗаменитьСсылку(ТекОбъект, "Родитель", ТекЗамены, Лог);
                    КонецЕсли;
                КонецЕсли;
                Для Каждого Реквизит Из МетаОРе Цикл //Замедляет, часто запускается! 300 тыс раз при 2000 данных и 3000 пар замен!
                    Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
                        ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
                    КонецЕсли; 
                КонецЦикла;
                Для Каждого Реквизит Из МетаХ.Реквизиты Цикл
                    //Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда //2,7 млн, 5%
                    ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
                КонецЦикла;
                Для Каждого ТЧ ИЗ МетаХ.ТабличныеЧасти Цикл
                    Если ТекОбъект[ТЧ.Имя].Количество() < 200 Тогда
                        //Маленькие ТЧ проще перебрать, избавившись от проверок типов и доп. цикла
                        Для каждого Строка_ТЧ_ Из ТекОбъект[ТЧ.Имя] Цикл
                            Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
                                ЗаменитьСсылку(Строка_ТЧ_, Реквизит.Имя, ТекЗамены, Лог);
                            КонецЦикла; 
                        КонецЦикла;
                    Иначе
                        //В больших ТЧ лучше ограничить число колонок
                        Для каждого КиЗ Из ТекЗамены Цикл
                            ПравильныйЭлемент = КиЗ.Значение;
                            Ссылка = КиЗ.Ключ;
                            ТипСсылки = ТипЗнч(Ссылка);
                            Для Каждого Реквизит Из ТЧ.Реквизиты Цикл //5 млн 7%
                                Если Реквизит.Тип.СодержитТип(ТипСсылки) Тогда //10 млн, 10%
                                    СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
                                    Пока СтрокаТабЧасти <> Неопределено Цикл
                                        СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
                                        СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
                                    КонецЦикла;
                                КонецЕсли; //2%
                            КонецЦикла;
                        КонецЦикла; 
                    КонецЕсли;
                КонецЦикла;
                Если ИнфоЭтиМД.ЭтоЗадача Тогда
                    Для Каждого Реквизит Из МетаХ.РеквизитыАдресации Цикл
                        //Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда
                        ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
                    КонецЦикла;
                КонецЕсли;
            Исключение
                СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов объекта)");
                БылиИсключения = Истина;
                Если ВыполнятьВТранзакции Тогда
                    Прервать; //На откат
                Иначе
                    ИсключенияВДанных = Истина;
                КонецЕсли;
            КонецПопытки;
            Если НЕ ИсключенияВДанных Тогда
                КЗаписи = Новый Массив;
                Попытка
                    Если ИнфоЭтиМД.ЭтоДок Тогда
                        Для Каждого Движение ИЗ МетаХ.Движения Цикл
                            ТекВидДвиж = ИнфоЭтиМД.Движения[Движение];
                            Если ТекВидДвиж = Неопределено Тогда
                                Если МетаРС.Содержит(Движение) Тогда
                                    ЭтоДвижениеРегистраБухгалтерии = Ложь;
                                    ЭтоДвижениеРегистраРасчета = Ложь;
                                    ЭтоДвижениеРегистраСведений = Истина;
                                    ТекВидДвиж = "РС";
                                ИначеЕсли МетаРН.Содержит(Движение) Тогда
                                    ЭтоДвижениеРегистраБухгалтерии = Ложь;
                                    ЭтоДвижениеРегистраРасчета = Ложь;
                                    ЭтоДвижениеРегистраСведений = Ложь;
                                    ТекВидДвиж = "РН";
                                ИначеЕсли МетаРБ.Содержит(Движение) Тогда
                                    ЭтоДвижениеРегистраБухгалтерии = Истина;
                                    ЭтоДвижениеРегистраРасчета = Ложь;
                                    ЭтоДвижениеРегистраСведений = Ложь;
                                    ТекВидДвиж = "РБ";
                                Иначе
                                    ЭтоДвижениеРегистраБухгалтерии = Ложь;
                                    ЭтоДвижениеРегистраРасчета = Истина;
                                    ЭтоДвижениеРегистраСведений = Ложь;
                                    ТекВидДвиж = "РР";
                                КонецЕсли; 
                                ИнфоЭтиМД.Движения.Вставить(Движение, ТекВидДвиж);
                            Иначе
                                ЭтоДвижениеРегистраБухгалтерии = ТекВидДвиж = "РБ";
                                ЭтоДвижениеРегистраРасчета = ТекВидДвиж = "РР";
                                ЭтоДвижениеРегистраСведений = ТекВидДвиж = "РС";
                            КонецЕсли;
                            //@skip-check wrong-type-expression
                            ЕстьКорреспонденция = ЭтоДвижениеРегистраБухгалтерии и ПараметрыХ[Движение.Имя + "Корреспонденция"];
                            НаборЗаписей  = ТекОбъект.Движения[Движение.Имя];
                            НаборЗаписей.Прочитать(); //1698 запусков 4%
                            НадоЗаписывать = Ложь;
                            ТаблицаНабора = НаборЗаписей.Выгрузить();
                            ТеККолво = ТаблицаНабора.Количество();
                            Если ТеККолво = 0 Тогда
                                Продолжить;
                            ИначеЕсли ТекКолво < 200 Тогда
                                Для каждого ТекЗапись Из ТаблицаНабора Цикл
                                    Для Каждого Измерение ИЗ Движение.Измерения Цикл
                                        Если ЕстьКорреспонденция И НЕ Измерение.Балансовый Тогда // (Измерение.ПризнакУчета <> Неопределено) Тогда
                                            ИмяРекв = Измерение.Имя + "Дт";
                                            Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
                                                НадоЗаписывать = Истина;
                                            КонецЕсли;  
                                            ИмяРекв = Измерение.Имя + "Кт";
                                            Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
                                                НадоЗаписывать = Истина;
                                            КонецЕсли;  
                                        Иначе
                                            ИмяРекв = Измерение.Имя;
                                            Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
                                                НадоЗаписывать = Истина;
                                            КонецЕсли;  
                                        КонецЕсли;
                                    КонецЦикла;
                                    // Получим имена ресурсов, которые могут содержать ссылку
                                    Если ЭтоДвижениеРегистраСведений Тогда
                                        Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
                                            //Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
                                            Если ЗаменитьСсылку(ТекЗапись, Ресурс.Имя, ТекЗамены, Лог) <> Неопределено Тогда
                                                НадоЗаписывать = Истина;
                                            КонецЕсли;  
                                        КонецЦикла;
                                    КонецЕсли;
                                    // Получим имена ресурсов, которые могут содержать ссылку
                                    Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
                                        Если ЗаменитьСсылку(ТекЗапись, Реквизит.Имя, ТекЗамены, Лог) <> Неопределено Тогда
                                            НадоЗаписывать = Истина;
                                        КонецЕсли;  
                                    КонецЦикла;
                                    Если ЭтоДвижениеРегистраБухгалтерии Тогда
                                        //@skip-check wrong-type-expression
                                        Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
                                            Если ЕстьКорреспонденция Тогда
                                                СубДт = "СубконтоДт" + ИндексСубконто;
                                                СубКт = "СубконтоКт" + ИндексСубконто;
                                                Если ЗаменитьСсылку(ТекЗапись, СубДт, ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                                Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                            Иначе                           
                                                СубКт = "Субконто" + ИндексСубконто;
                                                Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                            КонецЕсли;                      
                                        КонецЦикла;
                                        //Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
                                            Если ЕстьКорреспонденция Тогда
                                                Если ЗаменитьСсылку(ТекЗапись, "СчетДт", ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                                Если ЗаменитьСсылку(ТекЗапись, "СчетКт", ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                            Иначе
                                                Если ЗаменитьСсылку(ТекЗапись, "Счет", ТекЗамены, Лог) <> Неопределено Тогда
                                                    НадоЗаписывать = Истина;
                                                КонецЕсли;  
                                            КонецЕсли;
                                        //КонецЕсли;
                                    КонецЕсли;
                                    Если ЭтоДвижениеРегистраРасчета Тогда
                                        Если ЗаменитьСсылку(ТекЗапись, "ВидРасчета", ТекЗамены, Лог) <> Неопределено Тогда
                                            НадоЗаписывать = Истина;
                                        КонецЕсли;  
                                    КонецЕсли;
                                КонецЦикла; 
                            Иначе
                                Для каждого КиЗ Из ТекЗамены Цикл
                                    ПравильныйЭлемент = КиЗ.Значение;
                                    Ссылка = КиЗ.Ключ;
                                    масИменКолонок = Новый Массив;
                                    // Получим имена измерений, которые могут содержать ссылку
                                    Для Каждого Измерение ИЗ Движение.Измерения Цикл
                                        Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
                                            Если ЕстьКорреспонденция И (Измерение.ПризнакУчета <> Неопределено) Тогда
                                                масИменКолонок.Добавить(Измерение.Имя + "Дт");
                                                масИменКолонок.Добавить(Измерение.Имя + "Кт");
                                            Иначе
                                                масИменКолонок.Добавить(Измерение.Имя);
                                            КонецЕсли;
                                        КонецЕсли;
                                    КонецЦикла;
                                    // Получим имена ресурсов, которые могут содержать ссылку
                                    Если ЭтоДвижениеРегистраСведений Тогда
                                        Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
                                            Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
                                                масИменКолонок.Добавить(Ресурс.Имя);
                                            КонецЕсли;
                                        КонецЦикла;
                                    КонецЕсли;
                                    // Получим имена ресурсов, которые могут содержать ссылку
                                    Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
                                        Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
                                            масИменКолонок.Добавить(Реквизит.Имя);
                                        КонецЕсли;
                                    КонецЦикла;
                                    // Произведем замены в таблице
                                    Для Каждого ИмяКолонки Из масИменКолонок Цикл //4 млн 3%
                                        СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки); //3,7 млн, 8%
                                        Пока СтрокаТабЧасти <> Неопределено Цикл //3,7 млн 2%
                                            СтрокаТабЧасти[ИмяКолонки] = ПравильныйЭлемент;
                                            НадоЗаписывать = Истина;
                                            СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки);
                                        КонецЦикла;
                                    КонецЦикла;
                                    Если ЭтоДвижениеРегистраБухгалтерии Тогда
                                        //@skip-check wrong-type-expression
                                        Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
                                            Если ЕстьКорреспонденция Тогда
                                                СубДт = "СубконтоДт" + ИндексСубконто;
                                                СубКт = "СубконтоКт" + ИндексСубконто;
                                                СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
                                                Пока СтрокаТабЧасти <> Неопределено Цикл
                                                    СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
                                                    НадоЗаписывать = Истина;
                                                    СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
                                                КонецЦикла;
                                                СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
                                                Пока СтрокаТабЧасти <> Неопределено Цикл
                                                    СтрокаТабЧасти[СубКт] = ПравильныйЭлемент;
                                                    НадоЗаписывать = Истина;
                                                    СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
                                                КонецЦикла;                             
                                            Иначе                           
                                                СубДт = "Субконто" + ИндексСубконто;
                                                СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
                                                Пока СтрокаТабЧасти <> Неопределено Цикл
                                                    СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
                                                    НадоЗаписывать = Истина;
                                                    СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
                                                КонецЦикла;                         
                                            КонецЕсли;                      
                                        КонецЦикла;
                                        Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
                                            Для Каждого СтрокаТабЧасти Из ТаблицаНабора Цикл
                                                Если ЕстьКорреспонденция Тогда
                                                    Если СтрокаТабЧасти.СчетДт = Ссылка Тогда
                                                        СтрокаТабЧасти.СчетДт = ПравильныйЭлемент;
                                                        НадоЗаписывать = Истина;
                                                    КонецЕсли;
                                                    Если СтрокаТабЧасти.СчетКт = Ссылка Тогда
                                                        СтрокаТабЧасти.СчетКт = ПравильныйЭлемент;
                                                        НадоЗаписывать = Истина;
                                                    КонецЕсли;
                                                Иначе
                                                    Если СтрокаТабЧасти.Счет = Ссылка Тогда
                                                        СтрокаТабЧасти.Счет = ПравильныйЭлемент;
                                                        НадоЗаписывать = Истина;
                                                    КонецЕсли;
                                                КонецЕсли;
                                            КонецЦикла;
                                        КонецЕсли;
                                    КонецЕсли;
                                    Если ЭтоДвижениеРегистраРасчета Тогда //2% 600000
                                        СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
                                        Пока СтрокаТабЧасти <> Неопределено Цикл
                                            СтрокаТабЧасти["ВидРасчета"] = ПравильныйЭлемент;
                                            НадоЗаписывать = Истина;
                                            СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
                                        КонецЦикла;
                                    КонецЕсли;
                                КонецЦикла; 
                            КонецЕсли;
                            Если НадоЗаписывать Тогда
                                НаборЗаписей.Загрузить(ТаблицаНабора);
                                Если ОтключатьКонтрольЗаписи Тогда
                                    НаборЗаписей.ОбменДанными.Загрузка = Истина;
                                КонецЕсли;
                                КЗаписи.Добавить(НаборЗаписей);
                                //НаборЗаписей.Записать();
                            КонецЕсли;
                        КонецЦикла;
                        Для Каждого Последовательность ИЗ МетаПос Цикл
                            //Последовательностей мало, а по уму тоже надо в массив выностить
                            ТекПослед = ИнфоПослед[Последовательность];
                            Если ТекПослед = Неопределено Тогда
                                ТекПослед = Последовательность.Документы.Содержит(МетаХ);
                                ИнфоПослед.Вставить(Последовательность, ТекПослед);
                                НадоЗаписывать = Ложь;
                                НаборЗаписи = Последовательности[Последовательность.Имя].СоздатьНаборЗаписей();
                                НаборЗаписи.Отбор.Регистратор.Установить(СтрокаДанных.Данные);
                                НаборЗаписи.Прочитать();
                                Если НаборЗаписи.Количество() > 0 Тогда
                                    Для Каждого Измерение ИЗ Последовательность.Измерения Цикл
                                        Если ЗаменитьСсылку(НаборЗаписи[0], Измерение.Имя, ТекЗамены, Лог) <> Неопределено Тогда
                                            НадоЗаписывать = Истина;
                                        КонецЕсли;  
                                        //Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) И НаборЗаписи[0][Измерение.Имя]=Ссылка Тогда
                                        Если НадоЗаписывать Тогда
                                            Если ОтключатьКонтрольЗаписи Тогда
                                                НаборЗаписи.ОбменДанными.Загрузка = Истина;
                                            КонецЕсли;
                                            КЗаписи.Добавить(НаборЗаписей);
                                            //НаборЗаписи.Записать();
                                        КонецЕсли;
                                    КонецЦикла; 
                                КонецЕсли;
                            КонецЕсли;
                        КонецЦикла;
                    КонецЕсли; 
                Исключение  
                    СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов движений)");
                    БылиИсключения = Истина;
                    Если ВыполнятьВТранзакции Тогда
                        Прервать; //На откат
                    Иначе
                        ИсключенияВДанных = Истина;
                    КонецЕсли;
                КонецПопытки;
                Если НЕ ИсключенияВДанных Тогда
                    Если ОтключатьКонтрольЗаписи Тогда
                        ТекОбъект.ОбменДанными.Загрузка = Истина;
                    КонецЕсли;
                    Если Не ВыполнятьВТранзакции Тогда
                        НачатьТранзакцию();
                    КонецЕсли;
                    Попытка
                        Для каждого ТекЗапись Из КЗаписи Цикл
                            ТекЗапись.Записать();
                        КонецЦикла; 
                        ТекОбъект.Записать();
                        Если Не ВыполнятьВТранзакции Тогда
                            ЗафиксироватьТранзакцию();
                        КонецЕсли; 
                    Исключение
                        СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи движений или объекта)");
                        БылиИсключения = Истина;
                        Если ВыполнятьВТранзакции Тогда
                            Прервать; //На откат
                        Иначе
                            ОтменитьТранзакцию();
                        КонецЕсли;
                    КонецПопытки;
                КонецЕсли; 
            КонецЕсли; 
        Иначе
            Сообщение = Новый СообщениеПользователю;
            Сообщение.Текст = "Ссылки типа " + МетаХ + " не заменяются!!";
            Сообщение.Сообщить();
        КонецЕсли; 
    КонецЦикла;
    Если ВыполнятьВТранзакции Тогда
        Если БылиИсключения Тогда
            ОтменитьТранзакцию();
        Иначе
            ЗафиксироватьТранзакцию();
        КонецЕсли;  
    КонецЕсли;
    Возврат Не БылиИсключения;
КонецФункции //ЗаменитьСсылкиПоСоответствию

#КонецОбласти 

// Возвращает таблицу найденных ссылок по массиву искомых ссылок. Также является вспомогательной для функций замены.
// Параметры:
//  Ссылки  - Массив из Произвольный, ЛюбаяСсылка - или Список значений = искомые ссылки
// Возвращаемое значение:
//   ТаблицаЗначений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//      "Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция НайтиСсылкиПоМассиву(Ссылки) Экспорт
    Если ТипЗнч(Ссылки) = Тип("СписокЗначений") Тогда
        МассивЗаменяемых = Ссылки.ВыгрузитьЗначения();
    Иначе
        МассивЗаменяемых = Ссылки;
        //КлиентСерверХЪ
        ПреобразоватьВМассив(МассивЗаменяемых, Истина);
    КонецЕсли;
    НайденныеСсылки = НайтиПоСсылкам(МассивЗаменяемых);
    НайденныеСсылки.Колонки[0].Имя = "Ссылка";
    НайденныеСсылки.Колонки[1].Имя = "Данные";
    НайденныеСсылки.Колонки[2].Имя = "Метаданные";
    НайденныеСсылки.Колонки.Добавить("Включено", Новый ОписаниеТипов("Булево"));
    НайденныеСсылки.ЗаполнитьЗначения(Истина, "Включено");
    Возврат НайденныеСсылки;
КонецФункции // НайтиСсылкиПоМассиву()
 
// Возвращает таблицу найденных ссылок по таблице замен с колонками ЧтоЗаменять и Пометка
// Параметры:
//  ТабЗамен - ТаблицаЗначений - с колонками Пометка и ЧтоЗаменять
// Возвращаемое значение:
//   ТаблицаЗначений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//      "Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция НайтиСсылкиПоТаблицеЗамен(ТабЗамен) Экспорт
    ТабЗаменяемых = ТабЗамен.Скопировать(ТабЗамен.НайтиСтроки(Новый Структура("Пометка", Истина)), "ЧтоЗаменять");
    ТабЗаменяемых.Свернуть("ЧтоЗаменять");
    МассивЗаменяемых = ТабЗаменяемых.ВыгрузитьКолонку("ЧтоЗаменять");
    Если МассивЗаменяемых.Количество() = 0 Тогда
        Сообщение = Новый СообщениеПользователю;
        Сообщение.Текст = "Не выбрано ни одного значения для поиска!";
        Сообщение.Сообщить();
        Возврат Новый ТаблицаЗначений;
    КонецЕсли;
    Возврат НайтиСсылкиПоМассиву(МассивЗаменяемых)
КонецФункции

// Получает ссылку нового или существующего объекта, а если она пустая, то устанавливает её и возвращает новую ссылку.
// Параметры:
//  ПроверяемыйОбъект  - СправочникОбъект, ДокументОбъект - или иной объект = ссылка на который проверяется
// Возвращаемое значение:
//   ЛюбаяСсылка   -  на объект
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СсылкаНаОбъект(ПроверяемыйОбъект) Экспорт
    Если ПроверяемыйОбъект.ЭтоНовый() Тогда
        Результат = ПроверяемыйОбъект.ПолучитьСсылкуНового();
        Если СокрЛП(Результат.УникальныйИдентификатор()) = "00000000-0000-0000-0000-000000000000" Тогда
            Результат = ИмяТаблицыОбъектаПоТипу(ТипЗнч(Результат), "Менеджер").ПолучитьСсылку(Новый УникальныйИдентификатор);//ВОЛНА_ОбщегоНазначенияПовтИспСеансВызовСервера.
            ПроверяемыйОбъект.УстановитьСсылкуНового(Результат);
        КонецЕсли; 
    Иначе
        Результат = ПроверяемыйОбъект.Ссылка;
    КонецЕсли; 
    Возврат Результат
КонецФункции // СсылкаНаОбъект

#КонецОбласти 

#Область 		ТАБЛИЧНЫЙ_ДОКУМЕНТ

#Область 			РАСШИФРОВКА

// Заполняет в структуру имена и значения полей расшифровки
// Параметры:
//  Приёмник  - Структура - ключ = имя поля, значение = значение поля
//  ЭлементРасшифровки  - ЭлементРасшифровкиКомпоновкиДанныхПоля, ЭлементРасшифровкиКомпоновкиДанныхГруппировка - у которого будут искаться родительские поля
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, ЭлементРасшифровки) Экспорт
    ТекТип = ТипЗнч(ЭлементРасшифровки);
    Рекурсировать = Ложь;
    Если ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхПоля") Тогда
        Для каждого Поле Из ЭлементРасшифровки.ПолучитьПоля() Цикл
            Приёмник.Вставить(Поле.Поле, Поле.Значение);
        КонецЦикла;
        Рекурсировать = Истина;
    ИначеЕсли ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхГруппировка") Тогда
        Рекурсировать = Истина;
    КонецЕсли;
    Если Рекурсировать Тогда
        Для каждого Родитель_ Из ЭлементРасшифровки.ПолучитьРодителей() Цикл
            ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, Родитель_);
        КонецЦикла;
    КонецЕсли;
КонецПроцедуры // ПоляРасшифровкиВСтруктуруРекурсивно

#КонецОбласти
    
// Выводит картинку в табличный документ
// Параметры:
//  Приёмник  - ТабличныйДокумент - куда помещается картинка
//  Картинка_   - Картинка, ДвоичныеДанные - источник картинки
//  Верх_  - Число - Координата размещения картинки. По умолчанию 0
//  Лево_  - Число - Координата размещения картинки. По умолчанию 0
//  Высота_  - Число - Размер картинки. По умолчанию 20
//  Ширина_  - Число - Размер картинки. По умолчанию 20
//  Узор  - ТипУзораТабличногоДокумента - Узор картинки. По умолчанию без узора.
//  Линия  - Линия - Линия картинки. По умолчанию НетЛинии
//  Прозрачность  - Булево - Прозрачность картинки. По умолчанию Истина
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Процедура ВывестиКартинкуВТД(
		Приёмник,
		Картинка_ = Неопределено,
		Верх_ = 0,
		Лево_ = 0,
		Высота_ = 20,
		Ширина_ = 20,
		Узор = Неопределено,
		Линия = Неопределено,
		Прозрачность = Истина) Экспорт
    ТипКартинка = Тип("Картинка");
    ТипДД = Тип("ДвоичныеДанные");
    НовыйРисунок = Приёмник.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
    НовыйРисунок.Верх = Верх_;
    НовыйРисунок.Лево = Лево_;
    НовыйРисунок.Высота = Высота_;
    НовыйРисунок.Ширина = Ширина_;
    НовыйРисунок.Линия = ?(Линия = Неопределено, Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии), Линия);
    НовыйРисунок.Узор = ?(Узор = Неопределено, ТипУзораТабличногоДокумента.БезУзора, Узор);
    ТекКартинка = ?(Картинка_ = Неопределено, Новый Картинка, Картинка_);
    ТипТК = ТипЗнч(ТекКартинка);
    Если ТипТК = ТипДД Тогда
        НовыйРисунок.Картинка = Новый Картинка(ТекКартинка, Прозрачность);
    ИначеЕсли ТипТК = ТипКартинка Тогда
        НовыйРисунок.Картинка = ТекКартинка;
    КонецЕсли;
КонецПроцедуры // ВывестиКартинкуВТД

// Возвращает табличный документ с выведенной таблицей значений
// Параметры:
//  ТабЗн           - ТаблицаЗначений - таблица для вывода
//  ПерваяКолонка   - Число - >=1 = Номер первой колонки табличного документа для вывода данных. По умолчанию 1.
//  СтрокаЗаголовка - Число - Номер строки табличного документа для вывода заголовков колонок. <= 1 - заголовок не выводится. По умолчанию 1.
//  СтрокаДанных    - Число - Номер первой строки табличного документа для вывода данных таблицы. 0 - переводится в СтрокаЗаголовка + 1 (по умолчанию). <= СтрокаЗаголовка - данные не выводятся.
//  СтрокаИтогов    - Число - Номер строки табличного документа для вывода итогов. 0 (по умолчанию) - итоги не выводятся. Отрицательные значения - отсчёт от конца данных (-1 - сразу после данных).
//  КолонкиИтогов   - Строка, Массив из Строка - колонки, по которым подводятся итоги. По умолчанию Неопределено - итоги не выводятся.
//  СвойстваЯчеек   - Структура - ключи - имена колонок, значения - структуры, свойства которых копируются в ячейки колонки.
//          Ключи "ЯчейкаЗаголовок" и "ЯчейкаИтог" содержат такие же структуры для заголовков и  итогов. По умолчанию Неопределено - пустая структура.
//  Автовыравнивание- Булево - Истина - автовыравнивание: по верхнему краю, числа и даты - по правому краю, булево - по центру, остальное - по левому краю. В итогах и заголовках не действует.
//  ТолькоТекст     - Булево - Истина - вывод в свойство "Текст" ячейки, Ложь - в свойство "Значение". По умолчанию Ложь.
//  ЦветЗаголовка   - Цвет - Цвет фона заголовка по умолчанию (до применения свойств ячеек). По умолчанию Неопределено - без цвета.
//  ЦветРамки       - Цвет - Цвет границ. По умолчанию Неопределено - без цвета.
//  ЛинияГраниц     - Линия - Линия границ. По умолчанию Неопределено - без границ.
// Возвращаемое значение:
//   ТабличныйДокумент   - содержащий выведенную таблицу значений
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Функция ТабличныйДокументИзТаблицыЗначений(
		ТабЗн,
		ПерваяКолонка = 1,
		СтрокаЗаголовка = 1,
		СтрокаДанных = 0,
		СтрокаИтогов = 0,
		КолонкиИтогов = Неопределено,
        СвойстваЯчеек = Неопределено,
        Автовыравнивание = Истина,
        ТолькоТекст = Ложь,
        ЦветЗаголовка = Неопределено,
        ЦветРамки = Неопределено,
        ЛинияГраниц = Неопределено) Экспорт
    Результат = Новый ТабличныйДокумент;
    ПустаяСтруктура = Новый Структура;
    Если СвойстваЯчеек = Неопределено Тогда
        СвойстваЯчеек = ПустаяСтруктура;
    КонецЕсли;
    ПерваяСтрока = ?(СтрокаДанных = 0, СтрокаЗаголовка + 1, СтрокаДанных);
    КолвоСтрок = ТабЗн.Количество();
    СтрокаВыводаИтогов = ?(СтрокаИтогов < 0, ПерваяСтрока + КолвоСтрок - 1 - СтрокаИтогов, СтрокаИтогов);
    МИтогов = ?(КолонкиИтогов = Неопределено, Новый Массив, ?(ТипЗнч(КолонкиИтогов) = Тип("Строка"), СтрРазделить(КолонкиИтогов,, Ложь), КолонкиИтогов));
    ВыводитьЗаголовки = СтрокаЗаголовка >= 0;
    ВыводитьДанные = ПерваяСтрока > СтрокаЗаголовка;
    ВыводитьИтоги = (СтрокаВыводаИтогов >= 0) И (МИтогов.Количество() > 0);
    СтрНачала = Мин(СтрокаЗаголовка, СтрокаВыводаИтогов);
    СтрОкончания = Макс(СтрокаВыводаИтогов, ПерваяСтрока + КолвоСтрок - 1);
    ТипЧисло = Тип("Число");
    ТипДата = Тип("Дата");
    ТипБулево = Тип("Булево");
    
    СчКол = ПерваяКолонка;
    Для каждого Колонка Из ТабЗн.Колонки Цикл
        СвойстваЯчКол = ЧтСтрукт(СвойстваЯчеек, Колонка.Имя, ПустаяСтруктура);
        #Область ЗАГОЛОВКИ
            Если ВыводитьЗаголовки Тогда
                Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
                Ячейка_.Текст = Колонка.Имя;
                ГраницыИЗаливка(Ячейка_, ЦветЗаголовка, ЦветРамки, ЛинияГраниц);
                ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаЗаголовок", ПустаяСтруктура));
                Результат.Область(СтрНачала, СчКол, СтрОкончания, СчКол).ШиринаКолонки = Колонка.Ширина;
            КонецЕсли;
        #КонецОбласти
    
        #Область ИТОГИ
            Если ВыводитьИтоги И (МИтогов.СтрНайти(Колонка.Имя) <> Неопределено) Тогда
                Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
                Ячейка_.Текст = ТабЗн.Итог(Колонка.Имя);
                Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
                ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
                Ячейка_.Шрифт = Новый Шрифт(Ячейка_.Шрифт,,, Истина);
                ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаИтог", ПустаяСтруктура));
            КонецЕсли;
        #КонецОбласти
        #Область ДАННЫЕ
             Если ВыводитьДанные Тогда
                Ячейка_ = Результат.Область(ПерваяСтрока, СчКол, ПерваяСтрока + КолвоСтрок - 1, СчКол);
                Если ТолькоТекст Тогда
                    ИмяСвойства = "Текст";
                    СодержитЗначение = Ложь;
                Иначе
                    ИмяСвойства = "Значение";
                    СодержитЗначение = Истина;
                КонецЕсли;
                СчСтр = 0;
                Для каждого СтрокаТЗ Из ТабЗн Цикл
                    Ячейка_ = Результат.Область(ПерваяСтрока + СчСтр, СчКол);
                    Ячейка_.СодержитЗначение = СодержитЗначение;
                    ТекЗнч = СтрокаТЗ[Колонка.Имя];
                    Ячейка_[ИмяСвойства] = ТекЗнч;
                    ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
                    Если Автовыравнивание Тогда
                        ТекТип = ТипЗнч(ТекЗнч);
                        Ячейка_.ВертикальноеПоложение = ВертикальноеПоложение.Верх;
                        Если (ТекТип = ТипЧисло) ИЛИ (ТекТип = ТипДата) Тогда
                            Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
                        ИначеЕсли ТекТип = ТипБулево Тогда
                            Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
                        Иначе
                            Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
                        КонецЕсли;
                    КонецЕсли;
                    ЗаполнитьЗначенияСвойств(Ячейка_, СвойстваЯчКол);
                    СчСтр = СчСтр + 1;
                КонецЦикла;
            КонецЕсли;
        #КонецОбласти
    
        СчКол = СчКол + 1;
    КонецЦикла;
    
    Возврат Результат
КонецФункции // ТабличныйДокументИзТаблицыЗначений

// Проверяет, укладывается ли ТД в заданное колво страниц по ширине
// Параметры:
//  ТДок  - ТабличныйДокумент - ПроверяемыйТД
//  Страниц  - Число - Количество страниц в ширину. По умолчанию 1
//  Масштаб  - Число - Проверяемый масштаб. По умолчанию  0 = Берётся масштаб документа
// Возвращаемое значение:
//   Булево   - Документ размещается в страницы по ширине
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция ШиринаТДВСтраницахНеБолее(ТДок, Страниц = 1, Масштаб = 0) Экспорт
    Если Страниц <= 0 Тогда
        Результат = Истина;
    Иначе
        ПроверяемыйМасштаб = ?(Масштаб = 0, ТДок.МасштабПечати, Масштаб);
        ПустойТД = Новый ТабличныйДокумент;
        ПустойТД.Автомасштаб = Ложь;
        ПустойТД.МасштабПечати = ПроверяемыйМасштаб / Страниц;
        КПроверке = Новый Массив;
        КПроверке.Добавить(ТДок);
        Результат = ПустойТД.ПроверитьПрисоединение(КПроверке);
    КонецЕсли;
    Возврат Результат
КонецФункции // ШиринаТДВСтраницахНеБолее

#Область 			РАСПОЛОЖИТЬ_НА_СТРАНИЦУ
    
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
&НаСервереБезКонтекста
Функция ПолучитьВременныйТД(ТабДок, Временный)
    Если Временный = Неопределено Тогда
        Временный = СкопироватьПараметрыТД(, ТабДок);
        Временный.Вывести(ТабДок);
        Временный.АвтоМасштаб = Ложь;
    КонецЕсли;
    Возврат Временный
КонецФункции

// Проверяет расположение документов для неразрывной печати "низа" с подписями
// Вспомогательная для ПроверитьРасположениеИОбновитьРезультат
// Параметры:
//  ТабДок  - ТабличныйДокумент - Проверяемый ТД
//  МассивОписанийДокументов  - Массив из Структура - Каждая структура = описание одного документа при печати нескольких документов в один ТД.
//              Возможные ключи: Числа (номера строк) Начало, НачалоНиза и Конец, табличные документы Верх и Полный.
//  АвтоМасштаб  - Булево - Значение для установки автомасштаба. По умолчанию Истина.
//  МасштабПечати  - Число, Неопределено - По умолчанию Неопределено. Значение для установки масштаба печати
//  ХранитьТД  - Булево - Хранить ТД в ключах Верх и Полный элементов МассивОписанийДокументов для последующих использований (Ложь - каждый раз рассчитывать по НачалоНиза и Конец)
//  ДопустимоПлохих  - Число - Процент "плохих" (неисправленных) документов, принимаемый как удовлетворительный
//  КолвоВсего  - Число - Знаменатель расчёта процента плохих
//  МасштабРешения  - Число - Переменная для установки найденного масштаба
//  РезультатРешения  - Число - Переменная для процента "плохих" документов (присвоится, если будет найдено удовлетворительное решение лучше найденных ранее).
//  КолвоПлохих  - Число - Переменная для возврата количества найденных "плохих" документов.
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Процедура ПроверитьРасположениеДокументов(
        ТабДок,
        МассивОписанийДокументов,
        АвтоМасштаб = Истина,
        МасштабПечати = Неопределено,
        ХранитьТД,
        ДопустимоПлохих,
        КолвоВсего,
        МасштабРешения,
        РезультатРешения,
        КолвоПлохих = 0)
    КолвоПлохих = 0;
    Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
        Если ОписаниеДока.Свойство("Верх") Тогда
            ТДДляТестирования = ОписаниеДока.Верх;
            ТДДляТестированияПолный = ОписаниеДока.Полный;
            Если НЕ ХранитьТД Тогда
                ОписаниеДока.Удалить("Верх");
                ОписаниеДока.Удалить("Полный");
            КонецЕсли; 
        Иначе
            ТДДляТестирования = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.НачалоНиза - 1,);
            СкопироватьПараметрыТД(ТДДляТестирования, ТабДок);
            ТДДляТестированияПолный = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.Конец,);
            СкопироватьПараметрыТД(ТДДляТестированияПолный, ТДДляТестирования);
            Если ХранитьТД Тогда
                ОписаниеДока.Вставить("Верх", ТДДляТестирования);
                ОписаниеДока.Вставить("Полный", ТДДляТестированияПолный);
            КонецЕсли; 
        КонецЕсли; 
        ТДДляТестирования.Автомасштаб = Автомасштаб;
        ТДДляТестирования.МасштабПечати = МасштабПечати;
        ТДДляТестированияПолный.Автомасштаб = Автомасштаб;
        ТДДляТестированияПолный.МасштабПечати = МасштабПечати;
        КолвоСтраниц = ТДДляТестированияПолный.КоличествоСтраниц();
        Если ТДДляТестирования.КоличествоСтраниц() <> КолвоСтраниц Тогда
            КолвоПлохих = КолвоПлохих + 1;
        КонецЕсли;
    КонецЦикла;
    ТекРезультат = КолвоПлохих * 100 / КолвоВсего;
    Если ТекРезультат <= ДопустимоПлохих Тогда
        Если ТекРезультат < РезультатРешения Тогда
            МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
            РезультатРешения = ТекРезультат;
        ИначеЕсли ТекРезультат = РезультатРешения И МасштабРешения < МасштабПечати Тогда
            МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры // ПроверитьРасположениеДокументов
 
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
//Параметры см.ПроверитьРасположениеДокументов; Временный ТД - копия Табдок для экспериментов
//@skip-check method-too-many-params
&НаКлиентеНаСервереБезКонтекста
Процедура ПроверитьРасположениеИОбновитьРезультат(
        ТабДок,
        ВременныйТД,
        МассивОписанийДокументов,
        Автомасштаб,
        МасштабПечати,
        ХранитьТД,
        ДопустимоПлохих,
        КолвоВсего,
        МасштабРешения,
        РезультатРешения,
        КолвоПлохих = Неопределено,
        ПродолжитьПоискРешения)
    РезультатТекВарианта = 100;
    МасштабТекВарианта = 0;
    ПроверитьРасположениеДокументов(ВременныйТД, МассивОписанийДокументов, Автомасштаб, МасштабПечати, ХранитьТД, ДопустимоПлохих,
            КолвоВсего, МасштабТекВарианта, РезультатТекВарианта, КолвоПлохих); 
    Если РезультатТекВарианта = 0 Тогда
        ТабДок.АвтоМасштаб = Автомасштаб;
        ТабДок.МасштабПечати = МасштабТекВарианта;
        ПродолжитьПоискРешения = Ложь;
    ИначеЕсли РезультатТекВарианта < РезультатРешения Тогда
        Если АвтоМасштаб Тогда
            ВременныйТД.АвтоМасштаб = Ложь;
        КонецЕсли;
        МасштабРешения = МасштабТекВарианта;
        РезультатРешения = РезультатТекВарианта;
    КонецЕсли; 
КонецПроцедуры

// Располагает "низ" (условно - подписи) документа в пределах последней страницы неразрывно. Проверка идёт на то, что Низ и Верх должны заканчиваться на одной странице.
//  Алгоритм описан в начале функции
//  Рекомендация (но не обязательно) - делать макет единой ширины, т.к. иначе Получитьобласть() может работать некорректно.
// Параметры:
//  ТабДок  - ТабличныйДокумент - Преобразуемый табличный документ
//  ПроверятьРазмещениеСтраницВШирину - Число - По умолчанию 1. 0 = Не проверять.
//  НачальныйМасштаб  - Число - Масштаб табличного документа, с которого включительно начинаются попытки уменьшать масштаб.
//          По умолчанию 0 - МасштабПечати ТабДок, а если он не задан - 100%
//  КонечныйМасштаб  - Число - Масштаб табличного документа, до которого включительно проводятся попытки уменьшать масштаб.
//          По умолчанию 0 - НачальныйМасштаб - 30%
//  АвтоМасштаб  - Булево - Выполнять проверку с установленным автомасштабом. По умолчанию Истина.
//  УменьшениеМасштаба  - Булево - Выполнять проверку уменьшения масштаба. По умолчанию Истина.
//  ЕслиНеНашлосьБыстроИскатьПеребором  - Булево - Если "быстрый" способ не дал решения - поискать перебором масштабов (это долго). По умолчанию Истина.
//  ВставлятьРазрыв  - Булево - Вставлять разрыв, если масштаб подобрать не удалось. По умолчанию Истина.
//  ДопустимоПлохих  - Число - Процент допустимых "плохих" документов. По умолчанию 0.
//  ПолучилосьПлохих  - Число - Переменная, в которую будет возвращено число плохих документов в процентах от общего числа. По умолчанию 0.
//  МОписанияДокументов - Массив из Структура, Неопределено - (по умолчанию Неопределено) = массив структур с ключами Начало, НачалоНиза и Конец. Такой массив иногда проще составить при формировании ТД,
//          и, если он составлен, передать в эту процедуру готовый. Если массив задан, все параметры далее не используются. Если не задан - составляется в этой процедуре.
//  ВысотаВерха  - Число - Высота верха. В ТД выведено несколько документов (например, СФ и Актов).
//          Каждый документ состоит из низа (условно - блока подписей) и верха (документа до этого блока).
//          Для подбора масштаба надо найти эти документы и их верхи. Они могут быть фиксированными (заданы высота верха и/или высота документа) в строках.
//          По умолчанию 0, в этом случае производится поиск по контрольному значению в контрольной колонке.
//  КонтрольнаяКолонкаВерха  - Число - Колонка, в которой ищется контрольное значение при определении "верха".
//          Имеет смысл только при ВысотаВерха = 0. По умолчанию 1.
//          Если задано значение 0, то контрольное значение не считывается из колонки, а считается ИСТИНОЙ.
//          В этом случае имеет смысл использование в КонтрольноеЗначениеВерха только "менеджера" и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Истина.
//          М.б. задано менеджером, тогда рассчитвывается перед стартом и после нахождения контрольного значения ДОКУМЕНТА.
//          В "МЕНЕДЖЕРАХ" используются имена Табдок, МассивОписанийДокументов (см. мОписанияДокументов) - только для уже найденных документов,
//              НомерТекущейСтрокиТД, КонтрольнаяКолонкаВерха, КонтрольнаяКолонкаДокумента, ВысотаВерха, НачалоТекущегоДокумента, НачалоТекущегоНиза.
//  КонтрольноеЗначениеВерха  - Строка - Искомое контрольное значение при определении верха. Найденная строка при нулевом отступе является последней строкой верха.
//          Ищется в контрольной колонке. Имеет смысл только при ВысотаВерха = 0. По умолчанию "ИТОГО:".
//          Может быть "менеджером" (т.е. рассчитываться). 
//  РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз  - Булево - Заставляет пересчитывать контрольное значение для каждой проверяемой строки ТД.
//          Имеет смысл только при ВысотаВерха = 0 и применении "менеджера" в КонтрольноеЗначениеВерха. По умолчанию Ложь.
//          Установка в Истина при работе на клиенте может привести к массовым вызовам сервера, что не айс.
//  ОтступВерха  - Число - Отступ последней строки верха от строки, в которой найдено контрольное значение. Имеет смысл только при ВысотаВерха = 0. По умолчанию 0.
//  ВысотаДокумента  - Число - Высота всего документа (см. ВысотаВерха). Если значение не найдено, весь остаток ТД считается документом к распечатке.
//          Если задано - 1 (по умолчанию) - считается, что в ТД документ один и искать документы не надо.
//  КонтрольнаяКолонкаДокумента  - Число - Номер колонки (см. ВысотаВерха и КонтрольнаяКолонкаВерха).
//  КонтрольноеЗначениеДокумента  - Строка - Искомое контрольное значение (см. ВысотаВерха и КонтрольноеЗначениеВерха). Найденная строка при нулевом отступе является последней строкой документа.
//  РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз  - Булево - Рсчёт КЗ в каждой строке (см. ВысотаВерха и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз).
//  ОтступДокумента  - Число - Отступ последней строки документа (см. ВысотаВерха и ОтступВерха).
//@skip-check export-method-in-command-form-module
//@skip-check method-too-many-params
&НаСервереБезКонтекста
Процедура РасположитьПодвалТДНеразрывно(
        ТабДок,
        ПроверятьРазмещениеСтраницВШирину = 1,
        НачальныйМасштаб = 0,
        КонечныйМасштаб = 0,
        АвтоМасштаб = Истина,
        УменьшениеМасштаба = Истина,
        ЕслиНеНашлосьБыстроИскатьПеребором = Истина,
        ВставлятьРазрыв = Истина,
        ДопустимоПлохих = 0,
        ПолучилосьПлохих = 0,
        МОписанияДокументов = Неопределено,
        ВысотаВерха = 0,
        КонтрольнаяКолонкаВерха = 1,
        КонтрольноеЗначениеВерха = "ИТОГО:",
        РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Ложь,
        ОтступВерха = 0,
        ВысотаДокумента = -1,
        КонтрольнаяКолонкаДокумента = 1,
        КонтрольноеЗначениеДокумента = "ИТОГО:",
        РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз = Ложь,
        ОтступДокумента = -1
        ) Экспорт
        
    //Алгоритм проверки
    //1.Проверка при автомасштабе - полная; Если по умолчанию не автомасштаб - выполняется после шага 2.
    //2.Проверка при заданном начальном масштабе - полная (после проверки по ширине).
    //3.Поиск 100% решения ускоренным методом (половинное деление масштабов, быстрый расчёт). Проводится этапами: 1 - поиск интервала масштабов с ок шириной; 2- поиск решения (попутно ищутся неполные решения)
    //4.Полная проверка результата п.3
    //5.Если результат не найден - последовательное, с шагом 1%, уменьшение масштаба от верхней границы
    //6.Вставка разрывов страниц
    
    #Область ИНИЦИАЛИЗАЦИЯ_ОБЩАЯ
        СтрокаНачалаДокумента = 1;
        МасштабРешения = - 1;
        РезультатРешения = 100; //Процент "плохих"
        МасштабТекВарианта = -1;
        РезультатТекВарианта = 100;
        ВременныйТД = Неопределено;
        МасштабироватьДалее = Истина;
        РезультатУхудшился = Ложь;
        
        ВысотаТД = ТабДок.ВысотаТаблицы;
        ВычисленныйНачальныйМасштаб = ?(НачальныйМасштаб = 0, ?(ТабДок.МасштабПечати = Неопределено, 100, ТабДок.МасштабПечати), НачальныйМасштаб);
        ВычисленныйКонечныйМасштаб = ?(КонечныйМасштаб = 0, НачальныйМасштаб - 30, КонечныйМасштаб);
    #КонецОбласти
        
    #Область ВЫЧИСЛЕНИЕ_ПАРАМЕТРОВ_ВЫСОТЫ_ДОКУМЕНТОВ
        Если мОписанияДокументов = Неопределено Тогда
            #Область ИНИЦИАЛИЗАЦИЯ_ВПВД
                МассивОписанийДокументов = Новый Массив;
                ВычисленнаяВысотаВерха = ВысотаВерха;
                ВычисленнаяВысотаДокумента = ВысотаДокумента;
                ВычисленныйОтступВерха = ОтступВерха;
                ВычисленныйОтступДокумента = ОтступДокумента;
                #Область ПАРАМЕТРЫ_МЕНЕДЖЕРОВ
                    ПараметрыМенеджеров = Новый Структура;
                    ПараметрыМенеджеров.Вставить("Табдок", Табдок);
                    ПараметрыМенеджеров.Вставить("МассивОписанийДокументов", МассивОписанийДокументов);
                    ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", 0);
                    ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", КонтрольнаяКолонкаВерха);
                    ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", КонтрольнаяКолонкаДокумента);
                    ПараметрыМенеджеров.Вставить("ВысотаВерха", ВычисленнаяВысотаВерха);
                    ПараметрыМенеджеров.Вставить("ВысотаДокумента", ВычисленнаяВысотаДокумента);
                    ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
                    ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", 1);
                    ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
                #КонецОбласти
                #Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
                    ВычисленнаяКонтрольнаяКолонкаВерха = ЗапуститьМенеджер(КонтрольнаяКолонкаВерха, ПараметрыМенеджеров);
                    КолонкаВерхаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
                    Если КолонкаВерхаЗаданаМенеджером Тогда
                        ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", ВычисленнаяКонтрольнаяКолонкаВерха);
                    КонецЕсли;
                #КонецОбласти
                #Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
                    ВычисленнаяКонтрольнаяКолонкаДокумента = ЗапуститьМенеджер(КонтрольнаяКолонкаДокумента, ПараметрыМенеджеров);
                    КолонкаДокументаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
                    Если КолонкаДокументаЗаданаМенеджером Тогда
                        ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", ВычисленнаяКонтрольнаяКолонкаДокумента);
                    КонецЕсли;
                #КонецОбласти
                Если (ВычисленнаяВысотаВерха = 0) И НЕ РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
                    ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
                КонецЕсли; 
                Если (ВычисленнаяВысотаДокумента = 0) И НЕ РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз Тогда
                    ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
                КонецЕсли; 
            #КонецОбласти 
            Пока СтрокаНачалаДокумента <= ВысотаТД Цикл
                ОписаниеДока = Новый Структура("Начало,НачалоНиза,Конец", СтрокаНачалаДокумента, 0, 0);
                Если ВычисленнаяВысотаВерха <> 0 Тогда
                    ОписаниеДока.НачалоНиза = ОписаниеДока.Начало + ВычисленнаяВысотаВерха;
                КонецЕсли; 
                Если ВычисленнаяВысотаДокумента > 0 Тогда
                    ОписаниеДока.Конец = ОписаниеДока.Начало + ВычисленнаяВысотаДокумента - 1;
                ИначеЕсли ВычисленнаяВысотаДокумента = -1 Тогда
                    ОписаниеДока.Конец = ВысотаТД;
                КонецЕсли; 
                Если (ОписаниеДока.НачалоНиза = 0) ИЛИ (ОписаниеДока.Конец = 0) Тогда
                    СтартоваяКС = ОписаниеДока.Начало - Макс(Мин(0, ВычисленныйОтступВерха), Мин(0, ВычисленныйОтступДокумента));
                    ФинишнаяКС = ТабДок.ВысотаТаблицы - Мин(Макс(0, ВычисленныйОтступВерха), Макс(0, ВычисленныйОтступДокумента));
                    Для КонтрольнаяСтрока = СтартоваяКС По ФинишнаяКС Цикл
                        ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", КонтрольнаяСтрока);
                        Если РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз И (ОписаниеДока.Конец = 0) Тогда
                            ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
                        КонецЕсли;
                        ВозможныйКонецДокумента = КонтрольнаяСтрока + ВычисленныйОтступДокумента;
                        Если ?((ОписаниеДока.Конец = 0) И (ВозможныйКонецДокумента > 0),
                                ВычисленноеКонтрольноеЗначениеДокумента =
                                    ?(ВычисленнаяКонтрольнаяКолонкаДокумента = 0,
                                        Истина,
                                        ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаДокумента).Текст),
                                Ложь)
                                Тогда
                            #Область РАСЧЁТ_КОНЦА_ДОКУМЕНТА
                                ОписаниеДока.Конец = ВозможныйКонецДокумента;
                                Если ОписаниеДока.НачалоНиза = 0 Тогда
                                    ОписаниеДока.НачалоНиза = ОписаниеДока.Конец + 1;
                                КонецЕсли;
                                Прервать
                            #КонецОбласти
                        ИначеЕсли ОписаниеДока.НачалоНиза = 0 Тогда
                            #Область РАСЧЁТ_НАЧАЛА_НИЗА
                                Если РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
                                    ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
                                КонецЕсли; 
                                Если ?(ВычисленнаяКонтрольнаяКолонкаВерха = 0, Истина, ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаВерха).Текст) = ВычисленноеКонтрольноеЗначениеВерха Тогда
                                    ОписаниеДока.НачалоНиза = КонтрольнаяСтрока + ВычисленныйОтступВерха + 1;
                                    ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", ОписаниеДока.НачалоНиза);
                                    Если ОписаниеДока.Конец > 0 Тогда
                                        Прервать;
                                    КонецЕсли;
                                КонецЕсли;
                            #КонецОбласти
                        КонецЕсли;
                    КонецЦикла;
                    Если ОписаниеДока.НачалоНиза = 0 Тогда
                        ОписаниеДока.НачалоНиза = ФинишнаяКС + 1;
                    КонецЕсли;
                    Если ОписаниеДока.Конец = 0 Тогда
                        ОписаниеДока.Конец = ФинишнаяКС;
                    КонецЕсли;
                КонецЕсли;
                МассивОписанийДокументов.Добавить(ОписаниеДока);
                СтрокаНачалаДокумента = ОписаниеДока.Конец + 1;
                ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", СтрокаНачалаДокумента);
                ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
                ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
            КонецЦикла; 
        Иначе
            МассивОписанийДокументов = мОписанияДокументов;
        КонецЕсли;
        КолвоВсего = МассивОписанийДокументов.Количество();
        ХранитьТД = КолвоВсего < 100;
    #КонецОбласти
    
    Если КолвоВсего < 1 Тогда
        МасштабироватьДалее = Ложь;
    КонецЕсли;
    
    #Область ПРОВЕРКА_АВТОМАСШТАБА_1
        ПроверитьАвтоМасштаб = АвтоМасштаб И (ПроверятьРазмещениеСтраницВШирину < 2);
        Если ПроверитьАвтоМасштаб И МасштабироватьДалее И ТабДок.АвтоМасштаб  Тогда
            ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
            ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
                    КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
        КонецЕсли;
    #КонецОбласти 
    
    #Область ПРОВЕРКА_НАЧАЛЬНОГО_МАСШТАБА
        Если МасштабироватьДалее Тогда
            ПлохихВНачальнойТочке = КолвоВсего;
            ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
            ШиринаВПределе = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ВычисленныйНачальныйМасштаб);
            Если ШиринаВПределе Тогда
                ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ВычисленныйНачальныйМасштаб, ХранитьТД, ДопустимоПлохих,
                        КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
            Иначе
                РезультатРешения = 100;
            КонецЕсли;
        КонецЕсли; 
    #КонецОбласти 
    
    #Область ПРОВЕРКА_АВТОМАСШТАБА_2
        Если ПроверитьАвтоМасштаб И МасштабироватьДалее И НЕ ТабДок.АвтоМасштаб  Тогда
            ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
            ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
                    КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
        КонецЕсли;
    #КонецОбласти 
    
    #Область УМЕНЬШЕНИЕ_МАСШТАБА_ПОЛОВИННЫМ_ДЕЛЕНИЕМ
        Если УменьшениеМасштаба И МасштабироватьДалее Тогда
            //Допущение:
            //Предполагается, что при уменьшении масштаба сначала "плохие" перейдут в "хорошие", а уже потом начнут портиться "хорошие". Т.е. пока не ушли "плохие", "хорошие" будут ок.
            Для Этап = 1 По 2 Цикл
                Если МасштабироватьДалее
                        И ((Этап = 2) И (ПроверятьРазмещениеСтраницВШирину > 0) ИЛИ НЕ ШиринаВПределе) Тогда 
                    #Область ИНИЦИАЛИЗАЦИЯ_УМЕНЬШЕНИЯ
                        ВерхнийПределМасштаба = ВычисленныйНачальныйМасштаб - 1; //ВНМ уже проверен
                        НижнийПределМасштаба = ВычисленныйКонечныйМасштаб;
                        Вектор = - 1; //Вероятность решения выше в верхнем краю масштабной сетки
                        ВекторНазначен = Ложь;
                        Если Этап = 1 Тогда
                            ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
                        Иначе
                            ТекПлохих = ПлохихВНачальнойТочке;
                            ВременныйТД.МасштабПечати = ВычисленныйНачальныйМасштаб;
                            ИсходноеКолвоСтраниц = ВременныйТД.КоличествоСтраниц();
                            РезультатТекВарианта = РезультатРешения;
                            МасштабТекВарианта = ВерхнийПределМасштаба;
                            ПлохиеМасштабы = Новый Массив;
                        КонецЕсли;
                        ТочкаПроверки = ВерхнийПределМасштаба;
                    #КонецОбласти
                    //ДопУсловие = Ложь;
                    Пока (ВерхнийПределМасштаба >= НижнийПределМасштаба) Цикл 
                        ДлинаОтрезкаМасштабов = ВерхнийПределМасштаба - НижнийПределМасштаба + 1;
                        Шаг = ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор);
                        ТочкаПроВерки = ВерхнийПределМасштаба - Шаг + 1;
                        Если Этап = 1 Тогда
                            РезультатОк = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ТочкаПроВерки);
                        Иначе
                            ВременныйТД.МасштабПечати = ТочкаПроВерки;
                            Дельта = (ИсходноеКолвоСтраниц - ВременныйТД.КоличествоСтраниц()) / ПроверятьРазмещениеСтраницВШирину;
                            ТекПлохих = Цел(ПлохихВНачальнойТочке - Дельта);
                            ТекРезультат = ТекПлохих * 100 / КолвоВсего;
                            Если ТекРезультат <= ДопустимоПлохих Тогда
                                Если ТекРезультат < РезультатТекВарианта Тогда
                                    РезультатТекВарианта = ТекРезультат;
                                    МасштабТекВарианта = ТочкаПроВерки;
                                ИначеЕсли ТекРезультат = РезультатТекВарианта И МасштабТекВарианта < ТочкаПроВерки Тогда
                                    МасштабТекВарианта = ТочкаПроВерки;
                                КонецЕсли; 
                            КонецЕсли; 
                            Если ТекПлохих = 0 Тогда
                                РезультатОк = Истина;
                            Иначе
                                РезультатОк = Ложь;
                                ПлохиеМасштабы.Вставить(ТочкаПроВерки);
                            КонецЕсли;
                        КонецЕсли; 
                        Если РезультатОк Тогда
                            Если НЕ ВекторНазначен Тогда
                                Вектор = 1;
                                ВекторНазначен = Истина;
                            КонецЕсли; 
                            НижнийПределМасштаба = ТочкаПроВерки + 1;
                        Иначе
                            ВерхнийПределМасштаба = ТочкаПроВерки - 1;
                        КонецЕсли;
                    КонецЦикла;
                    Если Этап = 1 Тогда
                        ВычисленныйНачальныйМасштаб = ВерхнийПределМасштаба;
                        Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
                            МасштабТекВарианта = ВычисленныйНачальныйМасштаб;
                            РезультатТекВарианта = -1;
                        Иначе
                            Прервать;
                        КонецЕсли;
                    КонецЕсли;
                    Если РезультатТекВарианта < РезультатРешения Тогда
                        ТочкаПроВерки = МасштабТекВарианта;
                        ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
                                КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
                    КонецЕсли;
                    Если Этап = 2 Тогда
                        РезультатУхудшился = РезультатТекВарианта < РезультатРешения;
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    #КонецОбласти 
    
    #Область УМЕНЬШЕНИЕ_МАСШТАБА_ПЕРЕБОРОМ
        Если УменьшениеМасштаба И МасштабироватьДалее И ЕслиНеНашлосьБыстроИскатьПеребором Тогда
            #Область КРОМЕ_ПЛОХИХ_МАСШТАБОВ
                Для Сдвиг = ВычисленныйКонечныйМасштаб По ВычисленныйНачальныйМасштаб - 1 Цикл
                    ТочкаПроВерки = ВычисленныйНачальныйМасштаб + ВычисленныйКонечныйМасштаб - Сдвиг - 1;
                    Если ПлохиеМасштабы.Найти(ТочкаПроВерки) = Неопределено Тогда
                        ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
                                КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
                        Если НЕ МасштабироватьДалее Тогда
                            Прервать;
                        КонецЕсли;
                    КонецЕсли;
                КонецЦикла;
            #КонецОбласти
            
            //В плохих масштабах решение м.б. лучшим только если текущее решение ухудшилось при точной проверке
            Если МасштабироватьДалее И РезультатУхудшился Тогда
                Для каждого ТочкаПроВерки Из ПлохиеМасштабы Цикл
                    ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
                            КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
                    Если НЕ МасштабироватьДалее Тогда
                        Прервать;
                    КонецЕсли;
                КонецЦикла;
            КонецЕсли;
        КонецЕсли;
    #КонецОбласти
    
    ПолучилосьПлохих = РезультатРешения;
    
    #Область АНАЛИЗ_РЕЗУЛЬТАТА_И_ВСТАВКА_РАЗРЫВА
        Если МасштабироватьДалее И ВставлятьРазрыв Тогда
            ВременныйТД = ТабДок;
            ТабДок = СкопироватьПараметрыТД(, ВременныйТД);
            Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
                ТабДок.АвтоМасштаб = Ложь;
                ТабДок.МасштабПечати = ВычисленныйНачальныйМасштаб;
            Иначе
                ТабДок.АвтоМасштаб = Истина;
                ТабДок.МасштабПечати = 0;
            КонецЕсли; 
            НуженРазделитель = Ложь;
            Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
                Если НуженРазделитель Тогда
                    ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
                Иначе
                    НуженРазделитель = Истина;
                КонецЕсли;
                ОбластьКПроверкеИВыводу = ВременныйТД.ПолучитьОбласть(ОписаниеДока.НачалоНиза - 1,, ОписаниеДока.Конец);
                ТабДок.Вывести(ВременныйТД.ПолучитьОбласть(ОписаниеДока.Начало,, ОписаниеДока.НачалоНиза - 2));
                Если НЕ ТабДок.ПроверитьВывод(ОбластьКПроверкеИВыводу) Тогда
                    ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
                КонецЕсли;
                ТабДок.Вывести(ОбластьКПроверкеИВыводу);
            КонецЦикла; 
        ИначеЕсли МасштабРешения = 0 Тогда
            ТабДок.АвтоМасштаб = Истина;
            ТабДок.МасштабПечати = Неопределено;
        ИначеЕсли МасштабРешения <> - 1 Тогда
            ТабДок.АвтоМасштаб = Ложь;
            ТабДок.МасштабПечати = МасштабРешения;
        КонецЕсли; 
    #КонецОбласти 
            
КонецПроцедуры // ТабДок_РасположитьВСтранице

#КонецОбласти

#КонецОбласти

#Область 		УПРАВЛЯЕМАЯ_ФОРМА

// Преобразует таблицу значений в динамический список. ВНИМАНИЕ! Колонки ДС не обновляются, их надо обновлять функцией СоздатьКолонкиТаблицы.
// Скорее всего проще не переделывать ТЗ в ДС, а сделать команды фильтров
// Параметры:
//  ДинСписок  - ДинамическийСписок - Реквизит формы, приёмник
//  ТабИсточник  - ТаблицаЗначений - Источник данных. Не проверялось для больших таблиц.
//  ТипизироватьКолонки  - Строка - Список через запятую имён колонок или "ВСЕ". Если пустая строка (по умолчанию) - ни одна колонка не типизируется.
//          Типизация влияет на применение, например, вида сравнения "в иерархии".
//  ИмяПоляКлюча  - Строка - Имя специального поля поле с уникальным номером строки. По умолчанию "КлючСтроки". Если пустое - поле ключа не создаётся
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Процедура ДинамическийСписокИзТаблицыЗначений(ДинСписок, ТабИсточник, ТипизироватьКолонки = "", ИмяПоляКлюча = "КлючСтроки") Экспорт
    ПерваяСтрока = Истина;
    #Область ТИПИЗАЦИЯ
        Если ТипизироватьКолонки <> "" Тогда
            #Область ТАБЛИЦА_ПРИМЕРНЫХ_ЗНАЧЕНИЙ
                ОбозначениеПараметра = Новый Цвет;
                ТабЗнТипы = ТабИсточник.СкопироватьКолонки();
                ТабЗнТипы = Новый ТаблицаЗначений;
                Для каждого Колонка Из ТабИсточник.Колонки Цикл
                    ТабЗнТипы.Колонки.Добавить(Колонка.Имя);
                КонецЦикла;
                ТабЗнТипы.Добавить();
                СтруктураТипизируемыхКолонок = Новый Структура(ТипизироватьКолонки);
                Для каждого Колонка Из ТабИсточник.Колонки Цикл
                    ИмяКолонки = Колонка.Имя;
                    ТекТипы = Колонка.ТипЗначения.Типы();
                    Если ТекТипы.Количество() И ?(ТипизироватьКолонки = "ВСЕ", Истина, СтруктураТипизируемыхКолонок.Свойство(ИмяКолонки)) Тогда
                        ЁХ = 0;
                        Для каждого Тек_Тип Из ТекТипы Цикл
                            Если ЁХ = ТабЗнТипы.Количество() Тогда
                                ТабЗнТипы.Добавить();
                            КонецЕсли;
                            ТабЗнТипы[ЁХ][ИмяКолонки] =
                            		//КлиентСерверХЪ
                            		ПримерноеЗначение(
	                                    Тек_Тип,
    	                                Колонка.ТипЗначения.КвалификаторыЧисла,
        	                            Колонка.ТипЗначения.КвалификаторыСтроки,
            	                        Колонка.ТипЗначения.КвалификаторыДаты);
                            ЁХ = ЁХ + 1;
                        КонецЦикла;
                    Иначе
                        ТабЗнТипы[0][ИмяКолонки] = ОбозначениеПараметра;
                    КонецЕсли;
                КонецЦикла;
            #КонецОбласти
            #Область ТЕКСТ_ТИПИЗАЦИИ
                ТекстТипизации = "";
                Для каждого Строчка Из ТабЗнТипы Цикл
                    ТекстПоСтроке = "";
                    Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
                        ТекЗнч = Строчка[Колонка.Имя];
                        ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС
                                + ?(ЗначениеЗаполнено(ТекЗнч) И ТекЗнч <> ОбозначениеПараметра, ТекЗнч, "&ПараметрПусто")
                                + ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
                    КонецЦикла;
                    Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
                        ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "0"
                                + ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
                    КонецЕсли;
                    ПерваяСтрока = Ложь;
                    ТекстТипизации = ТекстТипизации + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС + "ГДЕ ЛОЖЬ" + Символы.ПС;
                КонецЦикла;
            #КонецОбласти
        КонецЕсли;
    #КонецОбласти
    #Область ФОРМИРОВАНИЕ_ТЕКСТА_И_ПАРАМЕТРОВ_ЗАПРОСА
        #Область ТЕКСТ_ПАРАМЕТРОВ_И_ПАРАМЕТРЫ
            ЁХ = 0;
            ТекстЗапроса= ТекстТипизации;
            НовыеПараметры = Новый Структура;
            Для каждого Строчка Из ТабИсточник Цикл
                ТекстПоСтроке = "";
                Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
                    ИмяКолонки = Колонка.Имя;
                    ИмяПараметра = "Строчка" + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0")) + ИмяКолонки;
                    ТекЗнч = Строчка[Колонка.Имя];
                    НовыеПараметры.Вставить(ИмяПараметра, ТекЗнч);
                    ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "&" + ИмяПараметра
                            + ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
                КонецЦикла;
                Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
                    ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0"))
                            + ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
                КонецЕсли;
                ПерваяСтрока = Ложь;
                ТекстЗапроса = ТекстЗапроса + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС;
                ЁХ = ЁХ + 1;
            КонецЦикла;
        #КонецОбласти
        #Область БАЗОВЫЙ_И_ФИНАЛЬНЫЙ_ТЕКСТ
            ДинСписок.ТекстЗапроса = Сред(ТекстЗапроса, 16);
            Если СтрНайти(ДинСписок.ТекстЗапроса, "&ПараметрПусто") > 0 Тогда
                ДинСписок.Параметры.УстановитьЗначениеПараметра("ПараметрПусто", Неопределено);
            КонецЕсли;
            Для каждого КиЗ Из НовыеПараметры Цикл
                ДинСписок.Параметры.УстановитьЗначениеПараметра(КиЗ.Ключ, КиЗ.Значение);
            КонецЦикла;
        #КонецОбласти
    #КонецОбласти
КонецПроцедуры // ДинамическийСписокИзТаблицыЗначений

// Формирует реквизит и элемент формы под загрузку заданной таблицы (в т.ч. колонки), а затем загружает туда таблицу
// Параметры:
//  УФорма  - ФормаКлиентскогоПриложения - Форма, которой принадлежит таблица или дерево
//  ИмяПриёмника  - Строка - Имя элемента, соответствующего загружаемой таблице
//  ТабИсточник  - ТаблицаЗначений, ДеревоЗначений - Имя реквизита и элемента, соответствующего загружаемой таблице
//  Загружать   - Строка -
//      *"Загрузка" - через Загрузить (только для таблиц значений)
//      *"ЗначВРеквФормы" - через ЗначениеВРеквизитФормы (по умолчанию). Только для одноуровневого пути.
//      *"Нет" - не выполнять
//  ТолькоЭлементы  - Булево - Не выполнять изменение реквизитов формы. По умолчанию Ложь.
// Возвращаемое значение:
//  Массив из Строка - имена колонок
//@skip-check export-method-in-command-form-module
&НаСервереБезКонтекста
Функция СоздатьКолонкиТаблицы(УФорма, ИмяПриёмника, ТабИсточник, Загружать = "ЗначВРеквФормы", ТолькоЭлементы = Ложь) Экспорт
    Результат = Новый Массив;
    МассивДобавляемыхРеквизитов = Новый Массив;
    ПутьКПриёмнику = УФорма.Элементы[ИмяПриёмника].ПутьКДанным;
    #Область РЕКВИЗИТЫ
        Если НЕ ТолькоЭлементы Тогда
            Для Каждого Колонка Из ТабИсточник.Колонки Цикл 
                РеквизитФормы = Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ПутьКПриёмнику, Колонка.Имя); 
                МассивДобавляемыхРеквизитов.Добавить(РеквизитФормы);
                Результат.Добавить(Колонка.Имя);
            КонецЦикла;
            МассивУдаляемыхРеквизитов = Новый Массив;
            Для Каждого РеквизитХ Из УФорма.ПолучитьРеквизиты(ПутьКПриёмнику) Цикл 
                МассивУдаляемыхРеквизитов.Добавить(ПутьКПриёмнику + "." + РеквизитХ.Имя); 
            КонецЦикла;
            УФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов, МассивУдаляемыхРеквизитов);
        КонецЕсли;
    #КонецОбласти
    #Область ЭЛЕМЕНТЫ
        МассивУдаляемыхРеквизитов = Новый Массив;
        Для Каждого КолонкаХ Из УФорма.Элементы[ИмяПриёмника].ПодчиненныеЭлементы Цикл
            МассивУдаляемыхРеквизитов.Добавить(КолонкаХ);
        КонецЦикла;
        Для Каждого КолонкаХ Из МассивУдаляемыхРеквизитов Цикл
            УФорма.Элементы.Удалить(КолонкаХ);
        КонецЦикла;
        Для Каждого Колонка Из ТабИсточник.Колонки Цикл
            Попытка
                Элемент = УФорма.Элементы.Добавить(ИмяПриёмника + "_" + Колонка.Имя, Тип("ПолеФормы"), УФорма.Элементы[ИмяПриёмника]); 
                Элемент.Заголовок = Колонка.Имя;
                Если Колонка.ТипЗначения = Новый ОписаниеТипов("Булево") Тогда
                    Элемент.Вид = ВидПоляФормы.ПолеФлажка;
                    Элемент.ВидФлажка = ВидФлажка.Флажок;
                    Элемент.РежимРедактирования = РежимРедактированияКолонки.Непосредственно;
                Иначе
                    Элемент.Вид = ВидПоляФормы.ПолеВвода;
                КонецЕсли;
                Элемент.ПутьКДанным = ПутьКПриёмнику + "." + Колонка.Имя;
            Исключение
                ООш = ОписаниеОшибки();
                Сообщение = Новый СообщениеПользователю;
                Сообщение.Текст = "Не удалось добавить колонку " + Колонка.Имя + " по причине: " + ООш;
                Сообщение.Сообщить();
            КонецПопытки;
        КонецЦикла;
    #КонецОбласти 
    Если Загружать <> "Нет" Тогда
        Если Загружать = "Загрузка" Тогда
            УФорма[ПутьКПриёмнику].Загрузить(ТабИсточник);
        Иначе
            УФорма.ЗначениеВРеквизитФормы(ТабИсточник, ПутьКПриёмнику);
        КонецЕсли;
    КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьКолонкиТаблицы

#КонецОбласти 

#КонецОбласти

#КонецОбласти

#Область КАРАНТИН

//Функции не используются и хранятся только для сохранения алгоритма трансляции

#Область ЗАПУСК

// Выполняет метод ВОЛНА. Предназначен для вызова с клиента: как из обработки, так и из модуля.
//	Нужна только в клиентском модуле, т.к. только там нужен &НаКлиенте.
//	КлиентСерверный модуль вызывается из макета по тексту, серверные - из модуля объекта
// Параметры:
//  ТекстВызова  - Строка - Текст вызова метода
//  СПрм  - Структура, Неопределено - Параметры вызова метода. По умолчанию Неопределено.
//  ЭтоФункция  - Булево - Вызвать как функцию. По умолчанию Ложь = вызов процедуры.
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода.Если ВернутьУспех = Истина Тогда возвращает структуру с ключами Успех и Результат
&НаКлиенте
Функция ВыполнитьМетодВОЛНА(ТекстВызова, СПрм = Неопределено, ЭтоФункция = Ложь) Экспорт
	Если Ложь Тогда Это___Форма = 1 КонецЕсли;
	Если Это___Форма Тогда
		#Область ЭТО_ОБРАБОТКА
			ИмяМодуля = Лев(ТекстВызова, СтрНайти(ТекстВызова, ".") - 1);
			Если ВРег(ИмяМодуля) = "ВОЛНА_ОбщегоНазначенияКлиентСервер" Тогда
				Результат = Вычислить("ВладелецФормы.ВыполнитьПоТекстуМетода(ТекстВызова, СПрм)");
			Иначе
				Результат = Вычислить("ВладелецФормы.ВыполнитьМетодНастоящегоОбъекта(ТекстВызова, ЭтоФункция, СПрм)");
			КонецЕсли;
		#КонецОбласти
	Иначе
		#Область ЭТО_МОДУЛЬ
			ПозСкобки = СтрНайти(ТекстВызова, "(");
			//@skip-check bsl-variable-name-invalid
			мТекстВСкобках = СтрРазделить(Сред(ТекстВызова, ПозСкобки + 1, СтрДлина(ТекстВызова) - ПозСкобки - 1), ",", Истина);
			ВыполняемыйТекст = "";
			Для каждого ПараметрВызова Из мТекстВСкобках Цикл
				ВыполняемыйТекст = ВыполняемыйТекст + ","
						+ ?(ЗначениеЗаполнено(ПараметрВызова), "СПрм." + СокрЛП(ПараметрВызова), "");
			КонецЦикла;
			ВыполняемыйТекст = Лев(ТекстВызова, ПозСкобки) + Сред(ВыполняемыйТекст, 2) + ")";
			Если ЭтоФункция Тогда
				Результат = Вычислить(ВыполняемыйТекст);
			Иначе
				Выполнить(ВыполняемыйТекст);
				Результат = Неопределено;
			КонецЕсли;
		#КонецОбласти
	КонецЕсли;
	Возврат Результат
КонецФункции // ВыполнитьМетодВОЛНА

#Конецобласти

#Область 		ТРАНСЛЯЦИЯ_И_ЗАПУСК_МЕТОДОВ

// Выполняет библиотечный метод объекта
// Параметры:
//  ИмяМетода  - Строка - Имя вызываемого метода
//  Параметр01..25  - Произвольные - Параметры вызываемого метода
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода
&НаКлиенте
Функция ВызватьБиблиотечныйВС(ИмяМетода, Параметр01 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр02 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр03 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр04 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр05 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр06 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр07 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр08 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр09 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр10 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр11 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр12 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр13 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр14 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр15 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр16 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр17 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр18 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр19 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр20 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр21 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр22 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр23 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр24 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр25 = "НЕ____БЫЛ_____НАЗНАЧЕН")
	Результат = ВызватьССервераБиблиотечныйМетодОбъекта(ИмяМетода, Параметр01, Параметр02, Параметр03, Параметр04, Параметр05,
			Параметр06, Параметр07,  Параметр08, Параметр09, Параметр10, Параметр11, Параметр12, Параметр13, Параметр14, Параметр15, Параметр16, Параметр17,
			Параметр18, Параметр19, Параметр20, Параметр21, Параметр22, Параметр23, Параметр24, Параметр25);
	Возврат Результат
КонецФункции // ВызватьБиблиотечныйВС

// Выполняет библиотечный метод объекта
// Параметры:
//  ИмяМетода  - Строка - Имя вызываемого метода
//  Параметр01..25  - Произвольные - Параметры вызываемого метода
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода
&НаКлиенте
Функция ВызватьССервераБиблиотечныйМетодОбъекта(ИмяМетода, Параметр01, Параметр02, Параметр03, Параметр04, Параметр05,
			Параметр06, Параметр07,  Параметр08, Параметр09, Параметр10, Параметр11, Параметр12, Параметр13, Параметр14, Параметр15, Параметр16, Параметр17,
			Параметр18, Параметр19, Параметр20, Параметр21, Параметр22, Параметр23, Параметр24, Параметр25)
	Результат = Неопределено;
	КВыполнению = "";
	Фрагмент = "";
	Для ЁХХ = 1 По 25 Цикл
		ИмяПараметра = "Параметр" + Прав("00" + ЁХХ, 2);
		ТекЗнч = Вычислить(ИмяПараметра);
		Если ТекЗнч = "НЕ____БЫЛ_____НАЗНАЧЕН" Тогда
			Фрагмент = Фрагмент + ",";
		Иначе
			КВыполнению = КВыполнению + Фрагмент + "," + ИмяПараметра;
		КонецЕсли;
	КонецЦикла;
	КВыполнению = ИмяМетода + "(" + Сред(КВыполнению, 2) + ")";
	Попытка
		Результат = Вычислить(КВыполнению);
	Исключение
		Выполнить(КВыполнению);
	КонецПопытки;
	Возврат Результат
КонецФункции // ВызватьССервераБиблиотечныйМетодОбъекта

//Вспомогательная для УниверсальныйВызовМетодаИзТекста.
//Производит запуск кода в отдельной процедуре без лишних контекстов, кроме контекста формы, что надо учитывать при формировании ТекстКода
&НаКлиенте
Функция ВыполнитьКодИзТекстаСПараметрами(ТекстКода, Параметр01, Параметр02, Параметр03, Параметр04, Параметр05,
				Параметр06, Параметр07,  Параметр08, Параметр09, Параметр10, Параметр11, Параметр12, Параметр13, Параметр14, Параметр15, Параметр16, Параметр17,
				Параметр18, Параметр19, Параметр20, Параметр21, Параметр22, Параметр23, Параметр24, Параметр25)
	РезультатВыполненияВозвращаемый_КАК_Функцией = Неопределено;
	Выполнить(ТекстКода);
	Возврат РезультатВыполненияВозвращаемый_КАК_Функцией
КонецФункции

//Вспомогательная для ВыполнитьПоТекстуМетода.
//Производит запуск кода в отдельной процедуре без лишних контекстов, кроме контекста формы, что надо учитывать при формировании ТекстКода
&НаКлиенте
Функция ВыполнитьКодСПараметрами(ТекстКода, Структура_ПараметровПереданных)
	РезультатВыполненияВозвращаемый_КАК_Функцией = Неопределено;
	Выполнить(ТекстКода);
	Возврат РезультатВыполненияВозвращаемый_КАК_Функцией
КонецФункции

// Выполняет внутренний код метода из текста модуля и текста вызова с вычисленными параметрами
// Параметры:
//  ТекстВызова  - Строка - Текст вызова метода от имени модуля до закрывающей скобки включительно
//  СПрм  - Структура/Неопределено - Параметры вызова. По умолч. Неопределено.
// Возвращаемое значение:
//   Произвольный   - Результат вычисления. Для процедуры = Неопределено
&НаКлиенте
Функция ВыполнитьПоТекстуМетода(ТекстВызова, СПрм = Неопределено) Экспорт
	ПозТочки = СтрНайти(ТекстВызова, ".");
	ПозСкобки = СтрНайти(ТекстВызова, "(");
	ИмяМетода = ВРег(Сред(ТекстВызова, ПозТочки + 1, ПозСкобки - ПозТочки - 1));
	ДанныеМетода = ТрансляторКС[ИмяМетода];
	мТекстВСкобках = СтрРазделить(Сред(ТекстВызова, ПозСкобки + 1, СтрДлина(ТекстВызова) - ПозСкобки - 1), ",", Истина);
	ТекстПараметровДо = "";
	ТекстПараметровПосле = "";
	Колво = мТекстВСкобках.ВГраница();
	Для ЁХХ = 0 По ДанныеМетода.Параметры.ВГраница() Цикл
		ВходящееИмя = ?(ЁХХ > Колво, "", СокрЛП(мТекстВСкобках[ЁХХ]));
		Если ЗначениеЗаполнено(ВходящееИмя) Тогда
			ТекстПараметровДо = ТекстПараметровДо + Символы.ПС + ДанныеМетода.Параметры[ЁХХ].Имя + " = Структура_ПараметровПереданных." + ВходящееИмя + ";";
			Если НЕ ДанныеМетода.Параметры[ЁХХ].ЭтоЗнач Тогда
				ТекстПараметровПосле = ТекстПараметровПосле + Символы.ПС + "Структура_ПараметровПереданных." + ВходящееИмя + " = " + ДанныеМетода.Параметры[ЁХХ].Имя + ";";
			КонецЕсли;
		Иначе
			ТекстПараметровДо = ТекстПараметровДо + Символы.ПС + ДанныеМетода.Параметры[ЁХХ].Имя + " = " + ДанныеМетода.Параметры[ЁХХ].Значение + ";";
		КонецЕсли;
	КонецЦикла;
	Возврат ВыполнитьКодСПараметрами(ТекстПараметровДо + Символы.ПС + ДанныеМетода.Текст + ";" + Символы.ПС + ТекстПараметровПосле, СПрм)
КонецФункции // ВыполнитьПоТекстуМетода

// Выполняет серверный метод объекта формы
// Параметры:
//  ВыполняемыйКод  - Строка - Текст вызова метода
//  ЭтоФункция - Булево - Вызвать метод как функцию. По умолчанию Ложь. 
//  СПрм - Строка - Текст вызова метода
//  НастоящийОбъект  - Строка/ОбработкаОбъект - Если "Клиент" (умолч.), объект будет автоопределён, а если "Сервер" - ещё и возвращён.
//			Другие значения приведут к ошибке!
// Возвращаемое значение:
//   Структура   - Ключи:
//		*Успех - выполнено без ошибок
//		*Результат - результат выполнения
&НаСервере
Функция ВыполнитьМетодНастоящегоОбъекта(ВыполняемыйКод, ЭтоФункция = Ложь, СПрм = Неопределено, НастоящийОбъект = "Клиент") Экспорт
	ОтменаВозврата = НастоящийОбъект = "Клиент";
	Если ОтменаВозврата ИЛИ НастоящийОбъект = "Сервер" Тогда
		НастоящийОбъект = Вычислить("РеквизитФормыВЗначение(""Объект"")");
	КонецЕсли;
	Попытка
		Результат = НастоящийОбъект.ВыполнитьКод("НастоящийОбъект." + ВыполняемыйКод, СПрм, ЭтоФункция);
		Успех = Истина;
	Исключение
		Успех = Ложь;
	КонецПопытки;
	Если ОтменаВозврата Тогда
		НастоящийОбъект = "Клиент";
	КонецЕсли;
	Возврат Новый Структура("Результат,Успех", Результат, Успех)
КонецФункции // ВыполнитьМетодНастоящегоОбъекта

#КонецОбласти

#Область ОБРАБОТКА_КОДА

// Разбирает текст модуля и возвращает структуру методов
// Возвращаемое значение:
//   Структура   - ИмяМетода => Текст, ЭтоФункция, ЭтоЭкспорт, Параметры = массив структур(Имя, Значение, ЭтоЗнач)
&НаСервере
Функция СобратьТрансляциюМодуляКС()
	Настоящий = Неопределено;
	ПроверитьНастоящий(Настоящий);
	Возврат Настоящий.СобратьТрансляциюМодуля(МодульКС);
КонецФункции // СобратьТрансляциюМодуляКС

// ВВызывает метод из текста модуля и передаёт ему параметры
// Параметры:
//  ОписаниеМетода  - Структура - ключи Параметры ==> Массив структур с ключами Значение, Имя, ФактическийТекст, ЭтоЗнач; ЭтоЭкспорт; ЭтоФункция; Текст.
//  Возвратные  - Строка - Строка из 0 и 1, где при 1 параметр надо возвращать (он был задан переменной, а 0 = нет.
//  Параметр01..25  - Произвольный - Параметр в структуру
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода
&НаКлиенте
Функция УниверсальныйВызовМетодаИзТекста(ОписаниеМетода, Возвратные = "", Параметр01 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр02 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр03 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр04 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр05 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр06 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр07 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр08 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр09 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр10 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр11 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр12 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр13 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр14 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр15 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр16 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр17 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр18 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр19 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр20 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр21 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр22 = "НЕ____БЫЛ_____НАЗНАЧЕН",
		Параметр23 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр24 = "НЕ____БЫЛ_____НАЗНАЧЕН", Параметр25 = "НЕ____БЫЛ_____НАЗНАЧЕН")
	Результат = Неопределено;
	#Область ПЕРЕИМЕНОВАНИЯ_ПАРАМЕТРОВ_ПОД_МЕТОД_И_НАЗАД
		ТекстКодаДоВызова = "";
		ТекстКодаПослеВызова = "";
		//ДлинаПараметраВозвратных = СтрДлина(Возвратные);
		НомерПараметра = 1;
		Для каждого ОписаниеПараметра Из ОписаниеМетода.Параметры Цикл
			ИмяПараметра = "Параметр" + Прав("00" + НомерПараметра, 2);
			ПараметрНазначен = НЕ Вычислить(ИмяПараметра + "=""НЕ____БЫЛ_____НАЗНАЧЕН""");
			ЭтоПеременная = Истина;//А почему бы и не вернуть всегда ПараметрНазначен И НомерПараметра <= ДлинаПараметраВозвратных И Сред(Возвратные, НомерПараметра, 1) = "1";
			ТекстКодаДоВызова = ТекстКодаДоВызова + ОписаниеПараметра.Имя
					+ "=" + ?(ПараметрНазначен, ИмяПараметра, ОписаниеПараметра.Значение) + ";" + Символы.ПС;
			Если ЭтоПеременная И НЕ ОписаниеПараметра.ЭтоЗнач Тогда
				 ТекстКодаПослеВызова = ТекстКодаПослеВызова + Символы.ПС + ИмяПараметра + "=" + ОписаниеПараметра.Имя;
			КонецЕсли;
			НомерПараметра = НомерПараметра + 1;
		КонецЦикла;
	#КонецОбласти	
	#Область ВЫПОЛНЕНИЕ
		Результат = ВыполнитьКодИзТекстаСПараметрами(ТекстКодаДоВызова + ОписаниеМетода.Текст + ТекстКодаПослеВызова, Параметр01, Параметр02, Параметр03, Параметр04, Параметр05,
				Параметр06, Параметр07,  Параметр08, Параметр09, Параметр10, Параметр11, Параметр12, Параметр13, Параметр14, Параметр15, Параметр16, Параметр17,
				Параметр18, Параметр19, Параметр20, Параметр21, Параметр22, Параметр23, Параметр24, Параметр25);
	#КонецОбласти	
	Возврат Результат
КонецФункции // УниверсальныйВызовМетодаИзТекста

#КонецОбласти


#Конецобласти

