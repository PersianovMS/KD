//1.При вызове формы д.б. число
//2.Переделать события при переключении
//3.Переделелать сброс Неопределено в ноль
//4.Скорректировать процедуру обработки флагов.

#Область ОПИСАНИЕ_ФОРМЫ
//При переносе следует изменить тип ОбработкаОбъект на другую обработку или Произвольный.

//ПАРАМЕТРЫ НА ВХОДЕ:
//АдресДерева - Адрес дерева в хранилище. Обязателен.
//АдресПроизвольногоПараметра - Адрес произвольного параметра в хранилище. Не имеет смысла, если установлен ПроизвольныйПараметрВХранилище.
//АдресРезультата - Адрес в хранилище, куда следует поместить результат. Обязателен при РезультатВТаблицуЗначений = Истина.
//ВозвращаемыеРеквизиты - Список реквизитов, значения которых будут возвращены в массив. (см. также параметр РезультатВТаблицуЗначений)
//		Если указано несколько - элементом массива будет структура,
//		Если одно имя - значение из колонки,
//		Если пустая строка - строка дерева.
//ВыбиратьГруппы - возможность выбора групп дерева. Если Ложь - выбор группы будет равнозначен выбору всех подчинённых элементов.
//ВыборМногих - возможность выбора нескольких значений
//ДублиСтрокОбрабатыватьКакОднуСтроку - Булево - если в возвращаемых колонках одинаковые значения, то строки будут считаться "аналогами": если флаг изменён в одной из них - он изменится и в другой
//ИмяКолонкиДерева - имя колонки, в которой будет отображаться дерево (не доделано). Используется и для ПриОткрытииРаскрытьУровень1
//ИмяКолонкиФлагов - имя колонки, в которой будут отображаться флаги выбора строк.
//КомандыФормы - Структура, где ключ - имя команды, а значение - структура с ключами Заголовок,Код,Картинка,Подсказка, где Код - исполняемый в контексте этой формы код.
//НачальнаяПозиция - Структура, аналогичная для НайтиСтроки - для позиционирования в дереве при открытии.
//ОбработкаОбъект - При необходимости (например, см. ПоддержкаВОЛНА_Владельцем) заполняется объектом обработки.
//ОбработчикВыбора - обработчик, запускаемый при выборе строки. Выполняется перед стандартной обработкой (переменная СтандартнаяОбработка запускает
//		основную кнопку, а если выбор групп запрещён и выбрана группа = сворачивание/разворачивание.
//ОбработчикПриЗакрытии - обработчик, запускаемый после формирования результата.
//		Выполняется на сервере, если РезультатВТаблицуЗначений, иначе = на клиенте.
//		В обработчиках доступны Результат, контекст формы и Осина = дерево как объект (на сервере).
//ОбработчикПриОткрытии - обработчик, запускаемый при открытии на клиенте.
//ОбработчикПриСоздании - обработчик, запускаемый при создании на сервере.
//ОтображатьРеквизиты - список реквизитов дерева через запятую. Если перед именем реквизита стоит минус, реквизит будет невидим. Ненайденные будут отображаться так же, как и первый реквизит в списке.
//ПоддержкаВОЛНА_Владельцем - Владелец формы поддерживает запуск методов ВОЛНА, как в КД3.0. Настоятельно рекомендуется устанавливать при запуске, если поддерживает,
//		а заодно и Объект в ОбработкаОбъект скопировать.
//ПоправитьФлагиПриОткрытии - При открытии проверить и при необходимости переустановить флаги групп по содержимому групп
//ПриОткрытииРаскрытьУровень1 - список текстовых значений, при обнаружении которых в первом уровне соответствующие группы раскроются.
//ПроизвольныйПараметр - Произвольный параметр, размещаемый в реквизит
//ПроизвольныйПараметрВХранилище - Произвольный параметр, который будет размещён в хранилище по адресу АдресПроизвольногоПараметра. Если используется параметр АдресПроизвольногоПараметра - перезапишет его.
//РежимВыбораДерева - булево. Дерево будет в режиме выбора.
//РезультатВТаблицуЗначений - булево. Предполагается, что все колонки возвращаемых значений содержат допустимые на клиенте типы. Но не всегда это можно обеспечить.
//		Поэтому при Истина считается, что Результат не будет возвращён на клиент. На сервере будет сформирована таблица значений с колонками согласно параметру ВозвращаемыеРеквизиты, в неё
//		будут записываться реквизиты колонок из выбранных строк дерева, таблица сохраняется в АдресРезультата (в этом случае АдресРезультата обязателен).
//		При ЛОЖЬ формируется массив (см. параметр ВозвращаемыеРеквизиты)
//ТолькоПросмотрДерева - Булево - Только просмотр в элементе дерева.
//ТриСостоянияВКолонкеФлагов - Строка -
//		Все - все флаги имеют три состояния, группа смешанная, если дочерние флаги различаются.
//		ВГруппах - флаги групп имеют три состояния, смешанное состояние не назначается вручную, группа смешанная, если дочерние флаги различаются, флаги конечных строк имеют два состояния.
//		Нигде - все флаги имеют два состояния, флаг группы установлен, если все флаги внутри установлены.
#КонецОбласти

#Область ПРОГРАММНЫЙ_ИНТЕРФЕЙС
	
#КонецОбласти

#Область СОБЫТИЯ_ФОРМЫ
	
&НаКлиенте
Процедура ПриОткрытии(Отказ)
	Если ВременныеПараметры.ПоправитьФлагиПриОткрытии Тогда
		ПоправитьФлаги(Деревяшка, Истина);
	КонецЕсли;
	ВременныйПараметр = ВременныеПараметры.ПриОткрытииРаскрытьУровень1;
	Если ЗначениеЗаполнено(ИмяКолонкиДерева) И ЗначениеЗаполнено(ВременныйПараметр)
			Тогда
		Для каждого ТекЭлемент Из Деревяшка.ПолучитьЭлементы() Цикл
			Если ВыполнитьМетодВОЛНА_К("НайтиПодСтроку(П1, П2, "","")", Новый Структура("П1,П2", ВременныйПараметр, ТекЭлемент[ИмяКолонкиДерева])) > 0 Тогда
				ИДСтрокиРаскрытия = ТекЭлемент.ПолучитьИдентификатор();
				Элементы.Деревяшка.Развернуть(ИДСтрокиРаскрытия);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ВременныеПараметры.Свойство("НачСтрокаИД") Тогда
		Элементы.Деревяшка.ТекущаяСтрока = ВременныеПараметры.НачСтрокаИД;
	КонецЕсли;
	Если ВременныеПараметры.Свойство("ОбработчикПриОткрытии") Тогда
		Выполнить(ВременныеПараметры.ОбработчикПриОткрытии);
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	ПоддержкаВОЛНА_Конфой = Метаданные.ОбщиеМодули.Найти("ВОЛНА_ОбщегоНазначенияКС") <> Неопределено;
	ПоддержкаВОЛНА_Владельцем = ОбработкаОбъект <> Неопределено;
	ВременныеПараметры = Новый Структура;
	ТекПараметр = Неопределено;
	Если ?(Параметры.Свойство("ОбработчикПриОткрытии", ТекПараметр), ЗначениеЗаполнено(ТекПараметр), Ложь) Тогда
		ВременныеПараметры.Вставить("ОбработчикПриОткрытии", ТекПараметр);
	КонецЕсли;
	ВременныеПараметры.Вставить("ПоправитьФлагиПриОткрытии", ?(Параметры.Свойство("ПоправитьФлагиПриОткрытии"), Параметры.ПоправитьФлагиПриОткрытии, Ложь));
	ВременныеПараметры.Вставить("ПриОткрытииРаскрытьУровень1", ?(Параметры.Свойство("ПоправитьФлагиПриОткрытии"), Параметры.ПриОткрытииРаскрытьУровень1, ""));
	ЗаполнитьЗначенияСвойств(ЭтотОбъект, Параметры,, "ТолькоПросмотр,КлючНазначенияИспользования,ЗакрыватьПриЗакрытииВладельца,ЗакрыватьПриВыборе");
	Дровина = ПолучитьИзВременногоХранилища(Параметры.АдресДерева);
	ИменаКолонокДерева = СтрСоединить(ВыполнитьМетодВОЛНА_С("СоздатьКолонкиТаблицы(П1, ""Деревяшка"", П2)", Новый Структура("П1,П2", ЭтотОбъект, Дровина),, "ВС"), ",");
	Элементы.Деревяшка.МножественныйВыбор = ВыборМногих;
	Элементы.Деревяшка.ИзменятьПорядокСтрок = Ложь;
	Элементы.Деревяшка.ИзменятьСоставСтрок = Ложь;
	Если Параметры.Свойство("РежимВыбораДерева") Тогда
		Элементы.Деревяшка.РежимВыбора = Параметры.РежимВыбораДерева;
	КонецЕсли;
	Если Параметры.Свойство("ТолькоПросмотрДерева") Тогда
		Элементы.Деревяшка.ТолькоПросмотр = Параметры.ТолькоПросмотрДерева;
	КонецЕсли;
	Если ЗначениеЗаполнено(ОтображатьРеквизиты) Тогда
		мВидимость = СтрРазделить(ОтображатьРеквизиты, ",", Ложь);
		ВидимостьПоУмолчанию = Лев(ОтображатьРеквизиты, 1) <> "-";
		СписокВидимости = Новый СписокЗначений;
		Для каждого ИмяРекв Из мВидимость Цикл
			элсз = СписокВидимости.Добавить();
			Если Лев(ИмяРекв, 1) = "-" Тогда
			    элсз.Пометка = Ложь;
				элсз.Значение = СокрЛП(Сред(ИмяРекв, 2));
			Иначе
			    элсз.Пометка = Истина;
				элсз.Значение = СокрЛП(ИмяРекв);
			КонецЕсли;
		КонецЦикла;
		Для каждого Колонка Из Элементы.Деревяшка.ПодчиненныеЭлементы Цикл
			элсз = СписокВидимости.НайтиПоЗначению(Сред(Колонка.Имя, 11));//Убираю "Деревяшка_"
			Колонка.Видимость = ?(элсз = Неопределено, ВидимостьПоУмолчанию, элсз.Пометка);
		КонецЦикла; 
	КонецЕсли;
	Если ЗначениеЗаполнено(ИмяКолонкиФлагов) Тогда
		Если ТриСостоянияВКолонкеФлагов = "Все" ИЛИ ТриСостоянияВКолонкеФлагов = "ВГруппах" Тогда
			Элемент = Элементы["Деревяшка_" + ИмяКолонкиФлагов];
			Элемент.Вид = ВидПоляФормы.ПолеФлажка;
			Элемент.ТриСостояния = Истина;
		КонецЕсли;
	Иначе
		Элементы.ДеревяшкаОфлажить.Видимость = Ложь;
		Элементы.ДеревяшкаСбросФлагов.Видимость = Ложь;
	КонецЕсли;
	Если Параметры.Свойство("КомандыФормы") Тогда
		ДобавленныеКоманды = Новый Структура;
		Для каждого КиЗ Из Параметры.КомандыФормы Цикл
			НоваяКоманда = Команды.Добавить("ДобавленнаяКоманда_" + КиЗ.Ключ);
			НоваяКоманда.Заголовок = КиЗ.Значение.Заголовок;
			НоваяКоманда.Картинка = КиЗ.Значение.Картинка;
			НоваяКоманда.Действие = "ДобавленнаяКоманда";
			НоваяКнопа = Элементы.Добавить("ДобавленнаяКнопа_" + КиЗ.Ключ, Тип("КнопкаФормы"), КоманднаяПанель);
			НоваяКнопа.РасширеннаяПодсказка.Заголовок = КиЗ.Значение.Подсказка;
			НоваяКнопа.ИмяКоманды = "ДобавленнаяКоманда_" + КиЗ.Ключ;
			ДобавленныеКоманды.Вставить(КиЗ.Ключ, КиЗ.Значение.Код);
		КонецЦикла;
	КонецЕсли;
	Если Параметры.Свойство("НачальнаяПозиция") Тогда
		ВременныеПараметры.Вставить("НачСтрокаИД", ВыполнитьМетодВОЛНА_С("НайтиВ_ДФД(П1, П2)", Новый Структура("П1, П2", Деревяшка, Параметры.НачальнаяПозиция)));
	КонецЕсли;
	Если Параметры.Свойство("ПроизВольныйПараметрВХранилище") Тогда
		АдресПроизвольногоПараметра = ПоместитьВоВременноеХранилище(Параметры.ПроизВольныйПараметрВХранилище, УникальныйИдентификатор);
	КонецЕсли;
	Если Параметры.Свойство("ОбработчикПриСоздании") Тогда
		Выполнить(Параметры.ОбработчикПриСоздании);
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область СОБЫТИЯ_ЭЛЕМЕНТОВ

&НаКлиенте
Процедура ДеревяшкаВыборЗначения(Элемент, Значение, СтандартнаяОбработка)
	//!!!!! Здесь должна по умолчанию запускаться основная команда, если не задан иной обработчик
	Закрытие = Истина;
	ТекИД = Элементы.Деревяшка.ТекущаяСтрока;
	ТекСтрока = Деревяшка.НайтиПоИдентификатору(ТекИД);
	ВыборСделан = ТекСтрока.ПолучитьЭлементы().Количество() = 0;
	СтандартнаяОбработка = Истина;
	Если ЗначениеЗаполнено(ОбработчикВыбора) Тогда
		Выполнить(ОбработчикВыбора);
	КонецЕсли;
	Если НЕ СтандартнаяОбработка Тогда
	ИначеЕсли ВыборСделан ИЛИ ВыбиратьГруппы Тогда
		ВыбратьИПродолжить(Новый Структура("Имя", "ВыбратьИПродолжить"));
	ИначеЕсли Элементы.Деревяшка.Развернут(ТекИД) Тогда
		Элементы.Деревяшка.Свернуть(ТекИД);
	Иначе
		Элементы.Деревяшка.Развернуть(ТекИД);
	КонецЕсли;
КонецПроцедуры
	
&НаКлиенте
Процедура ДеревяшкаПриИзменении(Элемент)
	Если Элементы.Деревяшка.ТекущаяСтрока <> Неопределено Тогда
		//Проверяются флаги родителей, изменяются флаги дочек
		ТекЭлемент = Деревяшка.НайтиПоИдентификатору(Элементы.Деревяшка.ТекущаяСтрока);
		Если ТриСостоянияВКолонкеФлагов = "ВГруппах" И ТекЭлемент[ИмяКолонкиФлагов] = 2 Тогда
			ТекЭлемент[ИмяКолонкиФлагов] = 0;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяКолонкиФлагов) Тогда
			Флаги(ТекЭлемент[ИмяКолонкиФлагов], ТекЭлемент);	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область КОМАНДЫ

//Закрывает форму. Возвращает массив выбранных строк дерева или значений указанного реквизита - как результат закрытия и/или в хранилище
&НаКлиенте
Процедура ВыбратьИПродолжить(Команда)
	Отказ = Ложь;
	Если РезультатВТаблицуЗначений Тогда
		Результат = АдресРезультата;
		ОбработатьФлагиНаСервере();
	Иначе
		Результат = Новый Массив;
		ЕстьФлаги = ИмяКолонкиФлагов <> "";
		Если ЕстьФлаги Тогда
			ВыбраннаяСтрока = Деревяшка;
			ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(Результат, ВыбраннаяСтрока, Истина, ВозвращаемыеРеквизиты, Истина);
		ИначеЕсли ВыборМногих Тогда
			Для каждого ИдентификаторСтроки Из Элементы.Деревяшка.ВыделенныеСтроки Цикл
				ВыбраннаяСтрока = Деревяшка.НайтиПоИдентификатору(ИдентификаторСтроки);
				Если ВыбраннаяСтрока.ПолучитьЭлементы().Количество() = 0 ИЛИ ВыбиратьГруппы Тогда
					ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(Результат, ВыбраннаяСтрока, Истина, ВозвращаемыеРеквизиты);
				КонецЕсли;
			КонецЦикла;
		Иначе
			ВыбраннаяСтрока = Элементы.Деревяшка.ТекущиеДанные;
			ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(Результат, ВыбраннаяСтрока, Истина, ВозвращаемыеРеквизиты);
		КонецЕсли;
		Отказ = ?(Результат.Количество(), Результат[0] = "ОТКАЗ", Ложь) ИЛИ Отказ;
		Если ЗначениеЗаполнено(ОбработчикПриЗакрытии) И НЕ Отказ Тогда
			Выполнить(ОбработчикПриЗакрытии);
		КонецЕсли;
		Если ЗначениеЗаполнено(АдресРезультата) Тогда
			ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
		КонецЕсли;
	КонецЕсли;
	Если НЕ Отказ Тогда
		Деревяшка.ПолучитьЭлементы().Очистить();
		Закрыть(Результат);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ДобавленнаяКоманда(Команда)
	КлючКода = Сред(Команда.Имя, 20);
	Код = ДобавленныеКоманды[КлючКода];
	Выполнить(Код);
КонецПроцедуры

&НаКлиенте
Процедура Офлажить(Команда)
	Флаги(?(ТриСостоянияВКолонкеФлагов, 1, Истина));
КонецПроцедуры

&НаКлиенте
Процедура СбросФлагов(Команда)
	Флаги(?(ТриСостоянияВКолонкеФлагов, 0, Ложь));
КонецПроцедуры
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
#КонецОбласти

#Область СЛУЖЕБНЫЕ

// Добавляет в массив строку или подчинённые строки
// Параметры:
//  Приёмник  - Массив - Массив идентификаторов строк
//  СтрокаДерева  - ДанныеФормыЭлементДерева - строка дерева
//  Отбор  - Произвольное -
//			*Истина - режим сбора строк по флагам перед закрытием окна, ЛОЖЬ(по умолчанию) = закрытия не будет, выборка без учёта флагов и идёт установка/сброс флагов подчинённым
//			*Любое незаполненное значение - отсутствие дополнительного отбора (по умолчанию)
//			*Массив структур - если хотя бы одна пореквизитно полностью совпадёт - отбор выполнен.
//  ИмяРеквизита  - Строка - Имя колонки дерева, значение из которой будет попадать в массив результатов. Иначе будет попадать строка дерева
//  ЭтоКорень  - Булево - Истина, если СтрокаДерева является необрабатываемым корнем.
&НаКлиенте
Процедура ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(Приёмник, СтрокаДерева, Отбор = Неопределено, ИмяРеквизита = "", ЭтоКорень = Ложь)
	Дочки = СтрокаДерева.ПолучитьЭлементы();
	ЕстьДочки = Дочки.Количество() > 0;
	Если ЕстьДочки Тогда
		Если ВыборМногих Тогда
			Для каждого Дочка Из Дочки Цикл
				ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(Приёмник, Дочка, Отбор, ИмяРеквизита);
			КонецЦикла;
		Иначе
			Приёмник.Очистить();
			Приёмник.Добавить("ОТКАЗ");
		КонецЕсли;
	КонецЕсли;
	Если НЕ ЭтоКорень И (ВыбиратьГруппы ИЛИ НЕ ЕстьДочки)
			Тогда
		#Область ОТБОР_ПО_ФЛАГАМ_ИЛИ_СТРУКТУРАМ
			Если Отбор = Истина Тогда
				ОтборВыполнен = ?(ИмяКолонкиФлагов = "", Истина, СтрокаДерева[ИмяКолонкиФлагов]);
			ИначеЕсли ЗначениеЗаполнено(Отбор) Тогда
				Для каждого Элемент Из Отбор Цикл
					ОтборВыполнен = Истина;
					Для каждого КиЗ Из Элемент Цикл
						Если КиЗ.Значение <> СтрокаДерева[КиЗ.Ключ] Тогда
							ОтборВыполнен = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если ОтборВыполнен Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			Иначе
				ОтборВыполнен = Истина;
			КонецЕсли;
		#КонецОбласти
		#Область ДОПОЛНЕНИЕ_МАССИВА_РЕЗУЛЬТАТА
			Если ОтборВыполнен Тогда
				Если ИмяРеквизита = "" Тогда
					ЗначениеВМассив = СтрокаДерева;
				ИначеЕсли СтрНайти(ИмяРеквизита, ",") = 0 Тогда
					ЗначениеВМассив = СтрокаДерева[ИмяРеквизита];
				Иначе
					ЗначениеВМассив = Новый Структура(ИмяРеквизита);
					ЗаполнитьЗначенияСвойств(ЗначениеВМассив, СтрокаДерева);
				КонецЕсли;
				СтрПараметр = Новый Структура("П1,П2", Приёмник, ЗначениеВМассив);
				ВыполнитьМетодВОЛНА_К("ДобавитьВМассивЕслиЕщёНет(П1,П2)", СтрПараметр, Ложь);
				Приёмник = СтрПараметр.П1;
			КонецЕсли;
		#КонецОбласти
	КонецЕсли;
КонецПроцедуры // ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив

// Формирует результат в виде ТЗ на сервере и запихивает в хранилище
&НаСервере
Процедура ОбработатьФлагиНаСервере()
	Результат = Новый ТаблицаЗначений;
	Осина = РеквизитФормыВЗначение("Деревяшка");
	ВсеКолонки = ВозвращаемыеРеквизиты = "";
	Для каждого Колонка Из Осина.Колонки Цикл
		Если ВсеКолонки ИЛИ ВыполнитьМетодВОЛНА_С("НайтиПодСтроку(П1,П2)", Новый Структура("П1,П2", ВозвращаемыеРеквизиты, Колонка.Имя)) > 0 Тогда
			Результат.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
		КонецЕсли;
	КонецЦикла;
	ОбходДереваНаСервере(Результат, Осина, Истина);
	Если ЗначениеЗаполнено(ОбработчикПриЗакрытии) Тогда
		Выполнить(ОбработчикПриЗакрытии);
	КонецЕсли;
	Если ЗначениеЗаполнено(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	КонецЕсли;
КонецПроцедуры // ОбработатьФлагиНаСервере

//Приёмник = ТЗ, Источник = Дерево
&НаСервере
Процедура ОбходДереваНаСервере(Приёмник, Источник, ЭтоКорень = Ложь)
	Дочки = Источник.Строки;
	ЕстьДочки = Дочки.Количество() > 0;
	Если ЕстьДочки Тогда
		Для каждого Дочка Из Дочки Цикл
			ОбходДереваНаСервере(Приёмник, Дочка);
		КонецЦикла;
	КонецЕсли;
	Если НЕ ЭтоКорень И
			Источник[ИмяКолонкиФлагов] И
			(ВыбиратьГруппы ИЛИ НЕ ЕстьДочки)
			Тогда
		ЗаполнитьЗначенияСвойств(Приёмник.Добавить(), Источник);
	КонецЕсли;
КонецПроцедуры // ОбработатьФлагиНаСервере

// Проверяет флаги элементов и поправляет флаги содержащей их группы как И от элементов, а для трёх состояний как 0 или 1 при равенстве всех подчинённых.
// Параметры:
//  ГруппаФлагов  - ДанныеДеревоЗначенийВетка - Проверяемая ветка
// Возвращаемое значение
//	Булево - значение изменено
&НаКлиенте
Функция ПоправитьФлаги(ГруппаФлагов, Рекурсивно = Ложь)
	Дочки = ГруппаФлагов.ПолучитьЭлементы();
	Если ТриСостоянияВКолонкеФлагов = "Все" ИЛИ ТриСостоянияВКолонкеФлагов = "ВГруппах" Тогда
		НовоеЗначение = 3;
		Для каждого Дочка Из Дочки Цикл
			Если Рекурсивно Тогда
				ПоправитьФлаги(Дочка, Истина)
			КонецЕсли;
			Если НовоеЗначение = 3 Тогда
				НовоеЗначение = Дочка[ИмяКолонкиФлагов];
			ИначеЕсли Дочка[ИмяКолонкиФлагов] <> НовоеЗначение Тогда
				НовоеЗначение = 2;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	Иначе
		НовоеЗначение = Истина;
		Для каждого Дочка Из Дочки Цикл
			Если Рекурсивно Тогда
				ПоправитьФлаги(Дочка, Истина)
			КонецЕсли;
			Если НЕ Дочка[ИмяКолонкиФлагов] Тогда
				НовоеЗначение = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Результат = НовоеЗначение <> ГруппаФлагов[ИмяКолонкиФлагов];
	ГруппаФлагов[ИмяКолонкиФлагов] = НовоеЗначение;
	Возврат Результат
КонецФункции // ПоправитьФлаги

// Устанавливает значение флагов
// Параметры:
//  НовоеЗначение  - Булево - новое значение флагов
//  мСтрокиДляФлагов  - Массив - строки, где надо сменить флаги. Если Неопределено - автоопредление по выделенным
&НаКлиенте
Процедура Флаги(НовоеЗначение, ИсключениеПродолжатьПроверку = Неопределено)
	#Область ВМЕСТО_СТРОК_ГРУПП_ПОДЧИНЁННЫЕ
		мВыделенныеСтрокиДеревяшки = Элементы.Деревяшка.ВыделенныеСтроки;
		мСтрокиДляФлагов = Новый Массив;
		Если ВыбиратьГруппы Тогда
			Для каждого ВыделеннаяСтрока Из мВыделенныеСтрокиДеревяшки Цикл
				мСтрокиДляФлагов.Добавить(Деревяшка.НайтиПоИдентификатору(ВыделеннаяСтрока));
			КонецЦикла;
		Иначе
			Для каждого ВыделеннаяСтрока Из мВыделенныеСтрокиДеревяшки Цикл
				ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(мСтрокиДляФлагов, Деревяшка.НайтиПоИдентификатору(ВыделеннаяСтрока));
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти
	#Область ФЛАГИ_АНАЛОГОВ
		Если ДублиСтрокОбрабатыватьКакОднуСтроку Тогда
			//В дереве могут быть строки, имеющие ту же суть, что и перефлаженные. Их тоже надо привести в соответствие
			СписокРеквизитов = ?(ВозвращаемыеРеквизиты = "", ИменаКолонокДерева, ВозвращаемыеРеквизиты);
			мПоиск = Новый Массив;
			Для каждого ТекЭлемент Из мСтрокиДляФлагов Цикл
				СтруктураПоискаАналогов = Новый Структура(СписокРеквизитов);
				ЗаполнитьЗначенияСвойств(СтруктураПоискаАналогов, ТекЭлемент);
				мПоиск.Добавить(СтруктураПоискаАналогов);
			КонецЦикла;
			ДобавитьСтрокуИлиПодчинённыеСтрокиВМассив(мСтрокиДляФлагов, Деревяшка, мПоиск,, Истина);
		КонецЕсли;
	#КонецОбласти
	#Область УСТАНОВКА_ФЛАГОВ
		ИзменённыеФлаги = ВыполнитьМетодВОЛНА_К("УстановитьФлаги(П1,П2,П3,П4,,,П5)",
				Новый Структура("П1,П2,П3,П4,П5", ЭтотОбъект, Элементы.Деревяшка, ИмяКолонкиФлагов, НовоеЗначение, мСтрокиДляФлагов));
		Если ИзменённыеФлаги.Количество() < 2 Тогда
			ИзменённыеФлаги = мСтрокиДляФлагов;
		Иначе
			ВыполнитьМетодВОЛНА_К("ДобавитьВМассивЕслиЕщёНет(П1,П2)", Новый Структура("П1,П2", ИзменённыеФлаги, мСтрокиДляФлагов[0]), Ложь);
		КонецЕсли;
	#КонецОбласти
	#Область ФЛАГИ_РОДИТЕЛЕЙ
		Если НЕ ВыбиратьГруппы Тогда
			Для каждого ТекЭлемент Из ИзменённыеФлаги Цикл
				Пока Истина Цикл
					ТекЭлемент = ТекЭлемент.ПолучитьРодителя();
					Если ТекЭлемент = Неопределено ИЛИ НЕ ПоправитьФлаги(ТекЭлемент) И ТекЭлемент <> ИсключениеПродолжатьПроверку Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти
КонецПроцедуры // Флаги

#КонецОбласти

#Область ВОЛНА

// Выполняет метод ВОЛНА из модуля, обработки либо отсюда. Только клиент/серверные методы.
// Параметры:
//  Метод  - Строка - Короткое имя метода с параметрами, например, "ЧТСтрукт(стрВолна, МойКлюч)"
//  Параметры_  - Структура/Неопределено - Параметры метода, например Новый Структура("ПервыйКлюч,МойКлюч", Зн1Ключ, ЗнМойКлюч)
//  ЭтоФункция  - Булево - Истина, если надо вернуть значение
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода
&НаКлиенте
Функция ВыполнитьМетодВОЛНА_К(Метод, Параметры_ = Неопределено, ЭтоФункция = Истина)
	Результат = Неопределено;
	Если ПоддержкаВОЛНА_Владельцем Тогда
		СПрм = Новый Структура("Метод,П1,Результат_____", Метод, Параметры_, Неопределено);
		ВладелецФормы.ВызватьАлгоритмКлиент(?(ЭтоФункция, "Результат_____ = ", "")
				+ "ВыполнитьМетодВОЛНА(""ВОЛНА_ОбщегоНазначенияКС."" + Метод, П1,"
				+ ?(ЭтоФункция, "Истина", "Ложь") + ")", СПрм, Ложь);
		Результат = СПрм.Результат_____;
		ЗаполнитьЗначенияСвойств(Параметры_, СПрм.П1); //Иначе теряет ссылку
	Иначе
		ИсполняемыйКод = Метод;
		Для каждого КиЗ Из Параметры_ Цикл
			ИсполняемыйКод = СтрЗаменить(ИсполняемыйКод, КиЗ.Ключ, "Параметры_." + КиЗ.Ключ);
		КонецЦикла;
		ПрефиксКода = ?(ЭтоФункция, "Результат = ", "Результат = Неопределено; ");
		ИмяМодуля = ?(ПоддержкаВОЛНА_Конфой, "ВОЛНА_ОбщегоНазначенияКС.", "");
		ИсполняемыйКод = ПрефиксКода + ИмяМодуля + ИсполняемыйКод;	
		Выполнить(ИсполняемыйКод);
	КонецЕсли;
	Возврат Результат
КонецФункции // ВыполнитьМетодВОЛНА

// Выполняет метод ВОЛНА из модуля, обработки либо отсюда
// Параметры:
//  Метод  - Строка - Короткое имя метода с параметрами, например, "ЧТСтрукт(стрВолна, МойКлюч)"
//  Параметры_  - Структура/Неопределено - Параметры метода, например Новый Структура("ПервыйКлюч,МойКлюч", Зн1Ключ, ЗнМойКлюч)
//  ЭтоФункция  - Булево - Истина, если надо вернуть значение
//  Откуда  - "КС"/"ВС" - Клиент/сервер или вызов сервера
// Возвращаемое значение:
//   Произвольный   - Результат выполнения метода
&НаСервере
Функция ВыполнитьМетодВОЛНА_С(Метод, Параметры_ = Неопределено, ЭтоФункция = Истина, Откуда = "КС")
	Результат = Неопределено;
	Если ПоддержкаВОЛНА_Владельцем И ОбработкаОбъект <> Неопределено Тогда
		Настоящий = РеквизитФормыВЗначение("ОбработкаОбъект");
		Параметры_.Вставить("Результат_____", Неопределено);
		Настоящий.ВызватьАлгоритмОбъект(?(ЭтоФункция, "Результат_____ = ", "") + Метод, Параметры_); //Убрал Ложь - см. дерево команд
		Результат = Параметры_.Результат_____;
	Иначе
		ИсполняемыйКод = Метод;
		Для каждого КиЗ Из Параметры_ Цикл
			ИсполняемыйКод = СтрЗаменить(ИсполняемыйКод, КиЗ.Ключ, "Параметры_." + КиЗ.Ключ);
		КонецЦикла;
		ПрефиксКода = ?(ЭтоФункция, "Результат = ", "Результат = Неопределено; ");
		Если ПоддержкаВОЛНА_Конфой Тогда
			ИсполняемыйКод = ПрефиксКода + ?(Откуда = "КС", "ВОЛНА_ОбщегоНазначенияКС", "ВОЛНА_ОбщегоНазначенияВС") + "." + ИсполняемыйКод;	
		Иначе
			ИсполняемыйКод = ПрефиксКода + ИсполняемыйКод;	
		КонецЕсли;
		Выполнить(ИсполняемыйКод);
	КонецЕсли;
	Возврат Результат
КонецФункции // ВыполнитьМетодВОЛНА

#Область МЕТОДЫ_ЛОКАЛЬНО

#Область ВЫЗОВ_СЕРВЕРА
	
// Формирует реквизит и элемент формы под загрузку заданной таблицы (в т.ч. колонки), а затем загружает туда таблицу
// Параметры:
//  УФорма  - ФормаКлиентскогоПриложения - Форма, которой принадлежит таблица или дерево
//  ИмяПриёмника  - Строка - Имя элемента, соответствующего загружаемой таблице
//  ТабИсточник  - Таблица или дерево значений - Имя реквизита и элемента, соответствующего загружаемой таблице
//	Загружать	- Строка -
//		*"Загрузка" - через Загрузить (только для таблиц значений)
//		*"ЗначВРеквФормы" - через ЗначениеВРеквизитФормы (по умолчанию). Только для одноуровневого пути.
//		*"Нет" - не выполнять
//  ТолькоЭлементы  - Булево - Не выполнять изменение реквизитов формы. По умолчанию Ложь.
// Возвращаемое значение:
//  Массив - имена колонок
&НаСервере
Функция СоздатьКолонкиТаблицы(УФорма, ИмяПриёмника, ТабИсточник, Загружать = "ЗначВРеквФормы", ТолькоЭлементы = Ложь)
	Результат = Новый Массив;
	МассивДобавляемыхРеквизитов = Новый Массив;
	ПутьКПриёмнику = УФорма.Элементы[ИмяПриёмника].ПутьКДанным;
	#Область РЕКВИЗИТЫ
		Если НЕ ТолькоЭлементы Тогда
			Для Каждого Колонка Из ТабИсточник.Колонки Цикл 
				РеквизитФормы = Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ПутьКПриёмнику, Колонка.Имя); 
				МассивДобавляемыхРеквизитов.Добавить(РеквизитФормы);
				Результат.Добавить(Колонка.Имя);
			КонецЦикла;
			МассивУдаляемыхРеквизитов = Новый Массив;
			Для Каждого РеквизитХ Из УФорма.ПолучитьРеквизиты(ПутьКПриёмнику) Цикл 
				МассивУдаляемыхРеквизитов.Добавить(ПутьКПриёмнику + "." + РеквизитХ.Имя); 
			КонецЦикла;
			УФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов, МассивУдаляемыхРеквизитов);
		КонецЕсли;
	#КонецОбласти
	#Область ЭЛЕМЕНТЫ
		МассивУдаляемыхРеквизитов = Новый Массив;
		Для Каждого КолонкаХ Из УФорма.Элементы[ИмяПриёмника].ПодчиненныеЭлементы Цикл
			МассивУдаляемыхРеквизитов.Добавить(КолонкаХ);
		КонецЦикла;
		Для Каждого КолонкаХ Из МассивУдаляемыхРеквизитов Цикл
			УФорма.Элементы.Удалить(КолонкаХ);
		КонецЦикла;
		Для Каждого Колонка Из ТабИсточник.Колонки Цикл
			Попытка
				Элемент = УФорма.Элементы.Добавить(ИмяПриёмника + "_" + Колонка.Имя, Тип("ПолеФормы"), УФорма.Элементы[ИмяПриёмника]); 
				Элемент.Заголовок = Колонка.Имя;
				Если Колонка.ТипЗначения = Новый ОписаниеТипов("Булево") Тогда
					Элемент.Вид = ВидПоляФормы.ПолеФлажка;
					Элемент.ВидФлажка = ВидФлажка.Флажок;
					Элемент.РежимРедактирования = РежимРедактированияКолонки.Непосредственно;
				Иначе
					Элемент.Вид = ВидПоляФормы.ПолеВвода;
				КонецЕсли;
				Элемент.ПутьКДанным = ПутьКПриёмнику + "." + Колонка.Имя;
			Исключение
				ООш = ОписаниеОшибки();
				Сообщить("Не удалось добавить колонку " + Колонка.Имя + " по причине: " + ООш)
			КонецПопытки;
		КонецЦикла;
	#КонецОбласти 
	Если Загружать <> "Нет" Тогда
		Если Загружать = "Загрузка" Тогда
			ТекстКода = "УФорма." + ПутьКПриёмнику + ".Загрузить(ТабИсточник)";
		Иначе
			ТекстКода = "УФорма.ЗначениеВРеквизитФормы(ТабИсточник, """ + ПутьКПриёмнику + """);";
		КонецЕсли;
		Выполнить(ТекстКода);
	КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьКолонкиТаблицы

#КонецОбласти

#Область КЛИЕНТ_СЕРВЕР

// Добавляет значение в массив, если его там нет
// Параметры:
//  Приёмник  - Массив - куда добавляется значение
//  Значение  - Произвольное - что добавляется в массив
//  Индекс  - Число - куда вставлять, -1 (по умолчанию) - в конец
// Возвращаемое значение:
//   Значение было добавлено   - Булево
&НаКлиенте
Функция ДобавитьВМассивЕслиЕщёНет(Приёмник, Значение, Индекс = -1)
	Результат = Приёмник.Найти(Значение) = Неопределено;
	Если Результат Тогда
		Если Индекс = -1 Тогда
			Приёмник.Добавить(Значение);
		Иначе
			Приёмник.Вставить(Индекс, Значение);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДобавитьВМассивЕслиЕщёНет

// Находит первую строку по структуре (Аналогично НайтиСтроку) в ДанныеФормыДерево
// Параметры:
//  ДФД  - ДанныеФормыДерево - Где искать
//	Критерии - Структура - Отбор поиска, аналогично НайтиСтроки
// Возвращаемое значение:
//   Число   - Идентификатор найденной строки. 0, если не найдена.
&НаСервере
Функция НайтиВ_ДФД(ДФД, Критерии) Экспорт
	Результат = 0;
	Для каждого СтрокаДЗ Из ДФД.ПолучитьЭлементы() Цикл
		Совпали = Истина;
		Для каждого КиЗ Из Критерии Цикл
			Если КиЗ.Значение <> СтрокаДЗ[КиЗ.Ключ] Тогда
				Совпали = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Совпали Тогда
			Результат = СтрокаДЗ.ПолучитьИдентификатор();
			Прервать;
		Иначе
			Результат = НайтиВ_ДФД(СтрокаДЗ.Строки, Критерии);
			Если Результат > 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // НайтиВ_ДФД

//Ищет строку в составе другой строки, но только как подстроку между разделителями без краевых пробелов
//Возвращает позицию найденной подстроки или 0
// Параметры:
//  ГдеИскать  - Любое значение, преобразуемое в строку - В которой будет поиск
//  ЧтоИскать  - Строка - Искомая строка
//  Разделитель  - Строка - Разделитель частей в ГдеИскать
// Возвращаемое значение:
//   Число   - Позиция начала подстроки
&НаСервере
Функция НайтиПодСтроку(ГдеИскать, ЧтоИскать, Разделитель = ",")
	Возврат СтрНайти(Разделитель + ГдеИскать + Разделитель, Разделитель + ЧтоИскать + Разделитель)
КонецФункции

// Устанавливает флаг в таблице формы в нужное значение
// Параметры:
//  Форма  - Управляемая форма - Форма, где меняются флаги
//  ТаблицаФормы  - Таблица формы - содержащая изменяемую колонку
//	ИмяПоля - Строка - на клиенте - путь к данным;
//			на сервере - список полей через запятую. Изменяется текущее, если оно в списке или список пуст.
//			Если текущее не найдено в списке - изменяется первое, если оно задано. По умолчанию "Пометка"
//	НовоеЗначение - Булево/Неопределено - Устанавливаемое значение. По умолчанию Истина.
//			В рехиме инвертирования - значение, подставляемое вместо Истина:
//			*Неопределено - Истина ==> Неопределено ==> Ложь ==> Истина; 
//			*Ложь - Истина ==> Ложь ==> Неопределено ==> Истина; 
//			*Истина - Истина ==> Ложь ==> Истина; 
//			*0 - 1 ==> 0 ==> 2 ==> 1; 
//			*1 - 1 ==> 0 ==> 1; 
//			*2 - 1 ==> 2 ==> 0 ==> 1; 
//	Инвертировать - Булево - режим инвертирования флагов. По умолчанию Ложь.
//	ИмяДанныхТаблицы - Строка - Имя данных формы, соответствующих таблице. По умолчанию "" - автоопределение.
//	МассивСтрокКИзменению - Массив - массив строк таблицы/дерева (ДанныеФормыЭлементДерева), в которых будет меняться флаг.
//			По умолчанию Неопределено = выделенные строки или (если выделена одна строка или ничего не выделено) = все строки.
// Возвращаемое значение - Массив - Строки данных формы с изменёнными флагами.
&НаКлиенте
Функция УстановитьФлаги(Форма, ТаблицаФормы_, ИмяПоля = "Пометка", НовоеЗначение = Истина, Инвертировать = Ложь, ИмяДанныхТаблицы = "", МассивСтрокКИзменению = Неопределено)
	Результат = Новый Массив;
	ИмяДанныхПоляВТаблице = СтрЗаменить(ИмяПоля, " ", "");
	#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
		ДопустимыеПоля = ИмяДанныхПоляВТаблице;
		ИмяДанныхПоляВТаблице = СтрЗаменить(ТаблицаФормы_.ТекущийЭлемент.ПутьКДанным, ".", Символы.ПС);
		ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(ИмяДанныхПоляВТаблице, СтрЧислоСтрок(ИмяДанныхПоляВТаблице));
		Если ИмяПоля <> "" Тогда
			Если СтрНайти("," + ДопустимыеПоля + ",", "," + ИмяДанныхПоляВТаблице + ",") = 0 Тогда
				ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(СтрЗаменить(ДопустимыеПоля, ",", Символы.ПС), 1);
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	#Область СТРОКИ_ДЛЯ_ФЛАГОВ
		МассивВЧёмМенять = Новый Массив;
		Если МассивСтрокКИзменению = Неопределено Тогда
			Если ИмяДанныхТаблицы = "" Тогда
				#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
					ИмяДанныхТаблицы = ТаблицаФормы_.ПутьКДанным;
				#Иначе
					ИмяДанныхТаблицы = "";
					ТестСтр = Новый Структура("Объект," + ТаблицаФормы_.Имя);
					ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
					Если ТестСтр[ТаблицаФормы_.Имя] = Неопределено Тогда
						Если ТестСтр.Объект <> Неопределено Тогда
							ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
							Если ТестСтр[ТаблицаФормы_.Имя] <> Неопределено Тогда
								ИмяДанныхТаблицы = "Объект." + ТаблицаФормы_.Имя;
							КонецЕсли;
						КонецЕсли;
					Иначе
						ИмяДанныхТаблицы = ТаблицаФормы_.Имя;
					КонецЕсли;
				#КонецЕсли
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяДанныхТаблицы) Тогда
				Колво = ТаблицаФормы_.ВыделенныеСтроки.Количество();
				ДанныеТаблицы = Вычислить("Форма." + ИмяДанныхТаблицы);
				Все = (Колво < 2) ИЛИ (Колво = ДанныеТаблицы.Количество());
				Если Все Тогда
					МассивВЧёмМенять = ДанныеТаблицы;
				Иначе
					Для каждого ВСтрока Из ТаблицаФормы_.ВыделенныеСтроки Цикл
						МассивВЧёмМенять.Добавить(ДанныеТаблицы.НайтиПоИдентификатору(ВСтрока));
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		Иначе
			МассивВЧёмМенять = МассивСтрокКИзменению;
		КонецЕсли;
	#КонецОбласти
	Для каждого СтрокаЗамены Из МассивВЧёмМенять Цикл
		ТекЗнч = СтрокаЗамены[ИмяДанныхПоляВТаблице];
		Если НЕ Инвертировать Тогда
			Если (ТекЗнч = Неопределено) ИЛИ (ТекЗнч = Истина) ИЛИ (ТекЗнч = Ложь) ИЛИ (ТекЗнч = 0) ИЛИ (ТекЗнч = 1) ИЛИ (ТекЗнч = 2) Тогда
				Если ТекЗнч <> НовоеЗначение Тогда
					Результат.Добавить(СтрокаЗамены);
					СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Результат.Добавить(СтрокаЗамены);
			Если ТекЗнч = Неопределено Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение <> Неопределено;
			ИначеЕсли ТекЗнч = Истина Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Истина, Ложь, НовоеЗначение);
			ИначеЕсли ТекЗнч = Ложь Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Ложь, Неопределено, Истина);
			ИначеЕсли ТекЗнч = 2 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 2, 0, 1);
			ИначеЕсли ТекЗнч = 1 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 1, 0, НовоеЗначение);
			ИначеЕсли ТекЗнч = 0 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 0, 2, 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // УстановитьФлаги

#КонецОбласти

#КонецОбласти

#КонецОбласти