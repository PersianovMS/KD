#Область ПРОГРАММНЫЙ_ИНТЕРФЕЙС

#Область ЧТО_ДЕЛАТЬ

//В обычной форме много недоделок и непроверенных вещей, но их надо кореллировать с УФ и МО.
//Совсем не сделаны команды сохранения настроек, не проверены менюшки: все от метаданных до СКД. Не работает автосохранение настроек.
//Но всё это быстро доделывается при необходимости.
//Настройки сейчас сохраняются в ХранилищеОбщихНастроек.
//Там имена
//	* Меню, Команды, Настройки, ИменаНастроек и ИнтервалАвтосохранения зарезервированы под текущие настройки, из которых идёт начальная загрузка и в которые идёт автосохранение.
//	* Команда___***** - настройки добавленных команд
//	* Права - отметка о лицензионном соглашении
//	* все прочие имена могут быть использованы под пользовательские настройки
//Настройки также могут сохраняться в файл - теперь это xml, сделанный сериализатором.
//Настройки есть для пользователя Общие и для текущего пользователя. Настройки текущего приоритетнее.
//За сохранение настроек отвечает ПодготовитьИСохранитьНастройки.
//За загрузку настроек отвечает ЗагрузитьМенюНастройкиИКоманды. В формах ещё есть ПрименитьНастройки*
//Библиотеки разделены на модули ВС,КС, Клиент, Сервер и ПовтИсп. Модуль Клиент хранится в отдельной форме, КС,ВС, ПИ и Сервер - в МО, плюс все модули - в макетах.
//КС на клиенте выполняется трансляцией макета.


Функция Планы____() Экспорт
	Планы_1 =
			"ДОДЕЛАТЬ:
			|Перенос ВОЛНА в ДатаБокс
			|ОФ - проверить, доделать сохранение и восстановление команд и настроек
            |
			|Доработать 2 этап:
			|Конструктор СКД для тонкого
			|	*Загрузки запроса и скд в тонком из хмл
			|Библиотека запросов
			|Добавить сохранение таблиц МВТ
			|Открыть значение из текячейки таблицы в новую таблицу
			|	*Добавить доптаблицу 2 и МВТ/пакет в несколько таблиц";
	Возврат Планы_1;
КонецФункции

#КонецОбласти

// Возвращает в форму данные СПарам
Процедура ВыгрузитьСтруктуруПараметров(Параметры_, Прм) Экспорт
	Для каждого КиЗ Из Прм Цикл
		СтрочкиТП = Параметры_.НайтиСтроки(Новый Структура("ИмяПараметра", КиЗ.Ключ));
		КУдалению = Новый Массив;
		Спец = 0;
		Для каждого СтрочкаТП Из СтрочкиТП Цикл
			Если СтрочкаТП.ЗначениеПараметра = "&ТабЗначений"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&ДопТаблица"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&Предмет"
					ИЛИ СтрочкаТП.ЗначениеПараметра = "&Код"
					ИЛИ Лев(СтрочкаТП.ЗначениеПараметра, 11) = "Результат ="
					Тогда
				Спец = Спец + 1;
			Иначе
				КУдалению.Добавить(СтрочкаТП);
			КонецЕсли;
		КонецЦикла;
		Для каждого Удаляемая Из КУдалению Цикл
			Параметры_.Удалить(Удаляемая);
		КонецЦикла;
		Если ТипЗнч(КиЗ.Значение) = Тип("Массив") Тогда
			Для каждого Элм Из КиЗ.Значение Цикл
				НовСтрока = Параметры_.Добавить();
				НовСтрока.ИмяПараметра = КиЗ.Ключ;
				НовСтрока.ЗначениеПараметра = Элм;
			КонецЦикла;
		ИначеЕсли Спец <> 1 Тогда
			НовСтрока = Параметры_.Добавить();
			НовСтрока.ИмяПараметра = КиЗ.Ключ;
			НовСтрока.ЗначениеПараметра = КиЗ.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // ВыгрузитьСтруктуруПараметров

Процедура ВызватьАлгоритмОбъект(Код_______, Прм = Неопределено, Подготовка = Истина) Экспорт
	Если Прм = Неопределено Тогда
		Прм = Новый Структура;
	КонецЕсли;
	Если Подготовка Тогда
		Код_К_Выполнению = ДобавитьПараметрыВВыполняемыйКод(Код_______, Прм);//"АдресДляСтруктурыПараметров = ЗаполнитьСтруктуруПараметров();" + Символы.ПС +
	Иначе
		Код_К_Выполнению = Код_______;
	КонецЕсли;
	Выполнить(Код_К_Выполнению);
КонецПроцедуры

// Дополняет структуру настроек другой
// Параметры:
//  Приёмник  - Структура - Настройки исходные
//  Источник  - Структура - Настройки дополняющие
Процедура ДополнитьНастройки(Приёмник, Источник) Экспорт
	Если Приёмник = Неопределено Тогда
		Приёмник = Новый Структура;
	КонецЕсли;
	Для каждого КиЗ Из Источник Цикл
		Если Лев(КиЗ.Ключ, 4) = "Есть" И КиЗ.Значение = Истина Тогда
			ОснКлюч = Сред(КиЗ.Ключ, 5);
			Приёмник.Вставить(КиЗ.Ключ, Источник[КиЗ.Ключ]);
			Приёмник.Вставить(ОснКлюч, Источник[ОснКлюч]);
		КонецЕсли;
	КонецЦикла;
	Если Источник.ЕстьСКД Тогда
		Приёмник.Вставить("НастройкиСКД", Источник.НастройкиСКД);
	КонецЕсли;
	Если Источник.Свойство("Имена_Настроек") Тогда
		Приёмник.Вставить("Имена_Настроек", Источник.Имена_Настроек);
	КонецЕсли;
	Если Источник.Свойство("ИнтервалАвтосохраненияВСекундах") Тогда
		Приёмник.Вставить("ИнтервалАвтосохраненияВСекундах", Источник.ИнтервалАвтосохраненияВСекундах);
	КонецЕсли;
	Если Источник.ЕстьЧАКО И Источник.СВойство("НастройкиЧАКО") Тогда
		Приёмник.Вставить("НастройкиЧАКО", Источник.НастройкиЧАКО);
	КонецЕсли;
	Если Источник.ЕстьТекстЗапроса Тогда
		Приёмник.Вставить("ПерезаписатьТекстЗапроса", Источник.ПерезаписатьТекстЗапроса);
	КонецЕсли;
	Если Источник.ЕстьТекстКода Тогда
		Приёмник.Вставить("ПерезаписатьТекстКода", Источник.ПерезаписатьТекстКода);
	КонецЕсли;
КонецПроцедуры // ДополнитьНастройки

Процедура ДополнитьСписокКартинокИзМакета(СписокКартинок, ВставлятьКартинки = Истина, ИмяМакета = "КоллекцияКартинок") Экспорт
	Макет = ПолучитьМакет(ИмяМакета);
	Синонимы = Новый Структура;
	Для Ё = 2 По Макет.ВысотаТаблицы Цикл
		Синонимы.Вставить(Макет.Область(Ё, 1).Текст, Макет.Область(Ё, 2).Текст);
	КонецЦикла; 
	Для каждого РисТД Из Макет.Рисунки Цикл
		СписокКартинок.Добавить("#М:" + РисТД.Имя, ?(Синонимы.Свойство(РисТД.Имя), Синонимы[РисТД.Имя], РисТД.Имя), Ложь, ?(ВставлятьКартинки, РисТД.Картинка, ""));
	КонецЦикла; 
КонецПроцедуры

//Возвращает загруженные меню, настройки и команды по итогам настроек с наложением на заданные или без
//Параметры:
//	Исходные - Структура - аналогично результату функции = значения до загрузки. Если Неопределено = загружаются стандартные.
//	Имя_Пользователя - Строка - Имя пользователя, у которого надо взять настройки. Если не указано ("") = текущий пользователь. Если "НЕТ" = берутся только стандартные.
//	ИмяНастроек - Строка - Имя параметра хранилища, из которого надо взять настройки. По умолчанию "Настройки". Пустая строка - не загружаются.
//	ИмяКоманд - Строка - Имя параметра хранилища, из которого надо взять команды. По умолчанию "Команды". Пустая строка - не загружаются.
//	ИмяМеню - Строка - Имя параметра хранилища, из которого надо взять меню. По умолчанию "Меню". Пустая строка - не загружаются.
//	Ключи - Строка - Через запятую ключи, которые надо подгрузить к Исходные/стандартным (применяется ко 2 уровню ключей). По умолчанию "" = все ключи.
//	ИменованныеНастройки - Строка - Имя настроек, сохранённых под именем или адрес прочитанного файла с префиксом FILE#. По умолчанию "" = текущие настройки.
// Возвращаемое значение
//	Структура - Ключи:
//		*ИнтервалАвтосохранения = число, интервал автосохранения в секундах
//		*ИменаНастроек = Список значений - Список имён сохранённых настроек 
//		*Команды = Структура см.СтандартныйСписокКоманд
//		*Меню = ДеревоЗначений см.СтандартныеКомандныеПанели
//		*Настройки = Структура см.СтандартныйСписокНастроек
Функция	ЗагрузитьМенюНастройкиИКоманды(
		Исходные = Неопределено,
		Имя_Пользователя = "",
		ИмяНастроек = "Настройки",
		ИмяКоманд = "Команды",
		ИмяМеню = "Меню",
		Ключи = "",
		ИменованныеНастройки = "") Экспорт
	#Область СТАНДАРТНЫЕ_НАСТРОЙКИ_И_КОМАНДЫ
		Если Исходные = Неопределено Тогда
			Результат = Новый Структура("ИнтервалАвтосохранения,ИменаНастроек,Команды,Меню,Настройки",
					150,
					Новый СписокЗначений,
					СтандартныйСписокКоманд(),
					СтандартныеКомандныеПанели(),
					СтандартныйСписокНастроек());
		Иначе
			Результат = Исходные;
		КонецЕсли;
	#КонецОбласти
	#Область ПРОЧИТАТЬ_СОХРАНЁННЫЕ
		Если Имя_Пользователя <> "НЕТ" Тогда
			Если НЕ ЗначениеЗаполнено(Имя_Пользователя) Тогда
				Имя_Пользователя = ИмяПользователя();
			КонецЕсли;
			ИмяЮзера = ИмяПользователя();
			Если Имя_Пользователя = ИмяЮзера ИЛИ ПравоДоступа("АдминистрированиеДанных", Метаданные) Тогда
				#Область НАСТРОЙКИ
					Если ИменованныеНастройки = "" Тогда
						ЕстьНастройки = ЗначениеЗаполнено(ИмяНастроек);
						ЕстьКоманды = ЗначениеЗаполнено(ИмяКоманд);
						ЕстьМеню = ЗначениеЗаполнено(ИмяМеню);
						ОбщиеСохранённыеНастройки = ?(ЕстьНастройки, ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", ИмяНастроек,, Имя_Пользователя), Неопределено);
						ОбщиеСохранённыеКоманды = ?(ЕстьКоманды, ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", ИмяКоманд,, Имя_Пользователя), Неопределено);
						ОбщиеСохранённыеМеню = ?(ЕстьМеню, ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", ИмяМеню,, Имя_Пользователя), Неопределено);
						ИнтервалАвтосохранения = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(
								ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", "ИнтервалАвтосохранения",, Имя_Пользователя), Неопределено, 150);
						ИменаНастроек = ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", "ИменаНастроек",, Имя_Пользователя);
					ИначеЕсли Лев(ИменованныеНастройки, 5) = "FILE#" Тогда
						//Загрузка из файла см.форму, ПрочитатьНастройкиИЗапихнутьВХранилище, там пишется в текущие, а из текущих грузится через здесь
					Иначе
						Все_Настройки = ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", ИменованныеНастройки,, Имя_Пользователя);
						Если Все_Настройки = Неопределено Тогда
							ОбщиеСохранённыеНастройки = Неопределено;
							ОбщиеСохранённыеКоманды =  Неопределено;
							ОбщиеСохранённыеМеню = Неопределено;
							ИнтервалАвтосохранения = 150;
							ИменаНастроек = Неопределено;
						ИначеЕсли Все_Настройки.Свойство("ЕстьТабЗначений") Тогда
							ОбщиеСохранённыеНастройки = Все_Настройки;
							ОбщиеСохранённыеКоманды =  Неопределено;
							ОбщиеСохранённыеМеню = Неопределено;
							ИнтервалАвтосохранения = 150;
							ИменаНастроек = Неопределено;
						Иначе
							ОбщиеСохранённыеНастройки = ЧтСтрукт(Все_Настройки, "Настройки");
							ОбщиеСохранённыеКоманды = ЧтСтрукт(Все_Настройки, "Команды");
							ОбщиеСохранённыеМеню = ЧтСтрукт(Все_Настройки, "Меню");
							ИнтервалАвтосохранения = ЧтСтрукт(Все_Настройки, "ИнтервалАвтосохранения", 150);
							ИменаНастроек = ЧтСтрукт(Все_Настройки, "ИменаНастроек");
						КонецЕсли;
					КонецЕсли;
				#КонецОбласти
				Если ЗначениеЗаполнено(Ключи) Тогда
					Если ЕстьНастройки Тогда
						ЕстьРеквизитыОбъекта(Ключи, ОбщиеСохранённыеНастройки, "Пересечение");
					КонецЕсли;
					Если ЕстьКоманды Тогда
						ЕстьРеквизитыОбъекта(Ключи, ОбщиеСохранённыеКоманды, "Пересечение");
					КонецЕсли;
					Если ЕстьМеню Тогда
						ЕстьРеквизитыОбъекта(Ключи, ОбщиеСохранённыеМеню, "Пересечение");
					КонецЕсли;
				КонецЕсли;
			Иначе
				ОбщиеСохранённыеНастройки = Неопределено;
				ОбщиеСохранённыеКоманды = Неопределено;
				ОбщиеСохранённыеМеню = Неопределено;
				ИнтервалАвтосохранения = 0;
				ИменаНастроек = Неопределено;
			КонецЕсли;
			Если ЗначениеЗаполнено(ОбщиеСохранённыеНастройки) Тогда
				ДополнитьНастройки(Результат.Настройки, ОбщиеСохранённыеНастройки);
			КонецЕсли;
			Если ЗначениеЗаполнено(ОбщиеСохранённыеКоманды) Тогда
				ЭтоУП = ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение;
				Если ЭтоУП Тогда
					Для каждого КиЗ Из ОбщиеСохранённыеКоманды Цикл
						КиЗ.Значение.Вставить("ТекстКоманды", КиЗ.Значение.ТекстКомандыУП);
						КиЗ.Значение.Вставить("ТекстПараметр", КиЗ.Значение.ТекстПараметрУП);
						КиЗ.Значение.Удалить("ТекстКомандыУП");
						КиЗ.Значение.Удалить("ТекстПараметрУП");
						КиЗ.Значение.Удалить("ТекстКомандыОП");
						КиЗ.Значение.Удалить("ТекстПараметрОП");
					КонецЦикла;
				Иначе
					Для каждого КиЗ Из ОбщиеСохранённыеКоманды Цикл
						КиЗ.Значение.Вставить("ТекстКоманды", КиЗ.Значение.ТекстКомандыОП);
						КиЗ.Значение.Вставить("ТекстПараметр", КиЗ.Значение.ТекстПараметрОП);
						КиЗ.Значение.Удалить("ТекстКомандыУП");
						КиЗ.Значение.Удалить("ТекстПараметрУП");
						КиЗ.Значение.Удалить("ТекстКомандыОП");
						КиЗ.Значение.Удалить("ТекстПараметрОП");
					КонецЦикла;
				КонецЕсли;
				ДополнитьСтруктуру(Результат.Команды, ОбщиеСохранённыеКоманды, Истина);
			КонецЕсли;
			Если ЗначениеЗаполнено(ОбщиеСохранённыеМеню) Тогда
				Дополнить_Дерево_Из_Сохранёнки(Результат.Меню, ОбщиеСохранённыеМеню);
			КонецЕсли;
			Если ИнтервалАвтосохранения > 0 Тогда
				Результат.Вставить("ИнтервалАвтосохранения", ИнтервалАвтосохранения);
			КонецЕсли;
			Если ЗначениеЗаполнено(ИменаНастроек) Тогда
				Если ?(Результат.Свойство("ИменаНастроек"), ЗначениеЗаполнено(Результат.ИменаНастроек), Ложь) Тогда
					Для каждого ИмяНастройки_Ист Из ИменаНастроек Цикл
						ТекПриёмник = Результат.ИменаНастроек.НайтиПоЗначению(ИмяНастройки_Ист.Значение);
						Если ТекПриёмник = Неопределено Тогда
							Результат.ИменаНастроек.Добавить(ИмяНастройки_Ист.Значение, ИмяНастройки_Ист.Представление);
						Иначе
							ЗаполнитьЗначенияСвойств(ТекПриёмник, ИмяНастройки_Ист);
						КонецЕсли;
					КонецЦикла;
				Иначе
					Результат.Вставить("ИменаНастроек", ИменаНастроек);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти
	Возврат Результат
КонецФункции //ЗагрузитьМенюНастройкиИКоманды

Функция ЗаписатьКоманду(ПараметрыСохранения)
	Результат = 0;
	ДеревоМеню = ПолучитьИзВременногоХранилища(ПараметрыСохранения.ФормаЭтойОбработки.АдресДереваМеню);
	МенюДерево = ДеревоМеню.Строки.Найти("ДеревоКоманд", "Имя");
	СтрокаТочка = МенюДерево.Строки.Найти(ПараметрыСохранения.ПутьККоманде, "ИД_", Истина);
	Если СтрокаТочка <> Неопределено Тогда
		#Область ИНИЦИАЛИЗАЦИЯ
			СтрокиНазначения = СтрокаТочка.Родитель.Строки;
			СтрокаПриёмник = СтрокиНазначения.Вставить(СтрокиНазначения.Индекс(СтрокаТочка) + ?(ПараметрыСохранения.ПередПосле = "После", 1, 0));
			ИмяНастроек = "Команда___" + ПараметрыСохранения.ИмяКоманды;
			Имя_Пользователя = ?(ПараметрыСохранения.ТолькоДляМеня, ИмяПользователя(), "Общие");
		#КонецОбласти
		#Область ОЧИСТКА_СТАРЫХ
			СтарыеКоманды = МенюДерево.Строки.НайтиСтроки(Новый Структура("Имя", ПараметрыСохранения.ИмяКоманды), Истина);
			Результат = СтарыеКоманды.Количество();
			Для каждого Ветюлечка Из СтарыеКоманды Цикл
				Ветюлечка.Родитель.Строки.Удалить(Ветюлечка);
			КонецЦикла;
			ХранилищеОбщихНастроек.Удалить("КонсольДанных_____", ИмяНастроек, Имя_Пользователя);
		#КонецОбласти
		#Область НОВОЕ_МЕНЮ
			Если ЗначениеЗаполнено(ПараметрыСохранения.ИмяПодменю) Тогда
				СтрокаПриёмник.ИД_	= НовыйИД(ДеревоМеню);
				СтрокаПриёмник.Имя	= ПараметрыСохранения.ИмяПодменю;
				СтрокаПриёмник.Команда	= ПараметрыСохранения.ПредставлениеПодменю;
				СтрокаПриёмник.Вид = ?(ПараметрыСохранения.ТолькоДляМеня, "П", "О");
				СтрокаПриёмник = СтрокаПриёмник.Строки.Добавить();
			КонецЕсли;
			СтрокаПриёмник.ИД_	= НовыйИД(ДеревоМеню);
			СтрокаПриёмник.Имя	= ПараметрыСохранения.ИмяКоманды;
			СтрокаПриёмник.Команда	= ПараметрыСохранения.ПредставлениеКоманды;
			СтрокаПриёмник.ДопИнф	= ?(ПараметрыСохранения.ЭтоРазделитель, "РАЗДЕЛИТЕЛЬ", "");
			СтрокаПриёмник.Картинка = ПолучитьКартинку(ПараметрыСохранения.ПутьККартинке);
			СтрокаПриёмник.ХотКей = ПараметрыСохранения.ХотКей;
			СтрокаПриёмник.Подсказка = ПараметрыСохранения.Подсказка;
			СтрокаПриёмник.Вид = ?(ПараметрыСохранения.ТолькоДляМеня, "П", "О");
			ПараметрыСохранения.ФормаЭтойОбработки.АдресДереваМеню = ПоместитьВоВременноеХранилище(ДеревоМеню, ПараметрыСохранения.ФормаЭтойОбработки.АдресДереваМеню);
			ЗаписатьВХранилище(ДеревоМеню, "Меню", ПараметрыСохранения.ТолькоДляМеня);
		#КонецОбласти
		#Область НОВЫЕ_НАСТРОЙКИ
			Если ПараметрыСохранения.СохранитьТекстЗапроса ИЛИ ПараметрыСохранения.СохранитьПредмет ИЛИ ПараметрыСохранения.СохранитьПараметры
					ИЛИ ПараметрыСохранения.СохранитьСКД ИЛИ ПараметрыСохранения.СохранитьТаб1 ИЛИ ПараметрыСохранения.СохранитьТаб2 ИЛИ ПараметрыСохранения.СохранитьТД Тогда
				ЭтиНастройки = ПодготовитьСохраняемыеНастройки(ПараметрыСохранения);
				//ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", ИмяНастроек, ЭтиНастройки,, Имя_Пользователя);
				ПодготовитьИСохранитьНастройки(ИмяНастроек, ЭтиНастройки, Истина,, ?(ПараметрыСохранения.ТолькоДляМеня, "", "Общие"));
			КонецЕсли;
		#КонецОбласти
		#Область НОВАЯ_КОМАНДА
			НоваяКоманда = Новый Структура("Вид", ?(ПараметрыСохранения.ТолькоДляМеня, "П", "О"));
			НоваяКоманда.Вставить("Имя", ПараметрыСохранения.ИмяКоманды);
			НоваяКоманда.Вставить("Заголовок", ПараметрыСохранения.ПредставлениеКоманды);
			НоваяКоманда.Вставить("ТекстКоманды", "");
			НоваяКоманда.Вставить("ТекстПараметр", "");
			ПараметрыСохранения.ФормаЭтойОбработки.КомандыСписок.Вставить(ПараметрыСохранения.ИмяКоманды, НоваяКоманда);
			ЗаписатьВХранилище(ПараметрыСохранения.ФормаЭтойОбработки.КомандыСписок, "Команды", ПараметрыСохранения.ТолькоДляМеня);
		#КонецОбласти
	Иначе
		Сообщить("Указанный путь к команде не найден");
	КонецЕсли;
Возврат Результат
КонецФункции

Функция ИмяФайлаНастроекПоУмолчанию() Экспорт
	Возврат ИмяКаталога(ЭтотОбъект.ИспользуемоеИмяФайла) + "\НастройкиКД\Настройки\ПоУмолчанию.нст3"
КонецФункции // ИмяФайлаНастроекПоУмолчанию()

//Получает картинку из макета или библиотеки
// Параметры:
//	Путь - Строка/Картинка - если пустая или картинка, возвращает сам путь. Если строка с префиксом "#Б:" или "#О:" - получает картинку из библиотеки по пути без префикса,
//			если префикс "#М:" - картинка получается из рисунков макета по имени без префикса, иначе - из файла по пути.
//	ПрозрачныйФон - Булево - Установить картинке прозрачность.
Функция ПолучитьКартинку(Путь, ПрозрачныйФон = Истина) Экспорт
	Если (Путь = "") ИЛИ (ТипЗнч(Путь) = Тип("Картинка")) Тогда
		Результат = Путь;
	Иначе
		Префикс = Лев(Путь, 3);
		НовыйПуть = Сред(Путь, 4);
		Результат = ?(Префикс = "#Б:", БиблиотекаКартинок[НовыйПуть],
				?(Префикс = "#О:", БиблиотекаКартинок[НовыйПуть], 
					?(Префикс = "#М:", КартинкаИзМакета(НовыйПуть),
					Новый Картинка(Путь, ПрозрачныйФон))));
	КонецЕсли; 
	Возврат Результат
КонецФункции // ПолучитьКартинку()

Процедура ПриСоздании() Экспорт
	Если Метаданные.ОбщиеМодули.Найти("ВОЛНА_ОбщегоНазначенияКС") = Неопределено Тогда
		ВОЛНА_ОбщегоНазначенияВС = ЭтотОбъект;
		ВОЛНА_ОбщегоНазначенияКС = ЭтотОбъект;
		ВОЛНА_ОбщегоНазначенияПовтИспСеансВС = ЭтотОбъект;
		ВОЛНА_ОбщегоНазначенияСервер = ЭтотОбъект;
	КонецЕсли;
КонецПроцедуры

#Область ТРАНСЛЯЦИЯ_МОДУЛЯ
	
//  Ищет вхождение строки в другую вне  строковых литералов в кавычках
// Параметры:
//  ГдеИскать  - Строка - Строка, в которой ищем
//  ЧтоИскать  - Строка - Строка, в которой ищем
//  СПозиции  - Число - Начальная позиция поиска. По умолчанию 1
// Возвращаемое значение:
//   Число   - Позиция вхождения
Функция НайтиНеВКавычках(ГдеИскать, ЧтоИскать, Знач СПозиции = 1)
	Кавычек = 1;
	Результат = 1;
	ТекДлина = СтрДлина(ЧтоИскать);
	Пока Цел(Кавычек / 2) * 2 <> Кавычек И Результат > 0 Цикл
		Результат = СтрНайти(ГдеИскать, ЧтоИскать,, СПозиции);
		Кавычек = СтрЧислоВхождений(Сред(ГдеИскать, СПозиции, Результат - СПозиции), """");
		СПозиции = СПозиции + ТекДлина;
	КонецЦикла;
	Возврат Результат
КонецФункции // НайтиНеВКавычках

// Разбирает текст вызова метода
// Параметры:
//  ТекстМодуля  - Строка - Текст кода, включающего вызов. Не содержит комментариев
//  НачПоз  - Число - Позиция начала вызова
//  ИмяМодуля  - Строка - Имя вызываемого модуля. По умолчанию "".
//  ИмяМетода  - Строка - Имя вызываемого метода. По умолчанию "".
// Возвращаемое значение:
//   Структура   - ключи:
//			ИмяМетода, ИмяМодуля, ДлинаВызова, ПараметрыВызова - параметры одной строкой как в вызове и
//			Возвратные (не стал делать, не нужно) - строка из нулей и единиц по колву факт параметров.
//			1=параметр должен вернуться.
Функция РазобратьВызовМетода(ТекстМодуля, НачПоз, ИмяМодуля = "", ИмяМетода = "")
	Результат = Новый Структура("Возвратные,ДлинаВызова,ИмяМетода,ИмяМодуля,ПараметрыВызова");
	#Область ИМЯ_МОДУЛЯ_И_МЕТОДА
		Если ИмяМетода = "" Тогда
			ПозСкобки = СтрНайти(ТекстМодуля, "(",, НачПоз);
			Результат.Вставить("ИмяМодуля", ИмяМодуля);
			ДлИмениМодуля = ?(ИмяМодуля = "", 0, СтрДлина(ИмяМодуля) + 1);
			Результат.Вставить("ИмяМетода", Сред(ТекстМодуля, НачПоз + ДлИмениМодуля, ПозСкобки - НачПоз - ДлИмениМодуля));
			ПозТочки = СтрНайти(Результат.ИмяМетода, ".");
			Если ПозТочки > 0 Тогда
				Результат.Вставить("ИмяМодуля", Сред(ТекстМодуля, НачПоз, ПозТочки - НачПоз));
				Результат.Вставить("ИмяМетода", Сред(ТекстМодуля, ПозТочки + 1, ПозСкобки - ПозТочки - 1));
			КонецЕсли;
		Иначе
			Результат.Вставить("ИмяМетода", ИмяМетода);
			Результат.Вставить("ИмяМодуля", ИмяМодуля);
			ТекПоз = НачПоз + СтрДлина(ИмяМодуля) + СтрДлина(ИмяМетода);
			ПозСкобки = СтрНайти(ТекстМодуля, "(",, ТекПоз);
		КонецЕсли;
	#КонецОбласти
	ТекПоз = ПозСкобки + 1;
	СчСк = 1;
	СчКв = 0;
	СчФг = 0;
	//СчПуст = 0;
	//ПервыйСимвол = "_АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюяabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	//ВторойСимвол = "_АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюяabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890.";
	//ИщемЗдесь = ПервыйСимвол;
	//Возвратные = "";
	//ПеремОк = Истина;
	ЭтоТекст = Ложь;
	Для СчПоз = ТекПоз По СтрДлина(ТекстМодуля) Цикл
		ТекСимвол = Сред(ТекстМодуля, СчПоз, 1);
		Если ТекСимвол = """" Тогда
			ЭтоТекст = Не ЭтоТекст;
		ИначеЕсли ЭтоТекст Тогда
		ИначеЕсли ТекСимвол = "(" Тогда
			СчСк = СчСк + 1;
		ИначеЕсли ТекСимвол = ")" Тогда
			СчСк = СчСк - 1;
		ИначеЕсли ТекСимвол = "{" Тогда
			СчФг = СчФг + 1;
		ИначеЕсли ТекСимвол = "}" Тогда
			СчФг = СчФг - 1;
		ИначеЕсли ТекСимвол = "[" Тогда
			СчКв = СчКв + 1;
		ИначеЕсли ТекСимвол = "]" Тогда
			СчКв = СчКв - 1;
		КонецЕсли;
		Если СчКв = 0 И СчСк = 0 И СЧФг = 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Результат.Вставить("ДлинаВызова", СчПоз - НачПоз + 1);
	Результат.Вставить("ПараметрыВызова", Сред(ТекстМодуля, ПозСкобки + 1, СчПоз - ПозСкобки - 1));
	Возврат Результат
КонецФункции // РазобратьВызовМетода

// Разбирает текст модуля и возвращает структуру методов
// Возвращаемое значение:
//   Структура   - ИмяМетода => Текст, ЭтоФункция, ЭтоЭкспорт, Параметры = массив структур(Имя, Значение, ЭтоЗнач)
Функция СобратьТрансляциюМодуля(ИсходныйТекстМодуля) Экспорт
	#Область ИНИЦИАЛИЗАЦИЯ
		Результат = Новый Структура;
	#КонецОбласти
	#Область ПЕРВОНАЧАЛЬНОЕ_ЗАПОЛНЕНИЕ
		#Область ДОЛОЙ_КОММЕНТЫ
			МодБезКомментов = "";
			НачПоз = 1;
			Пока НачПоз > 0 Цикл
				ПозКоммента = НайтиНеВКавычках(ИсходныйТекстМодуля, "//", НачПоз);
				Если ПозКоммента = 0 Тогда
					МодБезКомментов = МодБезКомментов + Сред(ИсходныйТекстМодуля, НачПоз);
					НачПоз = 0;
				Иначе
					ТекФрагмент = Сред(ИсходныйТекстМодуля, НачПоз, ПозКоммента - НачПоз);
					МодБезКомментов = МодБезКомментов + ТекФрагмент;
					НачПоз = СтрНайти(ИсходныйТекстМодуля, Символы.ПС,, ПозКоммента + 2);
				КонецЕсли;
			КонецЦикла;
		#КонецОбласти
		НачПоз = 1;
		ТекстМодЗагл = ВРег(МодБезКомментов);
		ИскатьМетоды = 2;
		ПозЭкспорт = 1;
		Пока Истина Цикл
			#Область ПОИСК_СЛЕДУЮЩЕГО_МЕТОДА
				Кавычек = 1;
				Если ИскатьМетоды < 3 Тогда
					ПозФунк = НайтиНеВКавычках(ТекстМодЗагл, "ФУНКЦИЯ", НачПоз);
				КонецЕсли;
				Кавычек = 1;
				Если ИскатьМетоды > 1 Тогда
					ПозПроц = НайтиНеВКавычках(ТекстМодЗагл, "ПРОЦЕДУРА", НачПоз);
				КонецЕсли;
			#КонецОбласти
			Если ПозФунк = 0 И ПозПроц = 0 Тогда
				Прервать;
			КонецЕсли;
			ОписаниеМетода = Новый Структура("Параметры,Текст,ЭтоФункция,ЭтоЭкспорт");
			#Область ИНИЦИАЛИЗАЦИЯ_И_ИЭТОФУНКЦИЯ
				Если ПозФунк > 0 И (ПозФунк < ПозПроц ИЛИ ПозПроц = 0) Тогда
					ОписаниеМетода.Вставить("ЭтоФункция", Истина);
					ТекПоз = ПозФунк;
					ПозИмени = ТекПоз + 8;
					ИскатьМетоды = 1;
				Иначе
					ОписаниеМетода.Вставить("ЭтоФункция", Ложь);
					ТекПоз = ПозПроц;
					ПозИмени = ТекПоз + 10;
					ИскатьМетоды = 3;
				КонецЕсли;
				НачПоз =  ПозИмени;
			#КонецОбласти
			Если НЕ ЗначениеЗаполнено(Сред(ТекстМодЗагл, ПозИмени - 1, 1)) И (ТекПоз = 1 ИЛИ НЕ ЗначениеЗаполнено(Сред(ТекстМодЗагл, ТекПоз - 1, 1))) Тогда
				ПозСкобки = СтрНайти(ТекстМодЗагл, "(",, ПозИмени);
				ПозКонца = НайтиНеВКавычках(ТекстМодЗагл, ")", ПозСкобки + 1);
				ИмяМетода = СокрЛП(Сред(ТекстМодЗагл, ПозИмени, ПозСкобки - ПозИмени));
				#Область ПАРАМЕТРЫ
					ПозНачала = ПозСкобки + 1;
					мПараметры = Новый Массив;
					Пока ПозНачала < ПозКонца Цикл
						#Область ТЕКСТ_ВСЕГО_ПАРАМЕТРА
							ПозЗапятой = НайтиНеВКавычках(ТекстМодЗагл, ",", ПозНачала);
							Если ПозЗапятой > ПозКонца ИЛИ ПозЗапятой = 0 Тогда
								ПозЗапятой = ПозКонца;
							КонецЕсли;
							ТекстПараметра = СокрЛП(Сред(МодБезКомментов, ПозНачала, ПозЗапятой - ПозНачала));
						#КонецОбласти
						#Область ЗНАЧ_
							ОписаниеПараметра = Новый Структура("Значение,Имя,ЭтоЗнач");
							Если ВРег(Лев(ТекстПараметра, 4)) = "ЗНАЧ" И НЕ ЗначениеЗаполнено(Сред(ТекстПараметра, 5, 1)) Тогда
								ОписаниеПараметра.Вставить("ЭтоЗнач", Истина);
								ТекстПараметра = СокрЛП(Сред(ТекстПараметра, 6));
							Иначе
								ОписаниеПараметра.Вставить("ЭтоЗнач", Ложь);
							КонецЕсли;
						#КонецОбласти
						#Область ИМЯ_И_ЗНАЧЕНИЕ
							ПозРавно = СтрНайти(ТекстПараметра, "=");
							Если ПозРавно = 0 Тогда
								ОписаниеПараметра.Вставить("Значение", "");
								ОписаниеПараметра.Вставить("Имя", ТекстПараметра);
							Иначе
								ОписаниеПараметра.Вставить("Значение", СокрЛП(Сред(ТекстПараметра, ПозРавно + 1)));
								ОписаниеПараметра.Вставить("Имя", СокрЛП(Лев(ТекстПараметра, ПозРавно - 1)));
							КонецЕсли;
						#КонецОбласти
						ПозНачала = ПозЗапятой + 1;
						мПараметры.Добавить(ОписаниеПараметра);
					КонецЦикла;
					ОписаниеМетода.Вставить("Параметры", мПараметры);
				#КонецОбласти
				#Область ЭКСПОРТ_
					ПозЭкспорт = ПозКонца - 6;
					Пока ПозЭкспорт > 0 И ПозЭкспорт < ПозКонца
							ИЛИ ЗначениеЗаполнено(Сред(ТекстМодЗагл, ПозЭкспорт - 1, 1))
							ИЛИ ЗначениеЗаполнено(Сред(ТекстМодЗагл, ПозЭкспорт + 7, 1)) Цикл
						ПозЭкспорт = СтрНайти(ТекстМодЗагл, "ЭКСПОРТ",, ПозЭкспорт + 7);
					КонецЦикла;
					ОписаниеМетода.Вставить("ЭтоЭкспорт", ПозЭкспорт = ПозКонца + 1 ИЛИ НЕ ЗначениеЗаполнено(Сред(ТекстМодЗагл, ПозКонца + 1, ПозЭкспорт - ПозКонца - 1)));
				#КонецОбласти
				#Область ТЕКСТ
					ПозНачала = ПозКонца + ?(ОписаниеМетода.ЭтоЭкспорт, 9, 1);
					ПозКонца = НайтиНеВКавычках(ТекстМодЗагл, ?(ОписаниеМетода.ЭтоФункция, "КОНЕЦФУНКЦИИ", "КОНЕЦПРОЦЕДУРЫ"), ПозНачала);
					ОписаниеМетода.Вставить("Текст", Сред(МодБезКомментов, ПозНачала, ПозКонца - ПозНачала));
					#Область ВОЗВРАТЫ
						Если ОписаниеМетода.ЭтоФункция Тогда
							ПозВозврата = ПозКонца + 1;
							Пока Истина Цикл
								ПозВозврата = СтрНайти(ТекстМодЗагл, "ВОЗВРАТ", НаправлениеПоиска.СКонца, ПозВозврата - 1);
								Если ПозВозврата < ПозНачала Тогда
									Прервать;
								КонецЕсли;
								ОписаниеМетода.Вставить("Текст", Лев(ОписаниеМетода.Текст, ПозВозврата - ПозНачала)
										+ "РезультатВыполненияВозвращаемый_КАК_Функцией =" + Сред(ОписаниеМетода.Текст, ПозВозврата - ПозНачала + 8));
							КонецЦикла;
						КонецЕсли;
					#КонецОбласти
					ОписаниеМетода.Вставить("Текст", СокрЛП(ОписаниеМетода.Текст));
				#КонецОбласти
				НачПоз = ПозКонца + ?(ОписаниеМетода.ЭтоФункция, 13, 15);
				Результат.Вставить(ИмяМетода, ОписаниеМетода);
			КонецЕсли;
		КонецЦикла;
	#КонецОбласти
	#Область ВЛОЖЕННЫЕ_ВЫЗОВЫ
		Для каждого КиЗ_Р Из Результат Цикл
			#Область ВЫЗОВЫ_КС
				ВРегТекст = ВРег(КиЗ_Р.Значение.Текст);
				Для каждого КиЗ_ВВ Из Результат Цикл
					НачПоз = 1;
					Пока Истина Цикл
						ПозИмени = НайтиНеВКавычках(ВРегТекст, ВРег(КиЗ_ВВ.Ключ) + "(", НачПоз);
						Если ПозИмени = 0 Тогда
							Прервать;
						КонецЕсли;
						СтрФакт = РазобратьВызовМетода(КиЗ_Р.Значение.Текст, ПозИмени,, КиЗ_ВВ.Ключ);
						НачПоз = ПозИмени + СтрФакт.ДлинаВызова;
						КиЗ_Р.Значение.Текст = Лев(КиЗ_Р.Значение.Текст, ПозИмени - 1)
								+ "УниверсальныйВызовМетодаИзТекста(ТрансляторКС[" + КиЗ_ВВ.Ключ + "],""" + СтрФакт.Возвратные + """," + СтрФакт.ПараметрыВызова + ")"
								+ Сред(КиЗ_Р.Значение.Текст, НачПоз);
						ВРегТекст = ВРег(КиЗ_Р.Значение.Текст);
					КонецЦикла;
				КонецЦикла;
			#КонецОбласти
			#Область ВЫЗОВЫ_ВС
				НачПоз = 1;
				Пока Истина Цикл
					ПозИмени = НайтиНеВКавычках(ВРегТекст, "ВОЛНА_ОБЩЕГОНАЗНАЧЕНИЯВС", НачПоз);
					Если ПозИмени = 0 Тогда
						Прервать;
					КонецЕсли;
					СтрФакт = РазобратьВызовМетода(КиЗ_Р.Значение.Текст, ПозИмени, "ВОЛНА_ОБЩЕГОНАЗНАЧЕНИЯВС");
					НачПоз = ПозИмени + СтрФакт.ДлинаВызова;
					КиЗ_Р.Значение.Текст = Лев(КиЗ_Р.Значение.Текст, ПозИмени - 1)
							+ "ВызватьБиблиотечныйВС(""" + СтрФакт.ИмяМетода + """, " + СтрФакт.ПараметрыВызова + ")"
							+ Сред(КиЗ_Р.Значение.Текст, ПозИмени + СтрФакт.ДлинаВызова);
					ВРегТекст = ВРег(КиЗ_Р.Значение.Текст);
				КонецЦикла;
			#КонецОбласти
		КонецЦикла;
	#КонецОбласти
	Возврат Результат
КонецФункции // СобратьТрансляциюМодуляКС

#КонецОбласти

Функция НетПрав(ТолькоПринято = "") Экспорт
	Если ЗначениеЗаполнено(ТолькоПринято) Тогда
		Результат = Ложь;
		ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Права", Ложь, ИмяПользователя());
	Иначе
		Результат = ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", "Права",, ИмяПользователя()) <> Ложь;
	КонецЕсли;
	Возврат Результат
КонецФункции // НетПрав

Функция ТекстОЛицензии() Экспорт
	Возврат "Обработка разработана Персиановым М.С. (2019).
			|
			|Использование обработки не допускается, если обработка не куплена у автора, или автор не давал согласия на её использование.
			|Согласие автора на бесплатное использование обработки может быть в любое время отозвано без объяснения причин.
			|Автор не несёт ответственности за ошибки алгоритмов, но гарантирует бесплатное исправление ошибок в обработке
			|(без каких-либо обязательств по срокам и исправлению последствий применения ошибочных алгоритмов).
			|Данная обработка является инструментом, который должен применяться с должной осмотрительностью.
			|Все алгоритмы не могли быть проверены по причине большого объёма проверки. Предполагается, что работать
			|с обработкой должен специалист достаточно квалифицированный, чтобы не допустить нежелательной потери данных.
			|Если Вы не согласны с этими условиями, не следует использовать эту обработку.
			|Автор будет благодарен за замечания по обработке ((906) 728 2540). Принятые замечания будут исправлены совершенно бесплатно.
			|Вы принимаете эти условия?"
КонецФункции

// Удаляет ИД из дерева меню и сохраняет  дерево меню
// Параметры:
//  СПодменю  - Булево - УдалитьПодменю-родитель
Функция УдалитьИзДереваМеню(УдаляемыйИД, СПодменю, АдресДереваМеню) Экспорт
	ДеревоМеню = ПолучитьИзВременногоХранилища(АдресДереваМеню);
	Родитель_ = ДеревоМеню.Строки.Найти(УдаляемыйИД, "ИД_", Истина);
	Первый = Истина;
	Пока Первый Цикл
		УдаляемаяСтрока = Родитель_;
		ТекВид = УдаляемаяСтрока.Вид;
		Родитель_ = УдаляемаяСтрока.Родитель;
		Если ТекВид = "В" Тогда
			УдаляемаяСтрока.Вид = "П";
			УдаляемаяСтрока.ДопИнф = "СКРЫТЬ";
		ИначеЕсли Родитель_ = Неопределено Тогда
			УдаляемаяСтрока.Владелец().Строки.Удалить(УдаляемаяСтрока);
		Иначе
			Родитель_.Строки.Удалить(УдаляемаяСтрока);
		КонецЕсли;
		Первый = Родитель_ <> Неопределено И СПодменю И Родитель_.Строки.Количество() = 0;
	КонецЦикла;
	ЗаписатьВХранилище(ДеревоМеню, "Меню", ТекВид <> "О");
	Возврат ДеревоМеню
КонецФункции // УдалитьИзДереваМеню

#КонецОбласти

#Область СЛУЖЕБНЫЕ

#Область ДЕРЕВО_КОМАНД
	
Функция ДобавитьПозициюДереваКоманд(Куда, Позиция = Неопределено, Имя, Представление_ = "", Картинка_ = Неопределено)
	Если Позиция = Неопределено Тогда
		Позиция = Куда.Строки.Количество();
	КонецЕсли;
	НоваяСтрока = Куда.Строки.Вставить(Позиция);
	НоваяСтрока.Имя = Имя;
	НоваяСтрока.Команда = Представление_;
	Если Картинка_ <> Неопределено Тогда
		НоваяСтрока.Картинка = Картинка_;
	КонецЕсли;
	Возврат НоваяСтрока
КонецФункции

Процедура ЗаполнитьПозициюВстроеннойКоманды(Позиция, Имя, Представление_ = "")
	Позиция.Имя = Имя; ВстроенныеКоманды = Новый Структура;//затычка
	Если ВстроенныеКоманды.Свойство(Имя) Тогда
		Позиция.Команда = ?(Представление_ = "", ВстроенныеКоманды[Имя].Заголовок, Представление_);
		Позиция.Картинка = ПолучитьКартинку(?(ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение, ?(ВстроенныеКоманды[Имя].КартинкаУП = "",
				ВстроенныеКоманды[Имя].Картинка, ВстроенныеКоманды[Имя].КартинкаУП), ВстроенныеКоманды[Имя].Картинка));
	Иначе
		Позиция.Команда = ?(Представление_ = "", Имя, Представление_);
	КонецЕсли; 
КонецПроцедуры

Функция НайтиВДеревеКоманд(Дерево, Путь, Уровень, Уровней)
	Результат = Неопределено;
	ТекПуть = СтрПолучитьСтроку(Путь, Уровень);
	Если ТекПуть = "#КОРЕНЬ" Тогда
		Результат = Дерево;
	Иначе
		ЭтоПервый = Уровень = 1;
		Подходят = Дерево.Строки.НайтиСтроки(Новый Структура("Имя", ТекПуть), ЭтоПервый);
		Если Подходят.Количество() > 0 Тогда
			Если Уровней - Уровень <= 1 Тогда
				Результат = Подходят[0];
			Иначе
				Результат = Новый Массив;
				Для каждого Строчка Из Подходят Цикл
					ВложенныйРезультат = НайтиВДеревеКоманд(Строчка, Путь, Уровень + 1, Уровней);
					Если ВложенныйРезультат <> Неопределено Тогда
						Результат.Добавить(ВложенныйРезультат);
						Прервать;
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли;
		Иначе
			Результат = Дерево;
			Для Ё = 1 По Макс(Уровней - Уровень, 1) Цикл
				ТекПуть = ?(Уровней - Уровень <= 1, ТекПуть, СтрПолучитьСтроку(Путь, Уровень + Ё - 1));
				Результат = ДобавитьПозициюДереваКоманд(Результат.Строки,, ТекПуть, ТекПуть);
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // НайтиВДеревеКоманд()
 
//Читает дерево команд из макета и СохранённыхКоманд, подчинённое элементу с заданным Имя = ИмяУровня
Функция ПрочитатьДеревоКоманд(ИмяУровня, ЧитатьСохранённые = Истина) Экспорт
	Результат = Новый ДеревоЗначений;
	Результат.Колонки.Добавить("Команда", Новый ОписаниеТипов("Строка"), "Команда", 40);
	Результат.Колонки.Добавить("Картинка", Новый ОписаниеТипов("Картинка"), "Имя", 10);
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"), "Имя", 0);
	Макет = ПолучитьМакет("СтруктураКоманд");
	НеНайденные = Новый Структура;
	Для Ё = 2 По Макет.ВысотаТаблицы Цикл
		ТекРодитель = Макет.Область(Ё, 1).Текст;
		ТекКоманда = "";
		Для ЁК = 2 По Макет.ШиринаТаблицы Цикл
			ТекКоманда = ТекКоманда + Макет.Область(Ё, ЁК).Текст;
		КонецЦикла;
		ТекПредставление = СтрЗаменить(ТекКоманда, "/", Символы.ПС);
		ТекКоманда = СтрПолучитьСтроку(ТекПредставление, 1);
		Если ТекРодитель = ИмяУровня Тогда
			ЗаполнитьПозициюВстроеннойКоманды(Результат.Строки.Добавить(), ТекКоманда, СтрПолучитьСтроку(ТекПредставление, 2));
		Иначе
			НайденныйРодитель = Результат.Строки.Найти(ТекРодитель, "Имя", Истина);
			Если НайденныйРодитель = Неопределено Тогда
				Если НЕ НеНайденные.Свойство(ТекРодитель) Тогда
					НеНайденные.Вставить(ТекРодитель, Новый Структура)
				КонецЕсли;
				НеНайденные[ТекРодитель].Вставить(ТекКоманда);
			Иначе
				ЗаполнитьПозициюВстроеннойКоманды(НайденныйРодитель.Строки.Добавить(), ТекКоманда, СтрПолучитьСтроку(ТекПредставление, 2));
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	ЁК = -1;
	Пока ЁК <> НеНайденные.Количество() Цикл
		ЁК = НеНайденные.Количество();
		Для каждого КиЗ Из НеНайденные Цикл
			ТекРодитель = КиЗ.Ключ;
			НайденныйРодитель = Результат.Строки.Найти(ТекРодитель, "Имя", Истина);
			Если НайденныйРодитель <> Неопределено Тогда
				Для каждого КиЗ_ Из КиЗ.Значение Цикл
					ЗаполнитьПозициюВстроеннойКоманды(НайденныйРодитель.Строки.Добавить(), КиЗ_.Ключ);
				КонецЦикла;
				НеНайденные.Удалить(КиЗ.Ключ);
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Если ЧитатьСохранённые Тогда
		СохранённыеКоманды = Новый Массив;//затычка
		Для каждого СохрК Из СохранённыеКоманды Цикл
			РасшифровкаПути = СтрЗаменить(СохрК.Значение.Путь, "$$$", Символы.ПС);
			Уровней = СтрЧислоСтрок(РасшифровкаПути);
			ТекРодитель = НайтиВДеревеКоманд(Результат, РасшифровкаПути, 1, Уровней);
			Если ТекРодитель = Неопределено Тогда
				Сообщить("Неудачная попытка	создания команды " + СохрК.Значение.Имя + "!");
			Иначе
				НоваяКоманда = ДобавитьПозициюДереваКоманд(ТекРодитель, Число(СтрПолучитьСтроку(РасшифровкаПути, Уровней)),
						СохрК.Значение.Имя, СохрК.Значение.Представление, ПолучитьКартинку(СохрК.Значение.Картинка));
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции

#КонецОбласти

#Область ЗАПРОС_И_СКД

//Получает параметры по запросу и дополняет ими таблицу параметров
Процедура ДополнитьПараметрыПоЗапросу(Знач ЗапросИлиЕгоТекст, Параметры_ = Неопределено, МВТ = Неопределено) Экспорт
	Если ТипЗнч(ЗапросИлиЕгоТекст) = Тип("Строка") Тогда
		ЗапросИлиЕгоТекст = СоздатьЗапрос(ЗапросИлиЕгоТекст, Параметры_, МВТ); 
	КонецЕсли; 
	Попытка
		ПараметрыЗапроса = ЗапросИлиЕгоТекст.НайтиПараметры();
	Исключение
		ООш = ОписаниеОшибки();
		Сообщить(ООш);
		Возврат;
	КонецПопытки;
	Если Параметры_ = Неопределено Тогда
		Параметры_ = Новый Структура;
	КонецЕсли;
	Для каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
		ИмяПараметра =  ПараметрЗапроса.Имя;
		Если НЕ Параметры_.Свойство(ИмяПараметра) Тогда
			Параметры_.Вставить(ИмяПараметра, ПараметрЗапроса.ТипЗначения.ПривестиЗначение(Неопределено));
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Формирует запрос по реквизитам обработки
Функция СформироватьЗапрос(Текст = "", Параметры_ = Неопределено, МВТ = Неопределено) Экспорт
	Если ИспользоватьМВТ Тогда
		Если МВТ = Неопределено Тогда
			МВТ = Новый МенеджерВременныхТаблиц;
		КонецЕсли; 
		Запрос_ = СоздатьЗапрос(Текст, ЗаполнитьСтруктуруПараметров(Параметры_), МВТ);
	Иначе	
		Запрос_ = СоздатьЗапрос(Текст, ЗаполнитьСтруктуруПараметров(Параметры_));
	КонецЕсли;
	Возврат Запрос_
КонецФункции // СформироватьЗапрос()
 
// Результат выполнения СКД в ТабДокумент
Процедура СКДвТДнаСервере(ТабДокумент, СКД, НастройкиСКД = Неопределено) Экспорт
	//ТабЗначений = ТаблицаСКД(СКД, СКД.НастройкиПоУмолчанию, Истина);
	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = СКД.НастройкиПоУмолчанию;
	КонецЕсли;
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиСКД,);
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ТабДокумент.Очистить();
	ПроцессорВывода.УстановитьДокумент(ТабДокумент);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
КонецПроцедуры // СКДвТДнаСервере()
	
#КонецОбласти 

#Область ИНИЦИАЛИЗАЦИЯ_И_НАЧАЛЬНЫЕ_ЗНАЧЕНИЯ

// Возвращает стандартные настройки - полный список, где надо заполненные
// Параметры:
//   Настоящий - эта обработка объект - исполнитель серверных методов. Если неопределено (умолч) - автоопределяется.
// Возвращаемое значение:
//   Структура - настройки обработки
Функция СтандартныеКомандныеПанели()
	Результат = Новый ДеревоЗначений;
	Результат.Колонки.Добавить("Картинка", Новый ОписаниеТипов("Картинка"), "Картинка", 4);
	Результат.Колонки.Добавить("Команда", Новый ОписаниеТипов("Строка"), "Команда", 50);
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"), "Имя", 0);
	Результат.Колонки.Добавить("ДопИнф", Новый ОписаниеТипов("Строка"), "ДопИнф", 0);
	Результат.Колонки.Добавить("ХотКей", Новый ОписаниеТипов("Строка"), "ХотКей", 0);
	Результат.Колонки.Добавить("Подсказка", Новый ОписаниеТипов("Строка"), "Подсказка", 0);
	Результат.Колонки.Добавить("ИД_", Новый ОписаниеТипов("Строка"), "ИД", 0);
	Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка"), "Вид", 0);
	Макет = ПолучитьМакет("СтруктураКоманд");
	ЭтоУП = ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение;
	ВсеКартинки = Новый Соответствие;
	ТабИзМакета = ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(Макет, 0, 1, 2,,,, 0,,,,,
			"Если (ИмяКолонки = ""КартинкаОП"" ИЛИ ИмяКолонки = ""КартинкаУП"") И ЗначениеЗаполнено(ИсходноеЗначение) Тогда "
			+ "Результат = ПолучитьКартинку(ИсходноеЗначение) КонецЕсли;"
			+ "Если ИмяКолонки = ""Команда"" И НЕ ЗначениеЗаполнено(ИсходноеЗначение) Тогда Результат = ИмяПеременнойВСтроку(ТекДанные.Имя); КонецЕсли;");
	Если ЭтоУП Тогда
		ТабИзМакета.Колонки.Удалить("КартинкаОП");
		ТабИзМакета.Колонки.КартинкаУП.Имя = "Картинка";
	Иначе
		ТабИзМакета.Колонки.Удалить("КартинкаУП");
		ТабИзМакета.Колонки.КартинкаОП.Имя = "Картинка";
	КонецЕсли;
	ТабИзМакета.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка"), "Вид", 0);
	ТабИзМакета.ЗаполнитьЗначения("В", "Вид");
	ДеревоИзТаблицыЗначений(ТабИзМакета, Результат, "Имя",,"ПАНЕЛИ", "Родитель");
	Возврат Результат
КонецФункции // СтандартныйСписокКоманд

// Возвращает стандартные настройки - полный список, где надо заполненные
// Параметры:
//   Настоящий - эта обработка объект - исполнитель серверных методов. Если неопределено (умолч) - автоопределяется.
// Возврааемое значение:
//   Структура - настройки обработки
Функция СтандартныйСписокНастроек()
	ТипВсеСсылочныеИПростые = ВсеСсылочныеИПростыеТипы();
	Результат = Новый Структура("ДобавленныеТаблицы,ДопТаблица,"
			+ "ЕстьДобавленныеТаблицы,ЕстьДопТаблица,ЕстьМВТ,ЕстьПараметры_,ЕстьПредмет,ЕстьСКД,ЕстьТабДокумент,ЕстьТабЗначений,ЕстьТекстЗапроса,ЕстьТекстКода,ЕстьЧАКО,"
			+ "МВТ,Параметры_,Предмет,СКД,НастройкиСКД,ПерезаписатьТекстЗапроса,ПерезаписатьТекстКода,ТабДокумент,ТабЗначений,ТекстЗапроса,ТекстКода,ЧАКО",
			Новый Массив,
			Новый ТаблицаЗначений,
			Истина,
			Истина,
			Истина,	//ЕстьМВТ
			Истина,
			Истина,
			Истина,	//ЕстьСКД
			Истина,
			Истина,
			Истина,
			Истина,	//ЕстьТекстКода
			Истина,
			Новый Структура("МВТ", Новый МенеджерВременныхТаблиц), //Иначе не лезет в хранилища!!!
			Новый ТаблицаЗначений,
			Неопределено,
			Новый СхемаКомпоновкиДанных,
			Новый НастройкиКомпоновкиДанных,
			Истина,
			Истина,
			Новый ТабличныйДокумент,
			Новый ТаблицаЗначений,
			"",
			"",
			Новый Структура);
	Результат.Параметры_.Колонки.Добавить("ИмяПараметра", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(70, ДопустимаяДлина.Переменная)));
	Результат.Параметры_.Колонки.Добавить("ЗначениеПараметра", ТипВсеСсылочныеИПростые);
	Результат.ДопТаблица.Колонки.Добавить("Ссылка", ТипВсеСсылочныеИПростые);
	Результат.ТабЗначений.Колонки.Добавить("Ссылка", ТипВсеСсылочныеИПростые);
	Результат.ТабДокумент.ОтображатьЗаголовки = Истина;
	Результат.ТабДокумент.Защита = Ложь;
	Возврат Результат
КонецФункции // СтандартныйСписокНастроек

// Возвращает стандартные настройки - полный список, где надо заполненные
// Параметры:
//   Настоящий - эта обработка объект - исполнитель серверных методов. Если неопределено (умолч) - автоопределяется.
// Возвращаемое значение:
//   Структура - настройки обработки
Функция СтандартныйСписокКоманд()
	//Заголовок,ТекстКоманды,ТекстПараметр,Вид,Настройки
	Макет = ПолучитьМакет("Команды_");
	ЭтоУП = ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение;
	ТабИзМакета = ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(Макет,,,,,,, 0);
	Если ЭтоУП Тогда
		Для каждого Строчка Из ТабИзМакета Цикл
			Если Строчка.ТекстКомандыУП = "ОП" Тогда
				Строчка.ТекстКомандыУП = Строчка.ТекстКомандыОП;
			КонецЕсли;
			Если Строчка.ТекстПараметрУП = "ОП" Тогда
				Строчка.ТекстПараметрУП = Строчка.ТекстПараметрОП;
			КонецЕсли;
			Если Строчка.ТекстКомандыОП = "УП" Тогда
				Строчка.ТекстКомандыОП = Строчка.ТекстКомандыУП;
			КонецЕсли;
			Если Строчка.ТекстПараметрОП = "УП" Тогда
				Строчка.ТекстПараметрОП = Строчка.ТекстПараметрУП;
			КонецЕсли;
		КонецЦикла;
		ТабИзМакета.Колонки.Удалить("ТекстКомандыОП");
		ТабИзМакета.Колонки.Удалить("ТекстПараметрОП");
		ТабИзМакета.Колонки.ТекстКомандыУП.Имя = "ТекстКоманды";
		ТабИзМакета.Колонки.ТекстПараметрУП.Имя = "ТекстПараметр";
	Иначе
		Для каждого Строчка Из ТабИзМакета Цикл
			Если Строчка.ТекстКомандыОП = "УП" Тогда
				Строчка.ТекстКомандыОП = Строчка.ТекстКомандыУП;
			КонецЕсли;
			Если Строчка.ТекстКомандыОП = "УП" Тогда
				Строчка.ТекстПараметрОП = Строчка.ТекстПараметрУП;
			КонецЕсли;
		КонецЦикла;
		ТабИзМакета.Колонки.Удалить("ТекстКомандыУП");
		ТабИзМакета.Колонки.Удалить("ТекстПараметрУП");
		ТабИзМакета.Колонки.ТекстКомандыОП.Имя = "ТекстКоманды";
		ТабИзМакета.Колонки.ТекстПараметрОП.Имя = "ТекстПараметр";
	КонецЕсли;
	Результат = СтруктураСтруктурИзТЗ(ТабИзМакета, "Имя");
	Для каждого КиЗ Из Результат Цикл
		КиЗ.Значение.Вставить("Вид", "В");
	КонецЦикла;
	Возврат Результат
КонецФункции // СтандартныйСписокКоманд

#КонецОбласти

#Область КОД_И_КОММЕНТАРИИ
	
Процедура ДополнитьПараметрыПоКоду(Текст_Кода, СПрм)
	ТекПоз = 1;
	ТекСим = "";
	Длина = СтрДлина(Текст_Кода);
	Пока ТекПоз <> 0 Цикл
		Пока ЗначениеЗаполнено(ТекСим) И ТекСим <> ";" Цикл
			ИмяПараметра = ИмяПараметра + ТекСим;
			ТекСим = Сред(Текст_Кода, ТекПоз, 1);
			ТекПоз = ТекПоз + 1;
		КонецЦикла;
		ИмяПараметра = Сред(ИмяПараметра, 2);
		Если ?(ЗначениеЗаполнено(ИмяПараметра), НЕ СПрм.Свойство(ИмяПараметра), Ложь) Тогда
			СПрм.Вставить(ИмяПараметра);
		КонецЕсли;
		Если ТекПоз >= Длина Тогда
			ТекПоз = 0;
		Иначе
			ТекПоз = СтрНайти(ВРег(Текст_Кода), "СПАРАМ.",, ТекПоз) + 7;
			ИмяПараметра = "";
			ТекСим = "!";
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Возвращает имена основных переменных среды обработки
// Возвращаемое значение:
//   Строка   - Имена через запятую
Функция ИменаОсновныхПеременных()
	Результат = "Алгоритмы,ДопТаблица,Запрос_,НастройкиСКД,Предмет,СКД,СПарам,ТабДокумент,ТабЗначений";
	Возврат Результат
КонецФункции // ИменаОсновныхПеременных

// Возвращает закомметированный/раскомментированный текст
// Параметры:
//  Текст_  - Строка - Комментируемый текст
//  Раскомментировать  - Булево - при истине удаляет комментарий
// Возвращаемое значение:
//   Строка   - Закомметированный или раскомментированный текст
Функция Комментарий(Текст_, Закомментировать = Истина) Экспорт
	Результат = "";
	Если Закомментировать Тогда
		Для СчСтр = 1 По СтрЧислоСтрок(Текст_) Цикл
			Результат = Результат + "//" + СтрПолучитьСтроку(Текст_, СчСтр) + Символы.ПС;
		КонецЦикла; 
	Иначе
		Для СчСтр = 1 По СтрЧислоСтрок(Текст_) Цикл
			ТекКод = СтрПолучитьСтроку(Текст_, СчСтр);
			ПозК = СтрНайти(ТекКод, "//");
			Если ПозК = 0 Тогда
				Результат = Результат + ТекКод + Символы.ПС;
			Иначе
				Префикс = Лев(ТекКод, ПозК - 1);
				Результат = Результат + ?(ПустаяСтрока(Префикс), Префикс + Сред(ТекКод, ПозК + 2), ТекКод) + Символы.ПС;
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // Комментарий

// Готовит Массив для выполнения кода из текста кода, полученного из формы
// Параметры:
//  ИсходныйТекст  - Строка - Текст кода к преобразованию. Кроме исполняемого кода может содержать префиксы
//	"&Форма", "&Клиент", "&Сервер", "&Объект" и "&Алгоритм[ИмяАлгоритма[Символы.ПС]]"
//  ГдеВыполнятьУмолчание  - Строка - Какой префикс использовать для кода от начала до первого префикса
// Возвращаемое значение:
//   	Массив   - структур с полями "Тип" = Форма (Код, выполняемый в обычной форме или в управляемой на клиенте), Клиент(выполняемый в отдельной форме на клиенте),
//			Сервер (выполняемый в УФ на сервере) и Объект (выполняемый в модуле обработки), и "Код".
//			Нулевой элемент всегда содержит структуру Алгоритмы - структура с именами алгоритмов в ключах и текстами в значениях
Функция РазобратьТекстКода(ИсходныйТекст, ГдеВыполнятьУмолчание = "Объект") Экспорт
	ВремТекст = ИсходныйТекст;
	#Область КЛЮЧИ_ПРМ_ДОБАВИТЬ_УДАЛИТЬ
		Для ЯХУ = 1 По 2 Цикл
			Пока Истина Цикл
				ПозПрм = СтрНайти(ВремТекст, "//#ПРМ" + ?(ЯХУ = 1, "+", "-"));
				Длина_ = СтрДлина(ВремТекст);
				Если ПозПрм = 0 Тогда
					Прервать;
				Иначе
					Поз1 = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "#С=",, ПозПрм + 7), 0, Длина_ + 1);
					Поз2 = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "#К=",, ПозПрм + 7), 0, Длина_ + 1);
					Поз3 = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, ";",, ПозПрм + 7), 0, Длина_ + 1);
					Поз4 = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, Символы.ПС,, ПозПрм + 7), 0, Длина_ + 1);
					ИмяСтруктуры = ?(Поз1 >= Поз3 ИЛИ Поз1 >= Поз4, "Прм", СокрЛП(Сред(ВремТекст, Поз1 + 3, ?(Поз2 > Поз1, Мин(Поз2, Поз3, Поз4), Мин(Поз3, Поз4)))));
					ИменаКлючей = ?(Поз2 >= Поз3 ИЛИ Поз2 >= Поз4, "", СокрЛП(Сред(ВремТекст, Поз2 + 3, ?(Поз1 > Поз2, Мин(Поз1, Поз3, Поз4), Мин(Поз3, Поз4)))));
					Если ЯХУ = 1 И Лев(ИмяСтруктуры, 1) = "+" Тогда
						СоздатьСтруктуру = Истина;
						ИмяСтруктуры = СокрЛП(Сред(ИмяСтруктуры, 2));
					Иначе
						СоздатьСтруктуру = Ложь;
					КонецЕсли;
					ИменаПараметр = ИменаОсновныхПеременных() + ?(ИменаКлючей = "", "", "," + ИменаКлючей);
					ВремТекст = Лев(ВремТекст, ПозПрм - 1)
						+ ?(ЯХУ = 1,
							КодДобавленияПараметровВСтруктуру(
								ИменаПараметр,
								ИмяСтруктуры,
								СоздатьСтруктуру),
							КодВосстановленияПараметровИзСтруктуры(
								ИменаПараметр,
								ИмяСтруктуры))
						+ ?(Поз3 > Поз4, Сред(ВремТекст, Поз4), Сред(ВремТекст, Поз3 + 1));
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	#КонецОбласти
	ПозС = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Сервер") - 1, - 1, Длина_);
	ПозО = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Объект") - 1, - 1, Длина_);
	ПозФ = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Форма") - 1, - 1, Длина_);
	ПозА = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Алгоритм") - 1, - 1, Длина_);
	ПозК = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Клиент") - 1, - 1, Длина_);
	//Результат = Новый Структура("Сервер,Объект,Форма,Алгоритмы", "", "", "", Новый Структура);
	Результат = Новый Массив;
	Результат.Добавить(Новый Структура);
	Урезать = 1;
	ТипКода = ГдеВыполнятьУмолчание;
	ИмяАлгоритма = "Ошибка";
	Пока Истина Цикл
		Урезать = Мин(ПозС, ПозО, ПозФ, ПозА, ПозК);
		Если Урезать < 0 Тогда
			Прервать;
		КонецЕсли;
		ТекКод = Лев(ВремТекст, Урезать);
		Если ТипКода = "Алгоритм" Тогда
			Результат[0].Вставить(ИмяАлгоритма, ТекКод);
		ИначеЕсли ЗначениеЗаполнено(ТекКод) Тогда
			Результат.Добавить(Новый Структура("Тип,Код", ТипКода, ТекКод));
		КонецЕсли; 
		Если СтрДлина(ВремТекст) = Урезать Тогда
			ТипКода = ГдеВыполнятьУмолчание;
		ИначеЕсли ПозС = Урезать Тогда
			ТипКода = "Сервер";
		ИначеЕсли ПозО = Урезать Тогда
			ТипКода = "Объект";
		ИначеЕсли ПозФ = Урезать Тогда
			ТипКода = "Форма";
		ИначеЕсли ПозА = Урезать Тогда
			ТипКода = "Алгоритм";
		ИначеЕсли ПозК = Урезать Тогда
			ТипКода = "Клиент";
		Иначе
			ТипКода = "Объект";
		КонецЕсли;
		Урезать = Урезать + СтрДлина(ТипКода) + 1;
		ВремТекст = Сред(ВремТекст, Урезать + 1);
		ДлинаИмени = -1;
		Если ТипКода = "Алгоритм" Тогда
			ИмяАлгоритма = СтрПолучитьСтроку(ВремТекст, 1);
			ДлинаИмени = СтрДлина(ИмяАлгоритма);
			ВремТекст = Сред(ВремТекст, ДлинаИмени + 2);
			ИмяАлгоритма = СокрЛП(ИмяАлгоритма);
		КонецЕсли;
		Урезать = Урезать + ДлинаИмени + 1;
		ПозС = ?(ТипКода = "Сервер", ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Сервер") - 1, - 1, Длина_), ПозС - Урезать);
		ПозО = ?(ТипКода = "Объект", ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Объект") - 1, - 1, Длина_), ПозО - Урезать);
		ПозФ = ?(ТипКода = "Форма", ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Форма") - 1, - 1, Длина_), ПозФ - Урезать);
		ПозА = ?(ТипКода = "Алгоритм", ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Алгоритм") - 1, - 1, Длина_), ПозА - Урезать);
		ПозК = ?(ТипКода = "Клиент", ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрНайти(ВремТекст, "&Клиент") - 1, - 1, Длина_), ПозК - Урезать);
	КонецЦикла;
	Возврат Результат
КонецФункции // РазобратьТекстКода()

#КонецОбласти 

#Область ОБЩЕЕ_ХРАНИЛИЩЕ
	
// Дополняет дерево из массива структур. Обратный процесс см. ЗаписатьВХранилище
// Параметры:
//  Приёмник  - ДеревоЗначений - Дерево меню. Колонки см. СтандартныеКомандныеПанели
//  Источник  - массив структур - у структур реквизиты совпадают с колонками дерева,
//			кроме Картинка (в дереве) против КартинкаОП, КартинкаУП и ИДСтрокиРодителя в источнике.
//			Добавленные в приёмник элементы удаляются из источника.
Процедура Дополнить_Дерево_Из_Сохранёнки(Приёмник, Источник)
	ОграничениеЦиклов = 12;
	ЭтоУП = ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение;
	Пока ОграничениеЦиклов > 0 и Источник.Количество() Цикл
		ОграничениеЦиклов = ОграничениеЦиклов - 1;
		ВГраница = Источник.ВГраница();
		Найдено = 0;
		Для ЁХХ = 0 По ВГраница Цикл
			стрЭлемент = Источник[ЁХХ - Найдено];
			СтрокаНазначение = Приёмник.Строки.Найти(стрЭлемент.ИД_, "ИД_", Истина);
			Если СтрокаНазначение = Неопределено Тогда
				Если ЗначениеЗаполнено(стрЭлемент.ИДСтрокиРодителя) Тогда
					Родитель_ = Приёмник.Строки.Найти(стрЭлемент.ИДСтрокиРодителя, "ИД_", Истина);
				Иначе
					Родитель_ = Приёмник;
				КонецЕсли;
				Если Родитель_ = Неопределено Тогда
				Иначе
					ИДПередКем_Вставить = "";
					стрЭлемент.Свойство("ИДПередКемВставить", ИДПередКем_Вставить);
					Если ЗначениеЗаполнено(ИДПередКем_Вставить) Тогда
						СтрокаДЗПередКоторойВставить = Родитель_.Строки.Найти(ИДПередКем_Вставить, "ИД_");
						Если СтрокаДЗПередКоторойВставить = Неопределено Тогда
							СтрокаНазначение = Родитель_.Строки.Вставить(0);
						Иначе
							СтрокаНазначение = Родитель_.Строки.Вставить(Родитель_.Строки.Индекс(СтрокаДЗПередКоторойВставить));
						КонецЕсли;
					Иначе
						СтрокаНазначение = Родитель_.Строки.Добавить();
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтрокаНазначение <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(СтрокаНазначение, стрЭлемент);
				СтрокаНазначение.Картинка = ?(ЭтоУП, стрЭлемент.КартинкаУП, стрЭлемент.КартинкаОП);
				Источник.Удалить(ЁХХ - Найдено);
				Найдено = Найдено + 1;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Для каждого СтрЭлемент Из Источник Цикл
		Сообщить("При формировании меню из настроек не найден родитель " + стрЭлемент.ИДСтрокиРодителя);
	КонецЦикла;
КонецПроцедуры // Дополнить_Дерево_Из_Сохранёнки

//Записывает меню и команды в общее хранилище. Обратное действие см. Дополнить_Дерево_Из_Сохранёнки для меню и для команд библиотечная ДополнитьСтруктуру
//Если указан только источник - возвращает подготовленный к записи объект данных
Функция ЗаписатьВХранилище(ЧтоПишем, ИмяНастроек = "", ТолькоДляМеня = Истина, НастройкиКоманд = Ложь)
	ТекВид = ?(ТолькоДляМеня, "П", "О");
	Если ТипЗнч(ЧтоПишем) = Тип("ДеревоЗначений") Тогда
		#Область МЕНЮ
			КЗаписи = Новый Массив;
			ЭтоУП = ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.УправляемоеПриложение;
			Ключи = СтрЗаменить(Список_Колонок(ЧтоПишем), "Картинка", "КартинкаОП,КартинкаУП,ИДСтрокиРодителя,ИДПередКемВставить");
			КСохранению = ЧтоПишем.Строки.НайтиСтроки(Новый Структура("Вид", ТекВид), Истина);
			Для каждого СтрокаДЗ Из КСохранению Цикл
				Приёмник = Новый Структура(Ключи);
				ЗаполнитьЗначенияСвойств(Приёмник, СтрокаДЗ);
				Если ЭтоУП Тогда
					Приёмник.КартинкаОП = "";
					Приёмник.КартинкаУП = СтрокаДЗ.Картинка;
				Иначе
					Приёмник.КартинкаУП = "";
					Приёмник.КартинкаОП = СтрокаДЗ.Картинка;
				КонецЕсли;
				ТекРодитель = СтрокаДЗ.Родитель;
				Если ТекРодитель = Неопределено Тогда
					Приёмник.ИДСтрокиРодителя = "";
					ТекРодитель = СтрокаДЗ.Владелец();
				Иначе
					Приёмник.ИДСтрокиРодителя = ТекРодитель.ИД_;
				КонецЕсли;
				ТекИндекс = ТекРодитель.Строки.Индекс(СтрокаДЗ);
				Приёмник.ИДПередКемВставить = ?(ТекИндекс = ТекРодитель.Строки.Количество() - 1, "", ТекРодитель.Строки[ТекИндекс + 1].ИД_);
				КЗаписи.Добавить(Приёмник);
			КонецЦикла;
		#КонецОбласти
	ИначеЕсли ТипЗнч(ЧтоПишем) = Тип("Структура") Тогда
		#Область КОМАНДЫ
			//Это команды - надо фильтрануть только пользовательские - мои или общие
			КЗаписи = Новый Структура;
			Имя_Пользователя = ИмяПользователя();
			Для каждого КиЗ Из ЧтоПишем Цикл
				Если КиЗ.Значение.Вид = ТекВид Тогда
					стрЭлемент = Новый Структура;
					Для каждого КиЗ_1 Из КиЗ.Значение Цикл
						Если КиЗ_1.Ключ = "ТекстПараметр" ИЛИ КиЗ_1.Ключ = "ТекстКоманды" Тогда
						Иначе
							стрЭлемент.Вставить(КиЗ_1.Ключ, КиЗ_1.Значение);
						КонецЕсли;
					КонецЦикла;
					стрЭлемент.Вставить("ТекстКомандыУП", "");
					стрЭлемент.Вставить("ТекстКомандыОП", "");
					стрЭлемент.Вставить("ТекстПараметрУП", "");
					стрЭлемент.Вставить("ТекстПараметрОП", "");
					Если НастройкиКоманд Тогда
						СтруктураНастроек = ХранилищеОбщихНастроек.Загрузить("КонсольДанных_____", "Команда___" + КиЗ.Ключ,, ?(КиЗ.Значение.Вид = "О", "Общие", Имя_Пользователя));
						Если ЗначениеЗаполнено(СтруктураНастроек) Тогда
							стрЭлемент.Вставить("СтруктураНастроек", СтруктураНастроек);
						КонецЕсли;
					КонецЕсли;
					КЗаписи.Вставить(КиЗ.Ключ, стрЭлемент);
				КонецЕсли;
			КонецЦикла;
		#КонецОбласти
	КонецЕсли;
	Если ИмяНастроек = "" Тогда
		Возврат КЗаписи
	Иначе
		ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", ИмяНастроек, КЗаписи, ?(ТолькоДляМеня, ИмяПользователя(), "Общие"));
		Возврат ИмяНастроек
	КонецЕсли;
КонецФункции

#КонецОбласти

//Заполняет структуру параметров из таблицы-реквизита
Функция ЗаполнитьСтруктуруПараметров(Параметры_ = Неопределено,
		ТабЗначений = Неопределено,
		ДопТаблица = Неопределено,
		Предмет = Неопределено) Экспорт
	СПарам = Новый Структура();
	Если ЗначениеЗаполнено(Параметры_) Тогда
		Для Каждого Строчка Из Параметры_ Цикл
			ПопыТка
				Если Строчка.ЗначениеПараметра = "&ТабЗначений" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, ТабЗначений);
				ИначеЕсли Строчка.ЗначениеПараметра = "&ДопТаблица" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, ДопТаблица);
				ИначеЕсли Строчка.ЗначениеПараметра = "&Предмет" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, Предмет);
				ИначеЕсли Лев(Строчка.ЗначениеПараметра, 4) = "&Код" Тогда
					СПарам.Вставить(Строчка.ИмяПараметра, Вычислить(Сред(Строчка.ЗначениеПараметра, 5)));
				ИначеЕсли Лев(Строчка.ЗначениеПараметра, 11) = "Результат =" Тогда
					Результат = Неопределено;
					Выполнить(Строчка.ЗначениеПараметра);
					СПарам.Вставить(Строчка.ИмяПараметра, Результат);
				Иначе
					СПарам.Вставить(Строчка.ИмяПараметра, Строчка.ЗначениеПараметра)
				КонецЕсли
			Исключение
			КонецПопытки
		КонецЦикла;
	КонецЕсли;
	Возврат СПарам;
КонецФункции

Функция КартинкаИзМакета(ИмяКартинки)
	Макет = ПолучитьМакет("КоллекцияКартинок");
	Попытка
		Возврат Макет.Рисунки[ИмяКартинки].Картинка;
	Исключение
		Возврат Новый Картинка
	КонецПопытки;
КонецФункции // КартинкаИзМакета()

//Находит минимальное свободное значение ИД
Функция НовыйИД(ДеревоМеню, Подвызов = Ложь)
	МинИд = "А0000";
	Для каждого СтрокаДЗ Из ДеревоМеню.Строки Цикл
		МинИД = Макс(СтрокаДЗ.ИД_, НовыйИД(СтрокаДЗ, Истина), МинИД);
	КонецЦикла;
	Возврат ?(Подвызов, МинИД, "А" + Прав("0000" + (1 + Число(Прав(МинИД, 4))), 4));
КонецФункции

// Готовит полную структуру настроек к сохранению.
// Параметры:
//  ПараметрыСохранения  - Структура - Источник данных для сохранения. Ключи:
// Возвращаемое значение:
//   Структура   - Готовые к сохранеию полные или неполные настройки
Функция ПодготовитьСохраняемыеНастройки(ПараметрыСохранения)
	ЭтиНастройки = СтандартныйСписокНастроек();
	ЭтиНастройки.Вставить("ЕстьДобавленныеТаблицы", Ложь); //Не реализованы
	ЭтиНастройки.Вставить("ЕстьДопТаблица", ПараметрыСохранения.СохранитьТаб2);
	ЭтиНастройки.Вставить("ЕстьМВТ", Ложь); //Ну не сохраняется он - это что-то вроде COMобъекта
	ЭтиНастройки.Вставить("ЕстьПараметры_", ПараметрыСохранения.СохранитьПараметры);
	ЭтиНастройки.Вставить("ЕстьПредмет", ПараметрыСохранения.СохранитьПредмет);
	ЭтиНастройки.Вставить("ЕстьСКД", ПараметрыСохранения.СохранитьСКД);
	ЭтиНастройки.Вставить("ЕстьТабДокумент", ПараметрыСохранения.СохранитьТД);
	ЭтиНастройки.Вставить("ЕстьТабЗначений", ПараметрыСохранения.СохранитьТаб1);
	ЭтиНастройки.Вставить("ЕстьТекстЗапроса", ПараметрыСохранения.СохранитьТекстЗапроса);
	ЭтиНастройки.Вставить("ЕстьТекстКода", ПараметрыСохранения.СохранитьТекстКода);
	ЭтиНастройки.Вставить("ЕстьЧАКО", ?(ПараметрыСохранения.Свойство("СохранитьЧАКО"), ПараметрыСохранения.СохранитьЧАКО, Ложь)); //ЧАКО не надо сохранять
	ЭтиНастройки.Вставить("ПерезаписатьТекстЗапроса", ПараметрыСохранения.ПерезаписатьТекстЗапроса);
	ЭтиНастройки.Вставить("ПерезаписатьТекстКода", ПараметрыСохранения.ПерезаписатьТекстКода);
	ЭтиНастройки.Удалить("МВТ");//Только мешается, толку не будет
	Если ЭтиНастройки.ЕстьДопТаблица Тогда
		ЭтиНастройки.Вставить("ДопТаблица", ПараметрыСохранения.ДопТаблица);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьПараметры_ Тогда
		ЭтиНастройки.Вставить("Параметры_",ПараметрыСохранения. Параметры_);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьПредмет Тогда
		ЭтиНастройки.Вставить("Предмет", ПараметрыСохранения.Предмет);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьСКД Тогда
		ЭтиНастройки.Вставить("СКД", ПараметрыСохранения.СКД);
		ЭтиНастройки.Вставить("НастройкиСКД", ПараметрыСохранения.НастройкиСКД);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьТабДокумент Тогда
		ЭтиНастройки.Вставить("ТабДокумент", ПараметрыСохранения.ТабДокумент);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьТабЗначений Тогда
		ЭтиНастройки.Вставить("ТабЗначений", ПараметрыСохранения.ТабЗначений);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьТекстЗапроса Тогда
		ЭтиНастройки.Вставить("ТекстЗапроса", ПараметрыСохранения.ТекстЗапроса);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьТекстКода Тогда
		ЭтиНастройки.Вставить("ТекстКода", ПараметрыСохранения.ТекстКода);
	КонецЕсли;
	Если ЭтиНастройки.ЕстьЧАКО Тогда
		ЭтиНастройки.Вставить("НастройкиЧАКО", ПараметрыСохранения.НастройкиЧАКО);
	КонецЕсли;
	//Это сохраняется в корне
	//Если ПараметрыСохранения.Свойство("Имена_Настроек") Тогда
	//	ЭтиНастройки.Вставить("Имена_Настроек", ПараметрыСохранения.Имена_Настроек);
	//КонецЕсли;
	//Если ПараметрыСохранения.Свойство("ИнтервалАвтосохраненияВСекундах") Тогда
	//	ЭтиНастройки.Вставить("ИнтервалАвтосохраненияВСекундах", ПараметрыСохранения.ИнтервалАвтосохраненияВСекундах);
	//КонецЕсли;
	ЕстьКоманды = ЧтСтрукт(ПараметрыСохранения, "СохранитьКоманды", Ложь);
	ЕстьМеню = ЧтСтрукт(ПараметрыСохранения, "СохранитьМеню", Ложь);
	ЕстьИАС = ПараметрыСохранения.Свойство("ИнтервалАвтосохраненияВСекундах");
	ЕстьИмена = ПараметрыСохранения.Свойство("Имена_Настроек");
	Если ЕстьКоманды ИЛИ ЕстьМеню ИЛИ ЕстьИмена ИЛИ ЕстьИАС Тогда
		Результат = Новый Структура("Команды,Меню,Настройки,ИнтервалАвтосохранения,ИменаНастроек",
				?(ЕстьКоманды, ЗаписатьВХранилище(ПараметрыСохранения.КомандыСписок), Неопределено),
				?(ЕстьМеню, ЗаписатьВХранилище(ПолучитьИзВременногоХранилища(ПараметрыСохранения.АдресДереваМеню)), Неопределено),
				ЭтиНастройки,
				?(ЕстьИАС, ПараметрыСохранения.ИнтервалАвтосохраненияВСекундах, Неопределено),
				?(ЕстьИмена, ПараметрыСохранения.Имена_Настроек, Неопределено));
	Иначе
		Результат = ЭтиНастройки;
	КонецЕсли;
	Возврат Результат
КонецФункции // ПодготовитьСохраняемыеНастройки

// Сохраняет настройки или готовит двоичные данные для сохранения в файл
// Параметры:
//  ИмяНастройкиИлиАдрес  - Строка - Имя настроек или адрес размещения двоичных данных в хранилище
//  СохраняемыеНастройки  - Структура - Параметры сохранения или готовые настройки
//  УжеГотовы  - Булево - Второй параметр = уже готовые настройки. По умолчанию Ложь = надо готовить
//  ВХранилищеОбщих  - Булево - Первый параметр = имя настройки. По умолчанию Истина. Ложь = в первом параметре адрес временного хранилища
//  Имя__Пользователя  - Строка - Имя пользователя, кому сохранять настройки. По умолчанию "" = текущий
// Возвращаемое значение:
//   Строка   - Текст ошибки
Функция ПодготовитьИСохранитьНастройки(ИмяНастройкиИлиАдрес, СохраняемыеНастройки,  УжеГотовы = Ложь, ВХранилищеОбщих = Истина, Имя__Пользователя = "")
	Результат = "";
	#Область ДОБАВЛЕНИЕ_НАСТРОЙКИ_В_СПИСОК
		//Если ВХранилищеОбщих И ИмяНастройкиИлиАдрес <> "#Текущие" Тогда
		//	ПриёмникСписка = ?(СохраняемыеНастройки.Свойство("Настройки"), СохраняемыеНастройки.Настройки, 
		//	Если СохраняемыеНастройки.Свойство("Настройки") Тогда
		//		Если СохраняемыеНастройки.Настройки.Свойство("ИменаНастроек") Тогда
		//			СписокПриёмник = СохраняемыеНастройки.Настройки.ИменаНастроек;
		//		Иначе
		//			СписокПриёмник = Новый СписокЗначений;
		//			СохраняемыеНастройки.Настройки.Вставить("ИменаНастроек", СписокПриёмник);
		//		КонецЕсли;
		//	ИначеЕсли СохраняемыеНастройки.Свойство("ЕстьТабЗначений") Тогда
		//		Если СохраняемыеНастройки.Свойство("ИменаНастроек") Тогда
		//			СписокПриёмник = СохраняемыеНастройки.Настройки.ИменаНастроек;
		//		Иначе
		//			СписокПриёмник = Новый СписокЗначений;
		//			СохраняемыеНастройки.Вставить("ИменаНастроек", СписокПриёмник);
		//		КонецЕсли;
		//	Иначе
		//		СписокПриёмник = Новый СписокЗначений;
		//		НовыеНастройки = Новый Структура("ИменаНастроек", СписокПриёмник);
		//		СохраняемыеНастройки.Вставить("Настройки", НовыеНастройки);
		//	КонецЕсли;
		//КонецЕсли;
		//СписокПриёмник.Добавить(ИмяНастройкиИлиАдрес, ИмяНастройкиИлиАдрес);
	#КонецОбласти
	КСохранению = ?(УжеГотовы, СохраняемыеНастройки, ПодготовитьСохраняемыеНастройки(СохраняемыеНастройки));
	Если ВХранилищеОбщих Тогда
		Имя_Пользователя = ?(Имя__Пользователя = "", ИмяПользователя(), Имя__Пользователя);
		Если ИмяНастройкиИлиАдрес = "#Текущие" Тогда
			Если КСохранению.Свойство("Настройки") И КСохранению.Настройки <> Неопределено Тогда
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Настройки", КСохранению.Настройки,, Имя_Пользователя);
			КонецЕсли;
			Если КСохранению.Свойство("Меню") И КСохранению.Меню <> Неопределено Тогда
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Меню", КСохранению.Меню,, Имя_Пользователя);
			КонецЕсли;
			Если КСохранению.Свойство("Команды") И КСохранению.Команды <> Неопределено Тогда
				#Область НАСТРОЙКИ_КОМАНД
					Для каждого КиЗ Из КСохранению.Команды Цикл
						
					КонецЦикла;
				#КонецОбласти
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Команды", КСохранению.Команды,, Имя_Пользователя);
			КонецЕсли;
			Если КСохранению.Свойство("ИнтервалАвтосохранения") И КСохранению.ИнтервалАвтосохранения <> Неопределено Тогда
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "ИнтервалАвтосохранения", КСохранению.ИнтервалАвтосохранения,, Имя_Пользователя);
			КонецЕсли;
			Если КСохранению.Свойство("ИменаНастроек") И КСохранению.ИменаНастроек <> Неопределено Тогда
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "ИменаНастроек", КСохранению.ИменаНастроек,, Имя_Пользователя);
			КонецЕсли;
			Если КСохранению.Свойство("ЕстьТабЗначений") Тогда //Это только настройки
				ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", "Настройки", КСохранению,, Имя_Пользователя);
			КонецЕсли;
		Иначе
			ХранилищеОбщихНастроек.Сохранить("КонсольДанных_____", ИмяНастройкиИлиАдрес, КСохранению,, Имя_Пользователя);
		КонецЕсли;
	Иначе
		Записулька = Новый ЗаписьXML;
		Записулька.УстановитьСтроку();
		СериализаторXDTO.ЗаписатьXML(Записулька, КСохранению);
		ТекстXML = Записулька.Закрыть();
		Дэдэшка = ПолучитьДвоичныеДанныеИзСтроки(ТекстXML);
		ПоместитьВоВременноеХранилище(Дэдэшка, ИмяНастройкиИлиАдрес);
	КонецЕсли;
	Возврат Результат
КонецФункции // ПодготовитьИСохранитьНастройки

Функция СписокДиректив()
	Результат = Новый СписокЗначений;
	Результат.Добавить("&Сервер", "В этой форме на сервере");
	Результат.Добавить("&Объект", "В модуле обработки");
	Результат.Добавить("&Форма", "В этой форме на клиенте");
	Результат.Добавить("&Алгоритм ИМЯ", "Обособленный алгоритм для вызова");
	Результат.Добавить("&Клиент", "В отдельной форме с библиотеками на клиенте");
	Результат.Добавить("//#ПОЗ+#С=[+]ИмяСтруктуры#К=ИмяПараметраКромеСтандартных1,ИмяПараметраКромеСтандартныхN;" + Символы.ПС, "Добавление параметров в структуру");
	Результат.Добавить("//#ПОЗ-#С=ИмяСтруктуры#К=ИмяПараметраКромеСтандартных1,ИмяПараметраКромеСтандартныхN;" + Символы.ПС, "Восстановление параметров из структуры");
	Возврат Результат
КонецФункции

#КонецОбласти 

//ДОБАВИТЬ ФУНКЦИИ ПОИСКА ССЫЛОК, ЗАМЕНЫ, ОТКРЫТИЯ РЕКВИЗИТОВ ОБЪЕКТА (ШАПКА В ОСНОВНОЙ, А ТЧ В ДОП ТАБЛИЦЕ), удаления объекта/списка

#Область БИБЛИОТЕКИ

#Область БИБЛИОТЕКА_ФУНКЦИЙ_ВС

#Область ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//	ТекстКодаПараметр - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//	ПрямоеОбращение - Строка, Массив - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//			"-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//	Журнал - Булево - Выполнять в попытке и ошибку записать в журнал
//	ИмяПроцесса - Строка - Параметр записи журнала
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке.
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКодНаСервере(
		ТекстКодаПараметр,
		Прм = Неопределено,
		Результат = Неопределено,
		РежимВычисления = Ложь,
		ПрямоеОбращение = "-В",
		Журнал = Ложь,
		ИмяПроцесса = "",
		ПрефиксОшибки = "") Экспорт
	Результат_ = Результат;
	#Область ЗАЩИТА
		//Предполагается, что обычным пользователям доступ к выполнению функции ограничен, так как иначе УстановитьПривилегированныйРежим, и всё доступно.
		//А вот от легального входа ограниченного пользователя внешним соединением с последующим запуском этой функции нужна защита.
		//Специальная роль (которой можно и не делать) ИЛИ Запуск тонкого/толстого клиента ИЛИ Фоновое задание без пользователя.
		//Хотя внешнее соединение тоже может запустить реглзадание, и тут пока нет защиты, хотя ВС должен быть админом для запуска РЗ.
		Попытка
			МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
		Исключение
			МожноВычислять = Ложь;
		КонецПопытки;
		Если ТекущийРежимЗапуска() <> Неопределено ИЛИ
				ИмяПользователя() = "" Тогда
			МожноВычислять = Истина;
		Иначе
			Попытка
				МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
			Исключение
				МожноВычислять = Ложь;
			КонецПопытки;
		КонецЕсли;
	#КонецОбласти
	Если МожноВычислять Тогда
		Результат_ = ВОЛНА_ОбщегоНазначенияКС.ВыполнитьКод(ТекстКодаПараметр, Прм, Результат, РежимВычисления, ПрямоеОбращение, Журнал, ИмяПроцесса, ПрефиксОшибки)
	КонецЕсли;
	Возврат Результат_
КонецФункции

#Конецобласти

#Область КОЛЛЕКЦИИ

#Область ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
	
// В таблице значений заменяет пустые значения на значения по умолчанию из структуры
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Произвольная
//  ЗначенияПоУмолчанию  - Структура - Ключи совпадают с именами колонок, где будет замена. Значения - новые значения.
//	ПрефиксФормулы - значение, начинающееся с этой строки, считается формулой. Обращение к данным строки - Строчка.
Процедура ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию(ТабЗн, ЗначенияПоУмолчанию, ПрефиксФормулы = "FRML") Экспорт
	ДлинаПрефикса = СтрДлина(ПрефиксФормулы);
	Для каждого Строчка Из ТабЗн Цикл
		Для каждого КиЗ Из ЗначенияПоУмолчанию Цикл
			Если НЕ ЗначениеЗаполнено(Строчка[КиЗ.Ключ]) Тогда
				Строчка[КиЗ.Ключ] = ?(Лев(КиЗ.Значение, ДлинаПрефикса) = ПрефиксФормулы, Вычислить(Сред(КиЗ.Значение, ДлинаПрефикса + 1)), КиЗ.Значение);
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
КонецПроцедуры // ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию()

#КонецОбласти 

#КонецОбласти

#КонецОбласти

#Область МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
	
// Запускает менеджер (обработчик) реквизита или события.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"Т:" (рус) - строка,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Имя реквизита, по которому вести распознавание.
//  Родитель  - Родитель, внутри которого вести распознавание.
//  Владелец  - Владелец, внутри которого вести распознавание.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция РассчитатьМенеджерНаСервере(
		Менеджер,
		ПараметрыМенеджера = Неопределено,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		СообщатьСюда = Неопределено) Экспорт
	ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	ЕстьДопИнструменты = ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.ЕстьДопОбработки();
	ТипМенеджера = ТипЗнч(Менеджер);
	Результат = Менеджер;
	ТекстКода = "";
	Распознать = "";
	Если ПараметрыМенеджера = Неопределено Тогда
		ПараметрыМенеджера = Новый Структура; 
	КонецЕсли; 
	
	Если ТипМенеджера = Тип("Строка") Тогда
		//Это строка
		ТекПрефикс = Лев(Менеджер, 2);
		Если ТекПрефикс = "Т:" Тогда
			Результат = Сред(Менеджер, 3);//Получить строку без лишних заморочек
		ИначеЕсли Лев(Менеджер, 11) = "Результат =" Тогда
			ТекстКода = Менеджер;
		ИначеЕсли ТекПрефикс = "F:" Тогда
			ИмяФайла = Сред(Менеджер, 3);
			Результат = ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		ИначеЕсли ТекПрефикс = "В:" Тогда
			Результат = ВыполнитьКод(СтрЗаменить(Сред(Менеджер, 3), Символ(10), " "), ПараметрыМенеджера,, Истина);
		ИначеЕсли ТекПрефикс = "Р:" Тогда
			Распознать = Сред(Менеджер, 3); 
		Иначе
			ПрогКод = СтрЗаменить(Менеджер, Символ(10), " ");
			Попытка
				Результат = ВыполнитьКод(ПрогКод, ПараметрыМенеджера,, Истина);
			Исключение
				Распознать = Менеджер;
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьПП, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаПП), Неопределено) Тогда
		//Это ПП
		ТекстКода = "Результат = Справочники.ВОЛНА_ПереопределяемыеПроцедуры.ВычислитьФункцию(Менеджер,, ПараметрыМенеджера,
				|?(ПараметрыМенеджера.Свойство(""ПолучитьСКД""), ПараметрыМенеджера.ПолучитьСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьНастройкиСКД""), ПараметрыМенеджера.ПолучитьНастройкиСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьПараметры""), ПараметрыМенеджера.ПолучитьПараметры, Ложь));"
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьВО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаВО), Неопределено) Тогда
		//Это ВО
		Если БезопасныйРежим() Тогда
			Результат = Неопределено;
			ДобавитьОшибку(ПараметрыМенеджера, "В безопасном режиме нельзя прочитать временный файл и запустить внешнюю обработку!");
		Иначе
			ТекстКода = "ЭтоОбработка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Менеджер, ""ВидОбработки"") = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
					|Если ЭтоОбработка Тогда
					|	Попытка
					|		ИмяФайла = ПолучитьИмяВременногоФайла();
					|		ДвоичныеДанные = Менеджер.ХранилищеВнешнейОбработки.Получить();
					|		ДвоичныеДанные.Записать(ИмяФайла);
					|		Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, ПараметрыМенеджера);
					|	Исключение
					|		ООШ = ОписаниеОшибки();
					|		ДобавитьОшибку(ПараметрыМенеджера, ООШ);
					|		Результат = Менеджер;
					|	КонецПопытки;
					|КонецЕсли;"
		КонецЕсли; 
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьДО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаДО), Неопределено) Тогда
		//Это ДО
		ТекстКода = "ПараметрыКоманды = Новый Структура(""ДополнительнаяОбработкаСсылка,ИдентификаторКоманды,ОбъектыНазначения"",
				|		Менеджер, ?(ПараметрыМенеджера.Свойство(""ИмяКоманды""), ПараметрыМенеджера.ИмяКоманды, ""ЗапуститьМенеджер""),
				|		?(ПараметрыМенеджера.Свойство(""ОбъектыНазначения""), ПараметрыМенеджера.ОбъектыНазначения, Новый Массив));
				|Если ПараметрыМенеджера.Свойство(""АдресВременногоХранилища"") Тогда
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды, ПараметрыМенеджера.АдресВременногоХранилища);
				|	Результат = ПолучитьИзВременногоХранилища(ПараметрыМенеджера.АдресВременногоХранилища);
				|Иначе
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды);
				|	Результат = ПараметрыКоманды.Результат;
				|КонецЕсли;
				|Если ПараметрыКоманды.Свойство(""ОписаниеОшибки"") Тогда
				|	ДобавитьОшибку(ПараметрыМенеджера, ПараметрыКоманды.ОписаниеОшибки);
				|КонецЕсли";
	ИначеЕсли ОбработкаИсключения <> "" Тогда
		Попытка
			ВыполнитьКод(ОбработкаИсключения, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли;
	Если Распознать <> "" Тогда
		Результат = РаспознатьЗначение(Распознать, ТипыДляРаспознавания, ПоРеквизиту, Родитель, Владелец);
	ИначеЕсли ТекстКода <> "" Тогда
		Попытка
			ВыполнитьКод(ТекстКода, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли; 
	
	Если ПараметрыМенеджера.Свойство("ОписаниеОшибки") Тогда
		ТекстСообщения = ПараметрыМенеджера.ОписаниеОшибки;
		Если ЕстьСтрокаТабло Тогда
			СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;		
		ПараметрыМенеджера.Вставить("ПоследняяОшибка", ПараметрыМенеджера.ОписаниеОшибки);
		ПараметрыМенеджера.Удалить("ОписаниеОшибки");
	КонецЕсли; 
	Возврат Результат;
КонецФункции // РассчитатьМенеджерНаСервере()

//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим уже д.б. проверен. Вспомогательная для РассчитатьМенеджерНаСервере.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом
Функция ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_)
	ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяФайла);
	Возврат ВнешняяОбработка.ЗапуститьМенеджер(Параметры_);
КонецФункции
 
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим проверяется этой функцией. Вспомогательная для РассчитатьМенеджерНаСервере.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод. В ключе "ОписаниеОшибки" возвращается строка - список ошибок выполнения.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом. При ошибке - Неопределено.
Функция ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, Параметры_)
	Если БезопасныйРежим() Тогда
		Результат = Неопределено;
		ДобавитьОшибку(Параметры_, "В безопасном режиме нельзя прочитать " + ИмяФайла);
	Иначе
		Попытка
			Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_);
		Исключение
			Результат = Неопределено;
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(Параметры_, "Обработка " + ИмяФайла + " не была выполнена по причине:" + ООШ);
		КонецПопытки;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Вспомогательная для РассчитатьМенеджерНаСервере.
// Добавляет переданную строку в ключ ОписаниеОшибки структуры параметров.
//Параметры:
//	Параметры_	- Структура - в ключ ОписаниеОшибки которой будет дописано сообщение;
//	Описание	-	Текст описания ошибки, записываемый в структуру
Процедура ДобавитьОшибку(Параметры_, Описание)
	Если Параметры_.Свойство("ОписаниеОшибки") Тогда
		Параметры_.ОписаниеОшибки = Параметры_.ОписаниеОшибки + "; " + Описание;
	Иначе
		Параметры_.Вставить("ОписаниеОшибки", Описание);
	КонецЕсли; 
КонецПроцедуры

//Возвращает результат распознавания строкового значения
//Параметры:
//	Значение_ - Строка - Распознаваемое значение в строковом выражении
//	ТипыИлиМенеджеры - Менеджер ссылочного значения или массив таких менеджеров или тип/массивТипов - типы, в которых ищется ссылочное значение. Если опущен, то возвращается простое нессылочное значение.
//	ПоРеквизиту - Строка - Имя реквизита, в котором ищется значение.
//	Родитель - ЛюбаяСсылка - Если требуется поиск по родителю, то задавать сюда. По умолчанию Неопределено (поиск не используется). Для поиска документа по номеру в этот реквизит надо поместить дату.
//	Владелец - ЛюбаяСсылка - Если требуется поиск по владельцу, то задавать сюда. По умолчанию Неопределено (поиск не используется)
//	АпострофЭтоСтрока - Булево - По умолчанию Истина. Значение, начинающееся с апострофа, будет считаться строкой.
//	НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//Возвращаемое значение:
//	Произвольный - Распознанное значение
Функция РаспознатьЗначение(Значение_, ТипыИлиМенеджеры = "", ПоРеквизиту = "", Родитель = Неопределено, Владелец = Неопределено, АпострофЭтоСтрока = Истина, НеРаспознаватьУИДБезТипа = Ложь) Экспорт
	Результат = Значение_;
	ВРЕГ_ = Врег(Значение_);
	Если АпострофЭтоСтрока И Лев(ВРЕГ_, 1) = "'"  Тогда
		Результат = Сред(Значение_, 2);
	Иначе
		Распознан = Ложь;
		ЭтоСтрока = Ложь;
		ЭтоЧисло = Ложь;
		ЭтоДата = Ложь;
		ЭтоБулево = Ложь;
		ЭтоУниверсал = ТипыИлиМенеджеры = "";
		Если НЕ ЭтоУниверсал Тогда
			мТиМ = ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(ТипыИлиМенеджеры);
			ТипТип = Тип("Тип");
			ТипСтрока = Тип("Строка");
			ТипДата = Тип("Дата");
			ТипЧисло = Тип("Число");
			ТипБулево = Тип("Булево");
			Для каждого ТекТиМ Из мТиМ Цикл
				ТекТип = ТипЗнч(ТекТиМ);
				ОбработатьТип = Ложь;
				Если ТекТип = ТипСтрока Тогда
					ВР_Т = Врег(ТекТиМ);
					Если ВР_Т = "СТРОКА" Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ВР_Т = "БУЛЕВО" Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ВР_Т = "ЧИСЛО" Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ВР_Т = "ДАТА" Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				Иначе
					Если ТекТиМ = ТипСтрока Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ТекТиМ = ТипБулево Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ТекТиМ = ТипЧисло Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ТекТиМ = ТипДата Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				КонецЕсли;
				Если ОбработатьТип Тогда
					Если ТекТип = ТипТип Тогда
						Менеджер = ИмяТаблицыОбъектаПоТипу(ТекТиМ, "Менеджер"); //ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
					ИначеЕсли ТекТип = ТипСтрока Тогда
						Менеджер = Вычислить(ТекТиМ);
					Иначе
						Менеджер = ТекТиМ;
					КонецЕсли; 
					ТипМенеджера = СтрПолучитьСтроку(СтрЗаменить(Менеджер, ".", Символы.ПС), 1);
					ЭтоУИД_ = ВОЛНА_ОбщегоНазначенияКС.ЭтоУИД(Значение_);
					Если ЭтоУИД_ Тогда
						ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение_));
						Если Лев(Строка(ТекСсылка), 18) = "<Объект не найден>" Тогда
							ЭтоУИД_ = Ложь
						Иначе
							Результат = ТекСсылка
						КонецЕсли
					КонецЕсли;
					Если НЕ ЭтоУИД_ И (Менеджер <> Неопределено) Тогда
						Если ТипМенеджера = "ПеречислениеМенеджер" Тогда //"Перечисления"
							//Перечисления грузим особо
							Результат = Менеджер.ПустаяСсылка();
							Если НЕ ПустаяСтрока(Значение_) Тогда
								ЗначенияП = Результат.Метаданные().ЗначенияПеречисления;
								ЗначениеПеречисления = ЗначенияП.Найти(Значение_);
								Если ЗначениеПеречисления = Неопределено Тогда
									Для каждого ЗначениеПеречисления Из ЗначенияП Цикл
										Если ЗначениеПеречисления.Синоним = Значение_ Тогда
											Прервать;
										КонецЕсли; 
									КонецЦикла; 
								КонецЕсли; 
								Если ЗначениеПеречисления <> Неопределено Тогда
									Результат = Менеджер[ЗначениеПеречисления.Имя];
								КонецЕсли; 
							КонецЕсли; 
						Иначе
							Если ПоРеквизиту = "" Тогда
								ПоРеквизиту = ?((ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), "Номер",   //"БизнесПроцессы" "Документы" "Задачи"
										?((ТипМенеджера = "ПланОбменаМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"), "Код", "Наименование"))
							КонецЕсли;
							ИскатьПоНомеру = ?(ПоРеквизиту = "Номер", (ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоКоду = ?(ПоРеквизиту = "Код", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер"), Ложь);
							ИскатьПоНаименованию = ?(ПоРеквизиту = "Наименование", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоРодителю = ?(Родитель = Неопределено, Ложь, (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"));
							ИскатьПОВладельцу = ?(Владелец = Неопределено, Ложь, ТипМенеджера = "СправочникМенеджер");
							Нашлось = Неопределено;
							Если ИскатьПоНомеру Тогда
								Если ТипМенеджера = "ДокументМенеджер" Тогда
									Нашлось = Менеджер.НайтиПоНомеру(Значение_, ?(Родитель = Неопределено, ТекущаяДата(), Родитель))
								Иначе
									Нашлось = Менеджер.НайтиПоНомеру(Значение_)
								КонецЕсли;
							ИначеЕсли ИскатьПоКоду Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Родитель)
									КонецЕсли
								Иначе
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь,, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_)
									КонецЕсли
								КонецЕсли
							ИначеЕсли ИскатьПоНаименованию Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина,, Владелец)
								Иначе
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина)
								КонецЕсли
							Иначе
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_,, Владелец)
								Иначе
									Попытка
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_)
									Исключение
										Нащлось = Ложь;
									КонецПопытки;
								КонецЕсли
							КонецЕсли;
							Если ЗначениеЗаполнено(Нашлось) Тогда
								Результат = Нашлось;
							КонецЕсли; 
						КонецЕсли
					КонецЕсли;
					Если Результат <> Значение_ Тогда
						Распознан = Истина;
						Прервать
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
		Если НЕ Распознан Тогда
			//Возвращается простое значение. Сначала - отработка насильственных типов
			Если (ВРЕГ_ = "ДА" ИЛИ ВРЕГ_ = "ИСТИНА") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Истина;
			ИначеЕсли (ВРЕГ_ = "НЕТ" ИЛИ ВРЕГ_ = "ЛОЖЬ") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Ложь;
			Иначе
				Если ЭтоУниверсал Тогда
					Попытка
						Результат = Вычислить(Значение_);
						Распознан = Истина;
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если НЕ Распознан Тогда
					Если ЭтоУниверсал ИЛИ ЭтоДата Тогда
						Попытка
							ЭтоТолькоВремя = Сред(Значение_, 2, 1) = ":" ИЛИ Сред(Значение_, 3, 1) = ":";
							СтрокаДатаВремя = СтрЗаменить(Значение_, " ", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ":", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, "/", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ".", Символы.ПС);
							Если ЭтоТолькоВремя Тогда
								День    = 1;
								Месяц   = 1;
								Год     = 1;
								Час     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 1, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 2, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3))), 0);
							Иначе
								День    = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Месяц   = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2)));
								Год     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3)));
								Час     = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 3, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 4))), 0);
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 4, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 5))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 5, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 6))), 0);
							КонецЕсли;
							НовДата = ДобавитьМесяц(Дата(1, 1, 1), (Год - 1) * 12 + Месяц - 1) + (День * 24 + Час - 24) * 3600 + Минута * 60 + Секунда;
							Если ЗначениеЗаполнено(НовДата)  Тогда
								Если Год < 100 И НЕ ЭтоТолькоВремя Тогда
									НовДата = ДобавитьМесяц(НовДата, Цел(Год(ТекущаяДатаСеанса()) / 100) * 1200);
								КонецЕсли
							КонецЕсли;
							Результат = НовДата;
							Распознан = Истина;
						Исключение
						КонецПопытки
					КонецЕсли;
					Если НЕ Распознан Тогда
						Если ЭтоУниверсал ИЛИ ЭтоЧисло Тогда
							Попытка
								Результат = Число(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение_, " ", ""), " ", ""), ",", "."));
								Распознан = Истина;
							Исключение
							КонецПопытки;
						КонецЕсли;
						Если НЕ Распознан Тогда
						    Если ЭтоСтрока Тогда
								Результат = Строка(Значение_);
							ИначеЕсли ЭтоБулево Тогда
								Результат = НЕ ПустаяСтрока(Значение_);
							Иначе
								Если ?(НеРаспознаватьУИДБезТипа, Ложь, ВОЛНА_ОбщегоНазначенияКС.ЭтоУИД(Значение_)) Тогда
									Результат = UUIDToСсылка(Значение_);
								КонецЕсли;
							КонецЕсли;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции //РаспознатьЗначение

#КонецОбласти 

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возвращает структуру реквизитов регистра, где ключ - имя реквизита, а значение - вид реквизита
// Параметры:
//  Регистр  - Строка - Строка вида "РегистрыСведений.АдресныеСведения" или объект регистра, по которому нужна структура.
//  Фильтр  - Строка - "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты" (по умолчанию) или только часть её в том же формате.
//  РазделятьВиды  - Булево - При Истина ключами будут "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", а значениями = структуры с ключами=именами м значениями=видами,
//			а при ЛОЖЬ (по умолчанию) - одна структура с ключами=именами и значениями=видами.
//  ЗначениеКлючей  - Произвольный - Значение, которое будет подставляться вместо видов. Если NULL или не обозначено - см.РазделятьВиды.
// Возвращаемое значение:
//   Структура   - Структура с ключами - имена реквизитов.
Функция СтруктураЗаписиРегистра(Регистр, Фильтр = "", РазделятьВиды = Ложь, ЗначениеКлючей = NULL) Экспорт
	Результат = Новый Структура;
	МетаДашка = Метаданные;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаМесяцРР = Неопределено;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаДашка = Вычислить("МетаДашка." + Регистр);
	СтруктураВозврата = Новый Структура(?(Фильтр = "", "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", Фильтр));
	Для каждого КиЗ Из СтруктураВозврата Цикл
		Для каждого Реквизит Из МетаДашка[КиЗ.Ключ] Цикл
			Результат.Вставить(Реквизит.Имя, ?(ЗначениеКлючей = NULL, КиЗ.Ключ, ЗначениеКлючей));
		КонецЦикла;
		Если РазделятьВиды Тогда
			СтруктураВозврата[КиЗ.Ключ] = Результат;
			Результат = Новый Структура;
		КонецЕсли;
	КонецЦикла;
	Если РазделятьВиды Тогда
		Результат = СтруктураВозврата;
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураЗаписиРегистра

// Загоняет в структуру все реквизиты объекта
// Параметры:
//  Чьих  - любая ссылка - ссылка на объект для чтения в структуру
//  Табчасти  - Булево - считывать ли табчасти
//  ТабчастиПредставлением  - Булево - Вставлять в результат вместо ТЧ строку "Табличная часть". По умолчанию ЛОЖЬ = возвращается табчасть.
//  Общие  - Булево - Включать в результат общие реквизиты.
// Возвращаемое значение:
//   Структура   - ключ - имя реквизита, значение - значение реквизита. Если Чьих не ссылка - ключ "Предмет", а значение - Чьих.
Функция СформироватьСтруктуруВсехРеквизитов(Чьих, Табчасти = Ложь, ТабчастиПредставлением = Ложь, Общие = Истина) Экспорт
	Попытка
		МетаХ = Чьих.Метаданные();
	Исключение
		МетаХ = Неопределено;
	КонецПопытки;
	Если МетаХ = Неопределено Тогда
		Возврат Новый Структура("Предмет", Чьих);
	Иначе
		Результат = Новый Структура;
		Для каждого Реквизит Из МетаХ.Реквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла; 
		Для каждого Реквизит Из МетаХ.СтандартныеРеквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла;
		Если Общие Тогда
			МетаВсё = Метаданные;
			МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
			ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
			РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
			АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
			ИнфоОР = Неопределено;
			Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
				//ЭлементР = Реквизит.Состав.Найти(МетаХ);
				Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
					//?(ЭлементР = Неопределено, Ложь, (ЭлементР.Использование = ИОР.Авто) ИЛИ (ЭлементР.Использование = ИОР.Использовать)) Тогда
					Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
		Если ТабЧасти Тогда
			Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
				Результат.Вставить(ТЧ.Имя, ?(ТабчастиПредставлением, "Табличная часть", Чьих[ТЧ.Имя]));
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
КонецФункции //  СформироватьСтруктуруВсехРеквизитов()

#Область РеквизитыОбъектаПоТипамИлиЗначениям
	
// Возвращает соответствие, где ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
// Параметры:
//  Источник  - Объект или ссылка, допускающие применение Метаданные() - Объект, в котором ищутся типы или значения
//  ТипыИлиЗначения  - Массив - Типы или значения, которые ищутся.
//  ИскатьВСтандартных  - Булево - Надо ли искать в стандартных реквизитах. По умолчанию Истина.
//  ИскатьВОбщих  - Булево - Надо ли искать в общих реквизитах. По умолчанию Истина.
//  ИскатьВТабЧастях  - Булево - Надо ли искать в табчастях. По умолчанию Истина.
// Возвращаемое значение:
//   Соответствие   - ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
Функция РеквизитыОбъектаПоТипамИлиЗначениям(Источник, ТипыИлиЗначения, ИскатьВСтандартных = Истина, ИскатьВОбщих = Истина, ИскатьВТабЧастях = Истина) Экспорт
	ТипТип = Тип("Тип");
	Результат = Новый Соответствие;
	Для каждого ТекЗнч Из ТипыИлиЗначения Цикл
		Результат.Вставить(ТекЗнч, Новый Массив);
	КонецЦикла; 
	МетаХ = Источник.Метаданные();
	РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.Реквизиты, ТипТип);
	Если ИскатьВСтандартных Тогда
		РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.СтандартныеРеквизиты, ТипТип);
	КонецЕсли;
	Если ИскатьВОбщих Тогда
		МетаВсё = Метаданные;
		МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
		ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
		РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
		АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
		ИнфоОР = Неопределено;
		Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
			//ЭлементР = Реквизит.Состав.Найти(МетаХ);
			Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
				РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(Реквизит), ТипТип);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Если ИскатьВТабЧастях Тогда
		Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
			РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ТЧ.Реквизиты, ТипТип, ТЧ.Имя + ".");
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // РеквизитыОбъектаПоТипамИлиЗначениям
 
//Вспомогательная для РеквизитыОбъектаПоТипамИлиЗначениям
// Параметры:
//  Приёмник  - Соответствие - Ключ = обрабатываемое значение, значение - массив имён реквизитов, найденных по значению
//  Источник  - Объект или ссылка - Объект, в котором ищутся значения
//  МетаКоллекция  - Коллекция объектов метаданных - Коллекция, по которой ищутся типы или значения
//  ТипТип  - Тип - Тип("Тип") - уже вычисленный
//  Префикс  - Строка - префикс имени реквизита (путь к родителю)
Процедура РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Приёмник, Источник, МетаКоллекция, ТипТип, Префикс = "")
	Для каждого Реквизит Из МетаКоллекция Цикл
		Для каждого КиЗ Из Приёмник Цикл
			ТекЗнч = КиЗ.Ключ;
			ЭтоТип = ТекЗнч = ТипТип;
			Если ?(ЭтоТип, Реквизит.Тип.СодержитТип(ТекЗнч), Источник[Реквизит.Имя] = ТекЗнч) Тогда
				КиЗ.Значение.Добавить(Префикс + Реквизит.Имя);
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла;
КонецПроцедуры // РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям

// Возвращает, применяется ли общий реквизит для объекта метаданных
// Параметры:
//  МетаХ  - Объект метаданных - для которого проверяется использование общего реквизита
//  ОРеквизит  - Объект метаданных Общий реквизит - для которого проверяется использование общего реквизита
//  ИспользованияОР  - Соответствие - Соответствие, где ключ - ОР, а значение - соответствие, где ключ - метаданные, а значение - булево, использование. Если Неопределено, рассчитывается и возвращается при необходимости.
//  ИОР  - Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  АИОРИ  - Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  РДОРР  - Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
// Возвращаемое значение:
//   Булево   - Истина, если реквизит используется
Функция ОбщийРеквизитИспользуется(МетаХ, ОРеквизит, ИспользованияОР = Неопределено, ИОР = Неопределено,
		АИОРИ = Неопределено, РДОРР = Неопределено) Экспорт
	Если (РДОРР = Неопределено) ИЛИ (ИОР = Неопределено) ИЛИ (АИОРИ = Неопределено) Тогда
		МСО = Метаданные.СвойстваОбъектов;
		РДОРР = МСО.РазделениеДанныхОбщегоРеквизита.Разделять;
		ИОР = МСО.ИспользованиеОбщегоРеквизита;
		АИОРИ = МСО.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли; 
	Если ИспользованияОР = Неопределено Тогда
		ИспользованияОР = Новый Соответствие;
	КонецЕсли; 
	Получен = Ложь;
	Использование_ = ИспользованияОР[ОРеквизит];
	Если Использование_ = Неопределено Тогда
		Использование_ = Новый Соответствие;
		ИспользованияОР.Вставить(ОРеквизит, Использование_);
		Результат = Неопределено;
	Иначе
		Результат = Использование_[МетаХ];
		Получен = Результат <> Неопределено;
	КонецЕсли;
	Если НЕ Получен Тогда
		ЭлементР = ОРеквизит.Состав.Найти(МетаХ);//Замедляет!!!!!! 40% при 250 тыс. запусках (а откуда столько? 250К Общих реквизитов????)
		Результат = Ложь;
		Если ЭлементР <> Неопределено Тогда
			ТекИсп = ЭлементР.Использование;
			Если ТекИсп = ИОР.Авто Тогда
				Если ОРеквизит.АвтоИспользование = АИОРИ Тогда //200000 запусков
					Результат = Истина;
				КонецЕсли; 
			ИначеЕсли ТекИсп = ИОР.Использовать Тогда
				Результат = Истина;
			КонецЕсли; 
			Если ОРеквизит.РазделениеДанных = РДОРР Тогда
				Если Строка(ОРеквизит.УсловноеРазделение) <> "" Тогда
					Попытка
						Результат = Результат И Константы[ОРеквизит.УсловноеРазделение.Имя].Получить();
					Исключение
						
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Использование_.Вставить(МетаХ, Результат);
	Возврат Результат
КонецФункции // ОбщийРеквизитИспользуется

#КонецОбласти 
 
#КонецОбласти 

#Область СКД
	
//Возвращает элементы структуры настроек схемы компоновки данных по их именам
//Параметры:
//  СтруктураСКД  - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - головной элемент структуры СКД (структура, таблица, строки или колонки),  в которой будет поиск
//  Имена  - Строка или Массив (массив изменяется в процессе!) - Через запятую или в массиве - имена элементов, которые надо найти. Имена у искомых элементов д.б. настроены в конфигураторе.
//  Результат  - Структура - Если структура уже есть, и в неё надо добавить элементы, то она передаётся в этом параметре. Она же будет возвращена.
//Возвращаемое значение:
//   Структура   - ключи - переданные имена, разобранные из строки, значения - найденные элементы
Функция НайтиЭлементыСтруктурыКДПоИменам(СтруктураСКД, Имена, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый Структура;
	КонецЕсли;
	МассивХ = ?(ТипЗнч(Имена) = Тип("Массив"), Имена, СтрРазделить(Имена, ",", Ложь));
	Для каждого СтрокаСтруктуры Из СтруктураСКД Цикл
		Индех = МассивХ.Найти(СтрокаСтруктуры.Имя);
		Если Индех <> Неопределено Тогда
			Результат.Вставить(СтрокаСтруктуры.Имя, СтрокаСтруктуры);
			МассивХ.Удалить(Индех);
		КонецЕсли; 
		//Если Флаги.Свойство(СтрокаСтруктуры.Идентификатор) Тогда
		//	СтрокаСтруктуры.Использование = Флаги[СтрокаСтруктуры.Идентификатор];
		//КонецЕсли;
		Если МассивХ.Количество() Тогда
			Тест = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
			ЗаполнитьЗначенияСвойств(Тест, СтрокаСтруктуры);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Колонки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Строки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Структура, МассивХ, Результат);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // НайтиЭлементыСтруктурыКДПоИменам
 
#Область КОПИРОВАНИЕ_ГРУППИРОВКИ_СКД
	
//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию выбранных полей
//Параметры:
//	СтруктураПриёмник - ВыбранныеПоляКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ВыбранноеПолеКомпоновкиДанных или АвтоВыбранноеПолеКомпоновкиДанных или ГруппаВыбранныхПолейКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьВыбранныеПоля(СтруктураПриёмник, Элемент) Экспорт
	Если Тип(Элемент) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Расположение = Элемент.Расположение; 
		НовЭлемент.Поле = Элемент.Поле; 
		Для каждого Элемент Из Элемент.Выбор.Элементы Цикл 
			ДобавитьВыбранныеПоля(НовЭлемент.Выбор.Элементы, Элемент); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Переносит свойства переданного элемента в соответствующий элемент параметров вывода приёмника.
//Параметры:
//	СтруктураПриёмник - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЗначениеПараметраКомпоновкиДанных или ЗначениеПараметраНастроекКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПараметрыВывода(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Найти(Строка(Элемент.Параметр)); 
	НовЭлемент.Значение = Элемент.Значение; 
	НовЭлемент.Использование = Элемент.Использование; 
	Для каждого Элемент Из Элемент.ЗначенияВложенныхПараметров Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.ЗначенияВложенныхПараметров, Элемент); 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию отборов
//Параметры:
//	СтруктураПриёмник - ОтборКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементОтбораКомпоновкиДанных или ГруппаЭлементовОтбораКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьОтбор(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.ВидСравнения = Элемент.ВидСравнения; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.ЛевоеЗначение = Элемент.ЛевоеЗначение; 
		НовЭлемент.ПравоеЗначение = Элемент.ПравоеЗначение; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
		НовЭлемент.ТипГруппы = Элемент.ТипГруппы; 
		Для каждого ЭлементОтбора Из Элемент.Элементы Цикл 
			ДобавитьОтбор(НовЭлемент.Отбор.Элементы, ЭлементОтбора); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию условного оформления
//Параметры:
//	СтруктураПриёмник - УсловноеОформлениеКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементУсловногоОформленияКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьУсловноеОформление(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Добавить(); 
	НовЭлемент.Представление = Элемент.Представление; 
	НовЭлемент.Использование = Элемент.Использование; 
	//отбор 
	Для каждого ЭлементОтбор Из Элемент.Отбор.Элементы Цикл 
		ДобавитьОтбор(НовЭлемент.Отбор.Элементы,ЭлементОтбор); 
	КонецЦикла; 
	//оформление 
	Для каждого ЭлементОформление Из Элемент.Оформление.Элементы Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.Оформление.Элементы,ЭлементОформление); 
	КонецЦикла; 
	//поля 
	Для каждого ЭлементПоле Из Элемент.Поля.Элементы Цикл 
		НовЭлементПоле = НовЭлемент.Поля.Элементы.Добавить(); 
		НовЭлементПоле.Использование = ЭлементПоле.Использование; 
		НовЭлементПоле.Поле = ЭлементПоле.Поле; 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию порядка
//Параметры:
//	СтруктураПриёмник - ПорядокКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементПорядкаКомпоновкиДанных или АвтоЭлементПорядкаКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПорядок(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
		НовЭлемент.ТипУпорядочивания = Элемент.ТипУпорядочивания; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции

//Копирует элемент структуры СКД в другую (или эту же) структуру СКД.
//Содрана https://forum.infostart.ru/forum9/topic47305/
//Параметры:
//	СтруктураПриёмник - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - куда будет помещён новый элемент
//	ЭлементИсточник - ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных или НастройкиВложенногоОбъектаКомпоновкиДанных - Копируемый элемент структуры настроек СКД.
//			Для некоторых типов м.б. не проверено :(
//	ОткудаУдалитьНаСтаромМесте - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - Коллекция, из которой надо удалять старый элемент (Неопределено по умолчанию - не удалять).
//Возвращаемое значение:
//	Того же типа, что и ЭлементИсточник - Добавленный элемент
Функция СкопироватьЭлементВСтруктуруСКД(СтруктураПриёмник, ЭлементИсточник, ОткудаУдалитьНаСтаромМесте = Неопределено) Экспорт 
	
	ЭтоВТаблице = ТипЗнч(СтруктураПриёмник) = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных");
	Результат = ?(ЭтоВТаблице, СтруктураПриёмник.Добавить(), СтруктураПриёмник.Добавить(ТипЗнч(ЭлементИсточник)));
	
	//выбор 
	Для каждого Элемент Из ЭлементИсточник.Выбор.Элементы Цикл 
		ДобавитьВыбранныеПоля(Результат.Выбор.Элементы, Элемент) 
	КонецЦикла; 
	//использование 
	Результат.Использование = ЭлементИсточник.Использование; 
	//имя 
	Результат.Имя = ЭлементИсточник.Имя; 
	//отбор 
	Для каждого Элемент Из ЭлементИсточник.Отбор.Элементы Цикл 
		ДобавитьОтбор(Результат.Отбор.Элементы, Элемент); 
	КонецЦикла; 
	// параметры вывода 
	Для каждого Элемент Из ЭлементИсточник.ПараметрыВывода.Элементы Цикл 
		ДобавитьПараметрыВывода(Результат.ПараметрыВывода.Элементы,Элемент); 
	КонецЦикла; 
	//поля группировки 
	Для каждого Элемент Из ЭлементИсточник.ПоляГруппировки.Элементы Цикл 
		Если ТипЗнч(Элемент) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
			НовЭлемент.КонецПериода = Элемент.КонецПериода; 
			НовЭлемент.НачалоПериода = Элемент.НачалоПериода; 
			НовЭлемент.Поле = Элемент.Поле; 
			НовЭлемент.ТипГруппировки = Элемент.ТипГруппировки; 
			НовЭлемент.ТипДополнения = Элемент.ТипДополнения; 
		ИначеЕсли ТипЗнч(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
		КонецЕсли; 
	КонецЦикла; 
	//порядок 
	Для каждого Элемент Из ЭлементИсточник.Порядок.Элементы Цикл 
		ДобавитьПорядок(Результат.Порядок.Элементы, Элемент); 
	КонецЦикла; 
	//условное оформление 
	Для каждого Элемент Из ЭлементИсточник.УсловноеОформление.Элементы Цикл 
		ДобавитьУсловноеОформление(Результат.УсловноеОформление.Элементы, Элемент); 
	КонецЦикла; 
	
	//обход структуры рекурсивно 
	ТМП = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
	ЗаполнитьЗначенияСвойств(ТМП, ЭлементИсточник);
	Для каждого Подчинённый Из ТМП.Структура Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Структура, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Строки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Строки, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Колонки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Колонки, Подчинённый) 
	КонецЦикла; 
	
	Если ОткудаУдалитьНаСтаромМесте <> Неопределено Тогда
		ОткудаУдалитьНаСтаромМесте.Удалить(ЭлементИсточник);
	КонецЕсли;
	Возврат Результат
КонецФункции 

#КонецОбласти 

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
//Возвращает ссылку по строке УИД
//Параметры:
//	УУИД - Строка - 36 значный УИД
//	НайтиВсе - Булево - Найти все ссылки и вернуть массив. При Ложь будет возвращена первая найденная.
//Возвращаемое значение:
//	Массив/Ссылка/Неопределено - Если НайтиВсе - будет массив, иначеесли найдена ссылка - найденная ссылка, если не найдено ничего - неопределено.
Функция UUIDToСсылка(УУИД, НайтиВсе = Ложь) Экспорт
	Результат = Новый Массив;
	ГдеИщем = Новый Соответствие;
	ГдеИщем.Вставить(Справочники, Метаданные.Справочники);
	ГдеИщем.Вставить(Документы, Метаданные.Документы);
	ГдеИщем.Вставить(ПланыВидовХарактеристик, Метаданные.ПланыВидовХарактеристик);
	ГдеИщем.Вставить(ПланыСчетов, Метаданные.ПланыСчетов);
	ГдеИщем.Вставить(ПланыВидовРасчета, Метаданные.ПланыВидовРасчета);
	ГдеИщем.Вставить(БизнесПроцессы, Метаданные.БизнесПроцессы);
	ГдеИщем.Вставить(Задачи, Метаданные.Задачи);
	ГдеИщем.Вставить(ПланыОбмена, Метаданные.ПланыОбмена);
	НУИД = Новый УникальныйИдентификатор(УУИД);
	Для Каждого ВидМетаданных Из ГдеИщем Цикл
		Для каждого л_Менеджер из ВидМетаданных.Значение Цикл
			л_Ссылка = ВидМетаданных.Ключ[л_Менеджер.Имя].ПолучитьСсылку(НУИД);
			//Элементы.ГруппаСсылки.Заголовок = ТипЗнч(л_Ссылка);
			Если л_Ссылка.ПолучитьОбъект() <> Неопределено Тогда
				Если НайтиВсе Тогда
					Результат.Добавить(л_Ссылка);
				Иначе
					Возврат л_Ссылка
				КонецЕсли; 
			КонецЕсли
		КонецЦикла
	КонецЦикла;
	Возврат ?(НайтиВсе, Результат, Неопределено)
КонецФункции

// Возвращает ссылки по УИД, но поиск происходит только по заданным типам
// Параметры:
//  УУИДы  - Строка или Массив строк - УИДы, по которым надо найти ссылку
//  ГдеИскать  - Массив - Допустимые типы ссылки
// Возвращаемое значение:
//   Массив   - Найденные ссылки или Неопределено
Функция СсылкиЗаданногоТипаПоУИД(УИДы, ГдеИскать) Экспорт
	ЧтоИскать = ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(УИДы);
	мГдеИскать = Новый Массив;
	Для каждого ТекТип Из ГдеИскать Цикл
		мГдеИскать.Добавить(ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер").Менеджер);//ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
	КонецЦикла;
	Результат = Новый Массив;
	Для каждого УИД Из ЧтоИскать Цикл
		ТекСсылка = Неопределено;
		Для каждого Менеджер Из мГдеИскать Цикл
			ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИД));
			Если ТекСсылка <> Неопределено Тогда
				Прервать;
			КонецЕсли;
			Результат.Добавить(ТекСсылка);
		КонецЦикла; 
	КонецЦикла;
	Возврат Результат
КонецФункции // СсылкиЗаданногоТипаПоУИД()
 
#КонецОбласти 

#Область СТРОКОВЫЕ

//Создаёт тестер маски.
//Параметры:
//	Маска - Строка - Маска для проверки. По умолчанию - маска проверки даты. Описание синтаксиса маски в функции ПроверитьСтроку
//Возвращаемое значение
//	 ЗначениеXDTO - для тестирования строки по маске
Функция ЗначениеXDTOдляПроВеркиСтроки(Маска = "\d{2}\.\d{2}\.\d{4}") Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Маска + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
КонецФункции // XDTOдляПроВеркиСтроки()
 
// Возврщает дерево процедур и функций модуля с учётом областей.
// Параметры:
//  ТекстМодуля - Строка - Текст модуля, в котором ищутся методы. Считается, что структурирован: не содержит ошибок, заголоврк и ркончание процедур и функций в отдельных строках с начала, ЭКСПОРТ не с новой строки. 
//  ТолькоЭкспорт - Булево - Выбирать только экспортные процедуры
//  ОбластьРодитель - Строка - Имя области, внутри которой ищутся процедуры. Допускается, что в модуле м.б. несколько областей с этим именем. Сам родитель в дерево не попадает. По умолчанию "" - обрабатывается весь модуль.
//  ТегМеню - Строка - Префикс строки (после знака комментария), идентифицирующий в модуле строку представления в дереве. Эта строка может быть в любом месте метода и не включается в другие тексты. По умолчанию "МЕНЮ:".
//	Приёмник - Дерево/Строка дерева - приёмник для дотройки ветви по модулю.
// Возвращаемое значение:
//   Дерево значений   - Список методов модуля с колонками
//		*Представление = для представления в дереве = имя или из строчки с ТегМеню
//		*Имя = Имя метода
//		*Описание = Начальный комментарий до Параметров
//		*ПолноеОписание = Весь начальный комментарий и заголовок метода с параметрами.
//		*Текст = текст метода от заголовка
//		*Вид = Функция или Процедура
//		*Экспорт = Булево
//		*Параметры = Список параметров в составе заголовка
Функция ДеревоМетодовМодуля(ТекстМодуля, ТолькоЭкспорт = Истина, ОбластьРодитель = "", ТегМеню = "МЕНЮ:", Приёмник = Неопределено) Экспорт
	Результат = ?(Приёмник = Неопределено, Новый ДеревоЗначений, Приёмник);
	#Область КОЛОНКИ
		Если Результат.Колонки.Найти("Представление") = Неопределено Тогда
			Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("ПолноеОписание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Экспорт", Новый ОписаниеТипов("Булево")); 
			Результат.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		КонецЕсли;
	#КонецОбласти
	Стек = Новый Массив;
	Коммент = Ложь; //Строка в теле комментария перед функцией
	Сброс = Истина; //Перед обработкой следующей строки обнулить данные записи
	Тело = Ложь; //Строка в теле функции
	СложныйКоммент = ""; //Комментарий, включающий область
	Заголовок = 0; //0 - это не заголовок, 1 - обработка заголовка до первой скобки, 2 - до второй скобки, 3 - после второй скобки
	Ветка = Результат;
	ДлТМ = СтрДлина(ТегМеню);
	РазрешеноЧтение = ОбластьРодитель = ""; //Строка внутри разрешённой области-родителя
	ИменаКолонок = ВОЛНА_ОбщегоНазначенияСервер.Список_Колонок(Результат);
	#Область ОПИСАНИЕ
		//Вне тела и заголовка метода:
		//	чтение построчно;
		//	[Nпс]// - в начале строки включает режим комментария до конца строки. Включает и продолжает режим описания.
		//	[Nпс]//[Nпс]Параметры отключает режим краткого описания, режим полного остаётся.
		//	[Nпс]& игнорируются.
		//	[Nпс]#Область - прерывают режим описания с отменой. Добавляют уровень подменю.
		//	[Nпс]#КонецОбласти - прерывают режим описания с отменой. Переводят в подменю на уровень выше.
		//	[Nпс][Асинх|][Nпс]Процедура|Функция[Nпс][ИМЯ]( - прерывают режим описаний с принятием. Переводят в режим чтения заголовка, имени и параметров.
		//  Прочие - прерывают режим описания с отменой. Потом игнорируются.
		//В заголовке метода:
		//	чтение посимвольно;
		//	// - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
		//	" - включает/выключает ре.жим текста. В режиме текста ищется только ", а запись заголовка продолжается.
		//	) - Закрывает чтение заголовка и параметров. Проверяется )[Nпс]Экспорт[Nпс].Включает режим тела процедуры/ функции. Не работает в режиме текста
		//В теле метода:
		//	Чтение поиском.
		//	[N*][Nпс]КонецПроцедуры|КонецФункции[Nпс] - завершает запись текста и режим тела метода и переводит в режим "Вне".
		//			Не работает, если внутри режима тела нечёт двойных кавычек вне комментариев. Не работает после символов комментария вне текста.
		//	" - включает/выключает режим текста. В режиме текста ищется только ", а запись текста продолжается.
		//	// - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
	#КонецОбласти
	Для Ё = 1 По СтрЧислоСтрок(ТекстМодуля) Цикл
		Если Сброс Тогда
			Сброс = Ложь;
			Тело = Ложь;
			Заготовка = Новый Структура(ИменаКолонок);
			//Если СложныйКоммент <> "" Тогда
				Заготовка.Вставить("ПолноеОписание", СложныйКоммент);
			//КонецЕсли;
			Заготовка.Вставить("Текст", "");
			Заготовка.Вставить("Экспорт", Ложь);
			СложныйКоммент = "";
		КонецЕсли;
		ТекСтрока = СокрЛП(СтрПолучитьСтроку(ТекстМодуля, Ё));
		НРегСтрока = НРег(ТекСтрока);
		Готово = Ложь; //Создать строку дерева после обработки строки модуля
		ВТекст = Ложь; //Вставить строку в текст метода
		ВКоммент = Ложь; // Вставить строку в текст комментария
		Если Лев(ТекСтрока, 2) = "//" Тогда
			ТекКоммент = СокрЛП(Сред(ТекСтрока, 3));
			Если Лев(ТекКоммент, ДлТМ) = ТегМеню Тогда
				Заготовка.Вставить("Представление", Сред(ТекКоммент, ДлТМ + 1));
			ИначеЕсли НЕ Тело Тогда
				Если НЕ Коммент Тогда
					Коммент = Истина;
					Заготовка.Вставить("ПолноеОписание", "");
				КонецЕсли;
				Если Лев(ТекКоммент, 9) = "Параметры" Тогда
					Заготовка.Вставить("Описание", Сред(Заготовка.ПолноеОписание, 2));
				КонецЕсли;
				ВКоммент = Истина;
			Иначе
				ВТекст = Истина;
			КонецЕсли; 
		ИначеЕсли Лев(ТекСтрока, 1) = "&" Тогда
			ВТекст = Тело;
		//ИначеЕсли Тело Тогда
		//	ВТекст = Тело;
		Иначе
			Если Лев(НРегСтрока, 5) = "асинх" И Не ЗначениеЗаполнено(Сред(НРегСтрока, 6, 1)) Тогда
				ТекСтрока = СокрЛП(Сред(ТекСтрока, 7));
				НРегСтрока = СокрЛП(Сред(НРегСтрока, 7));
			КонецЕсли;
			ЭтоПроц = Лев(НРегСтрока, 9) = "процедура";
			ЭтоФ = Лев(НРегСтрока, 7) = "функция";
			ЭтоОбл = Лев(НРегСтрока, 8) = "#область";
			ЭтоКОбл = Лев(НРегСтрока, 13) = "#конецобласти";
			ЭтоКПроц = Лев(НРегСтрока, 14) = "конецпроцедуры";
			ЭтоКФ = Лев(НРегСтрока, 12) = "конецфункции";
			Если ЭтоПроц ИЛИ ЭтоФ ИЛИ (Заголовок > 0) Тогда
				Тело = Истина;
				Если ЭтоПроц Или ЭтоФ Тогда
					Заготовка.Вставить("Текст", ТекСтрока);
					Заготовка.Вставить("Вид", ?(ЭтоФ, "Функция", "Процедура"));
					Квант = СокрЛП(Сред(ТекСтрока, ?(ЭтоФ, 9, 11)));
					Заголовок = 1;
					ПроверитьДругиеВарианты = Ложь;
				Иначе
					ПроверитьДругиеВарианты = Заголовок = 3; //Новая строка после скобки может быть новым оператором
					ВТекст = Истина;
					Квант = ТекСтрока;
				КонецЕсли;
				ВКоммент = НЕ ПроверитьДругиеВарианты; //Если нет других вариантов - это заголовок метода, он должен попадать в полный коммент
				//Имя метода
				Если Заголовок = 1 Тогда
					ПСкобки = СтрНайти(Квант, "(");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Имя", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 2;
						Заготовка.Вставить("Параметры", "");
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 2 Тогда
					ПСкобки = СтрНайти(Квант, ")");
					Если ПСкобки = 0 Тогда
						Заготовка.Вставить("Параметры", Заготовка.Параметры + Квант + Символы.ПС);
					Иначе
						Заготовка.Вставить("Параметры", Заготовка.Параметры + Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 3;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 3 Тогда
					Заголовок = 0;
					Заготовка.Вставить("Экспорт", НРег(Лев(Квант, 7)) = "экспорт");
				КонецЕсли;
			Иначе
				ПроверитьДругиеВарианты = Истина;
			КонецЕсли;
			Если ПроверитьДругиеВарианты Тогда
				ВТекст = Тело;
				Если ЭтоОбл И НЕ Тело Тогда
					Сброс = Истина;
					Готово = РазрешеноЧтение;
					Заготовка.Вставить("Вид", "Подменю");
					Заготовка.Вставить("Имя", СокрЛП(Сред(ТекСтрока, 10)));
					Если (Заготовка.Имя = ОбластьРодитель) И (ОбластьРодитель <> "") Тогда
						РазрешеноЧтение = Истина;
					КонецЕсли;
				ИначеЕсли ЭтоКОбл И НЕ Тело Тогда
					Сброс = Истина;
					Если Стек.Количество() = 0 Тогда
						РазрешеноЧтение = Ложь;
					Иначе
						Колво = Ветка.Строки.Количество();
						КомментВОбласти = "";
						УдалитьПодменю = (Колво = 0) ИЛИ ((Колво = 1) И ТолькоЭкспорт);
						УдаляемоеПодменю = Ветка;
						КомментВнутриОбласти = Заготовка.ПолноеОписание;
						Ветка = Стек[Стек.ВГраница()];
						Стек.Удалить(Стек.ВГраница());
						Если УдалитьПодменю Тогда
							СложныйКоммент = "" + УдаляемоеПодменю.ПолноеОписание + Символы.ПС + "#Область" + УдаляемоеПодменю.Имя + Символы.ПС + КомментВнутриОбласти + Символы.ПС + ТекСтрока;
							Если Колво = 1 Тогда
								ЗаполнитьЗначенияСвойств(Ветка.Строки.Добавить(), УдаляемоеПодменю.Строки[0]);
							КонецЕсли;
							Ветка.Строки.Удалить(УдаляемоеПодменю);
						КонецЕсли;
					КонецЕсли; 
				ИначеЕсли ЭтоКПроц ИЛИ ЭтоКФ Тогда
					Готово = Истина;
					Сброс = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Коммент И НЕ Тело Тогда
				Заготовка.Вставить("ПолноеОписание", "");
				Заготовка.Вставить("Описание", "");
			КонецЕсли;
			Коммент = Ложь;
		КонецЕсли;
		Если ВКоммент Тогда
			Заготовка.Вставить("ПолноеОписание", Заготовка.ПолноеОписание + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если ВТекст Тогда
			Заготовка.Вставить("Текст", Заготовка.Текст + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если Готово Тогда
			Если РазрешеноЧтение Тогда
				ЭтоПодменю = Заготовка.Вид = "Подменю";
				Если ЭтоПодменю ИЛИ Заготовка.Экспорт ИЛИ НЕ ТолькоЭкспорт Тогда
					Если ПустаяСтрока(Заготовка.Представление) Тогда
						Заготовка.Вставить("Представление", Заготовка.Имя);
					КонецЕсли;
					НоваяСтрока = Ветка.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Заготовка);
					Если ЭтоПодменю Тогда
						Стек.Добавить(Ветка);
						Ветка = НоваяСтрока;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Готово = Ложь;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ДеревоМетодовМодуля

#КонецОбласти

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ

// Получает табличный документ из двоичных данных Excel или Excel
// Параметры:
//  ДДилиФайл  - ДвоичныеДанные/Строка - ДД, полученные, например, из хранилища или макета/путь к файлу
//  Расширение  - Строка - расширение Excel (нужно только для ДД), по умолчанию xlsx
// Возвращаемое значение:
//   Табличный документ   - Прочитанный из Excel
Функция ТДизExcel(ДДилиФайл, Расширение = "xlsx") Экспорт
	ТекТип = ТипЗнч(ДДилиФайл);
	ЭтоДД = ТекТип = Тип("ДвоичныеДанные");
	Если ТекТип = Тип("Строка") Тогда
		ПутьКФайлуИсточнику = ДДилиФайл;
	ИначеЕсли ЭтоДД Тогда
		ПутьКФайлуИсточнику = ПолучитьИмяВременногоФайла(Расширение);
		ДДилиФайл.Записать(ПутьКФайлуИсточнику);
		ФайлГотов = Истина;
	Иначе
		ПутьКФайлуИсточнику = ДДилиФайл;
	КонецЕсли;
	Результат = Новый ТабличныйДокумент;
	Если ЗначениеЗаполнено(ПутьКФайлуИсточнику) Тогда
		Результат.ИспользуемоеИмяФайла = ПутьКФайлуИсточнику;
		Результат.Прочитать(ПутьКФайлуИсточнику);
	КонецЕсли;
	Если ЭтоДД Тогда
		УдалитьФайлы(ПутьКФайлуИсточнику);
	КонецЕсли;
	Возврат Результат
КонецФункции // ТДизExcel

#Область РАСШИФРОВКА

// Возвращает структуру полей расшифровки ячейки
// Параметры:
//	ИР  - Идентификатор расшифровки КД - ИД для получения данных
//	ДанныеРасшифровки  - Адрес данных расшифровки КД во временном хранилище/ДанныеРасшифровки - Источник получения данных
//	ВключитьНастройки  - Булево - Включить в объект ключ Настройки_ = Структура настроек пасшифровки. Включает только верхний уровень.
//	ВключитьДРО  - Булево - Включить в объект ключ ДРО_ = Данные расшифровки
// Возвращаемое значение:
//	Структура   - Ключи = имена полей, значения = значения полей 
Функция ПоляТекущейРасшифровки(ИР, ДанныеРасшифровки, ВключитьНастройки = Истина, ВключитьДРО = Ложь) Экспорт
	Результат_ = Новый Структура;
	Если ИР <> Неопределено Тогда
		_ДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки);
		эДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки).Элементы[ИР];
		ВОЛНА_ОбщегоНазначенияСервер.ПоляРасшифровкиВСтруктуруРекурсивно(Результат_, эДРО);
		Если эДРО.ПолучитьПоля()[0].Поле = "Результат" Тогда
			//ПолучитьИзВременногоХранилища(ДанныеРасшифровки).Элементы[ИР].ПолучитьРодителей()[0].ПолучитьПоля()[1].Значение
			Для каждого Родитель_ Из эДРО.ПолучитьРодителей() Цикл
				Для каждого ПолеРодителя Из Родитель_.ПолучитьПоля() Цикл
					Результат_.Вставить(ПолеРодителя.Поле, ПолеРодителя.Значение);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		Если ВключитьДРО Тогда
			Результат_.Вставить("ДРО_", _ДРО);
		КонецЕсли;
		Если ВключитьНастройки Тогда
			ТекНастройки = Новый Структура;
			Для каждого ТекЭлемент Из _ДРО.Настройки.ПараметрыДанных.Элементы Цикл
				ТекНастройки.Вставить(СокрЛП(ТекЭлемент.Параметр), ТекЭлемент.Значение);
			КонецЦикла;
			Результат_.Вставить("Настройки_", ТекНастройки);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат_
КонецФункции // ДанныеТекущейРасшифровки

#КонецОбласти
	
#КонецОбласти 

//Возвращает массив видов характеристик, содержащих заданный тип
//ПВХ - строка с именем ПВХ, Тип - Тип
//Параметры:
//	ПВХ - строка -  имя плана вида характеристик
//	Тип - Тип -  искомый тип
//Возвращаемое значение:
//	Массив - виды характеристик, содержащие заданный тип.
Функция ВыбратьПВХСодержащиеТип(ПВХ, Тип) Экспорт
	Массив = Новый Массив;
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	ОбъектыСвойств.Ссылка,
	|	ОбъектыСвойств.ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик." + ПВХ + " КАК ОбъектыСвойств");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(Тип) Тогда
			Массив.Добавить(Выборка.Ссылка)
		КонецЕсли
	КонецЦикла;
	Возврат Массив
КонецФункции

// Формирует записи регистра сведений по переданной таблице значений.
// Параметры:
//	ИмяРегистра - Строка - Имя регистра сведений.
//  ТабЗнач  - Таблица значений - пригодная для загрузки в регистр. При вызове с клиента - массив структур.
//  Перезаписать  - Булево - при Истина регистр будет предварительно очищен, при Ложь (по умолчанию) - нет. При вызове с клиента только Ложь.
//  МаксКолвоДляЗаписиПоОдной  - Число - Оптимизационный параметр. При большом кол-ве записей быстрее записать весь регистр, чем писать записи по одной.
//		Границу определяет этот параметр. По умолчанию 50. При вызове с клиента должен быть больше числа записей - т.е. запись всего регистра вернёт ошибку.
Процедура ЗагрузитьРСИзТаблицы(ИмяРегистра, ТабЗнач, Перезаписать = Ложь, МаксКолвоДляЗаписиПоОдной = 50) Экспорт
	ТабДляЗаписи = ТабЗнач;
	Если Перезаписать Тогда
		ПоОдной = Ложь;
	Иначе
		ПоОдной = ТабЗнач.Количество() <= МаксКолвоДляЗаписиПоОдной;
		Если НЕ ПоОдной Тогда
			ТабДляЗаписи = ВОЛНА_ОбщегоНазначенияСервер.СоздатьЗапрос(
					"ВЫБРАТЬ Рег.* ИЗ РегистрСведений." + ИмяРегистра + " КАК Рег").Выполнить().Выгрузить();
			ВОЛНА_ОбщегоНазначенияСервер.ДобавитьЗаписиИзТаблицыВТаблицу(ТабЗнач, ТабДляЗаписи);
		КонецЕсли;
	КонецЕсли;
	Если ПоОдной Тогда
		Для каждого СтрокаТ Из ТабДляЗаписи Цикл
			ТекЗапись = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(ТекЗапись, СтрокаТ);
			ТекЗапись.Записать();
		КонецЦикла; 
	Иначе
		Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
		Набор.Загрузить(ТабДляЗаписи);
		Набор.Записать(Истина);
	КонецЕсли;
КонецПроцедуры // ЗагрузитьРСИзТаблицы

//!!!Похоже, не работает в модуле повтисп т.к. ругается на первый параметр (Тип):Несоответствие типов (параметр номер '1') (Неверный тип параметра. Допустимы только примитивные типы, ссылки, Структура)
//Функция продублирована сюда, но это по возможности надо исправить
//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//	Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//	Полностью - Булево или Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//		* ИмяТаблицы - Строка - Имя таблицы для запроса;
//		* Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//		* Метаданные - Объект метаданных - соответствующий объекту
//		* Менеджер - Менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//		Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//		Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение -  структура или строка -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
Функция ИмяТаблицыОбъектаПоТипу(Тип_, Полностью = Ложь) Экспорт
	МетаХ = Метаданные.НайтиПоТипу(Тип_);
	Если МетаХ = Неопределено Тогда
		Результат = Неопределено
	ИначеЕсли Полностью = "Метаданные" Тогда
		Результат = МетаХ;
	Иначе
		ТекИмя = МетаХ.Имя;
		Полная = Новый Структура;
		НуженМенеджер = (СтрНайти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
		Если Метаданные.Документы.Содержит(МетаХ) Тогда
			СтрокаТипа = "Документ";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Документы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
			СтрокаТипа = "Справочник";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Справочники[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Перечисления.Содержит(МетаХ) Тогда
			СтрокаТипа = "Перечисление";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Перечисления[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовХарактеристик";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланСчетов";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовРасчета";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
			СтрокаТипа = "БизнесПроцесс";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
			СтрокаТипа = "Задача";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Задачи[ТекИмя]);
			КонецЕсли; 
		Иначе
			Результат = "";
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, СтрНайти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
			Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Текст,") > 0) Тогда
			Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
			Полная.Вставить("Метаданные", МетаХ);
		КонецЕсли;
		Результат = Полная;
		Если Результат.Количество() = 1 Тогда
			Для каждого КиЗ Из Полная Цикл
				Результат = КиЗ.Значение;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

// Возвращает массив иерархии объекта. Первый элемент - сам объект, последний - высший родитель
// Параметры:
//  СсылочныйОбъект  - ЛюбаяСсылка с реквизитом Родитель - Объект, мерархию которого надо получить
// Возвращаемое значение:
//   Массив   - Ссылки на объект и по очереди все его родители
Функция МассивИерархии(СсылочныйОбъект) Экспорт
	Результат = Новый Массив;
	ИмяТаблицы = ИмяТаблицыОбъектаПоТипу(ТипЗнч(СсылочныйОбъект)); //ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
	Родитель = СсылочныйОбъект;
	Пока ЗначениеЗаполнено(Родитель) Цикл
		Результат.Добавить(Родитель);
		#Область ТЕКСТ_ЗАПРОСА
			Родитель = ВОЛНА_ОбщегоНазначенияСервер.ПолучитьЕдинственноеЗначениеЗапроса(ВОЛНА_ОбщегоНазначенияСервер.СоздатьЗапрос(
					СтрЗаменить(
						"ВЫБРАТЬ
						|	Банки.Родитель
						|ИЗ
						|	Справочник.Банки КАК Банки
						|ГДЕ
						|	Банки.Ссылка = &Ссылка", "Справочник.Банки", ИмяТаблицы), Новый Структура("Ссылка", Родитель)));
		#КонецОбласти 
	КонецЦикла;
	Возврат Результат
КонецФункции // МассивИерархии

//Сериализует заданное значение в XML
//Параметры:
//	Значение - Произвольный - Сериализуемое
// Возвращаемое значение:
//	Строка - XML текст
Функция ПолучитьXML(Значение) Экспорт
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(Запись, Значение);
	Возврат Запись.Закрыть();
КонецФункции

//Определяет имя метаданных значения перечисления
//Параметры:
//	ЗначениеПеречисления - ПеречислениеСсылка.* - Ссылка, по которой надо вернуть имя
//Возвращаемое значение:
//	Строка - Имя МД значения перечисления
Функция ПолучитьИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
	ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
	ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя  
КонецФункции

//Копирует отбор набора записей в отбор другого НЗ того же регистра
//Параметры:
//	Приёмник - Набор записей или иной объект, содержащий Отбор. - Объект для настройки отбора
//	Источник - Набор записей или иной объект, содержащий Отбор. - Откуда берётся отбор для настройки
Процедура СкопироватьОтборы(Приёмник, Источник) Экспорт
	Для каждого ЭлементОтбора_ из Источник.Отбор Цикл
		ЭлементПриёмник = Приёмник.Отбор.Найти(ЭлементОтбора_.Имя);
		ЭлементПриёмник.Использование = ЭлементОтбора_.Использование;
		ЭлементПриёмник.ВидСравнения = ЭлементОтбора_.ВидСравнения;
		ЭлементПриёмник.Значение = ЭлементОтбора_.Значение;
		ЭлементПриёмник.ЗначениеС = ЭлементОтбора_.ЗначениеС;
		ЭлементПриёмник.ЗначениеПо = ЭлементОтбора_.ЗначениеПо
	КонецЦикла
КонецПроцедуры

//Возвращает список значений с именами временных таблиц МВТ.
Функция СписокВременныхТаблиц(МВТ) Экспорт
	Результат = Новый СписокЗначений;
	Если ТипЗнч(МВТ) = Тип("МенеджерВременныхТаблиц") Тогда
		Для каждого ВТаб Из МВТ.Таблицы Цикл
			Результат.Добавить(ВТаб.ПолноеИмя, ВТаб.ПолноеИмя);
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции // СписокВременныхТаблиц()

#КонецОбласти

#Область БИБЛИОТЕКА_ФУНКЦИЙ_КЛИЕНТСЕРВЕР

#Область ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//	ТекстКодаПараметр - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//	ПрямоеОбращение - Строка, Массив - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//			"-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//	Журнал - Булево - Выполнять в попытке и ошибку записать в журнал. Не используется на клиенте.
//	ИмяПроцесса - Строка - Параметр записи журнала. Не используется на клиенте.
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке. Не используется на клиенте.
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКод(
		ТекстКодаПараметр,
		Прм = Неопределено, 
		Результат = Неопределено,
		РежимВычисления = Ложь,
		ПрямоеОбращение = "-В",
		Журнал = Ложь,
		ИмяПроцесса = "",
		ПрефиксОшибки = "") Экспорт
	ТекстКода_ = ДобавитьПараметрыВВыполняемыйКод(?(РежимВычисления, "Результат = ", "") + ТекстКодаПараметр, Прм);
	ЭтоСервер = МестоВыполненияКода(Истина) = "Сервер";
	Если ЭтоСервер И Журнал Тогда
		Попытка
			Выполнить(ТекстКода_);
		Исключение
			Результат = ОписаниеОшибки();
			Выполнить("ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ПрефиксОшибки + Результат)");
		КонецПопытки;
	Иначе
		Выполнить(ТекстКода_);
	КонецЕсли;
	Возврат Результат
КонецФункции

// Добавляет в выполняемый код параметы из структуры для использования напрямую, как переменные
// Параметры:
//  ТекстКодаПараметр  - Строка - Выполняемый код
//	СтрПараметров - Структура - Параметры, добавляемые в код. Допускается использование строки таблицы значений, но только если указан ДобавитьТолькоЭтиКлючи
//	ВКонцеВернутьКакБыло - Булево - В конце кода вернуть значения в структуру. По умолчанию Истина
//	ДобавитьТолькоЭтиКлючи - Строка/Массив  - Через запятую ключи, которые надо добавить. По умолчанию "-В" = Все ключи
// Возвращаемое значение:
//   Строка   - Исправленный код
Функция ДобавитьПараметрыВВыполняемыйКод(ТекстКодаПараметр, СтрПараметров, ВКонцеВернутьКакБыло = Истина, ДобавитьТолькоЭтиКлючи = "-В") Экспорт
	Результат = ТекстКодаПараметр;
	ТипПрм = ТипЗнч(СтрПараметров);
	Если (ТипПрм = Тип("Структура")) ИЛИ (ТипПрм = Тип("ФиксированнаяСтруктура")) ИЛИ Строка(ТипПрм) + "СтрокаТаблицыЗначений" Тогда
		Если ДобавитьТолькоЭтиКлючи = "-В" Тогда
			МассивКлючей = Новый Массив;
			Для каждого КиЗ Из СтрПараметров Цикл
				МассивКлючей.Добавить(КиЗ.Ключ);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ДобавитьТолькоЭтиКлючи) = Тип("Массив") Тогда
			МассивКлючей = ДобавитьТолькоЭтиКлючи;
		Иначе
			МассивКлючей = СтрРазделить(ДобавитьТолькоЭтиКлючи, ",", Ложь);
		КонецЕсли;
		Для каждого Ключ_ Из МассивКлючей Цикл
			Результат = Ключ_ + " = Прм[""" + Ключ_ + """];" + Результат + ?(ВКонцеВернутьКакБыло, ";Прм[""" + Ключ_ + """] = " + Ключ_, ";");
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДобавитьПараметрыВВыполняемыйКод

// Удаляет из текста запроса уничтожение ВТ
// Параметры:
//  ТекстЗапроса  - Строка - Исходный текст запроса
//  Исключения  - Строка - Имена таблиц, уничтожение которых отменять не надо (через запятую). По умолчанию ""
// Возвращаемое значение:
//   Строка   - Текст запроса без уничтожений ВТ
Функция ОтменитьУничтожения(ТекстЗапроса, Исключения = "") Экспорт
	ВесьТекстЗагл = ВРег(ТекстЗапроса);
	ЭтоНачалоЗапроса = Истина;
	Результат = "";
	ДопустимыеСимволыИмени = СимволыГруппы("ДляПеремВсеЗагл");
	ДопустимыйПервый = СимволыГруппы("ДляПерем1Загл");
	ВзятьЭтуПодстроку = Истина;
	УсловноеНачало = "";
	//Цикл по строкам текста запроса
	Для СчСтрТ = 1 По СтрЧислоСтрок(ВесьТекстЗагл) Цикл
		ТекСтрокаЗапроса = СтрПолучитьСтроку(ТекстЗапроса, СчСтрТ);
		ТекСтрокаЗагл = СтрПолучитьСтроку(ВесьТекстЗагл, СчСтрТ);
		ПоложениеКоммента = СтрНайти(ТекСтрокаЗагл, "//");
		ДлинаТекСтроки = СтрДлина(ТекСтрокаЗагл);
		Если ПоложениеКоммента = 0 Тогда
			ПоложениеКоммента = ДлинаТекСтроки + 1;
		КонецЕсли; 
		ТекСтрокаЗагл = СтрЗаменить(Лев(ТекСтрокаЗагл, ПоложениеКоммента - 1), ";", Символы.ПС);
		СчДл = 0;
		РезультатПоСтроке = "";
		КолвоЗапросовВСтроке = СтрЧислоВхождений(ТекСтрокаЗагл, Символы.ПС) + 1;//Именно так! СтрЧислоСтрок(ТекСтрокаЗагл); даёт ошибку!
		СчЗапросов = 0;
		//Цикл по запросам (фрагментам между ;) внутри строки
		Пока СчЗапросов < КолвоЗапросовВСтроке Цикл
			СчЗапросов = СчЗапросов + 1;
			ЭтаПодстрока = СтрПолучитьСтроку(ТекСтрокаЗагл, СчЗапросов);// + ";";//?(СчЗапросов = КолвоЗапросовВСтроке, "", ";");
			ДлинаЭтойПодстроки = СтрДлина(ЭтаПодстрока);
			Если ДлинаЭтойПодстроки + СчДл >= ПоложениеКоммента Тогда
				ДлинаЭтойПодстроки = ПоложениеКоммента - 1 - СчДл;
				ЭтаПодстрока = Лев(ЭтаПодстрока, ДлинаЭтойПодстроки);
				КолвоЗапросовВСтроке = СчЗапросов; //Завершение цикла
			КонецЕсли;
			ПрошлаяСтрокаЗакончиласьПСПослеУничтожить = УсловноеНачало <> "";
			//Похоже, ЭтоНачалоЗапроса пытались убирать из этого условия. Это нельзя делать, иначе все ; пропадут
			//ВзятьЭтуПодстроку нужно, чтобы после УНИЧТОЖИТЬ не брались строки до конца запроса, когда будет СчЗапросов > 1.
			Если ВзятьЭтуПодстроку ИЛИ (СчЗапросов > 1) ИЛИ ПрошлаяСтрокаЗакончиласьПСПослеУничтожить ИЛИ ЭтоНачалоЗапроса Тогда
				ВзятьЭтуПодстроку = Истина;
				Если ПустаяСтрока(ЭтаПодстрока) Тогда
					Если КолвоЗапросовВСтроке = 1 Тогда
						Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
							УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
						КонецЕсли;
					Иначе
						ЭтоНачалоЗапроса = Истина;
						Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
							РезультатПоСтроке = РезультатПоСтроке + УсловноеНачало;
							УсловноеНачало = "";
						КонецЕсли;
					КонецЕсли;
				Иначе
					ДоУничтожитьЧисто = Ложь;
					Если ЭтоНачалоЗапроса Тогда
						ЕстьОтступПослеУничтожить = Ложь;//Скорректируется позже, это инициализация
						ПолУн = СтрНайти(ЭтаПодстрока, "УНИЧТОЖИТЬ");
						ДоУничтожитьЧисто = ПустаяСтрока(Лев(ЭтаПодстрока, ПолУн - 1));
					ИначеЕсли ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
						ДоУничтожитьЧисто = Истина;
						ЕстьОтступПослеУничтожить = Истина;
						ПолУн = - 9;
					КонецЕсли;
					Если ДоУничтожитьЧисто Тогда
						ТекСимвол = "";
						Для Ё = ПолУн + 10 По ДлинаЭтойПодстроки Цикл
							ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
							Если НЕ ПустаяСтрока(ТекСимвол) Тогда
								Прервать;
							КонецЕсли;
							ЕстьОтступПослеУничтожить = Истина;
						КонецЦикла;
						Если ЕстьОтступПослеУничтожить Тогда
							Если (Ё > ДлинаЭтойПодстроки) И (КолвоЗапросовВСтроке = СчЗапросов) Тогда
								УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
								ВзятьЭтуПодстроку = Ложь;
							ИначеЕсли СтрНайти(ДопустимыйПервый, ТекСимвол) > 0 Тогда
								ПозНачалаИмени = Ё;
								Пока Истина Цикл
									Ё = Ё + 1;
									ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
									Если (ТекСимвол = "") ИЛИ (СтрНайти(ДопустимыеСимволыИмени, ТекСимвол) = 0) Тогда
										Прервать;
									КонецЕсли;
								КонецЦикла;
								Если ПустаяСтрока(Сред(ЭтаПодстрока, Ё, ДлинаЭтойПодстроки - Ё + 1)) Тогда
									ИмяВТ = Сред(ЭтаПодстрока, ПозНачалаИмени, Ё - ПозНачалаИмени);
									Если НайтиПодСтроку(Исключения, ИмяВТ) = 0 Тогда
										ВзятьЭтуПодстроку = Ложь;
										УсловноеНачало = "";
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					ЭтоНачалоЗапроса = КолвоЗапросовВСтроке > СчЗапросов;
				КонецЕсли;
			КонецЕсли;
			Если ВзятьЭтуПодстроку Тогда
				РезультатПоСтроке = РезультатПоСтроке + ";" + УсловноеНачало + Сред(ТекСтрокаЗапроса, СчДл, ДлинаЭтойПодстроки);// + ";"
			КонецЕсли;
			СчДл = СчДл + ДлинаЭтойПодстроки + 1;
		КонецЦикла;
		Результат = Результат + Символы.ПС + Сред(РезультатПоСтроке, 2) + Сред(ТекСтрокаЗапроса, ПоложениеКоммента, ДлинаТекСтроки);//после ПоложениеКоммента было -1 - убрал, должен же браться коммент
	КонецЦикла;
	Возврат Сред(Результат, 2)
КонецФункции // ОтменитьУничтожения
 
//Генерит ошибку для запуска конфигуратора
Процедура ПерейтиВКонфигуратор() Экспорт
	Ы = 1/0
КонецПроцедуры

#Конецобласти

#Область ДАТЫ_И_ПЕРИОДЫ
	
// Возвращает граничную дату по варианту СДН или СП. Аналог обращений СтандартнаяДатаНачала.Дата или СтандартныйПериод.ДатаОкончания,
//но дляотсчёта от несегодня СДП и СДН неприменимы.
// Параметры:
//  ДатаОтсчёта  - Дата - Дата отсчёта для вычисления периода
//	Вариант - ВариантСтандартнойДатыНачала/ВариантСтандартногоПериода - вариант из СДП или СДН, применяемый к ДатаОтсчёта
//	Начало - Неопределено/Булево - При Истина возращается дата начала периода. При Ложь - возвращается конец.
//			По умолчанию Неопределено - возвращается структура с ключами Дата1 и Дата2.
//			Для СДН Конец = Дата-1, начало = Дата, т.е. Конец < Начало.
// Возвращаемое значение:
//   Дата   - Найденная граничная дата
Функция ДатаПоВарианту(ДатаОтсчёта, Вариант, Начало = Неопределено) Экспорт
	Результат = ?(Начало, '00000000', '39991231235959');
	Если Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоГода Тогда
		Дата1 = Дата(Год(ДатаОтсчёта) - 1, 1, 1);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоДня Тогда
		Дата1 = НачалоДня(ДатаОтсчёта - 24 * 3600);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоКвартала Тогда
		Дата1 = ДобавитьМесяц(НачалоКвартала(ДатаОтсчёта), -3);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоМесяца Тогда
		Дата1 = ДобавитьМесяц(НачалоМесяца(ДатаОтсчёта), -1);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоПолугодия Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -6);
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойДекады Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойНедели Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоГода Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоКвартала Тогда
		Дата2 = КонецКвартала(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоМесяца Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоПолугодия Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -6);
		КонецЕсли;
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейДекады Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		КонецЕсли;
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейНедели Тогда
		Дата2 = КонецНедели(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоГода Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоДня Тогда
		Дата1 = НачалоДня(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоКвартала Тогда
		Дата1 = НачалоКвартала(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоМесяца Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоПолугодия Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата1 = ДобавитьМесяц(ДатаОтсчёта, 6);
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойДекады Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) > 10 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойНедели Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.ПроизвольнаяДата Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Вчера Тогда
		Дата2 = НачалоДня(ДатаОтсчёта) - 1;
		Дата1 = НачалоДня(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоГода Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецГода(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоКвартала Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецКвартала(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоМесяца Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецМесяца(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоПолугодия Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойДекады Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойНедели Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецНедели(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Завтра Тогда
		Дата1 = КонецДня(ДатаОтсчёта) + 1;
		Дата2 = КонецДня(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Месяц Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = ДобавитьМесяц(Дата2, -1) + 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Последние7Дней Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = Дата2 + 1 - 7 * 24 * 3600;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = ДатаОтсчёта;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = Дата1 - 1;
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		Иначе
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекадаДоТакогоЖеНомераДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = Дата2 - 10 * 24 * 3600;
		Иначе
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата2 - 10 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделя Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата2 = КонецНедели(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделяДоТакогоЖеДняНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодие Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -6);
		КонецЕсли;
		Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодиеДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), -6);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГод Тогда
		Дата2 = НачалоГода(ДатаОтсчёта) - 1;
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГодДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -12));
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКвартал Тогда
		Дата2 = НачалоКвартала(ДатаОтсчёта) - 1;
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКварталДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -3));
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяц Тогда
		Дата2 = НачалоМесяца(ДатаОтсчёта) - 1;
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяцДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -1));
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Сегодня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоДня(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = КонецМесяца(ДатаОтсчёта);
		Иначе
			Дата2 = КонецМесяца(ДатаОтсчёта) + 10 * 24 * 3600 - 1;
			Дата1 = ДобавитьМесяц(Дата1, 1);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекадаДоТакогоЖеНомераДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата2 + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = Дата2 + 10 * 24 * 3600;
		Иначе
			Дата1 = ДобавитьМесяц(Дата1, 1);
			Дата2 = ДобавитьМесяц(Дата2, 1) - 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделя Тогда
		Дата1 = КонецНедели(ДатаОтсчёта) + 1;
		Дата2 = КонецНедели(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделяДоТакогоЖеДняНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта) + 7 * 24 * 3600;
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодие Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата2 = ДобавитьМесяц(Дата2, 6);
		КонецЕсли;
		Дата1 = ДобавитьМесяц(Дата1 + 1, -6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодиеДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 6);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Следующие7Дней Тогда
		Дата1 = НачалоДня(ДатаОтсчёта);
		Дата2 = Дата1 + 7 * 24 * 3600 - 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГод Тогда
		Дата1 = КонецГода(ДатаОтсчёта)+ 1;
		Дата2 = КонецГода(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГодДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, 12));
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКвартал Тогда
		Дата1 = КонецКвартала(ДатаОтсчёта) + 1;
		Дата2 = КонецКвартала(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКварталДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 3);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяц Тогда
		Дата1 = КонецМесяца(ДатаОтсчёта) + 1;
		Дата2 = КонецМесяца(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяцДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 1);
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоГода Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоКвартала Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоМесяца Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоПолугодия Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойДекады Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		Иначе
			Дата1 = Дата1 + 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		Иначе
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = КонецМесяца(Дата1);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаНеделя Тогда
		Дата2 = КонецНедели(ДатаОтсчёта);
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтоПолугодие Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
		Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотГод Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотКвартал Тогда
		Дата2 = КонецКвартала(ДатаОтсчёта);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотМесяц Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Дата1 = НачалоМесяца(Дата2);
	Иначе
		Дата1 = ДатаОтсчёта;
		Дата2 = ДатаОтсчёта;
	КонецЕсли;
	Возврат ?(Начало = Неопределено, Новый Структура("Дата1,Дата2", Дата1, Дата2), ?(Начало, Дата1, Дата2));
КонецФункции // ДатаПоВарианту

// Возвращает текущую дату клиента или сервера
// Параметры:
//  Универсальная  - Булево - На сервере вернуть униврсальную дату. Ложь (по умолчанию) с сервера возвратит дату сеанса
// Возвращаемое значение:
//   Дата   - Текущая дата клиента или сервера
Функция ЗасечьВремя(Универсальная = Ложь) Экспорт
	Если МестоВыполненияКода(Истина) = "Клиент" Тогда
		Результат = ТекущаяДата();
	Иначе
		Если Универсальная Тогда
			Код = "ТекущаяУниверсальнаяДата()";
		Иначе
			Код = "ТекущаяДатаСеанса()";
		КонецЕсли;
		Результат = Вычислить(Код);
	КонецЕсли;
	Возврат Результат
КонецФункции // ЗасечьВремя

// Возвращает соответствие месяца номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения первая заглавная), Истина = Ключи = Строки (ВРЕГ), строки всегда без предлогов
//   Формат_ - Строка -
//			*В среду
//          *Все (только для КлючСтрокаЗначениеЧисло = Истина)
//          *Все среды
//			*До среды
//			*К среде
//			*По средам
//			*Среда (по умолчанию)
// Возвращаемое значение:
//   Соответствие   - месяцев и их номеров
Функция СоответствиеДнейНедели(КлючСтрокаЗначениеЧисло = Ложь, Формат_ = "Среда") Экспорт
	Результат = Новый Соответствие;
	Если КлючСтрокаЗначениеЧисло Тогда
		Если Формат_ = "Среда" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
			Результат.Вставить("ВТОРНИК", 2);
			Результат.Вставить("СРЕДА", 3);
			Результат.Вставить("ЧЕТВЕРГ", 4);
			Результат.Вставить("ПЯТНИЦА", 5);
			Результат.Вставить("СУББОТА", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
		КонецЕсли;
		Если Формат_ = "По средам" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКАМ", 1);
			Результат.Вставить("ВТОРНИКАМ", 2);
			Результат.Вставить("СРЕДАМ", 3);
			Результат.Вставить("ЧЕТВЕРГАМ", 4);
			Результат.Вставить("ПЯТНИЦАМ", 5);
			Результат.Вставить("СУББОТАМ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯМ", 7);
		КонецЕсли;
		Если Формат_ = "В среду" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
			Результат.Вставить("ВТОРНИК", 2);
			Результат.Вставить("СРЕДУ", 3);
			Результат.Вставить("ЧЕТВЕРГ", 4);
			Результат.Вставить("ПЯТНИЦУ", 5);
			Результат.Вставить("СУББОТУ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
		КонецЕсли;
		Если Формат_ = "До среды" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКА", 1);
			Результат.Вставить("ВТОРНИКА", 2);
			Результат.Вставить("СРЕДЫ", 3);
			Результат.Вставить("ЧЕТВЕРГА", 4);
			Результат.Вставить("ПЯТНИЦЫ", 5);
			Результат.Вставить("СУББОТЫ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
		КонецЕсли;
		Если Формат_ = "К среде" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКУ", 1);
			Результат.Вставить("ВТОРНИКУ", 2);
			Результат.Вставить("СРЕДЕ", 3);
			Результат.Вставить("ЧЕТВЕРГУ", 4);
			Результат.Вставить("ПЯТНИЦЕ", 5);
			Результат.Вставить("СУББОТЕ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЮ", 7);
		КонецЕсли;
		Если Формат_ = "Все среды" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКИ", 1);
			Результат.Вставить("ВТОРНИКИ", 2);
			Результат.Вставить("СРЕДЫ", 3);
			Результат.Вставить("ЧЕТВЕРГИ", 4);
			Результат.Вставить("ПЯТНИЦЫ", 5);
			Результат.Вставить("СУББОТЫ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
		КонецЕсли;
	Иначе
		Если Формат_ = "Среда" Тогда
			Результат.Вставить(1, "Понедельник");
			Результат.Вставить(2, "Вторник");
			Результат.Вставить(3, "Среда");
			Результат.Вставить(4, "Четверг");
			Результат.Вставить(5, "Пятница");
			Результат.Вставить(6, "СУббота");
			Результат.Вставить(7, "Воскресенье");
		ИначеЕсли Формат_ = "По средам" Тогда
			Результат.Вставить(1, "Понедельникам");
			Результат.Вставить(2, "Вторникам");
			Результат.Вставить(3, "Средам");
			Результат.Вставить(4, "Четвергам");
			Результат.Вставить(5, "Пятницам");
			Результат.Вставить(6, "СУбботам");
			Результат.Вставить(7, "Воскресеньям");
		ИначеЕсли Формат_ = "В среду" Тогда
			Результат.Вставить(1, "Понедельник");
			Результат.Вставить(2, "Вторник");
			Результат.Вставить(3, "Среду");
			Результат.Вставить(4, "Четверг");
			Результат.Вставить(5, "Пятницу");
			Результат.Вставить(6, "СУбботу");
			Результат.Вставить(7, "Воскресенье");
		ИначеЕсли Формат_ = "До среды" Тогда
			Результат.Вставить(1, "Понедельника");
			Результат.Вставить(2, "Вторника");
			Результат.Вставить(3, "Среды");
			Результат.Вставить(4, "Четверга");
			Результат.Вставить(5, "Пятницы");
			Результат.Вставить(6, "СУбботы");
			Результат.Вставить(7, "Воскресенья");
		ИначеЕсли Формат_ = "К среде" Тогда
			Результат.Вставить(1, "Понедельнику");
			Результат.Вставить(2, "Вторнику");
			Результат.Вставить(3, "Среде");
			Результат.Вставить(4, "Четвергу");
			Результат.Вставить(5, "Пятнице");
			Результат.Вставить(6, "СУбботе");
			Результат.Вставить(7, "Воскресенью");
		ИначеЕсли Формат_ = "Все среды" Тогда
			Результат.Вставить(1, "Понедельники");
			Результат.Вставить(2, "Вторники");
			Результат.Вставить(3, "Среды");
			Результат.Вставить(4, "Четверги");
			Результат.Вставить(5, "Пятницы");
			Результат.Вставить(6, "СУбботы");
			Результат.Вставить(7, "Воскресенья");
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СоответствиеМесяцев

// Возвращает соответствие месяца номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения Первая Заглавная), Истина = Ключи = Строки (ВРЕГ)
//   Родительный - Булево/Неопределено -
//			Неопределено (по умолч) = для КлючСтрокаЗначениеЧисло = Истина = оба, КлючСтрокаЗначениеЧисло = Ложь = аналогично Ложь;
//			Ложь = Строка в именительном падеже,
//			Истина = Строка в родительном падеже
// Возвращаемое значение:
//   Соответствие   - месяцев и их номеров
Функция СоответствиеМесяцев(КлючСтрокаЗначениеЧисло = Ложь, Родительный = Неопределено) Экспорт
	Результат = Новый Соответствие;
	Если КлючСтрокаЗначениеЧисло Тогда
		Если Родительный <> Истина Тогда
			Результат.Вставить("ЯНВАРЬ", 	1);
			Результат.Вставить("ФЕВРАЛЬ", 2);
			Результат.Вставить("МАРТ", 	3);
			Результат.Вставить("АПРЕЛЬ", 	4);
			Результат.Вставить("МАЙ", 	5);
			Результат.Вставить("ИЮНЬ", 	6);
			Результат.Вставить("ИЮЛЬ", 	7);
			Результат.Вставить("АВГУСТ", 	8);
			Результат.Вставить("СЕНТЯБРЬ", 9);
			Результат.Вставить("ОКТЯБРЬ", 10);
			Результат.Вставить("НОЯБРЬ", 	11);
			Результат.Вставить("ДЕКАБРЬ", 12);
		КонецЕсли;
		Если Родительный <> Ложь Тогда
			Результат.Вставить("ЯНВАРЯ", 	1);
			Результат.Вставить("ФЕВРАЛЯ", 2);
			Результат.Вставить("МАРТА", 	3);
			Результат.Вставить("АПРЕЛЯ", 	4);
			Результат.Вставить("МАЯ", 	5);
			Результат.Вставить("ИЮНЯ", 	6);
			Результат.Вставить("ИЮЛЯ", 	7);
			Результат.Вставить("АВГУСТА", 	8);
			Результат.Вставить("СЕНТЯБРЯ", 9);
			Результат.Вставить("ОКТЯБРЯ", 10);
			Результат.Вставить("НОЯБРЯ", 	11);
			Результат.Вставить("ДЕКАБРЯ", 12);
		КонецЕсли;
	Иначе
		Если Родительный = Истина Тогда
			Результат.Вставить(1, "Января");
			Результат.Вставить(2, "Февраля");
			Результат.Вставить(3, "Марта");
			Результат.Вставить(4, "Апреля");
			Результат.Вставить(5, "Мая");
			Результат.Вставить(6, "Июня");
			Результат.Вставить(7, "Июля");
			Результат.Вставить(8, "Августа");
			Результат.Вставить(9, "Сентября");
			Результат.Вставить(10, "Октября");
			Результат.Вставить(11, "Ноября");
			Результат.Вставить(12, "Декабря");
		Иначе
			Результат.Вставить(1, "Январь");
			Результат.Вставить(2, "Февраль");
			Результат.Вставить(3, "Март");
			Результат.Вставить(4, "Апрель");
			Результат.Вставить(5, "Май");
			Результат.Вставить(6, "Июнь");
			Результат.Вставить(7, "Июль");
			Результат.Вставить(8, "Август");
			Результат.Вставить(9, "Сентябрь");
			Результат.Вставить(10, "Октябрь");
			Результат.Вставить(11, "Ноябрь");
			Результат.Вставить(12, "Декабрь");
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СоответствиеМесяцев

#КонецОбласти

#Область ЗАПРОСЫ

#Область ТЕКСТЫ_ЗАПРОСОВ

// Возвращает текст запроса к таблице регистра с фильтрацией
// Параметры:
//  ИмяМенеджераРегистра  - Строка - Имя регистра в формате РегистрыСведений.АдресныеСведения
//  Фильтр  - Строка - Фильтр ТабРегистра с ГДЕ.
//  ИмяВТ  - Строка - Имя ВТ результата. По умолчанию выборка данных.
//  ПоляВзять  - Строка - Через запятую имена полей результата. По умолчанию все поля.
//  ПоляНеБрать  - Строка - Через запятую поля, исключаемые из результата. По умолчанию без исключений.
// Возвращаемое значение:
//   Строка   - Текст запроса
Функция ТекстЗапросаДанныеРегистра(ИмяМенеджераРегистра, Фильтр = "", ИмяВТ = "", ПоляВзять = "", ПоляНеБрать = "") Экспорт
	Результат = "ВЫБРАТЬ" + Символы.ПС;
	ПоляВсе = СтруктураЗаписиРегистра(ИмяМенеджераРегистра);
	ЕстьВзять = ЗначениеЗаполнено(ПоляВзять);
	ЕстьНеБрать = ЗначениеЗаполнено(ПоляНеБрать);
	Для каждого КиЗ_Поле Из ПоляВсе Цикл
		Если ЕстьВзять Тогда
			Если НайтиПодСтроку(ПоляВзять, КиЗ_Поле.Ключ) = 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если ЕстьНеБрать Тогда
			Если НайтиПодСтроку(ПоляНеБрать, КиЗ_Поле.Ключ) <> 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + "	ТабРегистра." + КиЗ_Поле.Ключ + "," + Символы.ПС;
	КонецЦикла;
	Результат = Лев(Результат, СтрДлина(Результат) - 2) + Символы.ПС + ?(ЗначениеЗаполнено(ИмяВТ), "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС, "")
			+ "ИЗ " + СтрЗаменить(ИмяМенеджераРегистра, "Регистры", "Регистр") + " КАК ТабРегистра" + Символы.ПС + Фильтр;
	Возврат Результат
КонецФункции // ТекстЗапросаДанныеРегистра

// Создаёт текст запроса, возвращающего числа от А до Б включительно в ВТ Числа
// Параметры:
//  ЧислоА  - Число - Первое число возвращаемого интервала
//  ЧислоБ  - Число - Последнее число возвращаемого интервала
// Возвращаемое значение:
//   Строка   - Текст запроса
Функция ТекстЗапросаСчётчик(ЧислоА, ЧислоБ) Экспорт
	Чисел = ЧислоБ - ЧислоА + 1;
	Степень = Цел(Log10(Чисел)) + 1;
	Соединения = "Цифры" + Степень + Символы.ПС;
	Вычисления = "";
	Множитель = 1;
	
	Для Ё = 1 По Степень Цикл
		Вычисления = Вычисления + " + " + Множитель + " * Цифры" + Ё + ".Цифра";
		Множитель = Множитель * 10;
	КонецЦикла;
	Для Ё = 1 По Степень - 1 Цикл
		Соединения = Соединения + "ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры" + (Степень - Ё) + "
				|		ПО (ИСТИНА)
				|";
		Множитель = Множитель * 10;
	КонецЦикла;
	
	Результат = "ВЫБРАТЬ
	            |	0 КАК Цифра
	            |ПОМЕСТИТЬ Цифры
	            |";
	Для Ё = 1 По 9 Цикл
		Результат = Результат + "ОБЪЕДИНИТЬ ВСЕ
	            |
	            |ВЫБРАТЬ
	            |	" + Ё + "
	            |
	            |"
	КонецЦикла;
	Результат = Результат + ";
	            |
	            |////////////////////////////////////////////////////////////////////////////////
	            |" + 
				СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
				"ВЫБРАТЬ
                |	&ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра КАК Число
                |ПОМЕСТИТЬ Числа
                |ИЗ
                |	(ВЫБРАТЬ
                |		Цифры.Цифра КАК Цифра
                |	ИЗ
                |		Цифры КАК Цифры
                |	ГДЕ
                |		Цифры.Цифра <= &ПерваяЦифраБ) КАК Цифры3
                |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
                |		ПО (ИСТИНА)
                |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
                |		ПО (ИСТИНА)
                |ГДЕ
                |	&ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра <= &ЧислоБ",
				"&ЧислоА", ЧислоА),
				"&ЧислоБ", ЧислоБ),
				"&ПерваяЦифраБ", Лев(Чисел, 1)),
				"Цифры3
					|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
					|		ПО (ИСТИНА)
					|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
					|		ПО (ИСТИНА)", Соединения),
				" + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра", Вычисления) +
				";
				|
				|////////////////////////////////////////////////////////////////////////////////
				|УНИЧТОЖИТЬ Цифры
				|;";
	Возврат Результат
КонецФункции // ТекстЗапросаСчётчик

#КонецОбласти

#КонецОбласти

#Область КОЛЛЕКЦИИ

#Область ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
	
//Возвращает количество элементов коллекции-параметра, а если параметр - не коллекция, то
//	* -2, если значение - пустая ссылка
//	* -1 - иначе
//Параметры:
//	Коллекция - Произвольная коллекция - Кого посчитают :)
Функция КоличествоКоллекции(Коллекция) Экспорт
	Попытка
		КолвоПараметров = Коллекция.Количество();
	Исключение
		КолвоПараметров = -1;
		Попытка
			Если Коллекция.Пустая() Тогда КолвоПараметров = -2 КонецЕсли
		Исключение
		КонецПопытки;
	КонецПопытки;
	Возврат КолвоПараметров
КонецФункции

// Выгружает колонку коллекции (не обязательно ТЗ!) в строку с разделителями. Можно использовать, например, для получения строки для Свернуть.
// Параметры:
//  Коллекция		- любая коллекция с колонками (реквизитами строк) - источник данных
//  ИмяРеквизита	- строка - имя реквизита, из которого будет сформирована строка
//  Разделитель		- любое значение, преобразуемое в строку - разделитель для строки-результата
// Возвращаемое значение:
//   Строка   - строка с разделителями, содержащая представления заданного реквизита строк
Функция КолонкуКоллекцииВСтрокуСРазделителями(Коллекция, ИмяРеквизита, Разделитель = ",") Экспорт
	Результат = "";
	Для каждого Строчка Из Коллекция Цикл
		Результат = Результат + Разделитель + Строчка[ИмяРеквизита];
	КонецЦикла;
	Возврат Сред(Результат, СтрДлина(Разделитель) + 1);
КонецФункции // КолонкуКоллекцииВСтрокуСРазделителями()
 
//Удаляет заданные элементы из коллекции
//Параметры:
//	пКоллекция - Произвольная коллекция - откуда удалить элементы
//	пмЛишниеСтроки - Массив - Удаляемые элементы
Процедура УдалитьЛишниеСтроки(пКоллекция, пмЛишниеСтроки) Экспорт
	Для каждого ТекСтрока Из пмЛишниеСтроки Цикл
		пКоллекция.Удалить(ТекСтрока);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти 

#Область МАССИВЫ

// Добавляет значение в массив, если его там нет
// Параметры:
//  Приёмник  - Массив - куда добавляется значение
//  Значение  - Произвольное - что добавляется в массив
//  Индекс  - Число - куда вставлять, -1 (по умолчанию) - в конец
// Возвращаемое значение:
//   Значение было добавлено   - Булево
Функция ДобавитьВМассивЕслиЕщёНет(Приёмник, Значение, Индекс = -1) Экспорт
	Результат = Приёмник.Найти(Значение) = Неопределено;
	Если Результат Тогда
		Если Индекс = -1 Тогда
			Приёмник.Добавить(Значение);
		Иначе
			Приёмник.Вставить(Индекс, Значение);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДобавитьВМассивЕслиЕщёНет

// Дополняет массив, добавляя элементы в заданную позицию
// Параметры:
//  Приемник - Массив - Приёмник. Если не задан - будет создан новый
//  Источник - Массив - Источник. Если не задан - ничего добавлено не будет
//  Позиция - Число - Позиция вставки элементов. Отрицательные = позиция с конца. Минус один (по умолчанию) = добавление.
//  БезДублей - Булево - По умолчанию Ложь. Уже существующие дубли не проверяются.
//  ОбратныйПорядок - Булево - зачения будут вставлены в обратном порядке
// Возвращаемое значение:
//   Массив   - из параметра Приёмник или новый
Функция ДополнитьМассив(Приемник = Неопределено, Источник = Неопределено, Позиция = -1, БезДублей = Ложь, ОбратныйПорядок = Ложь) Экспорт
	Результат = ?(Приемник = Неопределено, Новый Массив, Приемник);
	БылоЭлементов = Результат.Количество();
	ТекПозПриемника = ?(Позиция < 0, Макс(Позиция + БылоЭлементов + 1, 0), Мин(Позиция, БылоЭлементов));
	Если ЗначениеЗаполнено(Источник) Тогда
		МаксИндексИсточника = Источник.ВГраница();
		Для Сч = 0 По МаксИндексИсточника Цикл
			ТекПозИсточника = ?(ОбратныйПорядок, МаксИндексИсточника - Сч, Сч);
			Если Не БезДублей ИЛИ Результат.Найти(Источник[ТекПозИсточника]) = Неопределено Тогда
				Если ТекПозПриемника = БылоЭлементов Тогда
					Результат.Добавить(Источник[ТекПозИсточника]);
				Иначе
					Результат.Вставить(Источник[ТекПозИсточника], ТекПозПриемника);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДополнитьМассив

//Аналог ВыгрузитьКолонку для коллекций, не поддерживающих ВыгрузитьКолонку
//Параметры:
//	  Коллекция - Произвольная коллекция, имеющая колонки у элементов - источник данных
//	  ИмяВыгружаемойКолонки - Строка - Имя выгружаемой колонки
//Возвращаемое значение:
//	  Массив - Значения из выгружаемой колонки
Функция КолонкуКоллекцииВМассив(Коллекция, ИмяВыгружаемойКолонки) Экспорт
	Результат = Новый Массив;
	Для каждого Элемент из Коллекция Цикл
		Результат.Добавить(Элемент[ИмяВыгружаемойКолонки])
	КонецЦикла;
	Возврат Результат
КонецФункции

//Проверяет, является ли параметр массивом, и если не является преобразует его в массив с единственным значением
//Параметры:
//	Что - Произвольное значение - источник данных
//	ПеределатьВМассивЕслиКоллекция - Булево - Если Истина, элементы коллекции из параметра Что будут добавлены в результат.
//		Д.б. установлена, если надо сложить два массива. При Ложь значение Что будет добавлено в конец массива. По умолчанию Ложь.
//	ПеременнаяДляПолученияРезультата - Произвольный - Переменная, в которую будет передано возвращаемое значение,
//		если невозможно исползовать как функцию. Сюда же передаётся начальный массив, к которому будут добавлены значения.
//		Если в эту переменную передать не массив, значение будет потеряно.
//	БратьЗначение - Булево - При Ложь (по умолчанию) в массив загружается весь элемент коллекции, при Истина - его значение
//Возвращаемое значение:
//	Массив - Массив из ПеременнаяДляПолученияРезультата, или новый массив
Функция ПреобразоватьВМассив(Что, ПеределатьВМассивЕслиКоллекция = Ложь, ПеременнаяДляПолученияРезультата = Неопределено, БратьЗначение = Ложь) Экспорт
	ТипМассив = Тип("Массив");
	Если ТипЗнч(ПеременнаяДляПолученияРезультата) <> ТипМассив Тогда
		ПеременнаяДляПолученияРезультата = Новый Массив;
	КонецЕсли;
	Результат = ПеременнаяДляПолученияРезультата;
	Если ПеределатьВМассивЕслиКоллекция Тогда
		Попытка
			Для каждого Элемент_ Из Что Цикл
				Результат.Добавить(?(БратьЗначение, Элемент_.Значение, Элемент_));
			КонецЦикла;
		Исключение
			Результат = Новый Массив;
			Результат.Добавить(Что);
		КонецПопытки;
	ИначеЕсли ТипЗнч(Что) = ТипМассив Тогда
		Результат = Что;
		ПеременнаяДляПолученияРезультата = Что;
	Иначе
		Результат.Добавить(Что);
	КонецЕсли;
	Возврат Результат
КонецФункции

// Разность Массивов
// Параметры:
//  Уменьшаемое  - Массив - Массив, значения из которого будут в разности, за исключением вычитаемого
//  Вычитаемое  - Массив - Массив, значения из которого будут исключены из результата
//  Разность  - Массив - Массив, то же самое, что и Результат. По умолчанию Неопределено (пустой). Для использования вызова без возвращаемого значения. Если непустой, значения будут добавлены к нему.
//  Свернуть  - Булево - Истина (по умолчанию) - из результата будут удалены дубли.
// Возвращаемое значение:
//   Массив   - Значения из Уменьшаемого, кроме значений из Вычитаемого
Функция РазностьМассивов(Уменьшаемое, Вычитаемое, Разность = Неопределено, Свернуть = Истина) Экспорт
	Если Разность = Неопределено Тогда
		Разность = Новый Массив;
	КонецЕсли;
	Если Разность = Уменьшаемое Тогда
		Свернуть = Истина;
	КонецЕсли;
	Для каждого ЭлементМ Из Уменьшаемое Цикл
		Если (Вычитаемое.Найти(ЭлементМ) = Неопределено) И ((НЕ Свернуть) ИЛИ (Разность.Найти(ЭлементМ) = Неопределено)) Тогда
			Разность.Добавить(ЭлементМ);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Разность
КонецФункции // РазностьМассивов

//Удаляет дубли из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
//Параметры:
//	Массив - Массив - Исходный массив
//Возвращаемое значение - массив без дублей. Он же в параметре Массив, что позволяет использовать функцию как процедуру.
Функция СвернутьМассив(Массив) Экспорт
	Размер = Массив.Количество();
	Для Ё = 1 По Размер Цикл
		ТекИндекс = Размер - Ё;
		Если Массив.Найти(Массив[ТекИндекс]) <> ТекИндекс Тогда
			Массив.Удалить(ТекИндекс)
		КонецЕсли;
	КонецЦикла;
	Возврат Массив
КонецФункции

//Складывает два массива (добавляет в новый массив элементы сначала первого, потом втогрого), при необходимости - со свёрткой
//Параметры:
//	Массив1 - массив - первое слагаемое
//	Массив2 - массив - второе слагаемое
//	Свернуть - Булево - Удалить дубли
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
//	РезультатВПервый - Булево - Не создавать новый массив, а всё сложить в первый
//Возвращаемое значение:
//	Массив - Элементы первого, за ними элементы второго массива. При свёртке из дублей попадает только первый.
Функция СложитьМассивы(Массив1, Массив2, Свернуть = Истина, УдалитьПустые = Ложь, РезультатВПервый = Ложь) Экспорт
	Если РезультатВПервый Тогда
		Результат = ?(Свернуть, СвернутьМассив(Массив1), Массив1);
		Если УдалитьПустые Тогда
			УдалитьПустыеИзМассива(Результат); 
		КонецЕсли; 
	Иначе
		Результат = СложитьМассивы(Новый Массив, Массив1, Свернуть, УдалитьПустые, Истина);
	КонецЕсли; 
	Для Каждого Элемент Из Массив2 Цикл
		Если ?(?(УдалитьПустые, ЗначениеЗаполнено(Элемент), Истина), ?(Свернуть, Результат.Найти(Элемент) = Неопределено, Истина), Ложь) Тогда
			Результат.Добавить(Элемент);
		Конецесли
	КонецЦикла;
	Возврат Результат
КонецФункции

//Преобразует массив в список значений.
//Параметры:
//	Массив - Массив - источник данных
//	Свернуть - Булево - при Истина будет взято только первое из повторяющихся значений.
//	ПометкаПоУмолчанию - Булево - Пометка для установки в элементы списка. По умолчанию Ложь.
//	КартинкаПоУмолчанию - Картинка или Неопределено - Картинка для установки в элементы списка. Если Неопределено (по умолчанию) - картинка не устанавливается.
//	Результат - Список значений или Неопределено (по умолчанию) - переменная для возврата результата для работы 
//			в режиме процедуры, когда список надо не присвоить, а разместить в существующий. При неопределено будет создан новый список.
//Результат - для работы  в режиме процедуры, когда список надо не присвоить, а разместить в существующий.
//Возвращаемое значение:
//	Список значений - где значение - элемент массива, представление - строковое представление элемента, картинка и пометка из параметров.
Функция СписокИзМассива(Массив, Свернуть = Истина, ПометкаПоУмолчанию = Ложь, КартинкаПоУмолчанию = Неопределено, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый СписокЗначений;
	КонецЕсли; 
	Если КартинкаПоУмолчанию = Неопределено Тогда
		КартинкаПоУмолчанию = Новый Картинка
	КонецЕсли;
	Для каждого Элемент из Массив Цикл
		Если ?(Свернуть, Результат.НайтиПоЗначению(Элемент) = Неопределено, Истина) Тогда
			Результат.Добавить(Элемент, СокрЛП(Элемент), ПометкаПоУмолчанию, КартинкаПоУмолчанию)
		КонецЕсли
	КонецЦикла;
	Возврат Результат
КонецФункции

// Сравнивает массивы более корректно, чем БСП, где два массива с разными задвоями будут равными и нет вызова с клиента
// Параметры:
//  м1  - Массив - Один из сравниваемых
//  м2  - Массив - Второй из сравниваемых
// Возвращаемое значение:
//   Булево   - Массивы равны
Функция МассивыРавны(м1, м2) Экспорт
	Результат = Истина;
	Тестер = Новый Соответствие;
	Для каждого элМ Из М1 Цикл
		Если Тестер[элМ] = Неопределено Тогда
			Тестер.Вставить(элМ, 1);
		Иначе
			Тестер[элМ] = Тестер[элМ] + 1;
		КонецЕсли;Тестер.Вставить(элМ, 1);
	КонецЦикла;
	Для каждого элМ Из М1 Цикл
		Если Тестер[элМ] = Неопределено Тогда
			Результат = Ложь;
			Прервать;
		Иначе
			Тестер[элМ] = Тестер[элМ] - 1;
			Если Тестер[элМ] < 0 Тогда
				Результат = Ложь;
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если Результат Тогда
		Для каждого КиЗ Из Тестер Цикл
			Если КиЗ.Значение <> 0 Тогда
				Результат = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // МассивыРавны

// Удаляет незаполненные элементы из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
// Параметры:
//  Массив_  - Массив - Проверяемый массив
// Возвращаемое значение:
//   Массив   - Тот же массив, что и был передан, но без пустых значений.
Функция УдалитьПустыеИзМассива(Массив_) Экспорт
	ВГр = Массив_.ВГраница();
	Для Ё = 1 По ВГр Цикл
		Если НЕ ЗначениеЗаполнено(Массив_[ВГр - Ё]) Тогда
			Массив_.Удалить(ВГр - Ё)
		КонецЕсли; 
	КонецЦикла; 
	Возврат Массив_
КонецФункции // УдалитьПустыеИзМассива
 
#КонецОбласти

#Область СПИСОК_ЗНАЧЕНИЙ
	
//Возвращает табличный документ, в который выведен список значений
//Параметры:
//	  Список - Список значений - Выводимый в таблицу
//Возвращаемое значение:
//	  Табличный документ - Значения из выгружаемой колонки
Функция ВывестиСписокВТабличныйДокумент(Список) Экспорт
	Результат = Новый ТабличныйДокумент;
	РазмерСписка = Список.Количество();
	Результат.Область(1, 1, РазмерСписка, 4).СодержитЗначение = Истина;
	Результат.Область(1, 1, РазмерСписка, 4).ШиринаКолонки = 70;
	Для Ё = 1 По РазмерСписка Цикл
		Элемент = Список[Ё - 1];
		Результат.Область(Ё, 1, Ё, 1).Значение = Элемент.Представление;
		Результат.Область(Ё, 1, Ё, 1).Расшифровка = Элемент.Значение;
		Результат.Область(Ё, 2, Ё, 2).Значение = Элемент.Пометка;
		Результат.Область(Ё, 3, Ё, 3).Значение = Элемент.Картинка
	КонецЦикла;
	Результат.ТолькоПросмотр = Истина;
	Результат.Защита = Истина;
	Возврат Результат
КонецФункции

// Перемешивает строки списка значений
// Параметры:
//  Список_  - Список значений - строки которого надо перемешать
Процедура ПеремешатьСписок(Список_) Экспорт
	СлуГен = Новый ГенераторСлучайныхЧисел(Секунда(ТекущаяДата()));
	Колво = Список_.Количество() - 1;
	Для Ё = 0 По Колво Цикл
		Список_.Сдвинуть(Список_[Ё], СлуГен.СлучайноеЧисло(0, Колво) - Ё);
	КонецЦикла; 
КонецПроцедуры // ПеремешатьСписок()

// Возвращает помеченные элементы списка значений
// Параметры:
//  Список  - Список значений - Источник данных. Допустимо = ТЗ с колонками Пометка, Значение, Представление, Картинка (какие востребованы).
//  Пометка  - Булево - Искомое значение пометок. Неопределено - все пометки. По умолчанию Истина.
//  Контент  - Строка - Вид возвращаемых данных:
//			*Значения - Массив значений (по умолчанию)
//			*Наоборот - Соответствие, где ключ - значение, а значение - представление
//			*Представления - Массив представлений
//			*Соответствие - Соответствие, где ключ - представление, а значение - значение
//			*Список - Список значений
//			*Структура - Структура, где ключ - представление, а значение - значение
//			*ТЗ - таблица значений
//			*Картинка - Массив картинок
//			*Элементы - Массив элементов
// Возвращаемое значение:
//   Массив/Соответствие/Структура/Список значений/ТаблицаЗначений   - Отобранные по пометке значения
Функция Помеченные(Список, Пометка = Истина, Контент = "Значения") Экспорт
	#Область ВАРИАНТЫ_КОНТЕНТА
		Если Контент = "Наоборот" Тогда
			ТипР = "Структура";
			Результат = Новый Соответствие;
			Ключ = "Значение";
			Значение = "Представление";
		ИначеЕсли Контент = "Представления" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Представление";
		ИначеЕсли Контент = "Соответствие" Тогда
			ТипР = "Структура";
			Результат = Новый Соответствие;
			Ключ = "Представление";
			Значение = "Значение";
		ИначеЕсли Контент = "Список" Тогда
			ТипР = "СЗ_ТЗ";
			Результат = Новый СписокЗначений;
			Ключ = "Значение";
			Значение = "Представление";
		ИначеЕсли Контент = "Структура" Тогда
			ТипР = "Структура";
			Результат = Новый Структура;
			Ключ = "Представление";
			Значение = "Значение";
		ИначеЕсли Контент = "ТЗ" Тогда
			#Если Сервер Тогда
				ТипР = "СЗ_ТЗ";
				Результат = Новый ТаблицаЗначений;
				Результат.Колонки.Добавить("Значение");
				Результат.Колонки.Добавить("Представление");
				Результат.Колонки.Добавить("Картинка");
				Результат.Колонки.Добавить("Пометка");
			#КонецЕсли
			#Если Клиент Тогда
				ТипР = "Массив";
				Результат = Новый Массив;
			#КонецЕсли
			Ключ = "Элемент";
			Значение = "";
		ИначеЕсли Контент = "Картинка" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Картинка";
		ИначеЕсли Контент = "Элементы" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "Элемент";
			Значение = "Элемент";
		Иначе
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Значение";
		КонецЕсли;
	#КонецОбласти 
	Для каждого ЭлементС Из Список Цикл
		Если Пометка = Неопределено ИЛИ ЭлементС.Пометка = Пометка Тогда
			Если ТипР = "Массив" Тогда
				Результат.Добавить(?(Значение = "Элемент", ЭлементС, ЭлементС[Значение]));
			ИначеЕсли ТипР = "Структура" Тогда
				Результат.Вставить(ЭлементС[Ключ], ЭлементС[Значение]);
			ИначеЕсли ТипР = "СЗ_ТЗ" Тогда
				ЗаполнитьЗначенияСвойств(Результат.Добавить(), ЭлементС);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // Помеченные

// Дополняет список значений по структуре/соответствию
// Параметры:
//  Источник  - Структура/Соответстивие - Источник данных
//  Приёмник  - Список значений - Список-получатель
//  Пометка  - Булево - Значение пометки новых элементов
//  Режим  - Строка -
//		*ДобавитьСУчётомКлючей (по умолчанию) - добавить к существующим, заменив существующие ключи
//		*ДобавитьВсё - добавить к существующим без проверок
//		*ДобавитьНовые - добавить к существующим только новые ключи
//		*Очистить - предварительно очистить
//		*НеДобавлять - только заменить существующие ключи
//	Сортировать_ - Булево - Сортировка по представлению: Неопределено (По умолчанию) = по необходимости, Истина/Ложь - всега сортировать/нет
// Возвращаемое значение:
//   Список значений   - Дополненный из источника
Функция СписокИзСтруктуры(Источник, Приёмник = Неопределено, Пометка = Ложь, Режим = "ДобавитьСУчётомКлючей", Сортировать_ = Неопределено) Экспорт
	Если Источник = Неопределено Тогда
		Источник = Новый Структура;
	КонецЕсли;
	Если Приёмник = Неопределено Тогда
		Результат = Новый СписокЗначений;
		Вариант = "ДобавитьВсё";
	Иначе
		Результат = Приёмник;
		Вариант = Режим;
	КонецЕсли;
	Если Вариант = "Очистить" Тогда
		Результат.Очистить();
	КонецЕсли;
	РежимВсе = Режим = "Очистить" ИЛИ Режим = "ДобавитьВсё";
	Если ?(Сортировать_ = Неопределено, НЕ РежимВсе, Сортировать_) Тогда
		Результат.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	КонецЕсли; 
	Для каждого КиЗ Из Источник Цикл
		Если РежимВсе Тогда
			НовЭл = Результат.Добавить();
		Иначе
			НовИндекс = ИндексПоловиннымДелением(КиЗ.Ключ, Приёмник, "Представление");
			НовЭл = Результат[НовИндекс];
			Если НовЭл.Представление = КиЗ.Ключ Тогда
				Если Режим = "ДобавитьНовые" Тогда
					НовЭл = "";
				КонецЕсли;
			Иначе
				Если Режим = "НеДобавлять" Тогда
					НовЭл = "";
				Иначе
					НовЭл = Результат.Добавить();
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		Если НовЭл <> "" Тогда
			НовЭл.Значение = КиЗ.Значение;
			НовЭл.Представление = КиЗ.Ключ;
			НовЭл.Пометка = Пометка;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // СписокИзСтруктуры

// Дополняет структуру (или сздаёт её) / соответствие значениями из списка
// Параметры:
//  Список  - Список значений - Источник данных
//  Исходная  - Структура/Соответствие - Приёмник данных
//  ВСоответствие  - Булево - Преобразовать в соответствие. Если ложь (по умолчанию) = будет тип как у Исходной, а при создании = Структура.
//  Скопировать  - Булево - Вернуть копию (аналог Знач). По умолчанию Ложь.
//  ВставлятьНеПомеченные  - Булево - Вставлять в структуру непомеченные элементы. По умолчанию Ложь.
// Возвращаемое значение:
//   Структура/Соответствие   - Исходная + данные списка
Функция СтруктураИзСпискаЗначений(Список, Исходная = Неопределено, ВСоответствие = Ложь, Скопировать = Ложь, ВставлятьНеПомеченные = Истина) Экспорт
	Если Исходная = Неопределено Тогда
		Исходная = Новый Структура;
	КонецЕсли;
	Результат = ?(Скопировать, ?(ВСоответствие, Новый Соответствие, Новый Структура), Исходная);
	Особый = ВСоответствие И ТипЗнч(Исходная) <> Тип("Соответствие") И НЕ Скопировать;
	Если Особый Тогда
		Результат = Новый Соответствие;
	КонецЕсли;
	Если Особый ИЛИ Скопировать Тогда
		Для каждого КиЗ Из Исходная Цикл
			Результат.Вставить(?(ВСоответствие, КиЗ.Ключ, СтрокуВИмяПеременной(СокрЛП(КиЗ.Ключ))), КиЗ.Значение);
		КонецЦикла;
	КонецЕсли;
	Для каждого ЭлементСЗ Из Список Цикл
		Если ВставлятьНеПомеченные ИЛИ ЭлементСЗ.Пометка Тогда
			Результат.Вставить(?(ВСоответствие, ЭлементСЗ.Представление, СтрокуВИмяПеременной(СокрЛП(ЭлементСЗ.Представление))), ЭлементСЗ.Значение);
		КонецЕсли;
	КонецЦикла;
	Если Особый Тогда
		Исходная = Результат
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураИзСпискаЗначений

#КонецОбласти 

#Область СТРУКТУРА
	
// Добавляет КиЗы источника в приёмник
// Параметры:
//  Приёмник - Структура или Неопределено - Одно из слагаемых. Если Неопределено, то возвращается копия источника независимо от РежимПроцедуры.
//  Источник  - Структура - Второе слагаемое
//	РежимПроцедуры - Булево - Если Истина, результат сложения окажется в Приёмнике, а вернётся Истина.
//		Если Ложь (по умолчанию), то Приёмник и Источник не изменятся, а результат будет возвращён.
// Возвращаемое значение:
//   Структура или Булево   - описание выше
Функция ДополнитьСтруктуру(Приёмник = Неопределено, Источник, РежимПроцедуры = Ложь) Экспорт
	Результат = ?(Приёмник = Неопределено, Новый Структура, ?(РежимПроцедуры, Приёмник, ДополнитьСтруктуру(Неопределено, Приёмник)));
	Для каждого КиЗ Из Источник Цикл
		Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
	КонецЦикла; 
	Возврат ?(РежимПроцедуры, Истина, Результат)
КонецФункции // ДополнитьСтруктуру()

// Возвращает копию заданной структуры с теми же ключами и значениями Неопределено
// Параметры:
//  СтрКлючи  - Структура - Источник
// Возвращаемое значение:
//   Структура   - со сброшенными значениями
Функция СброситьСтруктуру(СтрКлючи) Экспорт
	Результат = Новый Структура;
	Для каждого КиЗ Из СтрКлючи Цикл
		Результат.Вставить(КиЗ.Ключ, Неопределено);
	КонецЦикла;
	Возврат Результат
КонецФункции // СброситьСтруктуру

// Удаляет из структуры ключи с пустыми значениями
// Параметры:
//  Очищаемая  - Структура - Из которой будут удалить ключи
Процедура УдалитьПустыеЗначенияИзСтруктуры(Очищаемая) Экспорт
	КУдалению = Новый Массив;
	Для каждого КиЗ Из Очищаемая Цикл
		Если НЕ ЗначениеЗаполнено(КиЗ.Значение) Тогда
			КУдалению.Добавить(КиЗ.Ключ);
		КонецЕсли;
	КонецЦикла;
	УдалитьЛишниеСтроки(Очищаемая, КУдалению);
КонецПроцедуры // УдалитьПустыеЗначенияИзСтруктуры

//Читает значение заданного ключа из структуры с проверками на наличие структуры и ключа.
//Параметры:
//	Структура_ - Структура - из которой будет прочитано значение.
//	ИмяСвойства - Строка - искомый ключ
//	ЗначениеЕслиНет - Произвольный -  Значение, возвращаемое, если прочитать не вышло
//	ПроверитьЧтоЭтоСтруктура - Булево - Если ложь, без проверки принимается, что тип параметра "Структура_" - структура.
//Возвращаемое значение -  Произвольный -  значение ключа
Функция ЧтСтрукт(Структура_, ИмяСвойства, ЗначениеЕслиНет = Неопределено, ПроверитьЧтоЭтоСтруктура = Ложь) Экспорт
	ТекТип = ТипЗнч(Структура_);
	Возврат ?(?(ПроверитьЧтоЭтоСтруктура, ТекТип = Тип("Структура") ИЛИ ТекТип = Тип("ФиксированнаяСтруктура"), Истина),
			?(Структура_.Свойство(ИмяСвойства), Структура_[ИмяСвойства], ЗначениеЕслиНет), ЗначениеЕслиНет)
КонецФункции

#КонецОбласти 

#Область ТАБЛИЦА_ЗНАЧЕНИЙ
	
//Загружает содержимое табличного документа в таблицу значений. Может возвращать массив структур.
//Параметры:
//	ТабДокИлиExcel - Табличный документ/Строка - Источник. Колонки с пустыми заголовками не читаются. Строка рассматривается как путь к Excel, из которого считывается файл
//	СтрокаТипов - Число/Массив - Номер строки, где расположены типы. 0 - типы не загружаются. По умолчанию - 1. Строка типов должна содержать имя менеджера (например, Справочники.Номенклатура).
//					или массив типов, менеджеров ссылочных значений или строк или массивов таких значений - типы колонок в порядке их следования (исключаемые колонки с пустыми заголовками не исключаются из массива (и других параметров далее)).
//	СтрокаЗаголовков - Число - Номер строки, содержащей заголовки колонок. По умолчанию - 2
//	СтрокаДанных - Число - Номер строки, с которой начинаются данные. По умолчанию = 3
//	Типизировать - Булево - Если Истина (Только для ТЗ на сервере), то колонки будут типизированы, что необходимо для использования ТЗ в параметре запроса и удобно для ручного выбора значения. По умолчанию = Ложь
//	Ширина - Число - Ширина таблицы в ТД. По умолчанию = 0, в этом случае определяется автоматически.
//	Высота - Число - Номер последней строки от начала ТД, используемой загрузки данных. По умолчанию 0. В этом случае загружается вся таблица.
//	Распознавание - Число -
//			* 0 - не распознавать
//			* 1 - распознавание только при заданном типе
//			* 2 - распознавание всегда (по умолчанию)
//			Распознавание простых типов - на общих основаниях.
//	СтрокаРеквизита - Число - Номер строки, в которой содержится имя реквизита, по которому распознаётся значение. По умолчанию = 0, реквизит определяется автоматически.
//	СтрокаРодитель - Число - Номер строки, в которой содержится имя колонки родителя, с учётом которого должен вестись поиск. По умолчанию = 0, родитель не учитывается.
//			Колонку родителя надо размещать левее подчинённой колонки.
//	СтрокаВладелец - Число - Номер строки, в которой содержится имя колонки владельца, с учётом которого должен вестись поиск. По умолчанию = 0, владелец не учитывается.
//			Колонку владельца надо размещать левее подчинённой колонки.
//	Подстановки - ТаблицаЗначений - (Только для ТЗ на сервере) = С колонками "КолонкаФайла,ЗначениеИзФайла,НовоеЗначение". Если КолонкаФайла = "", то замена по всем колонкам.
//			По умолчанию = Неопределено, и замен нет. При этом накапливаются знания о распознанных значениях - по каждой колонке и общие. Если не надо накапливать, 
//			а каждый раз распознавать заново, надо передавать в этом параметре "ТОЛЬКО_КОЛОНКА", "ТОЛЬКО_ОБЩИЕ" или "НЕТ".
//			Первые колонки содержат строковые значения, третья - произвольное. После замены распознавание не производится.
//	ПослеРаспознавания - Строка, Массив - Обработчик(и (для каждой колонки)) после распознавания значения. По умолчанию "" - обработчика нет.
//			В Результат передаётся распознанное значение. Структура Прм имеют ключи (в обработчике обращение по ключам, без Прм):
//			*Заданные при вызове = см.Прм,
//			*Доназначенные в обработчике, (далее - ключи, автообновляемые для каждого значения/колонки)
//			*ИсходноеЗначение, (распознаваемый текст)
//			*Типы, (массив допустимых типов)
//			*ИмяКолонки,
//			*ТекДанные, (редактируемая строка таблицы)
//			*Таблица, (ссылка на таблицу в целом)
//			*ПодстановкаПоКолонке, (соответствие - накопитель распознанных значений в колонке; наличие в соответствии автопроверяется и автоустанавливантся до обработчика;
//				после обрабочика - переустанавливается (согласно параметру Подстановки));
//			*Получен, ("НЕТ", "РАСПОЗНАН", "ИЗ_ОБЩЕЙ", или "ПО_КОЛОНКЕ")
//			*ОбщаяПодстановка, (то же, но по всем колонкам - см. Подстановки);
//			*Родитель, (имя колонки родителя)
//			*Владелец. (имя колонки владельца)
//	Прм - Структура - параметры, передаваемые в обработчики ПослеРаспознавания
//	ТипизацияКолонок - Массив - (Только для ТЗ на сервере) = Карта предварительной типизации колонок. Размерность строго по количеству колонок. Элементами м.б.:
//          *Описание типов - присвоится колонке при её создании
//          *"ПоТипу" - Тип будет определён по строке типов
//			Остальные значения игнорируются и тип не присваивается.
//			По умолчанию Неопределено - типизации нет.
//	ЗначенияНераспознанных - Любое значение - Если массив по числу колонок - значения для каждой колонки берутся из элемента.
//			Любое другое значение подставляется, если не распознано. По умолчанию "!_НЕ_НУЖНЫ_!" - берётся распознаваемая строка.
//	НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//	СообщатьОКолонках - Булево - По умолчанию Ложь. Включает вывод сообщения после загрузки колонки.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
//	ВернутьМассивСтруктур - Булево - Всегда Истина на тонком и мобильном клиенте, в остальных случаях по умолчанию - ложь
//	СпособЧтения - СпособЧтенияЗначенийТабличногоДокумента - параметр чтения таблицы из Excel. По умолчанию Значение.
//	ОбластьЧтения - Строка - Имя области, из которой надо прочитать данные/листа Excel. По умолчанию пустая строка - чтение из всего ТД.
//Возвращаемое значение
//	Таблица значений - загруженная из ТД с распознаванием значений
Функция ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(
		ТабДокИлиExcel,
		СтрокаТипов = 1,
		СтрокаЗаголовков = 2,
		СтрокаДанных = 3,
		Типизировать = Ложь,
		Ширина = 0,
		Высота = 0,
		Распознавание = 2,
		СтрокаРеквизита = 0,
		СтрокаРодитель = 0,
		СтрокаВладелец = 0,
		Подстановки = Неопределено,
		ПослеРаспознавания = "",
		Прм = Неопределено,
		ТипизацияКолонок = Неопределено,
		ЗначенияНераспознанных = "!_НЕ_НУЖНЫ_!",
		НеРаспознаватьУИДБезТипа = Ложь,
		СообщатьОКолонках = Ложь,
		СообщатьСюда = Неопределено,
		ВернутьМассивСтруктур = Ложь,
		СпособЧтения = Неопределено,
		ОбластьЧтения = "") Экспорт
	#Если ТонкийКлиент ИЛИ МобильныйКлиент ИЛИ МобильноеПриложениеКлиент Тогда
		ВернутьМассивСтруктур = Истина;
	#КонецЕсли
	ТипСтрока = Тип("Строка");
	ТипМассив = Тип("Массив");
	ТипТип = Тип("Тип");
	Если СпособЧтения = Неопределено Тогда
		СпособЧтения = СпособЧтенияЗначенийТабличногоДокумента.Значение;
	КонецЕсли;
	Если ТипЗнч(ТабДокИлиExcel) = ТипСтрока Тогда
		ТаблДокумент = Новый ТабличныйДокумент;
		ТаблДокумент.ИспользуемоеИмяФайла = ТабДокИлиExcel;
		ТаблДокумент.Прочитать(ТабДокИлиExcel, СпособЧтения);
	Иначе
		ТаблДокумент = ТабДокИлиExcel;
	КонецЕсли;
	Если ЗначениеЗаполнено(ОбластьЧтения) Тогда
		ТаблДокумент = ТаблДокумент.ПолучитьОбласть(ОбластьЧтения);
	КонецЕсли;
	ТекШирина_ = ?(Ширина = 0, ТаблДокумент.ШиринаТаблицы, Ширина);
	ТекВысота_ = ?(Высота = 0, ТаблДокумент.ВысотаТаблицы, Высота);
	Если ВернутьМассивСтруктур Тогда
		Результат = Новый Массив;
		Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
			НоваяСтрока_ = Новый Структура;
			Результат.Добавить(НоваяСтрока_);
		КонецЦикла;
	Иначе
		Результат = Вычислить("Новый ТаблицаЗначений");
		Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
			НоваяСтрока_ = Результат.Добавить();
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(СтрокаТипов) = ТипМассив Тогда
		МассивТиповГотов = Истина;
	Иначе
		МассивТиповГотов = Ложь;
	КонецЕсли;
	ЕстьОбработчик = ПослеРаспознавания <> "";
	ЕстьУмолчаниЕ = ЗначенияНераспознанных <> "!_НЕ_НУЖНЫ_!";
	ЕстьУмолчаниЯ = ?(ТипЗнч(ЗначенияНераспознанных) = Тип("Массив"), ЗначенияНераспознанных.Количество() = ТекШирина_, Ложь);
	ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	ЕстьОбщиеПодстановки = НЕ (Подстановки = "НЕТ" ИЛИ Подстановки = "ТОЛЬКО_КОЛОНКА");
	ЕстьПодстановкиПоКолонке = НЕ (Подстановки = "НЕТ" ИЛИ Подстановки = "ТОЛЬКО_ОБЩИЕ");
	ЕстьПодстановки = НЕ (Подстановки = Неопределено ИЛИ Подстановки = "НЕТ" ИЛИ Подстановки = "ТОЛЬКО_ОБЩИЕ" ИЛИ Подстановки = "ТОЛЬКО_КОЛОНКА");
	#Если Клиент Тогда
		МодульВОНС = Неопределено;
	#Иначе
		МодульВОНС = ВОЛНА_ОбщегоНазначенияСервер;
	#КонецЕсли
	ОбщаяПодстановка = ?(ЕстьПодстановки,
			МодульВОНС.СтруктураИзКолонокТаблицы(
			Подстановки.НайтиСтроки(Новый Структура("КолонкаФайла", "")),
			"ЗначениеИзФайла", "НовоеЗначение", Истина, Подстановки.Колонки), Новый Соответствие);
	Если СообщатьОКолонках Тогда
		ТекстСообщения = "Старт загрузки: " + ТекущаяДата();
		Если ЕстьСтрокаТабло Тогда
			СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;		
	КонецЕсли;
	Для СчКол = 0 По ТекШирина_ - 1 Цикл
		Сч1 = СчКол + 1;
		ТекИмяК = ТаблДокумент.Область(СтрокаЗаголовков, Сч1).Текст;
		Если ТекИмяК <> "" Тогда
			Если НЕ ВернутьМассивСтруктур Тогда
				#Область ТИПЫ_КОЛОНКИ
					ЕстьТипы = Истина;
					ТекТипМ = Новый Массив; //Массив менеджеров
					ТекТипТ = Новый Массив; //Массив типов для типизации колонки
					Если МассивТиповГотов Тогда
						КОбработке = СтрокаТипов[СчКол];
						Если КОбработке = "" Тогда
							КОбработке = Новый Массив;
							ЕстьТипы = Ложь;
						ИначеЕсли ТипЗнч(КОбработке) = ТипСтрока Тогда
							КОбработке = СтрРазделить(КОбработке, ",", Истина);
						ИначеЕсли ТипЗнч(КОбработке) = ТипМассив Тогда
						ИначеЕсли ТипЗнч(КОбработке) = ТипТип Тогда
							ТекМенеджер = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(КОбработке, "Менеджер"), Неопределено, КОбработке);
							ТекТипТ.Добавить(КОбработке);
							ТекТипМ.Добавить(ТекМенеджер);
							КОбработке = Новый Массив;
						Иначе
							//Считаем, что это менеджер ссылки
							ТекТипМ.Добавить(КОбработке);
							ТекТипТ.Добавить(ТипЗнч(КОбработке.ПустаяСсылка()));
							КОбработке = Новый Массив;
						КонецЕсли;
					ИначеЕсли СтрокаТипов = 0 Тогда
						КОбработке = Новый Массив;
						ЕстьТипы = Ложь;
					Иначе
						//Тип представлен строкой. Возможно перечисление через запятую.
						СтрокиМенеджеров = ТаблДокумент.Область(СтрокаТипов, Сч1).Текст;
						Если СтрокиМенеджеров = "" Тогда
							КОбработке = Новый Массив;
							ЕстьТипы = Ложь;
						Иначе
							КОбработке = СтрРазделить(СтрокиМенеджеров, ",", Истина);
						КонецЕсли;
					КонецЕсли;
					Если ЕстьТипы Тогда
						Для каждого СтрочкаДляОпределенияТипа Из КОбработке Цикл
							Попытка
								ТекМенеджер = Вычислить(СтрочкаДляОпределенияТипа);
								ТекТип = ТипЗнч(ТекМенеджер.ПустаяСсылка());
							Исключение
								ТекТип = Тип(СтрочкаДляОпределенияТипа);
								ТекМенеджер = ЕслиПервоеВтороеРавныТоТретьеИначеПервое(ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер"), Неопределено, ТекТип);
							КонецПопытки;
							ТекТипМ.Добавить(ТекМенеджер);
							ТекТипТ.Добавить(ТекТип);
						КонецЦикла; 
					КонецЕсли; 
					Если ТипизацияКолонок <> Неопределено Тогда
						ТекОТКолонки = ТипизацияКолонок[СчКол];
						ТекТипОТ = ТипЗнч(ТекОТКолонки);
						ТекОТКолонки = ?(ТекОТКолонки = "ПоТипу", ?(ЕстьТипы, Новый ОписаниеТипов(ТекТипТ), Неопределено),
								?(ТекТипОТ = Тип("ОписаниеТипов"), ТекОТКолонки,
								?(ТекТипОТ = ТипМассив, Новый ОписаниеТипов(ТекОТКолонки),
								?(ТекТипОТ = ТипТип, Новый ОписаниеТипов(ПреобразоватьВМассив(ТекОТКолонки)), Неопределено))));
					Иначе
						ТекОТКолонки = Неопределено;
					КонецЕсли;
					ТекТип = ?(ЕстьТипы, ТекТипМ, "");
				#КонецОбласти 
				#Область ДОБАВЛЕНИЕ_КОЛОНКИ
					Если ТекОТКолонки = Неопределено Тогда
						Результат.Колонки.Добавить(ТекИмяК);
					Иначе
						Результат.Колонки.Добавить(ТекИмяК, ТекОТКолонки);
					КонецЕсли;
				#КонецОбласти 
			КонецЕсли; 
			Если СтрокаРеквизита = 0 Тогда
				ТекИмяРеквизита = "";
			Иначе
				ТекИмяРеквизита = ТаблДокумент.Область(СтрокаРеквизита, Сч1).Текст;
			КонецЕсли;
			Если СтрокаРодитель = 0 Тогда
				ТекРодитель = "";
			Иначе
				ТекРодитель = ТаблДокумент.Область(СтрокаРодитель, Сч1).Текст;
			КонецЕсли;
			Если СтрокаВладелец = 0 Тогда
				ТекВладелец = "";
			Иначе
				ТекВладелец = ТаблДокумент.Область(СтрокаВладелец, Сч1).Текст;
			КонецЕсли;
			Если ЕстьПодстановки Тогда
				ТекПодстановка = МодульВОНС.СтруктураИзКолонокТаблицы(
						Подстановки.НайтиСтроки(Новый Структура("КолонкаФайла", ТекИмяК)),
						"ЗначениеИзФайла", "НовоеЗначение", Истина, Подстановки.Колонки);
			Иначе
				ТекПодстановка = Новый Соответствие;
			КонецЕсли; 
			ТекУмолчание = ?(ЕстьУмолчаниЯ, ЗначенияНераспознанных[СчКол], ЗначенияНераспознанных);
			ЕстьТекУмолчание = ТекУмолчание <> "!_НЕ_НУЖНЫ_!";
			Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
				ТекЗнч = ТаблДокумент.Область(СчСтр, Сч1).Текст;
				НоваяСтрока_ = Результат[СчСтр - СтрокаДанных];
				Получен = "НЕТ";
				Если ЕстьПодстановкиПоКолонке Тогда
					РезультатРаспознавания = ТекПодстановка[ТекЗнч];
				КонецЕсли;
				Если РезультатРаспознавания = Неопределено Тогда
					Если ЕстьОбщиеПодстановки Тогда
						РезультатРаспознавания = ОбщаяПодстановка[ТекЗнч];
					КонецЕсли;
					Если РезультатРаспознавания = Неопределено Тогда
						Если (Распознавание = 0) ИЛИ ((ТекТип = "") И (Распознавание = 1)) Тогда
							РезультатРаспознавания = ТекЗнч;
						Иначе
							РезультатРаспознавания = ВОЛНА_ОбщегоНазначенияВС.РаспознатьЗначение(ТекЗнч, ТекТип,
									?(СтрокаРеквизита = 0, "", ТекИмяРеквизита),
									?(ТекРодитель = "", Неопределено, НоваяСтрока_[ТекРодитель]),
									?(ТекВладелец = "", Неопределено, НоваяСтрока_[ТекВладелец]),, Истина);
							Если (РезультатРаспознавания = ТекЗнч) И ЕстьТекУмолчание Тогда
								РезультатРаспознавания = ТекУмолчание;
							КонецЕсли;
						КонецЕсли;
						Если ЕстьОбщиеПодстановки Тогда
							ОбщаяПодстановка.Вставить(ТекЗнч, РезультатРаспознавания);
						КонецЕсли;
						Получен = "РАСПОЗНАН";
					Иначе
						Получен = "ИЗ_ОБЩЕЙ";
					КонецЕсли;
					Если ЕстьПодстановкиПоКолонке Тогда
						ТекПодстановка.Вставить(ТекЗнч, РезультатРаспознавания);
					КонецЕсли;
				Иначе
					Получен = "ПО_КОЛОНКЕ"
				КонецЕсли;
				Если ЕстьОбработчик Тогда
					Если Прм = Неопределено Тогда
						Прм = Новый Структура;
					КонецЕсли;
					ПараметрыОбработчика =
							ДополнитьСтруктуру(
								Новый Структура("ИсходноеЗначение,Типы,ИмяКолонки,Таблица,ПодстановкаПоКолонке,ОбщаяПодстановка,Родитель,Владелец,Получен,ТекДанные",
									ТекЗнч, ТекТип, ТекИмяК, Результат, ТекПодстановка, ОбщаяПодстановка, ТекРодитель, ТекВладелец, Получен, НоваяСтрока_),
								Прм);
					РезультатРаспознавания = ВыполнитьКод(ПослеРаспознавания, ПараметрыОбработчика, РезультатРаспознавания);
					Если ЕстьОбщиеПодстановки Тогда
						ОбщаяПодстановка.Вставить(ТекЗнч, РезультатРаспознавания);
					КонецЕсли;
					Если ЕстьПодстановкиПоКолонке Тогда
						ТекПодстановка.Вставить(ТекЗнч, РезультатРаспознавания);
					КонецЕсли;
				КонецЕсли; 
				Если ВернутьМассивСтруктур Тогда
					НоваяСтрока_.Вставить(ТекИмяК, РезультатРаспознавания);
				Иначе
					НоваяСтрока_[ТекИмяК] = РезультатРаспознавания;
				КонецЕсли;
			КонецЦикла	
		КонецЕсли;
		Если СообщатьОКолонках Тогда
			ТекстСообщения = "Загружено " + ТекИмяК + ": " + ТекущаяДата();
			Если ЕстьСтрокаТабло Тогда
				СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
			Иначе
				Сообщить(ТекстСообщения);
			КонецЕсли;		
		КонецЕсли;
	КонецЦикла;	
	Если Типизировать И НЕ ВернутьМассивСтруктур Тогда
		МодульВОНС.ТипизироватьТаблицу(Результат);
		Если СообщатьОКолонках Тогда
			ТекстСообщения = "Таблица типизирована: " + ТекущаяДата();
			Если ЕстьСтрокаТабло Тогда
				СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
			Иначе
				Сообщить(ТекстСообщения);
			КонецЕсли;		
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции //ЗагрузитьТаблицуЗначенийИзТабличногоДокумента

// Возвращает структуру/соответствие структур, сформированных из строк таблицы значений (массива структур)
// Параметры:
//  ТабИсточник  - Таблица значений/массив структур - Откуда взять данные
//  КолонкиКлючей  - Строка - Имена колонок ключей через запятую. Значение одной колонки при возвращении соответствия берётся как есть, во всех остальных случаях ключ
//			получается объединением колонок с разделителем
//  Разделитель  - Строка - будет разделять значения из колонок ключей. По умолчанию ""
//  ВернутьСоответствие  - Булево - Результат будет соответствием. При Ложь(по умолчанию) = структурой.
//  КолонкиЗначений  - Строка - Имена колонок через запятую. Остальные колонки не войдут в результат. По умолчанию "". Для массива структур - обязателен.
//  ИсключаемыеКолонки  - Строка - Имена колонок через запятую. Эти колонки также не войдут в результат.
// Возвращаемое значение:
//   Структура/соответствие   - Структура с определёнными ключами и значениями - структурами
Функция СтруктураСтруктурИзТЗ(ТабИсточник, КолонкиКлючей = "ИД", Разделитель = "", ВернутьСоответствие = Ложь, КолонкиЗначений = "", ИсключаемыеКолонки = "") Экспорт
	Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
	Если ЗначениеЗаполнено(КолонкиЗначений) Тогда
		ИспользуемыеКолонки = "";
		мКолонок = СтрРазделить(КолонкиЗначений, ",", Ложь);
		Для каждого КолонкаТ Из мКолонок Цикл
			Если НайтиПодСтроку(ИсключаемыеКолонки, КолонкаТ) = 0 Тогда
				ИспользуемыеКолонки = ИспользуемыеКолонки + "," + КолонкаТ;
			КонецЕсли;
		КонецЦикла;
	Иначе
		ИспользуемыеКолонки = "";
		Для каждого КолонкаТ Из ТабИсточник.Колонки Цикл
			Если НайтиПодСтроку(ИсключаемыеКолонки, КолонкаТ.Имя) = 0 Тогда
				ИспользуемыеКолонки = ИспользуемыеКолонки + "," + КолонкаТ.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ИспользуемыеКолонки = Сред(ИспользуемыеКолонки, 2);
	мКлючи = СтрРазделить(КолонкиКлючей, ",", Ложь);
	ОдинКлюч = мКлючи.Количество() = 1;
	ДлинаРазделителя = СтрДлина(Разделитель);
	Для каждого СтрокаТ Из ТабИсточник Цикл
		Если ОдинКлюч Тогда
			ТекКлюч = ?(ВернутьСоответствие, СтрокаТ[КолонкиКлючей], СокрЛП(СтрокаТ[КолонкиКлючей]));
		Иначе
			ТекКлюч = "";
			Для каждого элКлюч Из мКлючи Цикл
				ТекКлюч = ТекКлюч + Разделитель + СтрокаТ[элКлюч];
			КонецЦикла;
			ТекКлюч = Сред(ТекКлюч, ДлинаРазделителя);
		КонецЕсли;
		ТекЗначение = Новый Структура(ИспользуемыеКолонки);
		ЗаполнитьЗначенияСвойств(ТекЗначение, СтрокаТ);
		Результат.Вставить(ТекКлюч, ТекЗначение);
	КонецЦикла;
	Возврат Результат
КонецФункции // СтруктураСтруктурИзТЗ

#КонецОбласти

// Возвращает иерархию соответствий - фактически аналог индекса
// Параметры:
//  Источник - Коллекция с именованными свойствами элемента (ТЗ, массив структур, ДанныеФормыКоллекция , и т.д. - Источник данных
//  Ключи - Массив структур - Ключи:
//			*Колонка = Имя реквизита элемента источника, откуда берутся ключи,
//			*ЭтоСтруктура = Булево: Истина - создавать структуру, Ложь - соответствие.
//			Иерархия строится в порядке элементов массива.
//  ИсточникЭлементаРезультата - Строка - Имя реквизита, из которого будет назначаться элемент результата (значение низа иерархии).
//			По умолчанию "#ВесьЭлемент" = берётся весь элемент источника
//  ТипЭлементаРезультата - Строка - возможные значения:
//			*Массив - (по умолчанию) - массив, все новые значения заносятся туда
//			*Значение - значение элемента источника. Последующие значения перезаписываются поверх предыдущих
//			*Любое прочее значение - это значение
//  ВзятьЭлементИсточникаИзРеквизита - Строка - Если надо брать элемент источника не из элемента коллекции, а из его реквизита (например, из значения КиЗ),
//			то указывается имя реквизита-источника. По умолчанию пустая строка = ключи берутся из реквизитов самого элемента.
//  ВзятьЭлементРезультатаИзРеквизита - Строка - аналогично ВзятьЭлементИсточникаИзРеквизита, но для ИсточникЭлементаРезультата.
// Возвращаемое значение:
//   Структура/Соответствие - Корень иерархии структур/соответствий
Функция СоответствияИзКоллекции(
		Источник,
		Ключи,
		ИсточникЭлементаРезультата = "#ВесьЭлемент",
		ТипЭлементаРезультата = "Массив",
		ВзятьЭлементИсточникаИзРеквизита = "",
		ВзятьЭлементРезультатаИзРеквизита = "") Экспорт
	Результат  = Новый Структура("Результат");
	Если Ключи.Количество() <> 0 Тогда
		Если Источник.Количество() Тогда
			Для каждого ЭлементИсточника Из Источник Цикл
				Корень = Результат;
				ТекКлюч = "Результат";
				ТекЭтаж = Корень.Результат;
				ТекДанные = ?(ВзятьЭлементИсточникаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементИсточникаИзРеквизита]);
				//ИЕРАРХИЯ
				Для каждого ОписаниеКлюча Из Ключи Цикл
					Если ТекЭтаж = Неопределено Тогда
						ТекЭтаж = ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие);
						Корень.Вставить(ТекКлюч, ТекЭтаж);
					КонецЕсли;
					ТекКлюч = ТекДанные[ОписаниеКлюча.Колонка];
					Корень = ТекЭтаж;
					Если ?(ОписаниеКлюча.ЭтоСтруктура, НЕ ТекЭтаж.Свойство(ТекКлюч), ТекЭтаж[ТекКлюч] = Неопределено) Тогда
						ТекЭтаж = Неопределено;
					Иначе
						ТекЭтаж = ТекЭтаж[ТекКлюч];
					КонецЕсли;
				КонецЦикла;
				#Область ЗАПИХНУТЬ_НИЖНИЙ_УРОВЕНЬ
					#Область РАСЧЁТ_ЗНАЧЕНИЯ
						ТекДанные = ?(ВзятьЭлементРезультатаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементРезультатаИзРеквизита]);
						ТекЗначение = ?(ИсточникЭлементаРезультата = "#ВесьЭлемент", ТекДанные, ТекДанные[ИсточникЭлементаРезультата]);
					#КонецОбласти
					Если ТипЭлементаРезультата = "Массив" Тогда
						Если ТекЭтаж = Неопределено Тогда
							ТекЭтаж = Новый Массив;
						КонецЕсли;
						ТекЭтаж.Добавить(ТекЗначение);
					ИначеЕсли ТипЭлементаРезультата = "Значение" Тогда
						ТекЭтаж = ТекЗначение;
					Иначе
						ТекЭтаж = ТипЭлементаРезультата;
					КонецЕсли;
					Корень.Вставить(ТекКлюч, ТекЭтаж);
				#КонецОбласти
			КонецЦикла;
		Иначе
			Для каждого ОписаниеКлюча Из Ключи Цикл
				Результат.Вставить("Результат", ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие));
				Прервать;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат.Результат
КонецФункции // СоответствияИзКоллекции

// Получает КиЗ соответствия по индексу
// Параметры:
//  Откуда  - [Фиксированнное ]Соответствие - Откуда получить КИЗ
//  Индекс  - Число, начиная с нуля - Индекс элемента
// Возвращаемое значение:
//   КлючИЗначение   - КиЗ с заданным индексом. Неопределено, если такого нет.
Функция ЭлементСоответствияПоИндексу(Откуда, Индекс) Экспорт
	Результат = Неопределено;
	ЕЙЦ = 0;
	Найден = Ложь;
	Для каждого КиЗ Из Откуда Цикл
		Если ЕЙЦ = Индекс Тогда
			Найден = Истина;
			Прервать;
		Иначе
			ЕЙЦ = ЕЙЦ + 1;
		КонецЕсли; 
	КонецЦикла;
	Если Найден Тогда
		Результат = КиЗ;
	КонецЕсли; 
	Возврат Результат
КонецФункции // ЭлементСоответствияПоИндексу

#КонецОбласти

#Область МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
	
// Запускает менеджер (обработчик) реквизита или события. При этом нераспознаваемые значения не будут приводить к вызову сервера.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"Т:" (рус) - строка,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Имя реквизита, по которому вести распознавание.
//  Родитель  - Родитель, внутри которого вести распознавание.
//  Владелец  - Владелец, внутри которого вести распознавание.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция ЗапуститьМенеджер(
		Менеджер,
		ПараметрыМенеджера = Неопределено,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		СообщатьСюда = Неопределено) Экспорт
	Хрюква = "Специальная@#Хрюква_КоТоРоЙ:$ЯвноНе()Будет";
	Результат = Хрюква;
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		ТекТип = ТипЗнч(Менеджер);
		Если ТекТип <> Тип("Строка") И СтрНайти("Переопределяемые процедуры,Внешние обработки,Дополнительные отчеты и обработки", ТекТип) = 0 Тогда
			Результат = Менеджер;
			//Сюда надо добавить проверки других вариантов, чтоб не прыгать с клиента на сервер
		КонецЕсли;
	#КонецЕсли
	Если Результат = Хрюква Тогда
		Результат = ВОЛНА_ОбщегоНазначенияВС.РассчитатьМенеджерНаСервере(
				Менеджер,
				ПараметрыМенеджера,
				ТипыДляРаспознавания,
				ОбработкаИсключения,
				ПоРеквизиту,
				Родитель,
				Владелец,
				СообщатьСюда)
	КонецЕсли;
	Возврат Результат
КонецФункции

#КонецОбласти

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возращает, есть ли реквизит у объекта. При массивных данных в реквизите может притормозить выполнение.
// Параметры:
//  Реквизит  - Строка - Имя проверяемого реквизита
//  Объект  - Любое значение - Любое значение, имеющее реквизиты
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
Функция ЕстьРеквизитОбъекта(Реквизит, УКого) Экспорт
	ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
	Проверятель = Новый Структура(Реквизит, ЛюбоеНедопустимоеЗначение);
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Возврат Проверятель[Реквизит] <> ЛюбоеНедопустимоеЗначение
КонецФункции // ЕстьРеквизитОбъекта()

// Возращает структуру с информацией, есть ли реквизиты у объекта. При массивных данных в реквизитах может притормозить выполнение.
// Параметры:
//  Реквизиты  - Строка с разделеителем - Имена проверяемоых реквизитов
//  УКого  - Любое значение - Любое значение, имеющее реквизиты
//  Режим  - Строка - 
//			*"Копирование" Останутся все перечисленные в Ревизиты со значениями реквизитов + ключ "Хрюква", его значение будет в отсутствующих реквизитах.
//			*"Пересечение" Включение режима, когда в результате останутся значения только имеющихся в УКого реквизитов.
//			*"Проверка" (По умолчанию) = Останутся все перечисленные в Ревизиты, а значения будут булевыми
// Возвращаемое значение:
//   Структура - Истина/значение реквизита, если реквизит есть, Ложь - если реквизита нет.
Функция ЕстьРеквизитыОбъекта(Реквизиты, УКого, Режим = "Проверка") Экспорт
	ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
	Проверятель = Новый Структура(Реквизиты);
	Для каждого КиЗ Из Проверятель Цикл
		Проверятель.Вставить(КиЗ.Ключ, ЛюбоеНедопустимоеЗначение);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Если Режим = "Копирование" Тогда
		Результат = Проверятель;
		Результат.Вставить("Хрюква", ЛюбоеНедопустимоеЗначение);
	ИначеЕсли Режим = "Пересечение" Тогда
		Результат = Новый Структура;
		Для каждого КиЗ Из Проверятель Цикл
			Если КиЗ.Значение <> ЛюбоеНедопустимоеЗначение Тогда
				Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Результат = Новый Структура;
		Для каждого КиЗ Из Проверятель Цикл
			Результат.Вставить(КиЗ.Ключ, КиЗ.Значение <> ЛюбоеНедопустимоеЗначение);
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ЕстьРеквизитОбъекта()

// Получает значение реквизита объекта без ошибки, если реквизита нет.
// Параметры:
//  Источник  - Произвольный - Любой объект, который может быть источником для ЗаполнитьЗначенияСвойств
//  ИмяРеквизита  - Строка - Имя читаемого реквизита
//	ЕслиНеНайден - Произвольный - возвращаемое значение, если реквизит не найден. По умолчанию NULL.
//	ПолученноеЗначение - Произвольный - Переменная, куда будет возвращено значение (для запуска как процедуры). По умолчанию NULL.
// Возвращаемое значение:
//   Произвольный   - Значение указанного реквизита
Функция Получить(Источник, ИмяРеквизита, ЕслиНеНайден = NULL, ПолученноеЗначение = NULL) Экспорт
	Результат = Новый Структура(ИмяРеквизита, ЕслиНеНайден);
	ЗаполнитьЗначенияСвойств(Результат, Источник);
	Возврат Результат[ИмяРеквизита]
КонецФункции // Получить

// Сравнивает объекты пореквизитно (Истина - равны)
// Параметры:
//  Значение1  - Произвольное значение с реквизитами - Первый объект сравнения
//  Значение2  - Произвольное значение с реквизитами - Второй объект сравнения
//  МассивСвойств  - Массив строк - Имена реквизитов. Если не указан, предполагается, что первый объект - структура или соответствие, и сравнение идёт по его ключам
// Возвращаемое значение:
//   Булево   - Истина, если пореквизитное равенство
Функция ПореквизитноРавны(Значение1, Значение2, МассивСвойств = Неопределено) Экспорт
	Если МассивСвойств = Неопределено Тогда
		МассивСвойств = Новый Массив;
		Для каждого КиЗ Из Значение1 Цикл
			МассивСвойств.Добавить(КиЗ.Ключ);
		КонецЦикла; 
	КонецЕсли;
	Результат = Истина;
	Для каждого Имя Из МассивСвойств Цикл
		Если Значение1[Имя] <> Значение2[Имя] Тогда
			Результат = Ложь;
			Прервать
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // ПореквизитноРавны

#КонецОбласти 

#Область ССЫЛКИ_УИДЫ
	
//Переводит строку ГУИД в УИД
//Параметры:
//	GUID_ - Строка - 32 значный ГУИД
//Возвращаемое значение:
//	Строка - в формате УникальныйИдентификатор (36 символов)
Функция GUIDToUUID(GUID_) Экспорт
 
 Возврат Прав(GUID_, 8) + "-" + Сред(GUID_, 21, 4) + "-" + Сред(GUID_, 17, 4) + "-" + Лев(GUID_, 4) + "-" + Сред(GUID_, 5, 12);
 
КонецФункции

//Переводит строку УИД в ГУИД
//Параметры:
//	UUID_ - Строка - в формате УникальныйИдентификатор (36 символов)
//Возвращаемое значение:
//	Строка - 32 значный ГУИД
Функция UUIDToGUID(UUID_) Экспорт
 
 Возврат Сред(UUID_, 20, 4) + Прав(UUID_, 12) + Сред(UUID_, 15, 4) + Сред(UUID_, 10, 4) + Лев(UUID_, 8);
 
КонецФункции

#КонецОбласти 

#Область СТРОКОВЫЕ

// Преобразует строку в дату
// Параметры:
//  Строчка  - Строка - Строка, из которой надо попытаться сделать дату
//  ВПериодеВзятьКонец  - Булево - Если строка - период, то вернуть его конец. Иначе (по умолчанию - ложь) - начало.
// Возвращаемое значение:
//   Дата   - Дата, вычисленная из строки. Неопределено, если не получается.
Функция ДатаИзСтроки(Строчка, ВПериодеВзятьКонец = Ложь) Экспорт
	Результат = Неопределено;
	СтрокаРаспознания = СтрЗаменить(СтрЗаменить(СтрЗаменить(Строчка, "/", Символы.ПС), ".", Символы.ПС), " ", Символы.ПС);
	Сброс = Истина;
	Для Сч = 1 По СтрЧислоСтрок(СтрокаРаспознания) Цикл
		Если Сброс Тогда
			ГодДаты = 0;
			МесяцДаты = 0;
			ДеньДаты = 0;
			Сброс = Ложь;
		КонецЕсли;
		ТекСтр = ВРег(СтрПолучитьСтроку(СтрокаРаспознания, Сч));
		Если НЕ ПустаяСтрока(ТекСтр) Тогда
			Если ДеньДаты = 0 Тогда
				Если СтрДлина(ТекСтр) < 3 Тогда
					Попытка
						ДеньДаты = Число(ТекСтр);
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если ДеньДаты = 0 Тогда
					Если ТекСтр = "ЯНВАРЬ" Тогда
						МесяцДаты = 1;
					ИначеЕсли ТекСтр = "ФЕВРАЛЬ" Тогда
						МесяцДаты = 2;
					ИначеЕсли ТекСтр = "МАРТ" Тогда
						МесяцДаты = 3;
					ИначеЕсли ТекСтр = "АПРЕЛЬ" Тогда
						МесяцДаты = 4;
					ИначеЕсли ТекСтр = "МАЙ" Тогда
						МесяцДаты = 5;
					ИначеЕсли ТекСтр = "ИЮНЬ" Тогда
						МесяцДаты = 6;
					ИначеЕсли ТекСтр = "ИЮЛЬ" Тогда
						МесяцДаты = 7;
					ИначеЕсли ТекСтр = "АВГУСТ" Тогда
						МесяцДаты = 8;
					ИначеЕсли ТекСтр = "СЕНТЯБРЬ" Тогда
						МесяцДаты = 9;
					ИначеЕсли ТекСтр = "ОКТЯБРЬ" Тогда
						МесяцДаты = 10;
					ИначеЕсли ТекСтр = "НОЯБРЬ" Тогда
						МесяцДаты = 11;
					ИначеЕсли ТекСтр = "ДЕКАБРЬ" Тогда
						МесяцДаты = 12;
					КонецЕсли;
					Если МесяцДаты > 0 Тогда
						ДеньДаты = ?(ВПериодеВзятьКонец, -1, 1)
					КонецЕсли;
				КонецЕсли; 
			ИначеЕсли МесяцДаты = 0 Тогда
				Попытка
					МесяцДаты = Число(ТекСтр);
				Исключение
					ТекСтр = ВРег(ТекСтр);
					Если ТекСтр = "ЯНВАРЯ" Тогда
						МесяцДаты = 1;
					ИначеЕсли ТекСтр = "ФЕВРАЛЯ" Тогда
						МесяцДаты = 2;
					ИначеЕсли ТекСтр = "МАРТА" Тогда
						МесяцДаты = 3;
					ИначеЕсли ТекСтр = "АПРЕЛЯ" Тогда
						МесяцДаты = 4;
					ИначеЕсли ТекСтр = "МАЯ" Тогда
						МесяцДаты = 5;
					ИначеЕсли ТекСтр = "ИЮНЯ" Тогда
						МесяцДаты = 6;
					ИначеЕсли ТекСтр = "ИЮЛЯ" Тогда
						МесяцДаты = 7;
					ИначеЕсли ТекСтр = "АВГУСТА" Тогда
						МесяцДаты = 8;
					ИначеЕсли ТекСтр = "СЕНТЯБРЯ" Тогда
						МесяцДаты = 9;
					ИначеЕсли ТекСтр = "ОКТЯБРЯ" Тогда
						МесяцДаты = 10;
					ИначеЕсли ТекСтр = "НОЯБРЯ" Тогда
						МесяцДаты = 11;
					ИначеЕсли ТекСтр = "ДЕКАБРЯ" Тогда
						МесяцДаты = 12;
					Иначе
						Сброс = Истина;
					КонецЕсли;
				КонецПопытки;
			Иначе
				Попытка
					ТекСтр = СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекСтр, "ГОДА", ""), "ГОД", ""), "Г", "");
					ГодДаты = Число(ТекСтр);
					Если ГодДаты < 100 Тогда
						ТекГод = Год(ТекущаяДата());
						ГодДаты = ГодДаты + ТекГод - ТекГод % 100;
					КонецЕсли; 
					Если (ГодДаты < 100) ИЛИ (ГодДаты > 3999) Тогда
						Сброс = Истина;
					Иначе
						Прервать;
					КонецЕсли; 
				Исключение
					Сброс = Истина;
				КонецПопытки;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Попытка
		Результат = Дата(ГодДаты, МесяцДаты, ?(ДеньДаты = -1, 1, ДеньДаты));
		Если ДеньДаты = -1 Тогда
			Результат = КонецМесяца(Результат);
		КонецЕсли; 
	Исключение
	КонецПопытки;
	Возврат Результат
КонецФункции // ДатаИзСтроки
 
// Заменяет наименования подразделения на наименовния для печати
// Параметры:
//  Текст  - Строка - Где менять
//  Замены  - Соответствие - Что менять (ключ) и на что менять (значение)
Функция ЗаменитьВТексте(Текст, Замены) Экспорт
	Результат = Текст;
	Для каждого КиЗ Из Замены Цикл
		Результат = СтрЗаменить(Результат, КиЗ.Ключ, КиЗ.Значение);
	КонецЦикла;
	Возврат Результат
КонецФункции // ЗаменитьВТексте
 
// Заменяет конец строки новым набором символов той же длины
// Параметры:
//  ГдеМенять  - Любое значение, преобразуемое в строку - Исходная строка;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Новый конец строки;
Процедура ЗаменитьКонецСтроки(ГдеМенять, НаЧтоМенять)Экспорт
	ГдеМенять = Лев(ГдеМенять, СтрДлина(ГдеМенять) - СтрДлина(НаЧтоМенять)) + НаЧтоМенять
КонецПроцедуры

//Преобразует имя переменной в строку представления
//заменой заглавных букв на строчные с пробелом
// Параметры:
//  ИмяПеременной  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПропуститьНедопустимые  - Булево - При Истина (по умолчанию) символы, недопустимые в имени переменной, будут заменены на пробел,
//			а следующий символ - на заглавный, при Ложь - будут обработаны как допустимый символ;
// Возвращаемое значение:
//   Строка   - Исходная строка с заменой:
//			*Обозначения:
//				а = строчный
//				А = заглавный
//				Ь = заглавный, подлежащий проверке в следующих комбинациях
//				% = любой небуквенный непустой и не _
//				_ = _
//				9 = цифра
//				Н = Первый в строке и заглавный
//				П = Пустой
//				п = пустой или _
//			*Замены:
//				*Первый символ кроме пустых - всегда как есть. Краевые пробелы и _ убираются.
//				*Последний символ любой комбинации участвует в следующей проверке.
//				п_А => "_А"
//				п_% => "_%"
//				п_п => " п"
//				п_а => " а"
//				пП => " "
//				пААп => " а а "
//				пАА% => " АА%"
//				пААА => " ЬЬЬ"
//				пААа => " а аа"
//				_Аа => " аа"
//				ПАа => " Аа"
//				пАп => " а "
//				пА% => " А%"
//				па => " а"
//				п% => "_%"
//				%ААп => "% а а "
//				%АА% => % АА%
//				%ААА => % ЬЬЬ
//				%ААа => % а аа
//				%Ап => "%А "
//				%А% => % А%
//				%Аа => % аа
//				%а => "% а"
//				АААа => АА аа
//				НАп => "НА "
//				НАа => Н аа
//				аААп => а АА
//				аАА% => а АА%
//				аААА => а ЬЬЬ
//				аААа => а а аа
//				аАп => "а А "
//				аА% => а А%
//				аАа => а аа
Функция ИмяПеременнойВСтроку(ИмяПеременной, ПропуститьНедопустимые = Истина) Экспорт
	#Область ИНИЦИАЛИЗАЦИЯ
		Заглавные = СимволыГруппы("БуквыЗагл");
		Строчные = СимволыГруппы("БуквыСтр");
		Допустимые = СимволыГруппы("СПиЦ");
		Цифры = СимволыГруппы("Цифры");
		ТекДлина = СтрДлина(ИмяПеременной);
		Результат = "";
		Буфер = ""; //Символы, ещё не попавших в результат - к следующей проверке
		КрайНеОк = Истина;
		ЭтоПервый = Истина;
		Пропустить = 0;
		ИсходноеИмя = ИмяПеременной;
	#КонецОбласти
	
	ПрошлаяСерия = 0;
	ПозаСерия = 0;
	Серия = 0; //1 - строчные, 2 - заглавные, 3 - символы и цифры.
	
	#Область КРАЕВЫЕ
		Пока КрайНеОк И ТекДлина > 0 Цикл
			КрайНеОк = Ложь;
			ТекБуква = Прав(ИсходноеИмя, 1);
			Если ТекБуква = "_" ИЛИ НЕ ЗначениеЗаполнено(ТекБуква) Тогда
				ТекДлина = ТекДлина - 1;
				ИсходноеИмя = Лев(ИсходноеИмя, ТекДлина);
				КрайНеОк = Истина;
			КонецЕсли;
			ТекБуква = Лев(ИсходноеИмя, 1);
			Если ТекБуква = "_" ИЛИ НЕ ЗначениеЗаполнено(ТекБуква) Тогда
				ТекДлина = ТекДлина - 1;
				ИсходноеИмя = Сред(ИсходноеИмя, 2);
				КрайНеОк = Истина;
			КонецЕсли;
		КонецЦикла;
	#КонецОбласти
	#Область ЗАМЕНЫ
		Для Ё = 1 По ТекДлина Цикл
			Если ЭтоПервый Тогда
				#Область РАСЧЁТ_БУКВЫ
					ТекБуква = Лев(ИсходноеИмя, 1);
					ТекБуква_ = ТекБуква = "_";
					ТекБукваПустая = НЕ ЗначениеЗаполнено(ТекБуква);
					ТекБукваЗаглавная = СтрНайти(Заглавные, ТекБуква) > 0;
					ТекБукваСтрочная = СтрНайти(Строчные, ТекБуква) > 0;
					ТекБукваДопустимая = СтрНайти(Допустимые, ТекБуква) > 0;
					ТекБуква1 = Сред(ИсходноеИмя, 2, 1);
					ТекБуква1_ = ТекБуква1 = "_";
					ТекБуква1Пустая = НЕ ЗначениеЗаполнено(ТекБуква1);
					ТекБуква1Заглавная = СтрНайти(Заглавные, ТекБуква1) > 0;
					ТекБуква1Строчная = СтрНайти(Строчные, ТекБуква1) > 0;
					ТекБуква1Допустимая = СтрНайти(Допустимые, ТекБуква1) > 0;
					ТекБуква2 = Сред(ИсходноеИмя, 3, 1);
					ТекБуква2_ = ТекБуква2 = "_";
					ТекБуква2Пустая = НЕ ЗначениеЗаполнено(ТекБуква2);
					ТекБуква2Заглавная = СтрНайти(Заглавные, ТекБуква2) > 0;
					ТекБуква2Строчная = СтрНайти(Строчные, ТекБуква2) > 0;
					ТекБуква2Допустимая = СтрНайти(Допустимые, ТекБуква2) > 0;
					ТекБуква3 = Сред(ИсходноеИмя, 4, 1);
					ТекБуква3_ = ТекБуква3 = "_";
					ТекБуква3Пустая = НЕ ЗначениеЗаполнено(ТекБуква3);
					ТекБуква3Заглавная = СтрНайти(Заглавные, ТекБуква3) > 0;
					ТекБуква3Строчная = СтрНайти(Строчные, ТекБуква3) > 0;
					ТекБуква3Допустимая = СтрНайти(Допустимые, ТекБуква3) > 0;
				#КонецОбласти
			Иначе
				#Область ИЗ_ПРЕД_ДАННЫХ
					ТекБуква = ТекБуква1;
					ТекБуква_ = ТекБуква1_;
					ТекБукваПустая = ТекБуква1Пустая;
					ТекБукваЗаглавная = ТекБуква1Заглавная;
					ТекБукваСтрочная = ТекБуква1Строчная;
					ТекБукваДопустимая = ТекБуква1Допустимая;
					ТекБуква1 = ТекБуква2;
					ТекБуква1_ = ТекБуква2_;
					ТекБуква1Пустая = ТекБуква2Пустая;
					ТекБуква1Заглавная = ТекБуква2Заглавная;
					ТекБуква1Строчная = ТекБуква2Строчная;
					ТекБуква1Допустимая = ТекБуква2Допустимая;
					ТекБуква2 = ТекБуква3;
					ТекБуква2_ = ТекБуква3_;
					ТекБуква2Пустая = ТекБуква3Пустая;
					ТекБуква2Заглавная = ТекБуква3Заглавная;
					ТекБуква2Строчная = ТекБуква3Строчная;
					ТекБуква2Допустимая = ТекБуква3Допустимая;
					ТекБуква3 = Сред(ИсходноеИмя, Ё + 3, 1);
					Если ТекБуква3 = "" Тогда
						ТекБуква3 = "Х";
					КонецЕсли;
					ТекБуква3_ = ТекБуква3 = "_";
					ТекБуква3Пустая = НЕ ЗначениеЗаполнено(ТекБуква3);
					ТекБуква3Заглавная = СтрНайти(Заглавные, ТекБуква3) > 0;
					ТекБуква3Строчная = СтрНайти(Строчные, ТекБуква3) > 0;
					ТекБуква3Допустимая = СтрНайти(Допустимые, ТекБуква3) > 0;
				#КонецОбласти
			КонецЕсли;
			Если Пропустить > 0 Тогда
				Пропустить = Пропустить - 1;
			Иначе
				Если ТекБукваПустая Тогда
					Если ТекБуква1_ Тогда
						Если ТекБуква2Пустая ИЛИ ТекБуква2Строчная Тогда
							ТекБуква1 = " "; 
						Иначе
							ТекБуква1 = "_"; 
						КонецЕсли;
					ИначеЕсли ТекБуква1Пустая Тогда
						ТекБуква1 = " "; 
					ИначеЕсли ТекБуква1Заглавная Тогда
						Если ТекБуква2Заглавная Тогда
							Если ТекБуква3Заглавная Тогда
								Результат = Результат + " ";
							ИначеЕсли ТекБуква3Строчная Тогда
								Результат = Результат + " ";
							ИначеЕсли ТекБуква3Пустая Тогда
								Результат = Результат + " " + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
								Пропустить = 2;
							Иначе
								Результат = Результат + " " + ТекБуква1 + ТекБуква2;
								Пропустить = 2;
							КонецЕсли;
						ИначеЕсли ТекБуква2Строчная Тогда
							Результат = Результат + " " + ?(ТекБуква_, НРег(ТекБуква1), ТекБуква1);
							Пропустить = 1;
						ИначеЕсли ТекБуква2Пустая Тогда
							Результат = Результат + " " + НРег(ТекБуква1);
							Пропустить = 1;
						Иначе
							Результат = Результат + " " + ТекБуква1;
							Пропустить = 1;
						КонецЕсли;
					ИначеЕсли ТекБуква1Строчная Тогда
						Результат = Результат + " "; 
					Иначе
						Результат = Результат + "_"; 
					КонецЕсли;
				ИначеЕсли ТекБукваЗаглавная Тогда
					Если ТекБуква1Заглавная Тогда
						Если ТекБуква2Заглавная И ТекБуква3Строчная Тогда
							Результат = Результат + ТекБуква + ТекБуква1 + " " + НРег(ТекБуква2);
							Пропустить = 2;
						ИначеЕсли ЭтоПервый И ТекБуква2Пустая Тогда
							Результат = Результат + ТекБуква + ТекБуква1;
							Пропустить = 1;
						ИначеЕсли ЭтоПервый И ТекБуква2Строчная Тогда
							Результат = Результат + ТекБуква + " " + НРег(ТекБуква1);
							Пропустить = 1;
						Иначе
							Результат = Результат + ТекБуква;
						КонецЕсли;
					Иначе
						Результат = Результат + ТекБуква;
					КонецЕсли;
				ИначеЕсли ТекБукваСтрочная Тогда
					Если ТекБуква1Заглавная Тогда
						Если ТекБуква2Заглавная Тогда
							Если ТекБуква3Заглавная Тогда
								Результат = Результат + ТекБуква + " ";
							ИначеЕсли ТекБуква3Строчная Тогда
								Результат = Результат + ТекБуква + " " + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
								Пропустить = 2;
							Иначе
								Результат = Результат + ТекБуква + " " + ТекБуква1 + ТекБуква2;
								Пропустить = 2;
							КонецЕсли;
						ИначеЕсли ТекБуква2Строчная Тогда
							Результат = Результат + ТекБуква + " " + НРег(ТекБуква1);
							Пропустить = 1;
						Иначе
							Результат = Результат + ТекБуква + " " + ТекБуква1;
							Пропустить = 1;
						КонецЕсли;
					Иначе
						Результат = Результат + ТекБуква;
					КонецЕсли;
				Иначе
					Если ТекБукваДопустимая ИЛИ НЕ ПропуститьНедопустимые Тогда
						Результат = Результат + ТекБуква;
					КонецЕсли;
					Если ТекБуква1Заглавная Тогда
						Если ТекБуква2Заглавная Тогда
							Результат = Результат + " ";
							Если ТекБуква3Заглавная Тогда
							ИначеЕсли ТекБуква3Пустая ИЛИ ТекБуква3Строчная Тогда
								Результат = Результат + НРег(ТекБуква1) + " " + НРег(ТекБуква2);
								Пропустить = 2;
							Иначе
								Результат = Результат + ТекБуква1 + ТекБуква2;
								Пропустить = 2;
							КонецЕсли;
						ИначеЕсли ТекБуква2Пустая ИЛИ ТекБуква2Строчная Тогда
							Результат = Результат + ТекБуква1;
							Пропустить = 1;
						Иначе
							Результат = Результат + " " + ТекБуква1;
							Пропустить = 1;
						КонецЕсли;
					ИначеЕсли ТекБуква1Строчная Тогда
						Результат = Результат + " ";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			ЭтоПервый = Ложь;
		КонецЦикла;
	#КонецОбласти
	
	#Область СТАРЫЙ_КОД
		//Для Ё = 1 По ТекДлина Цикл
		//	ПозаСерия = ПрошлаяСерия;
		//	ПрошлаяСерия = Серия;
		//	Если Ё = ТекДлина Тогда
		//		КВставке = "";
		//		Серия = 0;
		//	Иначе
		//		ТекСимвол = Сред(ИмяПеременной, Ё, 1);
		//		Если ТекСимвол = "_" Тогда
		//			КВставке = ?(ПустаяСтрока(Прав(Буфер, 1)), "", " ");
		//			Серия = 3;
		//		ИначеЕсли Найти(Цифры, ТекСимвол) > 0 Тогда
		//			КВставке = ТекСимвол;
		//			Серия = 3;
		//		ИначеЕсли Найти(Строчные, ТекСимвол) > 0 Тогда
		//			КВставке = ТекСимвол;
		//			Серия = 1;
		//		ИначеЕсли Найти(Заглавные, ТекСимвол) > 0 Тогда
		//			КВставке = ТекСимвол;
		//			Серия = 2;
		//		Иначе
		//			КВставке = ?(ПропуститьНедопустимые, ?(ПустаяСтрока(Прав(Буфер, 1)), "", " "), ТекСимвол);
		//			Серия = 3;
		//		КонецЕсли;
		//	КонецЕсли;
		//	Если ПрошлаяСерия = Серия Тогда
		//		Буфер = Буфер + КВставке;
		//	ИначеЕсли ПрошлаяСерия = 0 ИЛИ ПрошлаяСерия = 3 Тогда
		//		Если ПрошлаяСерия = 3 Тогда
		//			Результат = Результат + Буфер;
		//			Буфер = "";
		//		Иначе
		//			Буфер = Буфер + ВРег(КВставке);
		//		КонецЕсли;
		//	ИначеЕсли ПрошлаяСерия = 2 Тогда
		//		Если Серия = 1 И (ПозаСерия = 1 ИЛИ ПозаСерия = 2) Тогда
		//			ТекСлово = Лев(Буфер, СтрДлина(Буфер) - 1) + " ";
		//			Буфер = НРег(Прав(Буфер, 1)) + КВставке;
		//		Иначе
		//			ТекСлово = Буфер;
		//			Буфер = КВставке;
		//		КонецЕсли; 
		//		//Если СтрДлина(ТекСлово) = 1 Тогда
		//		//	ТекСлово = НРег(ТекСлово);
		//		//КонецЕсли;
		//		Результат = Результат + ТекСлово;
		//	Иначе
		//		Результат = Результат + СокрЛП(Буфер);
		//		Буфер = КВставке;
		//	КонецЕсли; 
		//КонецЦикла;
		//Возврат Сред(Результат, 2)
	#КонецОбласти
	Возврат Результат
КонецФункции

// Заменяет в исходной строке все заданные значения на заданные значения замен с повторением,
// пока не исчезнут заменяемые значения. По умолчанию - для замены лишних пробелов.
// Параметры:
//  НачСтрока  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПодстрокаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, которую искоренить;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, на которую заменить;
// Возвращаемое значение:
//   Строка   - Строка без заменяемой подстроки (после всех замен)
Функция ИскоренитьПодстроку(НачСтрока, ПодстрокаЧтоМенять = "  ", НаЧтоМенять = " ") Экспорт
	Результат = Строка(НачСтрока);
	Пока СтрНайти(Результат, ПодстрокаЧтоМенять) > 0 Цикл
		Результат = СтрЗаменить(Результат, ПодстрокаЧтоМенять, НаЧтоМенять);
	КонецЦикла;
	Возврат Результат
КонецФункции // ИскоренитьПодстроку()
 
// Преобразует строковый литерал в текст
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: удалены символы переноса, раздвоены кавычки
Функция ЛитералВТекст(Текст_) Экспорт
	Возврат СтрЗаменить(СтрЗаменить(Текст_, "|",  ""), """""", """")
КонецФункции // ТекстВЛитерал

//Находит число символов до заданной подстроки. Если подстроки нет, берётся вся строка.
// Параметры:
//	ГдеИскать - Строка - в которой ищем
//	ИскомыйТекст - Строка - которую ищем
// Возвращаемое значение:
//	Число - колво символов до подстроки. СлужебнаяНайтиКолвоСимволовДоВхождения("12345", "234") = 1
Функция НайтиКолвоСимволовДоВхождения(ГдеИскать, ИскомыйТекст) Экспорт
	Результат = СтрНайти(ГдеИскать, ИскомыйТекст) - 1;
	Возврат ?(Результат < 0, СтрДлина(ГдеИскать), Результат)
КонецФункции // СлужебнаяНайтиКолвоСимволовДоВхождения()

//Ищет строку в составе другой строки, но только как подстроку между разделителями без краевых пробелов
//Возвращает позицию найденной подстроки или 0
// Параметры:
//  ГдеИскать  - Любое значение, преобразуемое в строку - В которой будет поиск
//  ЧтоИскать  - Строка - Искомая строка
//  Разделитель  - Строка - Разделитель частей в ГдеИскать
// Возвращаемое значение:
//   Число   - Позиция начала подстроки
Функция НайтиПодСтроку(ГдеИскать, ЧтоИскать, Разделитель = ",") Экспорт
	Возврат СтрНайти(Разделитель + ГдеИскать + Разделитель, Разделитель + ЧтоИскать + Разделитель)
КонецФункции

// Возвращает типовой разделитель запросов
// Возвращаемое значение:
//   Строка   - Типовой разделитель запросов
Функция РазделительЗапросов() Экспорт
	Результат =
			"
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|";
	Возврат Результат
КонецФункции // РазделительЗапросов

//Проверяет строку на соответствие маске
//источник - инфостарт
//Параметры:
//	Строчка - строка/Массив - проверяемые строки
//	Тестер - значение XDTO - Тестер строки по маске. Если Неопределено - создаётся.
//	Маска - строка - шаблон, на соответствие которому проверяется
//		. - любой символ
//		+ - один или более раз, пример ".+" - один или более любой символ. Суффикс "ревнивого" квантификатора (аа в ааа найдёт только одно вхождение, т.к. вторая а уже участвовала в первом и не может быть использована повторно).
//		* - ноль или более раз, пример ".*" - любое количество любых символов (даже ни одного).
//		[n-m] - символ от m до n, пример: "[0-9]+" - одна или более цифр(а).
//		\b - граница слова (первый или последний символ).
//		\B - не граница слова.
//		\d - цифра, пример \d+ - одна или более цифр(а).
//		\D - не цифра.
//		\G - Предыдущий успешный поиск (\Ga - первая позиция не с буквой а).
//		\s - пробельный символ - ТАБ, пробел, перенос строки, возврат каретки и т.п.
//		\S - непробельный символ.
//		\w, [[:word:]] - буква, цифра, подчеркивание.
//		\W - не буква, не цифра и не подчеркивание соответственно.
//		^ - начало текста, например "^\d+" - строка начинается с цифры.
//		$ - конец текста, например "\D+$" - строка заканчивается НЕ цифрой.
//		{m,n} - шаблон для от m до n символов, например "\d{2,4}" - от двух до четырех цифр. Можно указать одну цифру для строгого соответвия или цифру с запятой для только одной границы (от/до бесконечности).
//		\ - экранирует спецсимволы. Например, "\." - символ точки.
//		| - ИЛИ.
//		^ - НЕ, конец текста.
//		$ - начало текста.
//		\ - экранирует спецсимволы. Например, "\." - символ точки.
//		() - границы, приоритет - как в выражениях.
//		? - префикс - 0 или 1 повтор, суффикс - ленивого квантификатора (0*х найдёт в 0ААхх только 0ААх, но не 0ААхх).
//		?>ШАБЛОН - ищет шаблон "жадно". ?>(2*)5 не найдёт 2225, т.к. найдёт 2225 по шаблону 2*, после чего 5 уже занято. Работает быстрее.
//	По умолчанию - маска проверки даты "\d{2}\.\d{2}\.\d{4}"
//Возвращаемое значение - Булево - Строка соответствует шаблону или массив, если передан массив.
Функция ПроверитьСтроку(Строчка, Маска = "\d{2}\.\d{2}\.\d{4}", Тестер = Неопределено) Экспорт
	Если Тестер = Неопределено Тогда
		Тестер = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Маска)
	КонецЕсли;

	Результат = Новый Массив;
	Для каждого ТекЗначение Из ПреобразоватьВМассив(Строчка) Цикл
	    Попытка
	        Тестер.TestItem = Строчка;
	        Результат.Добавить(Истина);
	    Исключение
	        Результат.Добавить(Ложь);
	    КонецПопытки;
	КонецЦикла; 
	Возврат ?(Результат.Количество() = 1, Результат[0], Результат)
КонецФункции

// Возвращает строку всех символов заданной группы
// Параметры:
//  Группа  - Строка - вид символов:
//		*Цифры
//		*БуквыРЛ
//		*БуквыРус
//		*БуквыЛат
//		*БуквыЗагл
//		*БуквыСтр
//		*БуквыРЗагл
//		*БуквыРСтр
//		*БуквыЛЗагл
//		*БуквыЛСтр
//		*ДляПеременной1
//		*ДляПеременнойВсе
//		*СПиЦ - символ подчёркивания и цифры
//		*АрифметикаДействия
// Возвращаемое значение:
//   Строка   - Все символы группы
Функция СимволыГруппы(Группа) Экспорт
	Результат = "";
	Если Группа = "АрифметикаДействия" Тогда
		Результат = "+-*/:^%";
	Иначе
		Цифры = "0123456789";
		БРЗ = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
		БЛЗ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		БРС = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
		БЛС = "abcdefghijklmnopqrstuvwxyz";
		СимП = "_";
		Если Группа = "БуквыЗагл" Тогда
			Результат = БЛЗ + БРЗ;
		ИначеЕсли Группа = "БуквыЛат" Тогда
			Результат = БЛЗ + БЛС;
		ИначеЕсли Группа = "БуквыЛЗагл" Тогда
			Результат = БЛЗ;
		ИначеЕсли Группа = "БуквыЛСтр" Тогда
			Результат = БЛС;
		ИначеЕсли Группа = "БуквыРЗагл" Тогда
			Результат = БРЗ;
		ИначеЕсли Группа = "БуквыРЛ" Тогда
			Результат = БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "БуквыРСтр" Тогда
			Результат = БРС;
		ИначеЕсли Группа = "БуквыРус" Тогда
			Результат = БРЗ + БРС;
		ИначеЕсли Группа = "БуквыСтр" Тогда
			Результат = БЛС + БРС;
		ИначеЕсли Группа = "ДляПерем1Загл" Тогда
			Результат = СимП + БЛЗ + БРЗ;
		ИначеЕсли Группа = "ДляПерем1Стр" Тогда
			Результат = СимП + БЛС + БРС;
		ИначеЕсли Группа = "ДляПеременной1" Тогда
			Результат = СимП + БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "ДляПеремВсеЗагл" Тогда
			Результат = СимП + Цифры + БЛЗ + БРЗ;
		ИначеЕсли Группа = "ДляПеремВсеСтр" Тогда
			Результат = СимП + Цифры + БЛС + БРС;
		ИначеЕсли Группа = "ДляПеременнойВсе" Тогда
			Результат = СимП + Цифры + БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "СПиЦ" Тогда
			Результат = СимП + Цифры;
		ИначеЕсли Группа = "Цифры" Тогда
			Результат = Цифры;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СимволыГруппы

//Возвращает сочетание клавиш по строковому обозначению   ??? Вызовет ошибку на сервере??? - надо проверить
//Параметры:
//	СтроковоеОбозначениеСочетания - Строка - Расшифровываемое сочетание
//Возвращаемое значение
//	СочетаниеКлавиш - распознанное сочетание или Неопределено
Функция СочетаниеКлавишПоСтроке(СтроковоеОбозначениеСочетания) Экспорт
	Результат = Неопределено;
	Ктрл = Ложь;
	Шифт = Ложь;
	Алт = Ложь;
	Код = СтрЗаменить(СтроковоеОбозначениеСочетания, " ", "");
	
	ТекТекст = "Ctrl+";
	Поз = СтрНайти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Ктрл = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли; 
	
	ТекТекст = "Shift+";
	Поз = СтрНайти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Шифт = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли; 
	
	ТекТекст = "Alt+";
	Поз = СтрНайти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Алт = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли;
	
	Клав = Новый Структура("Код", "");
	ЗаполнитьЗначенияСвойств(Клав, Клавиша);
	Клав = Клав.Код;
	//Попытка
	//	Клав = Клавиша[Код];
	//Исключение
	//	Клав = "";
	//КонецПопытки;
	//
	Если Клав <> "" Тогда
		Результат = Новый СочетаниеКлавиш(Клав, Алт, Ктрл, Шифт);
	КонецЕсли; 
	Возврат Результат
КонецФункции // СочетаниеКлавишПоСтроке()

// СтрЗаменить, но без учёта регистра
// Параметры:
//  ГдеМенять  - Строка - в котрой надо сделать замены, например, аБабА
//  ЧтоМенять  - Строка - которую надо найти и обезвредить, например, АБА
//  НаЧтоМенять  - Строка - Которая появится вместо искомой, например, АА
// Возвращаемое значение:
//   Строка   - с заменами, в примере - ААБА
Функция СтрЗаменитьБезУчётаРегистра(ГдеМенять, ЧтоМенять, НаЧтоМенять) Экспорт
	НачСтрока = ГдеМенять;
	Результат = "";
	ДлинаЧтоЗаменять = СтрДлина(ЧтоМенять);
	Пока Истина Цикл
		ПозВхождения = СтрНайти(ВРег(НачСтрока), ВРег(ЧтоМенять));
		Если ПозВхождения = 0 Тогда
			Результат = Результат + НачСтрока;
			Прервать;
		КонецЕсли;
		Результат = Результат + Лев(НачСтрока, ПозВхождения - 1) + НаЧтоМенять;
		НачСтрока = Сред(НачСтрока, ПозВхождения + ДлинаЧтоЗаменять);
	КонецЦикла; 
	Возврат Результат;
КонецФункции // СтрЗаменитьБезУчётаРегистра()

//Преобразует строку представления в имя переменной
//заменой строчных букв с пробелом на заглавные
// Параметры:
//  Строка_  - Любое значение, преобразуемое в строку - Исходная строка;
// Возвращаемое значение:
//   Строка   - Строка без запретных символов и с заменой " символ" на ВРег(символ)
Функция СтрокуВИмяПеременной(Строка_) Экспорт
	Результат = "";
	Источник = Строка_;
	СтарДл = - 1;
	Пока Истина Цикл
		ТекДл = СтрДлина(Источник);
		Если ТекДл = СтарДл Тогда
			Прервать
		КонецЕсли;
		СтарДл = ТекДл;
		Источник = СтрЗаменить(Источник, "  ", " ");
	КонецЦикла; 
	Допустимые = СимволыГруппы("ДляПеременной1");
	ДопустимыеВсе = СимволыГруппы("ДляПеременнойВсе");
	ФлВРег = Истина;
	Для Ё = 1 По СтрДлина(Источник) Цикл
		ТекСимв = Сред(Источник, Ё, 1);
		Если СтрНайти(?(Ё = 1, Допустимые, ДопустимыеВсе), ТекСимв) > 0 Тогда
			Результат = Результат + ?(ФлВРег, ВРег(ТекСимв), ТекСимв);
			ФлВРег = Ложь;
		Иначе
			ФлВРег = Истина;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
Функция СтрРазделить_(ЧтоДелим, Разделитель = ",", ВключатьПустые = Истина) Экспорт
	Хрюква = "/°|°\";
	ХрюкваР = "/°-|-°\";
	ИзувеченнаяСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(ЧтоДелим, Разделитель, ХрюкваР), Символы.ПС, Хрюква), ХрюкваР, Символы.ПС);
	Результат = Новый Массив;
	Для Ё = 1 По СтрЧислоСтрок(ИзувеченнаяСтрока) Цикл
		ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(ИзувеченнаяСтрока, Ё), Хрюква, Символы.ПС);
		Если ВключатьПустые ИЛИ НЕ ПустаяСтрока(ТекЗнч) Тогда
			Результат.Добавить(ТекЗнч);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // СтрРазделить()

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
Функция СтрСоединить_(ЧтоСоединяем, Разделитель = ",") Экспорт
	Результат = "";
	Для Ё = 0 По ЧтоСоединяем.ВГраница() Цикл
		Результат = Результат + Разделитель + ЧтоСоединяем[Ё]; 
	КонецЦикла; 
	Возврат Сред(Результат, СтрДлина(Разделитель) + 1)
КонецФункции // СтрРазделить()

// Преобразует текст в строковый литерал
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: добавлены символы переноса, удвоены кавычки
Функция ТекстВЛитерал(Текст_) Экспорт
	Возврат СтрЗаменить(СтрЗаменить(Текст_, Символы.ПС, Символы.ПС + "|"), """", """""")
КонецФункции // ТекстВЛитерал
 
// Возвращает строку с разделителями без заданных элементов, например "Коля ,Вася , Галя", " Вася" = > "Коля,Галя"
// Лишние пробелы будут устранены.
// Параметры:
//	СтрокаСРазделителями- Любое значение, преобразуемое в строку - Исходная строка
//	УдаляемыеЭлементы	- Любое значение, преобразуемое в строку - удаляемые элементы с разделителями
//	Разделитель			- Любое значение, преобразуемое в строку - Разделитель, общий для СтрокаСРазделителями и УдаляемыеЭлементы
// Возвращаемое значение:
//	Строка   - строка с разделителями без указанных элементов
Функция УдалитьЭлементыИзСтрокиСРазделителями(СтрокаСРазделителями, УдаляемыеЭлементы, Разделитель = ",") Экспорт
	ЧтоУдалять = СтрЗаменить(УдаляемыеЭлементы, Разделитель, Символы.ПС);
	Результат = ИскоренитьПодстроку(ИскоренитьПодстроку(СтрокаСРазделителями,
			" " + Разделитель, Разделитель), Разделитель + " ", Разделитель);
	Для Ё = 1 По СтрЧислоСтрок(ЧтоУдалять) Цикл
		ЧтоМенять = СтрПолучитьСтроку(ЧтоУдалять, Ё);
		Результат = СтрЗаменить(Результат, ЧтоМенять + Разделитель, "");
		Результат = СтрЗаменить(Результат, Разделитель + ЧтоМенять, "");
		Если Результат = ЧтоМенять Тогда
			Результат = "";
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // УдалитьЭлементыИзСтрокиСРазделителями()

//Проверяет, подойдёт ли строчка для преобразования в УИД
// Параметры:
//  Строчка  - Любое значение, преобразуемое в строку - Проверяемая строка.
// Возвращаемое значение:
//   Булево   - Истина, если подходит для УИД. Считаются подходящими символами "-", 0-9, a-f, A-F.
Функция ЭтоУИД(Строчка) Экспорт
	Возврат ПроверитьСтроку(НРег(Строчка), "[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]");
КонецФункции // ЭтоУИД()
 
#КонецОбласти

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ
	
// Выводит картинку в табличный документ
// Параметры:
//  Приёмник  - Табличный документ - куда помещается картинка
//  Картинка_	- картинка или двоичные данные - источник картинки
//  Верх_  - Число - Координата размещения картинки. По умолчанию 0
//  Лево_  - Число - Координата размещения картинки. По умолчанию 0
//  Высота_  - Число - Размер картинки. По умолчанию 20
//  Ширина_  - Число - Размер картинки. По умолчанию 20
//  Узор  - ТипУзораТабличногоДокумента - Узор картинки. По умолчанию без узора.
//  Линия  - Линия - Линия картинки. По умолчанию НетЛинии
//  Прозрачность  - Булево - Прозрачность картинки. По умолчанию Истина
Процедура ВывестиКартинкуВТД(Приёмник, Картинка_ = Неопределено, Верх_ = 0, Лево_ = 0, Высота_ = 20, Ширина_ = 20, Узор = Неопределено, Линия = Неопределено, Прозрачность = Истина) Экспорт
	ТипКартинка = Тип("Картинка");
	ТипДД = Тип("ДвоичныеДанные");
	НовыйРисунок = Приёмник.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	НовыйРисунок.Верх = Верх_;
	НовыйРисунок.Лево = Лево_;
	НовыйРисунок.Высота = Высота_;
	НовыйРисунок.Ширина = Ширина_;
	НовыйРисунок.Линия = ?(Линия = Неопределено, Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии), Линия);
	НовыйРисунок.Узор = ?(Узор = Неопределено, ТипУзораТабличногоДокумента.БезУзора, Узор);
	ТекКартинка = ?(Картинка_ = Неопределено, Новый Картинка, Картинка_);
	ТипТК = ТипЗнч(ТекКартинка);
	Если ТипТК = ТипДД Тогда
		НовыйРисунок.Картинка = Новый Картинка(ТекКартинка, Прозрачность);
	ИначеЕсли ТипТК = ТипКартинка Тогда
		НовыйРисунок.Картинка = ТекКартинка;
	КонецЕсли;
КонецПроцедуры // ВывестиКартинкуВТД

// Устанавливает границу и заливку области табличного документа
// Параметры:
//  Область  - Область табличного документа - Редактируемые ячейки
//  Заливка  - Цвет - устанавливаемый цвет фона. По умолчанию Наопределено - не устанавливается
//  ЦветРамки  - Цвет - устанавливаемый цвет рамки. По умолчанию Наопределено - не устанавливается
//  ЛинииРамки  - Линия, структура - Линия уставнавливается для всех границ, Структура может содержать поля "Лево", "Право", "Верх", "Низ" и/или "ГраницаСверху", "ГраницаСлева", "ГраницаСнизу" или "ГраницаСправа"
Процедура ГраницыИЗаливка(Область, Заливка = Неопределено, ЦветРамки = Неопределено, ЛинииРамки = Неопределено) Экспорт
				Если Заливка <> Неопределено Тогда
					Область.ЦветФона = Заливка;
				КонецЕсли;
				Если ЦветРамки <> Неопределено Тогда
					Область.ЦветРамки = ЦветРамки;
				КонецЕсли;
				Если ЛинииРамки = Неопределено Тогда
				ИначеЕсли ТипЗнч(ЛинииРамки) = Тип("Линия") Тогда
					Область.ГраницаСверху = ЛинииРамки;
					Область.ГраницаСлева = ЛинииРамки;
					Область.ГраницаСнизу = ЛинииРамки;
					Область.ГраницаСправа = ЛинииРамки;
				Иначе
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСверху", ЧтСтрукт(ЛинииРамки, "Верх"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСверху = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСправа", ЧтСтрукт(ЛинииРамки, "Право"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСправа = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСнизу", ЧтСтрукт(ЛинииРамки, "Низ"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСнизу = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСлева", ЧтСтрукт(ЛинииРамки, "Лево"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСлева = ТекЦвет;
					КонецЕсли;
				КонецЕсли;
КонецПроцедуры // ГраницыИЗаливка

// Ищет в составе табличного документа дату и возвращает её
// Параметры:
//  ТабДок  - Табличный документ - в котором ищется дата
//  НомерВхождения  - Число - Номер вхождения даты от начала документа. Чтение идёт построчно слева направо.
//  ВернутьСтрокой  - Булево - Тип возвращаемого значения. Ложь (по умолчанию) - дата, иначе - строка.
//  ВЗначениях  - Булево - Необходимость поиска в значениях ячеек.
//  ВТексте  - Булево - Необходимость поиска в текстах ячеек.
//  Форматы  - Массив тестеров, сформированных функцией ЗначениеXDTOдляПроВеркиСтроки - Формат даты, только в этом формате будет искаться дата в тексте. По умолчанию - неопределено - в форматах dd.mm.yyyy, dd month yyyy и month yyyy.
//  Верх  - Число - Верх области поиска, по умолчанию - 1
//  Низ  - Число - Низ области поиска, по умолчанию - нижняя строка ТД
//  Право  - Число - Номер крайней левой колонки области поиска, по умолчанию - 1
//  Лево  - Число - Номер крайней правой колонки области поиска, по умолчанию - правая колонка ТД
// Возвращаемое значение:
//   Дата, Строка   - Найденная в документе дата. Пустая, если ничего не найдено. Если найдена строка, которую невозможно преобразовать в дату, вернётся строка, даже если указано вернуть дату.
Функция ДатаИзТД(ТабДок, ВернутьСтрокой = Ложь, НомерВхождения = 1, ВЗначениях = Истина, ВТексте = Истина, Форматы = Неопределено, Знач Верх = 1, Знач Низ = 0, Знач Лево = 1, Знач Право = 0) Экспорт
	Результат = ?(ВернутьСтрокой, "", '00000000');
	СчётчикВхождений = НомерВхождения;
	Если Низ = 0 Тогда
		Низ = ТабДок.ВысотаТаблицы;
	КонецЕсли; 
	Если Право = 0 Тогда
		Право = ТабДок.ШиринаТаблицы;
	КонецЕсли; 
	Если Верх = 0 Тогда //Бесконечные области!!!
		Верх = 1;
	КонецЕсли; 
	Если Лево = 0 Тогда
		Лево = 1;
	КонецЕсли; 
	ЭтоТиповыеФорматы = Ложь;
	Если Форматы = Неопределено Тогда
		СтрокиФорматов = Новый Массив;
		СтрокиФорматов.Добавить(".*\d{2}\.\d{2}\.\d{4}.*");
		СтрокиФорматов.Добавить(".*\d{1,2}\s+((Я|я)нваря|(Ф|ф)евраля|(М|м)арта|(М|м)ая|(А|а)преля|(И|и)ю(н|л)я|(А|а)вгуста|(С|с)ентября|(О|о)ктября|(Н|н)оября|(Д|д)екабря)\s+\d{4}.*");
		СтрокиФорматов.Добавить(".*\s+((Я|я)нварь|(Ф|ф)евраль|(М|м)арт|(М|м)ай|(А|а)прель|(И|и)ю(н|л)ь|(А|а)вгуст|(С|с)ентябрь|(О|о)ктябрь|(Н|н)оябрь|(Д|д)екабрь)\s+\d{4}.*");
		Форматы = Новый Массив;
		Для каждого СтрочкаФ Из СтрокиФорматов Цикл
			Форматы.Добавить(ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(СтрочкаФ));
		КонецЦикла; 
		ЭтоТиповыеФорматы = Истина;
	КонецЕсли;
	#Область ПОИСК
		Для СчСтр = Верх По Низ Цикл
			Найдена = Неопределено;
			Для СчКол = Лево По Право Цикл
				Ячейка = ТабДок.Область(СчСтр, СчКол);
				Если ВЗначениях И Ячейка.СодержитЗначение Тогда
					Если ТипЗнч(Ячейка.Значение) = Тип("Дата") Тогда
						Найдена = Ячейка.Значение;
					КонецЕсли; 
				КонецЕсли;
				Если (Найдена = Неопределено) И ВТексте И НЕ Ячейка.СодержитЗначение Тогда
					ТекТекст = Ячейка.Текст;
					Для СчМ = 0 По Форматы.ВГраница() Цикл
						Если ПроверитьСтроку(ТекТекст,, Форматы[СчМ]) Тогда
							Найдена = СчМ;
						КонецЕсли; 
					КонецЦикла; 
				КонецЕсли; 
				Если Найдена <> Неопределено Тогда
					СчётчикВхождений = СчётчикВхождений - 1;
				КонецЕсли; 
				Если СчётчикВхождений = 0 Тогда
					СчСтр = Низ;
					Прервать;
				КонецЕсли; 
			КонецЦикла; 
		КонецЦикла;
	#КонецОбласти 
	//Теперь в Найдена либо сама дата, либо номер формата, по которому найдена строка
	#Область ВЫДЕЛЕНИЕ_ДАТЫ_ИЗ_ДЛИННОЙ_СТРОКИ_И_ПРЕОБРАЗОВАНИЕ_ФОРМАТА
		Если Найдена <> Неопределено Тогда
			ЭтоЧисло = ТипЗнч(Найдена) = Тип("Число");
			Если ЭтоТиповыеФорматы и ЭтоЧисло Тогда
				//Попытка вытащить дату из текста.
				ФорматНачало = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3));
				ФорматОк = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3, СтрДлина(СтрочкаФ) - 4));
				ДлТхт = СтрДлина(ТекТекст);
				Ок = Ложь;
				Для СчНач = 1 По ДлТхт Цикл
					Если ПроверитьСтроку(Сред(ТекТекст, СчНач),, ФорматНачало) Тогда
						Ок = Истина;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если Ок Тогда
					Ок = Ложь;
					Для СчДл = 1 По ДлТхт - СчНач + 1 Цикл
						ТекстВЦикле = Сред(ТекТекст, СчНач, СчДл);
						Если ПроверитьСтроку(ТекстВЦикле,, ФорматОк) Тогда
							Ок = Истина;
							Прервать;
						КонецЕсли; 
					КонецЦикла; 
					Если Ок Тогда
						ТекТекст = ТекстВЦикле;
					КонецЕсли; 
				КонецЕсли; 
				Если НЕ ВернутьСтрокой Тогда
					//Попытка преобразовать в дату
					ДатаХ = ДатаИзСтроки(ТекТекст, Истина);
					Если ДатаХ <> Неопределено Тогда
						Найдена = ДатаХ;
						ЭтоЧисло = Ложь;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;
			Если ВернутьСтрокой И НЕ ЭтоЧисло Тогда
				//Преобразование даты в строку
				ТекТекст = Формат(Найдена, "ДФ=dd.MM.yyyy");
				ЭтоЧисло = Истина;
			КонецЕсли;
			Если ЭтоЧисло Тогда
				Результат = ТекТекст;
			Иначе
				Результат = Найдена;
			КонецЕсли; 
		КонецЕсли;
	#КонецОбласти 
	Возврат Результат
КонецФункции // ДатаИзТД

// Выполняет замены текста в табличном документе
// Параметры:
//  ТабДок  - Табличный документ - в котором будут замены текста
//  Замены  - Таблица значений или массив структур - с колонками ЧтоМенять и НаЧтоМенять
//  Верх  - Число - Верх изменяемой области, по умолчанию - 1
//  Низ  - Число - Низ изменяемой области, по умолчанию - нижняя строка ТД
//  Право  - Число - Номер крайней левой колонки изменяемой области, по умолчанию - 1
//  Лево  - Число - Номер крайней правой колонки изменяемой области, по умолчанию - правая колонка ТД
Процедура ЗаменитьТекстыВТД(ТабДок, Замены, Знач Верх = 1, Знач Низ = 0, Знач Лево = 1, Знач Право = 0, ИскатьПоСтрокам = Истина, ЯчейкаЦеликом = Ложь, ИскатьВперед = Истина, ИгнорироватьРегистр = Ложь) Экспорт
	Если Низ = 0 Тогда
		Низ = ТабДок.ВысотаТаблицы;
	КонецЕсли; 
	Если Право = 0 Тогда
		Право = ТабДок.ШиринаТаблицы;
	КонецЕсли; 
	Если Верх = 0 Тогда //Бесконечные области!!!
		Верх = 1;
	КонецЕсли; 
	Если Лево = 0 Тогда
		Лево = 1;
	КонецЕсли; 
	#Область НОВЫЙ_ВАРИАНТ
		Обыскиваемая = ТабДок.Область(Верх, Лево, Низ, Право);
		Начало = Неопределено;//ТабДок.Область(Верх, Лево);
		БылТП = ТабДок.ТолькоПросмотр;
		Для каждого СтрЗамен Из Замены Цикл
			НачалоПоЗамене = Начало;
			Пока Истина Цикл
				НачалоПоЗамене = ТабДок.НайтиТекст(СтрЗамен.ЧтоМенять, НачалоПоЗамене, Обыскиваемая, ИскатьПоСтрокам, ЯчейкаЦеликом, ИскатьВперед, ИгнорироватьРегистр);
				Если НачалоПоЗамене = Неопределено Тогда
					Прервать
				КонецЕсли;
				НачалоПоЗамене.Текст = СтрЗаменить(НачалоПоЗамене.Текст, СтрЗамен.ЧтоМенять, СтрЗамен.НаЧтоМенять);
			КонецЦикла;
		КонецЦикла;
		Если БылТП Тогда
			ТабДок.ТолькоПросмотр = Истина;
		КонецЕсли; 
	#КонецОбласти 
	#Область СТАРЫЙ_ВАРИАНТ
		//Для СчСтр = Верх По Низ Цикл
		//	Для СчКол = Лево По Право Цикл
		//		ТекТекст = Строка(ТабДок.Область(СчСтр, СчКол).Текст);
		//		СтарыйТекст = ТекТекст;
		//		Для каждого СтрЗамен Из Замены Цикл
		//			ТекТекст = СтрЗаменить(ТекТекст, СтрЗамен.ЧтоМенять, СтрЗамен.НаЧтоМенять);
		//		КонецЦикла;
		//		Если СтарыйТекст <> ТекТекст Тогда
		//			БылТП = ТабДок.ТолькоПросмотр;
		//			ТабДок.ТолькоПросмотр = Ложь;
		//			ТабДок.Область(СчСтр, СчКол).Текст = ТекТекст;
		//			Если БылТП Тогда
		//				ТабДок.ТолькоПросмотр = Истина;
		//			КонецЕсли; 
		//		КонецЕсли; 
		//	КонецЦикла; 
		//КонецЦикла; 
	#КонецОбласти
КонецПроцедуры // ЗаменитьТекстыВТД

//Возвращает реквизиты табличного документа, доступные для записи
Функция ИзменяемыеРеквизитыТД() Экспорт
	//В УП было:
	//АвтоМасштаб,Вывод,ДвусторонняяПечать,Защита,ИмяПараметровПечати,ИмяПринтера,ИспользуемоеИмяФайла,КоличествоЭкземпляров,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,ОтображатьСетку,
	//ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ЧерноБелаяПечать,ЧерноБелыйПросмотр,
	//ЭкземпляровНаСтранице,РазмерКолонтитулаСнизу,РазмерКолонтитулаСверху
	//Копируются:
	//АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,ИмяПараметровПечати,КлючПараметровПечати,КлючСохраненияПоложенияОкна,
	//	КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	//	ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,
	//	ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы.
	//НЕ копируются:
	//ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы.
	//Преднамеренно НЕ копируются:
	//ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть.
	Копируемые = "ИмяПараметровПечати,АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,КлючПараметровПечати,КлючСохраненияПоложенияОкна,";
	Копируемые = Копируемые + "КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,";
	Копируемые = Копируемые + "ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,";
	Копируемые = Копируемые + "ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы";
	//ИмяПараметровПечати (оно же КлючПараметровПечати) обязательно первым!
	Возврат Копируемые
КонецФункции // РеквизитыНастроекТД()

// Возвращает строку и столбец первой ячейки со значением или текстом
// Параметры:
//  ТаблДокумент  - Табличный документ - В котором ищем
//  МетодПоиска  - Строка - "ПоКолнкам" (по умолчанию), "ПоСтрокам" или "Радиально"
//  Строк  - Число - Сколько строк проверять. По умолчанию 10.
//  Колонок  - Число - Сколько колонок проверять. По умолчанию 10.
//  НачСтрока  - Число - С какой строки табдокумента проверять. По умолчанию 1.
//  НачКолонка  - Число - С какой колонки табдокумента проверять. По умолчанию 1.
// Возвращаемое значение:
//   Структура   - Ключи Строка, Столбец, Значение, Текст
Функция ПерваяЯчейка(ТаблДокумент, МетодПоиска = "ПоКолонкам", Строк = 10, Колонок = 10, НачСтрока = 1, НачКолонка = 1) Экспорт
	Результат = Новый Структура("Строка,Колонка,Текст,Значение", 0);
	ЭтоРадиально = МетодПоиска = "Радиально";
	ЭтоНеПоКолонкам = МетодПоиска = "ПоСтрокам" ИЛИ ЭтоРадиально;
	Ширина = ?(Колонок = 0, ТаблДокумент.ШиринаСтраницы - НачКолонка + 1, Колонок);
	Высота = ?(Строк = 0, ТаблДокумент.ВысотаСтраницы - НачСтрока + 1, Строк);
	КонРадиус = Макс(Ширина, Высота); //если по строкам - высота
	НачРадиус = ?(ЭтоНеПоКолонкам, 1, КонРадиус);
	Для Радиус = НачРадиус По КонРадиус Цикл
		КонКол = ?(ЭтоРадиально, Мин(Ширина, Радиус), Ширина);
		Для НомКол = НачКолонка По КонКол + НачКолонка - 1 Цикл
			Если ЭтоНеПоКолонкам И НЕ (ЭтоРадиально И НомКол = Радиус) Тогда
				НачСтр = Радиус + НачСтрока - 1;
				КонСтр = НачСтр;
			Иначе
				НачСтр = НачСтрока;
				КонСтр = Высота + НачСтрока - 1;
			КонецЕсли;
			Для НомСтр = НачСтр По КонСтр Цикл
				ТекОбласть = ТаблДокумент.Область(НомСтр, НомКол);
				ТекТекст = ТекОбласть.Текст;
				ТекЗнч = ?(ТекОбласть.СодержитЗначение, ТекОбласть.Значение, Неопределено);
				Если ЗначениеЗаполнено(ТекТекст) ИЛИ ЗначениеЗаполнено(ТекЗнч) Тогда
					Результат.Вставить("Строка", НомСтр);
					Результат.Вставить("Колонка", НомКол);
					Результат.Вставить("Текст", ТекТекст);
					Результат.Вставить("Значение", ТекЗнч);
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	Возврат Результат
КонецФункции // ПерваяЯчейка

//Получает значение из области в структуру или иной аналогичный объект. Не распознаёт ссылки, из строк убирает одиночный апостроф.
//Параметры:
//	Приёмник 			- Структура - Объект-приёмник
//	РеквизитПриёмника	- Строка - Имя реквизита, куда будет помещено значение
//	Источник			- Табличный документ - Откуда будет считано значение
//	НомерСтроки			- Число - Номер строки ячейки, из которой будет считано значение
//	НомерКолонки		- Число - Номер колонки ячейки, из которой будет считано значение
//	ТипДанных			- Строка - Тип данных, к оторому будет приведено значение (Булево/Строка/Число)
Процедура ПолучитьИзОбласти(Приёмник, РеквизитПриёмника, Источник, НомерСтроки, НомерКолонки, ТипДанных = "Строка") Экспорт
	ТДата = ТекущаяДата();
	Если НомерКолонки = 0 Тогда
		Если ТипДанных = "Строка" Тогда
			Приёмник[РеквизитПриёмника] = "";
		ИначеЕсли ТипДанных = "Число" Тогда
			Приёмник[РеквизитПриёмника] = 0;
		ИначеЕсли ТипДанных = "Дата" Тогда
			Приёмник[РеквизитПриёмника] = ТДата;
		Иначе //Булево
			Приёмник[РеквизитПриёмника] = Ложь;
		КонецЕсли; 
	Иначе
		ТекОбласть = Источник.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		НадоПриводитьКФормату = НЕ ТекОбласть.СодержитЗначение;
		Если НадоПриводитьКФормату И (ТипДанных <> "Строка") Тогда
			ТекстОбласти = ТекОбласть.Текст;
			Если ТипДанных = "Дата" Тогда
				//Из форматов "1.3.75" и "750301"
				ТекСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекстОбласти,
						".", Символы.ПС), "/", Символы.ПС), "-", Символы.ПС), "\", Символы.ПС), " ", Символы.ПС), ":", Символы.ПС);
				Если СтрЧислоСтрок(ТекСтрока) = 1 Тогда
					Век = Лев(ТекСтрока, 2);
					Если (Век <> "19") ИЛИ (Век <> "20") Тогда
						ТекСтрока = "20" + ТекСтрока;
					КонецЕсли; 
					Попытка
						НовоеЗначение = Дата(Число(Лев(ТекСтрока, 4)), Число(Сред(ТекСтрока, 5, 2)), Число(Сред(ТекСтрока, 7, 2)), Число(Сред(ТекСтрока, 9, 2)), Число(Сред(ТекСтрока, 11, 2)), Число(Прав(ТекСтрока, 2)));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				Иначе
					Попытка
						ТГод = СтрПолучитьСтроку(ТекСтрока, 3);
						Если ТГод = "" Тогда
							ТГод = "0"
						ИначеЕсли СтрДлина(ТГод) = 2 Тогда
							ТГод = "20" + ТГод;
						КонецЕсли; 
						НовоеЗначение = Дата(Число(ТГод),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 2), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 1), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 4), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 5), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 6), "", "0")));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				КонецЕсли; 
			ИначеЕсли ТипДанных = "Булево" Тогда
				ВРег_ = ВРЕГ(ТекстОбласти);
				НовоеЗначение = НЕ ((ВРег_ = "ЛОЖЬ") ИЛИ (ВРег_ = "НЕТ") ИЛИ ПустаяСтрока(ВРег_) ИЛИ (ВРег_ = "0"));
			Иначе //Число
				Попытка
					НовоеЗначение = Число(ТекстОбласти);
				Исключение
					НовоеЗначение = 0;
				КонецПопытки;
			КонецЕсли;
			Приёмник[РеквизитПриёмника] = НовоеЗначение;
		Иначе
			Приёмник[РеквизитПриёмника] = ?(НадоПриводитьКФормату, ТекОбласть.Текст, ТекОбласть.Значение);
		КонецЕсли; 
		Если ТипЗнч(Приёмник[РеквизитПриёмника]) = Тип("Строка") Тогда
			Приёмник[РеквизитПриёмника] = СокрЛП(Приёмник[РеквизитПриёмника]);
			Если Лев(Приёмник[РеквизитПриёмника], 1) = "'" Тогда
				Приёмник[РеквизитПриёмника] = Сред(Приёмник[РеквизитПриёмника], 2);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры

// Копирует параметры документа - источника в документ-приёмник. При отсутствии приёмника создаётся новый документ.
// Параметры:
//  Приёмник  - Табличный документ - тот, в который будут скопированы параметры
//  Источник  - Табличный документ или иной объект - тот, из которого будут скопированы параметры
//  ИсключаемыеСвойства  - Строка - Список свойств через запятую, которые не будут копироваться
// Возвращаемое значение:
//   Табличный документ   - Приёмник с параметрами источника
Функция СкопироватьПараметрыТД(Приёмник = Неопределено, Источник, ИсключаемыеСвойства = "") Экспорт
	Результат = ?(Приёмник = Неопределено, Новый ТабличныйДокумент, Приёмник);
	//В УП было:
	//АвтоМасштаб,Вывод,ДвусторонняяПечать,Защита,ИмяПараметровПечати,ИмяПринтера,ИспользуемоеИмяФайла,КоличествоЭкземпляров,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,ОтображатьСетку,
	//ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ЧерноБелаяПечать,ЧерноБелыйПросмотр,
	//ЭкземпляровНаСтранице,РазмерКолонтитулаСнизу,РазмерКолонтитулаСверху
	//Копируются:
	//АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,ИмяПараметровПечати,КлючПараметровПечати,КлючСохраненияПоложенияОкна,
	//	КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	//	ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,
	//	ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы.
	//НЕ копируются:
	//ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы.
	//Преднамеренно НЕ копируются:
	//ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть.
	Копируемые = "ИмяПараметровПечати,АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,КлючПараметровПечати,КлючСохраненияПоложенияОкна,";
	Копируемые = Копируемые + "КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,";
	Копируемые = Копируемые + "ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,";
	Копируемые = Копируемые + "ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы";
	ТМПСтр = Новый Структура(Копируемые);//Чтобы отсеять реквизиты, кроме указанных
	ЗаполнитьЗначенияСвойств(ТМПСтр, Результат);
	Если ИсключаемыеСвойства = "" Тогда
		ЗаполнитьЗначенияСвойств(ТМПСтр, Источник);
	Иначе
		ЗаполнитьЗначенияСвойств(ТМПСтр, Источник,, ИсключаемыеСвойства);
	КонецЕсли; 
	Копируемые = СтрЗаменить(Копируемые, ",", Символы.ПС);
	//А вот фиг бы я угадал, это не работает!!! ("Двусторонняя печать ваще не копируется, полный игнор"!) !ИмяПараметровПечати всё перезатирает!
	//ЗаполнитьЗначенияСвойств(Результат, Источник, Копируемые);
	Для Ё = 1 По СтрЧислоСтрок(Копируемые) Цикл
		ИмяРекв = СтрПолучитьСтроку(Копируемые, Ё);
		Результат[ИмяРекв] = ТМПСтр[ИмяРекв];
	КонецЦикла; 
	Возврат Результат
КонецФункции // СкопироватьПараметрыТД
 
// Возвращает список областей табличного документа
// Параметры:
//  ТабДок  - Табличный документ - имена областей которого будут выведены в список
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
// Возвращаемое значение:
//   СписокЗначений, Массив или строка   - Список областей ТД
Функция СписокОбластейТД(ТабДок, СтрокаМассивСписок = "Строка") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Область Из ТабДок.Области Цикл
			Результат = Результат + "," + Область.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, 2);
	КонецЕсли;
	Возврат Результат
КонецФункции // СписокОбластейТД

// Возвращает табличный документ с выведенной таблицей значений
// Параметры:
//  ТабЗн			- Таблица значений - таблица для вывода
//  ПерваяКолонка	- Число >=1 - Номер первой колонки табличного документа для вывода данных. По умолчанию 1.
//  СтрокаЗаголовка	- Число - Номер строки табличного документа для вывода заголовков колонок. <= 1 - заголовок не выводится. По умолчанию 1.
//  СтрокаДанных	- Число - Номер первой строки табличного документа для вывода данных таблицы. 0 - переводится в СтрокаЗаголовка + 1 (по умолчанию). <= СтрокаЗаголовка - данные не выводятся.
//  СтрокаИтогов	- Число - Номер строки табличного документа для вывода итогов. 0 (по умолчанию) - итоги не выводятся. Отрицательные значения - отсчёт от конца данных (-1 - сразу после данных).
//  КолонкиИтогов	- Строка или массив - колонки, по которым подводятся итоги. По умолчанию Неопределено - итоги не выводятся.
//  СвойстваЯчеек	- Структура - ключи - имена колонок, значения - структуры, свойства которых копируются в ячейки колонки.
//			Ключи "ЯчейкаЗаголовок" и "ЯчейкаИтог" содержат такие же структуры для заголовков и  итогов. По умолчанию Неопределено - пустая структура.
//  Автовыравнивание- Булево - Истина - автовыравнивание: по верхнему краю, числа и даты - по правому краю, булево - по центру, остальное - по левому краю. В итогах и заголовках не действует.
//  ТолькоТекст		- Булево - Истина - вывод в свойство "Текст" ячейки, Ложь - в свойство "Значение". По умолчанию Ложь.
//  ЦветЗаголовка	- Цвет - Цвет фона заголовка по умолчанию (до применения свойств ячеек). По умолчанию Неопределено - без цвета.
//  ЦветРамки		- Цвет - Цвет границ. По умолчанию Неопределено - без цвета.
//  ЛинияГраниц		- Линия - Линия границ. По умолчанию Неопределено - без границ.
// Возвращаемое значение:
//   Табличный документ   - содержащий выведенную таблицу значений
Функция ТабличныйДокументИзТаблицыЗначений(ТабЗн, ПерваяКолонка = 1, СтрокаЗаголовка = 1, СтрокаДанных = 0, СтрокаИтогов = 0, КолонкиИтогов = Неопределено,
		СвойстваЯчеек = Неопределено, Автовыравнивание = Истина, ТолькоТекст = Ложь, ЦветЗаголовка = Неопределено, ЦветРамки = Неопределено, ЛинияГраниц = Неопределено) Экспорт
	Результат = Новый ТабличныйДокумент;
	ПустаяСтруктура = Новый Структура;
	Если СвойстваЯчеек = Неопределено Тогда
		СвойстваЯчеек = ПустаяСтруктура;
	КонецЕсли;
	ПерваяСтрока = ?(СтрокаДанных = 0, СтрокаЗаголовка + 1, СтрокаДанных);
	КолвоСтрок = ТабЗн.Количество();
	СтрокаВыводаИтогов = ?(СтрокаИтогов < 0, ПерваяСтрока + КолвоСтрок - 1 - СтрокаИтогов, СтрокаИтогов);
	МИтогов = ?(КолонкиИтогов = Неопределено, Новый Массив, ?(ТипЗнч(КолонкиИтогов) = Тип("Строка"), СтрРазделить(КолонкиИтогов,, Ложь), КолонкиИтогов));
	ВыводитьЗаголовки = СтрокаЗаголовка >= 0;
	ВыводитьДанные = ПерваяСтрока > СтрокаЗаголовка;
	ВыводитьИтоги = (СтрокаВыводаИтогов >= 0) И (МИтогов.Количество() > 0);
	СтрНачала = Мин(СтрокаЗаголовка, СтрокаВыводаИтогов);
	СтрОкончания = Макс(СтрокаВыводаИтогов, ПерваяСтрока + КолвоСтрок - 1);
	ТипЧисло = Тип("Число");
	ТипДата = Тип("Дата");
	ТипБулево = Тип("Булево");
	
    СчКол = ПерваяКолонка;
	Для каждого Колонка Из ТабЗн.Колонки Цикл
		СвойстваЯчКол = ЧтСтрукт(СвойстваЯчеек, Колонка.Имя, ПустаяСтруктура);
		#Область ЗАГОЛОВКИ
			Если ВыводитьЗаголовки Тогда
				Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
				Ячейка_.Текст = Колонка.Имя;
				ГраницыИЗаливка(Ячейка_, ЦветЗаголовка, ЦветРамки, ЛинияГраниц);
				ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаЗаголовок", ПустаяСтруктура));
				Результат.Область(СтрНачала, СчКол, СтрОкончания, СчКол).ШиринаКолонки = Колонка.Ширина;
			КонецЕсли;
		#КонецОбласти
	
		#Область ИТОГИ
			Если ВыводитьИтоги И (МИтогов.СтрНайти(Колонка.Имя) <> Неопределено) Тогда
				Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
				Ячейка_.Текст = ТабЗн.Итог(Колонка.Имя);
				Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
				ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
				Ячейка_.Шрифт = Новый Шрифт(Ячейка_.Шрифт,,, Истина);
				ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаИтог", ПустаяСтруктура));
			КонецЕсли;
		#КонецОбласти
		#Область ДАННЫЕ
			 Если ВыводитьДанные Тогда
				Ячейка_ = Результат.Область(ПерваяСтрока, СчКол, ПерваяСтрока + КолвоСтрок - 1, СчКол);
				Если ТолькоТекст Тогда
					ИмяСвойства = "Текст";
					СодержитЗначение = Ложь;
				Иначе
					ИмяСвойства = "Значение";
					СодержитЗначение = Истина;
				КонецЕсли;
				СчСтр = 0;
				Для каждого СтрокаТЗ Из ТабЗн Цикл
					Ячейка_ = Результат.Область(ПерваяСтрока + СчСтр, СчКол);
					Ячейка_.СодержитЗначение = СодержитЗначение;
					ТекЗнч = СтрокаТЗ[Колонка.Имя];
					Ячейка_[ИмяСвойства] = ТекЗнч;
					ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
					Если Автовыравнивание Тогда
						ТекТип = ТипЗнч(ТекЗнч);
						Ячейка_.ВертикальноеПоложение = ВертикальноеПоложение.Верх;
						Если (ТекТип = ТипЧисло) ИЛИ (ТекТип = ТипДата) Тогда
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
						ИначеЕсли ТекТип = ТипБулево Тогда
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
						Иначе
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
						КонецЕсли;
					КонецЕсли;
					ЗаполнитьЗначенияСвойств(Ячейка_, СвойстваЯчКол);
					СчСтр = СчСтр + 1;
				КонецЦикла;
		 	КонецЕсли;
		#КонецОбласти
	
		СчКол = СчКол + 1;
	КонецЦикла;
	
	Возврат Результат
КонецФункции // ТабличныйДокументИзТаблицыЗначений

// Проверяет, укладывается ли ТД в заданное колво страниц по ширине
// Параметры:
//  ТД  - ТабличныйДокумент - ПроверяемыйТД
//  Страниц  - Число - Количество страниц в ширину. По умолчанию 1
//  Масштаб  - Число - Проверяемый масштаб. По умолчанию  0 = Берётся масштаб документа
// Возвращаемое значение:
//   Булево   - Документ размещается в страницы по ширине
Функция ШиринаТДВСтраницахНеБолее(ТД, Страниц = 1, Масштаб = 0) Экспорт
	Если Страниц <= 0 Тогда
		Результат = Истина;
	Иначе
		ПроверяемыйМасштаб = ?(Масштаб = 0, ТД.МасштабПечати, Масштаб);
		ПустойТД = Новый ТабличныйДокумент;
		ПустойТД.Автомасштаб = Ложь;
		ПустойТД.МасштабПечати = ПроверяемыйМасштаб / Страниц;
		КПроверке = Новый Массив;
		КПроверке.Добавить(ТД);
		Результат = ПустойТД.ПроверитьПрисоединение(КПроверке);
	КонецЕсли;
	Возврат Результат
КонецФункции // ШиринаТДВСтраницахНеБолее

#Область РАСПОЛОЖИТЬ_НА_СТРАНИЦУ
	
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
Функция ПолучитьВременныйТД(ТабДок, Временный)
	Если Временный = Неопределено Тогда
		Временный = СкопироватьПараметрыТД(, ТабДок);
		Временный.Вывести(ТабДок);
		Временный.АвтоМасштаб = Ложь;
	КонецЕсли;
	Возврат Временный
КонецФункции

// Проверяет расположение документов для неразрывной печати "низа" с подписями
// Вспомогательная для ПроверитьРасположениеИОбновитьРезультат
// Параметры:
//  ТабДок  - Табличный документ - Проверяемый ТД
//  МассивОписанийДокументов  - Массив структур - Каждая структура = описание одного документа при печати нескольких документов в один ТД.
//				Возможные ключи: Числа (номера строк) Начало, НачалоНиза и Конец, табличные документы Верх и Полный.
//  АвтоМасштаб  - Булево - Значение для установки автомасштаба. По умолчанию Истина.
//  МасштабПечати  - Число/Неопределено (по умолчанию) - Значение для установки масштаба печати
//  ХранитьТД  - Булево - Хранить ТД в ключах Верх и Полный элементов МассивОписанийДокументов для последующих использований (Ложь - каждый раз рассчитывать по НачалоНиза и Конец)
//	ДопустимоПлохих  - Число - Процент "плохих" (неисправленных) документов, принимаемый как удовлетворительный
//	МасштабРешения  - Число - Переменная для установки найденного масштаба
//  РезультатРешения  - Число - Переменная для процента "плохих" документов (присвоится, если будет найдено удовлетворительное решение лучше найденных ранее).
//  КолвоПлохих  - Число - Переменная для возврата количества найденных "плохих" документов.
Процедура ПроверитьРасположениеДокументов(
		ТабДок,
		МассивОписанийДокументов,
		АвтоМасштаб = Истина,
		МасштабПечати = Неопределено,
		ХранитьТД,
		ДопустимоПлохих,
		КолвоВсего,
		МасштабРешения,
		РезультатРешения,
		КолвоПлохих = 0)
	КолвоПлохих = 0;
	Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
		Если ОписаниеДока.Свойство("Верх") Тогда
			ТДДляТестирования = ОписаниеДока.Верх;
			ТДДляТестированияПолный = ОписаниеДока.Полный;
			Если НЕ ХранитьТД Тогда
				ОписаниеДока.Удалить("Верх");
				ОписаниеДока.Удалить("Полный");
			КонецЕсли; 
		Иначе
			ТДДляТестирования = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.НачалоНиза - 1,);
			СкопироватьПараметрыТД(ТДДляТестирования, ТабДок);
			ТДДляТестированияПолный = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.Конец,);
			СкопироватьПараметрыТД(ТДДляТестированияПолный, ТДДляТестирования);
			Если ХранитьТД Тогда
				ОписаниеДока.Вставить("Верх", ТДДляТестирования);
				ОписаниеДока.Вставить("Полный", ТДДляТестированияПолный);
			КонецЕсли; 
		КонецЕсли; 
		ТДДляТестирования.Автомасштаб = Автомасштаб;
		ТДДляТестирования.МасштабПечати = МасштабПечати;
		ТДДляТестированияПолный.Автомасштаб = Автомасштаб;
		ТДДляТестированияПолный.МасштабПечати = МасштабПечати;
		КолвоСтраниц = ТДДляТестированияПолный.КоличествоСтраниц();
		Если ТДДляТестирования.КоличествоСтраниц() <> КолвоСтраниц Тогда
			КолвоПлохих = КолвоПлохих + 1;
		КонецЕсли;
	КонецЦикла;
	ТекРезультат = КолвоПлохих * 100 / КолвоВсего;
	Если ТекРезультат <= ДопустимоПлохих Тогда
		Если ТекРезультат < РезультатРешения Тогда
			МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
			РезультатРешения = ТекРезультат;
		ИначеЕсли ТекРезультат = РезультатРешения И МасштабРешения < МасштабПечати Тогда
			МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры // ПроверитьРасположениеДокументов
 
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
//Параметры см.ПроверитьРасположениеДокументов; Временный ТД - копия Табдок для экспериментов
Процедура ПроверитьРасположениеИОбновитьРезультат(
		ТабДок,
		ВременныйТД,
		МассивОписанийДокументов,
		Автомасштаб,
		МасштабПечати,
		ХранитьТД,
		ДопустимоПлохих,
		КолвоВсего,
		МасштабРешения,
		РезультатРешения,
		КолвоПлохих = Неопределено,
		ПродолжитьПоискРешения
		)
    РезультатТекВарианта = 100;
	МасштабТекВарианта = 0;
	ПроверитьРасположениеДокументов(ВременныйТД, МассивОписанийДокументов, Автомасштаб, МасштабПечати, ХранитьТД, ДопустимоПлохих,
			КолвоВсего, МасштабТекВарианта, РезультатТекВарианта, КолвоПлохих); 
	Если РезультатТекВарианта = 0 Тогда
		ТабДок.АвтоМасштаб = Автомасштаб;
		ТабДок.МасштабПечати = МасштабТекВарианта;
		ПродолжитьПоискРешения = Ложь;
	ИначеЕсли РезультатТекВарианта < РезультатРешения Тогда
		Если АвтоМасштаб Тогда
			ВременныйТД.АвтоМасштаб = Ложь;
		КонецЕсли;
		МасштабРешения = МасштабТекВарианта;
		РезультатРешения = РезультатТекВарианта;
	КонецЕсли; 
КонецПроцедуры

// Располагает "низ" (условно - подписи) документа в пределах последней страницы неразрывно. Проверка идёт на то, что Низ и Верх должны заканчиваться на одной странице.
//	Алгоритм описан в начале функции
//	Рекомендация (но не обязательно) - делать макет единой ширины, т.к. иначе Получитьобласть() может работать некорректно.
// Параметры:
//  ТабДок  - Табличный документ - Преобразуемый табличный документ
//	ПроверятьРазмещениеСтраницВШирину - Число - По умолчанию 1. 0 = Не проверять.
//  НачальныйМасштаб  - Число - Масштаб табличного документа, с которого включительно начинаются попытки уменьшать масштаб.
//			По умолчанию 0 - МасштабПечати ТабДок, а если он не задан - 100%
//  КонечныйМасштаб  - Число - Масштаб табличного документа, до которого включительно проводятся попытки уменьшать масштаб.
//			По умолчанию 0 - НачальныйМасштаб - 30%
//	АвтоМасштаб  - Булево - Выполнять проверку с установленным автомасштабом. По умолчанию Истина.
//	УменьшениеМасштаба  - Булево - Выполнять проверку уменьшения масштаба. По умолчанию Истина.
//	ЕслиНеНашлосьБыстроИскатьПеребором  - Булево - Если "быстрый" способ не дал решения - поискать перебором масштабов (это долго). По умолчанию Истина.
//	ВставлятьРазрыв  - Булево - Вставлять разрыв, если масштаб подобрать не удалось. По умолчанию Истина.
//	ДопустимоПлохих  - Число - Процент допустимых "плохих" документов. По умолчанию 0.
//	ПолучилосьПлохих  - Число - Переменная, в которую будет возвращено число плохих документов в процентах от общего числа. По умолчанию 0.
//	мОписанияДокументов - Массив/Неопределено (по умолчанию) - массив структур с ключами Начало, НачалоНиза и Конец. Такой массив иногда проще составить при формировании ТД,
//			и, если он составлен, передать в эту процедуру готовый. Если массив задан, все параметры далее не используются. Если не задан - составляется в этой процедуре.
//  ВысотаВерха  - Число - Высота верха. В ТД выведено несколько документов (например, СФ и Актов).
//			Каждый документ состоит из низа (условно - блока подписей) и верха (документа до этого блока).
//			Для подбора масштаба надо найти эти документы и их верхи. Они могут быть фиксированными (заданы высота верха и/или высота документа) в строках.
//			По умолчанию 0, в этом случае производится поиск по контрольному значению в контрольной колонке.
//  КонтрольнаяКолонкаВерха  - Число - Колонка, в которой ищется контрольное значение при определении "верха".
//			Имеет смысл только при ВысотаВерха = 0. По умолчанию 1.
//			Если задано значение 0, то контрольное значение не считывается из колонки, а считается ИСТИНОЙ.
//			В этом случае имеет смысл использование в КонтрольноеЗначениеВерха только "менеджера" и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Истина.
//			М.б. задано менеджером, тогда рассчитвывается перед стартом и после нахождения контрольного значения ДОКУМЕНТА.
//			В "МЕНЕДЖЕРАХ" используются имена Табдок, МассивОписанийДокументов (см. мОписанияДокументов) - только для уже найденных документов,
//				НомерТекущейСтрокиТД, КонтрольнаяКолонкаВерха, КонтрольнаяКолонкаДокумента, ВысотаВерха, НачалоТекущегоДокумента, НачалоТекущегоНиза.
//  КонтрольноеЗначениеВерха  - Строка - Искомое контрольное значение при определении верха. Найденная строка при нулевом отступе является последней строкой верха.
//			Ищется в контрольной колонке. Имеет смысл только при ВысотаВерха = 0. По умолчанию "ИТОГО:".
//			Может быть "менеджером" (т.е. рассчитываться). 
//	РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз	- Булево - Заставляет пересчитывать контрольное значение для каждой проверяемой строки ТД.
//			Имеет смысл только при ВысотаВерха = 0 и применении "менеджера" в КонтрольноеЗначениеВерха. По умолчанию Ложь.
//			Установка в Истина при работе на клиенте может привести к массовым вызовам сервера, что не айс.
//  ОтступВерха  - Число - Отступ последней строки верха от строки, в которой найдено контрольное значение. Имеет смысл только при ВысотаВерха = 0. По умолчанию 0.
//  ВысотаДокумента  - Число - Высота всего документа (см. ВысотаВерха). Если значение не найдено, весь остаток ТД считается документом к распечатке.
//			Если задано - 1 (по умолчанию) - считается, что в ТД документ один и искать документы не надо.
//  КонтрольнаяКолонкаДокумента  - Число - Номер колонки (см. ВысотаВерха и КонтрольнаяКолонкаВерха).
//  КонтрольноеЗначениеДокумента  - Строка - Искомое контрольное значение (см. ВысотаВерха и КонтрольноеЗначениеВерха). Найденная строка при нулевом отступе является последней строкой документа.
//	РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз	- Булево - Рсчёт КЗ в каждой строке (см. ВысотаВерха и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз).
//  ОтступДокумента  - Число - Отступ последней строки документа (см. ВысотаВерха и ОтступВерха).
Процедура РасположитьПодвалТДНеразрывно(
		ТабДок,
		ПроверятьРазмещениеСтраницВШирину = 1,
		НачальныйМасштаб = 0,
		КонечныйМасштаб = 0,
		АвтоМасштаб = Истина,
		УменьшениеМасштаба = Истина,
		ЕслиНеНашлосьБыстроИскатьПеребором = Истина,
		ВставлятьРазрыв = Истина,
		ДопустимоПлохих = 0,
		ПолучилосьПлохих = 0,
		мОписанияДокументов = Неопределено,
		ВысотаВерха = 0,
		КонтрольнаяКолонкаВерха = 1,
		КонтрольноеЗначениеВерха = "ИТОГО:",
		РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Ложь,
		ОтступВерха = 0,
		ВысотаДокумента = -1,
		КонтрольнаяКолонкаДокумента = 1,
		КонтрольноеЗначениеДокумента = "ИТОГО:",
		РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз = Ложь,
		ОтступДокумента = -1
		) Экспорт
		
	//Алгоритм проверки
	//1.Проверка при автомасштабе - полная; Если по умолчанию не автомасштаб - выполняется после шага 2.
	//2.Проверка при заданном начальном масштабе - полная (после проверки по ширине).
	//3.Поиск 100% решения ускоренным методом (половинное деление масштабов, быстрый расчёт). Проводится этапами: 1 - поиск интервала масштабов с ок шириной; 2- поиск решения (попутно ищутся неполные решения)
	//4.Полная проверка результата п.3
	//5.Если результат не найден - последовательное, с шагом 1%, уменьшение масштаба от верхней границы
	//6.Вставка разрывов страниц
	
	#Область ИНИЦИАЛИЗАЦИЯ_ОБЩАЯ
		СтрокаНачалаДокумента = 1;
		МасштабРешения = - 1;
		РезультатРешения = 100; //Процент "плохих"
		МасштабТекВарианта = -1;
		РезультатТекВарианта = 100;
		ВременныйТД = Неопределено;
		МасштабироватьДалее = Истина;
		РезультатУхудшился = Ложь;
		МаксМасштабОкПоШирине = 0;
		
		ВысотаТД = ТабДок.ВысотаТаблицы;
		ВычисленныйНачальныйМасштаб = ?(НачальныйМасштаб = 0, ?(ТабДок.МасштабПечати = Неопределено, 100, ТабДок.МасштабПечати), НачальныйМасштаб);
		ВычисленныйКонечныйМасштаб = ?(КонечныйМасштаб = 0, НачальныйМасштаб - 30, КонечныйМасштаб);
	#КонецОбласти
		
	#Область ВЫЧИСЛЕНИЕ_ПАРАМЕТРОВ_ВЫСОТЫ_ДОКУМЕНТОВ
		Если мОписанияДокументов = Неопределено Тогда
			#Область ИНИЦИАЛИЗАЦИЯ_ВПВД
				МассивОписанийДокументов = Новый Массив;
				ВычисленнаяВысотаВерха = ВысотаВерха;
				ВычисленнаяВысотаДокумента = ВысотаДокумента;
				ВычисленныйОтступВерха = ОтступВерха;
				ВычисленныйОтступДокумента = ОтступДокумента;
				#Область ПАРАМЕТРЫ_МЕНЕДЖЕРОВ
					ПараметрыМенеджеров = Новый Структура;
					ПараметрыМенеджеров.Вставить("Табдок", Табдок);
					ПараметрыМенеджеров.Вставить("МассивОписанийДокументов", МассивОписанийДокументов);
					ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", 0);
					ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", КонтрольнаяКолонкаВерха);
					ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", КонтрольнаяКолонкаДокумента);
					ПараметрыМенеджеров.Вставить("ВысотаВерха", ВычисленнаяВысотаВерха);
					ПараметрыМенеджеров.Вставить("ВысотаДокумента", ВычисленнаяВысотаДокумента);
					ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
					ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", 1);
					ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
				#КонецОбласти
				#Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
					ВычисленнаяКонтрольнаяКолонкаВерха = ЗапуститьМенеджер(КонтрольнаяКолонкаВерха, ПараметрыМенеджеров);
					КолонкаВерхаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
					Если КолонкаВерхаЗаданаМенеджером Тогда
						ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", ВычисленнаяКонтрольнаяКолонкаВерха);
					КонецЕсли;
				#КонецОбласти
				#Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
					ВычисленнаяКонтрольнаяКолонкаДокумента = ЗапуститьМенеджер(КонтрольнаяКолонкаДокумента, ПараметрыМенеджеров);
					КолонкаДокументаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
					Если КолонкаДокументаЗаданаМенеджером Тогда
						ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", ВычисленнаяКонтрольнаяКолонкаДокумента);
					КонецЕсли;
				#КонецОбласти
				Если (ВычисленнаяВысотаВерха = 0) И НЕ РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
					ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
				КонецЕсли; 
				Если (ВычисленнаяВысотаДокумента = 0) И НЕ РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз Тогда
					ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
				КонецЕсли; 
			#КонецОбласти 
			Пока СтрокаНачалаДокумента <= ВысотаТД Цикл
				ОписаниеДока = Новый Структура("Начало,НачалоНиза,Конец", СтрокаНачалаДокумента, 0, 0);
				Если ВычисленнаяВысотаВерха <> 0 Тогда
					ОписаниеДока.НачалоНиза = ОписаниеДока.Начало + ВычисленнаяВысотаВерха;
				КонецЕсли; 
				Если ВычисленнаяВысотаДокумента > 0 Тогда
					ОписаниеДока.Конец = ОписаниеДока.Начало + ВычисленнаяВысотаДокумента - 1;
				ИначеЕсли ВычисленнаяВысотаДокумента = -1 Тогда
					ОписаниеДока.Конец = ВысотаТД;
				КонецЕсли; 
				Если (ОписаниеДока.НачалоНиза = 0) ИЛИ (ОписаниеДока.Конец = 0) Тогда
					СтартоваяКС = ОписаниеДока.Начало - Макс(Мин(0, ВычисленныйОтступВерха), Мин(0, ВычисленныйОтступДокумента));
					ФинишнаяКС = ТабДок.ВысотаТаблицы - Мин(Макс(0, ВычисленныйОтступВерха), Макс(0, ВычисленныйОтступДокумента));
					Для КонтрольнаяСтрока = СтартоваяКС По ФинишнаяКС Цикл
						ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", КонтрольнаяСтрока);
						Если РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз И (ОписаниеДока.Конец = 0) Тогда
							ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
						КонецЕсли;
						ВозможныйКонецДокумента = КонтрольнаяСтрока + ВычисленныйОтступДокумента;
						Если ?((ОписаниеДока.Конец = 0) И (ВозможныйКонецДокумента > 0),
								ВычисленноеКонтрольноеЗначениеДокумента =
									?(ВычисленнаяКонтрольнаяКолонкаДокумента = 0,
										Истина,
										ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаДокумента).Текст),
								Ложь)
								Тогда
							#Область РАСЧЁТ_КОНЦА_ДОКУМЕНТА
								ОписаниеДока.Конец = ВозможныйКонецДокумента;
								Если ОписаниеДока.НачалоНиза = 0 Тогда
									ОписаниеДока.НачалоНиза = ОписаниеДока.Конец + 1;
								КонецЕсли;
								Прервать
							#КонецОбласти
						ИначеЕсли ОписаниеДока.НачалоНиза = 0 Тогда
							#Область РАСЧЁТ_НАЧАЛА_НИЗА
								Если РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
									ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
								КонецЕсли; 
								Если ?(ВычисленнаяКонтрольнаяКолонкаВерха = 0, Истина, ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаВерха).Текст) = ВычисленноеКонтрольноеЗначениеВерха Тогда
									ОписаниеДока.НачалоНиза = КонтрольнаяСтрока + ВычисленныйОтступВерха + 1;
									ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", ОписаниеДока.НачалоНиза);
									Если ОписаниеДока.Конец > 0 Тогда
										Прервать;
									КонецЕсли;
								КонецЕсли;
							#КонецОбласти
						КонецЕсли;
					КонецЦикла;
					Если ОписаниеДока.НачалоНиза = 0 Тогда
						ОписаниеДока.НачалоНиза = ФинишнаяКС + 1;
					КонецЕсли;
					Если ОписаниеДока.Конец = 0 Тогда
						ОписаниеДока.Конец = ФинишнаяКС;
					КонецЕсли;
				КонецЕсли;
				МассивОписанийДокументов.Добавить(ОписаниеДока);
				СтрокаНачалаДокумента = ОписаниеДока.Конец + 1;
				ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", СтрокаНачалаДокумента);
				ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
				ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
			КонецЦикла; 
		Иначе
			МассивОписанийДокументов = мОписанияДокументов;
		КонецЕсли;
		КолвоВсего = МассивОписанийДокументов.Количество();
		ХранитьТД = КолвоВсего < 100;
	#КонецОбласти
	
	Если КолвоВсего < 1 Тогда
		МасштабироватьДалее = Ложь;
	КонецЕсли;
	
	#Область ПРОВЕРКА_АВТОМАСШТАБА_1
		ПроверитьАвтоМасштаб = АвтоМасштаб И (ПроверятьРазмещениеСтраницВШирину < 2);
		Если ПроверитьАвтоМасштаб И МасштабироватьДалее И ТабДок.АвтоМасштаб  Тогда
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
					КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
		КонецЕсли;
	#КонецОбласти 
	
	#Область ПРОВЕРКА_НАЧАЛЬНОГО_МАСШТАБА
		Если МасштабироватьДалее Тогда
			ПлохихВНачальнойТочке = КолвоВсего;
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ШиринаВПределе = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ВычисленныйНачальныйМасштаб);
			Если ШиринаВПределе Тогда
				МаксМасштабОкПоШирине = ВычисленныйНачальныйМасштаб;
				ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ВычисленныйНачальныйМасштаб, ХранитьТД, ДопустимоПлохих,
						КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
			Иначе
				РезультатРешения = 100;
			КонецЕсли;
		КонецЕсли; 
	#КонецОбласти 
	
	#Область ПРОВЕРКА_АВТОМАСШТАБА_2
		Если ПроверитьАвтоМасштаб И МасштабироватьДалее И НЕ ТабДок.АвтоМасштаб  Тогда
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
					КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
		КонецЕсли;
	#КонецОбласти 
	
	#Область УМЕНЬШЕНИЕ_МАСШТАБА_ПОЛОВИННЫМ_ДЕЛЕНИЕМ
		Если УменьшениеМасштаба И МасштабироватьДалее Тогда
			//Допущение:
			//Предполагается, что при уменьшении масштаба сначала "плохие" перейдут в "хорошие", а уже потом начнут портиться "хорошие". Т.е. пока не ушли "плохие", "хорошие" будут ок.
			Для Этап = 1 По 2 Цикл
				Если МасштабироватьДалее
						И ((Этап = 2) И (ПроверятьРазмещениеСтраницВШирину > 0) ИЛИ НЕ ШиринаВПределе) Тогда 
					#Область ИНИЦИАЛИЗАЦИЯ_УМЕНЬШЕНИЯ
						ВерхнийПределМасштаба = ВычисленныйНачальныйМасштаб - 1; //ВНМ уже проверен
						НижнийПределМасштаба = ВычисленныйКонечныйМасштаб;
						Вектор = - 1; //Вероятность решения выше в верхнем краю масштабной сетки
						ВекторНазначен = Ложь;
					    Если Этап = 1 Тогда
							ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
						Иначе
							ТекПлохих = ПлохихВНачальнойТочке;
							ВременныйТД.МасштабПечати = ВычисленныйНачальныйМасштаб;
							ИсходноеКолвоСтраниц = ВременныйТД.КоличествоСтраниц();
							РезультатТекВарианта = РезультатРешения;
							МасштабТекВарианта = ВерхнийПределМасштаба;
							ПлохиеМасштабы = Новый Массив;
						КонецЕсли;
						ТочкаПроверки = ВерхнийПределМасштаба;
					#КонецОбласти
					//ДопУсловие = Ложь;
					Пока (ВерхнийПределМасштаба >= НижнийПределМасштаба) Цикл 
						ДлинаОтрезкаМасштабов = ВерхнийПределМасштаба - НижнийПределМасштаба + 1;
						Шаг = ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор);
						ТочкаПроВерки = ВерхнийПределМасштаба - Шаг + 1;
						Если Этап = 1 Тогда
							РезультатОк = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ТочкаПроВерки);
						Иначе
							ВременныйТД.МасштабПечати = ТочкаПроВерки;
							Дельта = (ИсходноеКолвоСтраниц - ВременныйТД.КоличествоСтраниц()) / ПроверятьРазмещениеСтраницВШирину;
							ТекПлохих = Цел(ПлохихВНачальнойТочке - Дельта);
							ТекРезультат = ТекПлохих * 100 / КолвоВсего;
							Если ТекРезультат <= ДопустимоПлохих Тогда
								Если ТекРезультат < РезультатТекВарианта Тогда
									РезультатТекВарианта = ТекРезультат;
									МасштабТекВарианта = ТочкаПроВерки;
								ИначеЕсли ТекРезультат = РезультатТекВарианта И МасштабТекВарианта < ТочкаПроВерки Тогда
									МасштабТекВарианта = ТочкаПроВерки;
								КонецЕсли; 
							КонецЕсли; 
							Если ТекПлохих = 0 Тогда
								РезультатОк = Истина;
							Иначе
								РезультатОк = Ложь;
								ПлохиеМасштабы.Вставить(ТочкаПроВерки);
							КонецЕсли;
						КонецЕсли; 
						Если РезультатОк Тогда
							Если НЕ ВекторНазначен Тогда
								Вектор = 1;
								ВекторНазначен = Истина;
							КонецЕсли; 
							НижнийПределМасштаба = ТочкаПроВерки + 1;
						Иначе
							ВерхнийПределМасштаба = ТочкаПроВерки - 1;
						КонецЕсли;
					КонецЦикла;
					Если Этап = 1 Тогда
						ВычисленныйНачальныйМасштаб = ВерхнийПределМасштаба;
						Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
							МасштабТекВарианта = ВычисленныйНачальныйМасштаб;
							РезультатТекВарианта = -1;
						Иначе
							Прервать;
						КонецЕсли;
					КонецЕсли;
					Если РезультатТекВарианта < РезультатРешения Тогда
						ТочкаПроВерки = МасштабТекВарианта;
						ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
								КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
					КонецЕсли;
					Если Этап = 2 Тогда
						РезультатУхудшился = РезультатТекВарианта < РезультатРешения;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти 
	
	#Область УМЕНЬШЕНИЕ_МАСШТАБА_ПЕРЕБОРОМ
		Если УменьшениеМасштаба И МасштабироватьДалее И ЕслиНеНашлосьБыстроИскатьПеребором Тогда
			#Область КРОМЕ_ПЛОХИХ_МАСШТАБОВ
				Для Сдвиг = ВычисленныйКонечныйМасштаб По ВычисленныйНачальныйМасштаб - 1 Цикл
					ТочкаПроВерки = ВычисленныйНачальныйМасштаб + ВычисленныйКонечныйМасштаб - Сдвиг - 1;
					Если ПлохиеМасштабы.Найти(ТочкаПроВерки) = Неопределено Тогда
						ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
								КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
						Если НЕ МасштабироватьДалее Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			#КонецОбласти
			
			//В плохих масштабах решение м.б. лучшим только если текущее решение ухудшилось при точной проверке
			Если МасштабироватьДалее И РезультатУхудшился Тогда
				Для каждого ТочкаПроВерки Из ПлохиеМасштабы Цикл
					ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
							КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
					Если НЕ МасштабироватьДалее Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти
	
	ПолучилосьПлохих = РезультатРешения;
	
	#Область АНАЛИЗ_РЕЗУЛЬТАТА_И_ВСТАВКА_РАЗРЫВА
		Если МасштабироватьДалее И ВставлятьРазрыв Тогда
			ВременныйТД = ТабДок;
			ТабДок = СкопироватьПараметрыТД(, ВременныйТД);
			Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
				ТабДок.АвтоМасштаб = Ложь;
				ТабДок.МасштабПечати = ВычисленныйНачальныйМасштаб;
			Иначе
				ТабДок.АвтоМасштаб = Истина;
				ТабДок.МасштабПечати = 0;
			КонецЕсли; 
			НуженРазделитель = Ложь;
			Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
				Если НуженРазделитель Тогда
					ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
				Иначе
					НуженРазделитель = Истина;
				КонецЕсли;
				ОбластьКПроверкеИВыводу = ВременныйТД.ПолучитьОбласть(ОписаниеДока.НачалоНиза - 1,, ОписаниеДока.Конец);
				ТабДок.Вывести(ВременныйТД.ПолучитьОбласть(ОписаниеДока.Начало,, ОписаниеДока.НачалоНиза - 2));
				Если НЕ ТабДок.ПроверитьВывод(ОбластьКПроверкеИВыводу) Тогда
					ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
				КонецЕсли;
				ТабДок.Вывести(ОбластьКПроверкеИВыводу);
			КонецЦикла; 
		ИначеЕсли МасштабРешения = 0 Тогда
			ТабДок.АвтоМасштаб = Истина;
			ТабДок.МасштабПечати = Неопределено;
		ИначеЕсли МасштабРешения <> - 1 Тогда
			ТабДок.АвтоМасштаб = Ложь;
			ТабДок.МасштабПечати = МасштабРешения;
		КонецЕсли; 
	#КонецОбласти 
			
КонецПроцедуры // ТабДок_РасположитьВСтранице

#КонецОбласти

#КонецОбласти 

#Область ТИПЫ

//Возвращает описание типов "любая ссылка"
//Параметры:
//	ВключитьСписокЗначений - Булево - При Истина (по умолчанию) результат включает список значений
//Возвращаемое значение:
//	Описание типов - любая ссылка + Булево + Дата + Число + Строка + (Опционально) Список значений
Функция ВсеСсылочныеИПростыеТипы(ВключитьСписокЗначений = Истина) Экспорт
	МассивТипов = Новый Массив();
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	Если ВключитьСписокЗначений Тогда
		МассивТипов.Добавить(Тип("СписокЗначений"));
	КонецЕсли; 
	Возврат Новый ОписаниеТипов(ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.ВсеСсылочныеТипы(), МассивТипов,, Новый КвалификаторыЧисла(31, 7, ДопустимыйЗнак.Любой),
			Новый КвалификаторыСтроки(2000, ДопустимаяДлина.Переменная), Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя),
			Новый КвалификаторыДвоичныхДанных(2000, ДопустимаяДлина.Переменная));
КонецФункции // ВсеСсылочныеТипы()

//Создаёт "суммарное" описание типов из двух
//Параметры:
//	ОТ1 - Описание типов - слагаемое
//	ОТ2 - Описание типов - слагаемое
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОбъединитьОписанияТипов(ОТ1, ОТ2) Экспорт
	ТипОТ = Тип("ОписаниеТипов");
	ОТ_Итог = Новый ОписаниеТипов;
	Если ТипЗнч(ОТ1) = ТипОТ Тогда
		Если ТипЗнч(ОТ2) = ТипОТ Тогда
			//ОТ2 = Новый ОписаниеТипов;
			//ОТ1 = Новый ОписаниеТипов;
			Менять = Ложь;
			Если ОТ1.КвалификаторыДаты.ЧастиДаты <> ОТ2.КвалификаторыДаты.ЧастиДаты Тогда
				КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
				Менять = Истина
			Иначе
				КвалификаторДаты = ОТ1.КвалификаторыДаты
			КонецЕсли;
			МенятьПрм1 = ОТ2.КвалификаторыДвоичныхДанных.Длина > ОТ1.КвалификаторыДвоичныхДанных.Длина;
			Размер = ?(МенятьПрм1, ОТ2.КвалификаторыДвоичныхДанных.Длина, ОТ1.КвалификаторыДвоичныхДанных.Длина);
			МенятьПрм2 = ((ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная) И НЕ (ОТ1.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная));
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				КвалификаторДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Размер, ?(МенятьПрм2 или (ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная), ДопустимаяДлина.Переменная, ДопустимаяДлина.Фиксированная))
			Иначе
				КвалификаторДвоичныхДанных = ОТ1.КвалификаторыДвоичныхДанных
			КонецЕсли;
			МенятьПрм1 = ОТ2.КвалификаторыСтроки.Длина > ОТ1.КвалификаторыСтроки.Длина;
			Размер = ?(МенятьПрм1, ОТ2.КвалификаторыСтроки.Длина, ОТ1.КвалификаторыСтроки.Длина);
			МенятьПрм2 = ((ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная)
					И НЕ (ОТ1.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная))
					ИЛИ (ОТ2.КвалификаторыСтроки.Длина <> ОТ1.КвалификаторыСтроки.Длина);
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				КвалификаторСтроки = Новый КвалификаторыСтроки(Размер,
						?(МенятьПрм2 или (ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная),
							ДопустимаяДлина.Переменная,
							ДопустимаяДлина.Фиксированная))
			Иначе
				КвалификаторСтроки = ОТ1.КвалификаторыСтроки
			КонецЕсли;
			МенятьПрм1 = ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			МенятьПрм2 = ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			ЗнакОТ2аЛюбой = (ОТ2.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
			ЗнакОТ1аЛюбой = (ОТ1.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2 или (ЗнакОТ2аЛюбой и НЕ ЗнакОТ1аЛюбой);
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				РДЧ =?(МенятьПрм2, ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти, ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти); 
				КвалификаторЧисла = Новый КвалификаторыЧисла(
						?(МенятьПрм1, ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти,
							ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти) + РДЧ,
						РДЧ,
						?(ЗнакОТ2аЛюбой Или ЗнакОТ1аЛюбой, ДопустимыйЗнак.Любой, ДопустимыйЗнак.Неотрицательный))
			Иначе
				КвалификаторЧисла = ОТ1.КвалификаторыЧисла
			КонецЕсли;
			Типы = ОТ1.Типы();
			Для каждого Тип из ОТ2.Типы() Цикл
				Если Типы.Найти(Тип) = Неопределено Тогда
					Менять = Истина;
					Типы.Добавить(Тип)
				КонецЕсли
			КонецЦикла;
			Если Менять Тогда
				ОТ_Итог = Новый ОписаниеТипов(Типы, КвалификаторЧисла, КвалификаторСтроки, КвалификаторДаты, КвалификаторДвоичныхДанных)
			Иначе
				ОТ_Итог = ОТ1
			КонецЕсли
		Иначе
			ОТ_Итог = ОТ1;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ОТ2) = ТипОТ Тогда
		ОТ_Итог = ОТ2;
	КонецЕсли;
	Возврат ОТ_Итог
КонецФункции //ОбъединитьОписанияТипов (ПодключитьОписаниеТипов)

//Возвращает объединённое описание типов всех значений коллекции
//Параметры:
//	Коллекция - Произвольная коллекция - по элементам которой будет формироваться описание типов
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОписаниеТиповКоллекции(Коллекция) Экспорт
	Если Коллекция.Количество() = 0 Тогда
		Возврат ПолучитьОписаниеТипаЗначения(Неопределено)
	Иначе
		Результат = Неопределено;
		Для каждого Единица из Коллекция Цикл
			Результат = ОбъединитьОписанияТипов(Результат, ПолучитьОписаниеТипаЗначения(Единица))
		КонецЦикла;
		Возврат Результат
	КонецЕсли
КонецФункции

//Определяет ширину колонки для отображения типа. Для типов неопределённой длины берётся ширина 50.
//Параметры:
//	ОписаниеТипов - Описание типов - для которого требуется определить ширину колонки
//Первый параметр - описание типов, для этого описания определяется ширина.
//Возвращаемое значение:
//	Число - Ширина колонки
Функция ОпределитьШиринуКолонкиПоТипу(ОписаниеТипов) Экспорт
	Если ОписаниеТипов.КвалификаторыДаты = Неопределено	Тогда
		Ширина = 0
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		Ширина = 8
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
		Ширина = 10
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.ДатаВремя Тогда
		Ширина = 19
	Иначе
		Ширина = 0
	КонецЕсли;
	Если ОписаниеТипов.КвалификаторыДвоичныхДанных = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыСтроки = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыСтроки.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыЧисла = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыЧисла.Разрядность;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Для каждого Тип из ОписаниеТипов.Типы() Цикл
		Если Строка(Тип) = "Булево" Тогда
			Ширина_ = 2
		ИначеЕсли Строка(Тип) = "Null" Тогда
			Ширина_ = 4
		ИначеЕсли Строка(Тип) = "Неопределено" Тогда
			Ширина_ = 1
		ИначеЕсли Строка(Тип) = "Число" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Строка" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Дата" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Тип" Тогда
			Ширина_ = 24
		Иначе
			Ширина_ = СтрДлина(Строка(Новый(Тип)))
		КонецЕсли;
		Ширина = ?(Ширина < Ширина_, Ширина_, Ширина)
	КонецЦикла;
КонецФункции //ОпределитьШиринуКолонкиПоТипу

//Определяет тип значения и формирует описание типа по нему.
//Параметры:
//	Значение_ - Произвольный - по которому надо сформировать ОписаниеТипа
//Возвращаемое значение:
//	ОписаниеТипа - которому принадлежит заданное значение
Функция ПолучитьОписаниеТипаЗначения(Значение_) Экспорт
	Тип_ = ТипЗнч(Значение_);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип_);
	Если Тип_ = Тип("Число") Тогда
		//Определить квалификатор числа
		ДоЗапятой = Макс(1, 1 + Цел(Log10(?(Значение_ > 0, Значение_, ?(Значение_ < 0, -Значение_, 1)))));
		ПослеЗапятой = СтрДлина(Значение_ - Цел(Значение_)) - 2;
		//Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой + ПослеЗапятой + 1, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Возврат Новый ОписаниеТипов(МассивТипов, Квалификатор_)
	ИначеЕсли Тип_ = Тип("Строка") Тогда
		//Определить квалификатор строки
		//Квалификатор_ = Новый КвалификаторыСтроки(СтрДлина(Значение_), ДопустимаяДлина.Фиксированная);
		ТекДлина = СтрДлина(Значение_);
		Квалификатор_ = Новый КвалификаторыСтроки(?(ТекДлина = 0, 1, ТекДлина), ДопустимаяДлина.Фиксированная); //Чтобы нулевая длина не стала неограниченной
		Возврат Новый ОписаниеТипов(МассивТипов, , Квалификатор_)
	ИначеЕсли Тип_ = Тип("Дата") Тогда
		//Определить квалификатор даты
		Квалификатор_ = Новый КвалификаторыДаты(?((Час(Значение_) = 0) И (Минута(Значение_) = 0) И (Секунда(Значение_) = 0), ЧастиДаты.Дата,
				?((Год(Значение_) = 0) И (Месяц(Значение_) = 0) И (День(Значение_) = 0), ЧастиДаты.Время, ЧастиДаты.ДатаВремя)));
		Возврат Новый ОписаниеТипов(МассивТипов, , , Квалификатор_)
	ИначеЕсли Тип_ = Тип("ДвоичныеДанные") Тогда
		//Определить квалификатор двоичных данных
		Квалификатор_ = Новый КвалификаторыДвоичныхДанных(Значение_.Размер(), ДопустимаяДлина.Переменная);
		Возврат Новый ОписаниеТипов(МассивТипов, , , , Квалификатор_)
	Иначе
		Возврат Новый ОписаниеТипов(МассивТипов)
	КонецЕсли
КонецФункции

//Получает пустую ссылку по строке типа (результату метода ПолноеИмя)
//Параметры:
//	  ТипОбъекта - Строка - полное имя метаданных
//Возвращаемое значение:
//	  Ссылка - Пустая ссылка метаданных
Функция ПолучитьПустуюСсылкуТипа(ТипОбъекта) Экспорт
	СтрокаСсылки = СтрЗаменить(ТипОбъекта, ".", "Ссылка.");
	Возврат Новый(Тип(СтрокаСсылки)) 
КонецФункции //ПолучитьПустуюСсылкуТипа

// Возвращает примерное значение указанного типа. Для строки, даты  и числа это будет значение указанной квалификации, состоящее из единиц,
//		для ссылки - пустая ссылка, для остальных = приведение единицы к описанию типа.
// Параметры:
//	Источник  - Тип - Значение которого надо получить
//	КвалификаторЧисла  - КвалификаторыЧисла - Квалификатор типа
//	КвалификаторСтроки  - КвалификаторыСтроки - Квалификатор типа
//	КвалификаторДаты  - КвалификаторыДаты - Квалификатор типа
//	Строкой  - Булево - Представить значение в виде строки для текста запроса
// Возвращаемое значение:
//	Произвольный   - Примерное значение указанного типа
Функция ПримерноеЗначение(Источник, КвалификаторЧисла = "", КвалификаторСтроки = "", КвалификаторДаты = "", Строкой = Истина) Экспорт
	Результат = Новый Соответствие;
	Если Источник = Тип("Число") Тогда
		Если КвалификаторЧисла = "" ИЛИ КвалификаторЧисла.Разрядность = 0 Тогда
			Результат = 1;
		Иначе
			Результат = 0;
			Исходная = 1;
			Для ЁХ = 1 По КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
				Исходная = Исходная / 10;
				Результат = Результат + Исходная;
			КонецЦикла;
			Исходная = 1;
			Для ЁХ = 1 По КвалификаторЧисла.Разрядность - КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
				Результат = Результат + Исходная;
				Исходная = Исходная * 10;
			КонецЦикла;
			Если КвалификаторЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой Тогда
				Результат = - Результат;
			КонецЕсли;
		КонецЕсли;
		Если Строкой Тогда
			Результат = СтрЗаменить(ФОРМАТ(Результат, "ЧГ=0"), ",", ".");
		КонецЕсли;
	ИначеЕсли Источник = Тип("Булево") Тогда
		Если Строкой Тогда
			Результат = "ИСТИНА";
		Иначе
			Результат = Истина;
		КонецЕсли;
	ИначеЕсли Источник = Тип("Строка") Тогда
		Результат = "";
		Если КвалификаторСтроки <> "" Тогда
			Для ЁХ = 1 По КвалификаторСтроки.Длина Цикл
				Результат = Результат + "1";
			КонецЦикла;
		КонецЕсли;
		Если Строкой Тогда
			Результат = """" + Результат + """";
		КонецЕсли;
	ИначеЕсли Источник = Тип("Дата") ИЛИ Источник = Тип("СтандартнаяДатаНачала") ИЛИ Источник = Тип("СтандартныйПериод") Тогда
		Результат = '11111111111111';
		мТипов = Новый Массив;
		мТипов.Добавить(Тип("Дата"));
		ТекОТ = ?(КвалификаторСтроки = "", Новый ОписаниеТипов(мТипов), Новый ОписаниеТипов(мТипов,,, КвалификаторДаты));
		ИсхДата = ТекОТ.ПривестиЗначение(Результат);
		Если Источник = Тип("СтандартнаяДатаНачала") Тогда
			Результат = Новый СтандартнаяДатаНачала;
			Результат.Дата = ИсхДата;
			Если Строкой Тогда
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли Источник = Тип("СтандартныйПериод") Тогда
			Результат = Новый СтандартныйПериод;
			Результат.ДатаНачала = ИсхДата;
			Результат.ДатаОкончания = ИсхДата;
			Если Строкой Тогда
				Результат = Неопределено;
			КонецЕсли;
		Иначе
			Результат = ИсхДата;
			Если Строкой Тогда
				ТекГод = Год(Результат);
				ТекМес = Месяц(Результат);
				ТекДень = День(Результат);
				ТекЧас = Час(Результат);
				ТекМин = Минута(Результат);
				ТекСек = Секунда(Результат);
				Результат = "ДАТАВРЕМЯ("
						+ ?(ТекГод = 0, 1, Формат(ТекГод, "ЧГ=0")) + "," +
						+ ?(ТекМес = 0, 1, ТекМес) + "," +
						+ ?(ТекДень = 0, 1, ТекДень) + "," +
						+ ?(ТекЧас = 0, 1, ТекЧас) + "," +
						+ ?(ТекМин = 0, 1, ТекМин) + "," +
						+ ?(ТекСек = 0, 1, ТекСек) + ")";
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если Строкой Тогда
			Результат = ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(Источник);
			Если Результат = Неопределено Тогда
				Результат = "НЕОПРЕДЕЛЕНО";
			Иначе
				Результат = "ЗНАЧЕНИЕ(" + Результат + ".ПустаяСсылка)"
			КонецЕсли;
		Иначе
			мТипов = Новый Массив;
			мТипов.Добавить(Источник);
			ТекОТ = Новый ОписаниеТипов(мТипов);
			Результат = ТекОТ.ПривестиЗначение(1);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ПримерноеЗначение

// Разбивает массив на несколько массивов однотипных значений, помещаемых в Соответствие
// Параметры:
//  ИсходныйМассив  - Массив - Массив разнотипных объектов
// Возвращаемое значение:
//   Соответствие   - ключи - типы, значения - массивы однотипных значений
Функция РазбитьПоТипам(ИсходныйМассив) Экспорт
	СоответствиеТипов = Новый Соответствие;
	Если ТипЗнч(ИсходныйМассив) = Тип("Массив") Тогда
		Для каждого Док Из ИсходныйМассив Цикл
			ТекТип = ТипЗнч(Док);
			Если СоответствиеТипов[ТекТип] = Неопределено Тогда
				СоответствиеТипов.Вставить(ТекТип, Новый Массив);
			КонецЕсли;
			СоответствиеТипов[ТекТип].Добавить(Док);
		КонецЦикла;
	Иначе
		СоответствиеТипов.Вставить(ТипЗнч(ИсходныйМассив), ПреобразоватьВМассив(ИсходныйМассив));
	КонецЕсли;
	Возврат СоответствиеТипов;
КонецФункции // РазбитьПоТипам()

//Возвращает булево, равен ли тип значения обозначенному строкой.
//Параметры:
//	 Значение - произвольный - проверяемое значение
//	 СтрокаОбозначенияТипа - Строка - строковое обозначение типа, например, СправочникСсылка.Банки
//Возвращаемое значение:
//	 Истина - тип значения совпадает с типом, полученным по строке
Функция ТипРавен(Значение, СтрокаОбозначенияТипа) Экспорт
	Результат = Ложь;
	Попытка
		Результат = ТипЗнч(Значение) = Тип(СтрокаОбозначенияТипа)
	Исключение
	КонецПопытки;
	Возврат Результат
КонецФункции //ТипРавен

#КонецОбласти

#Область УПРАВЛЯЕМАЯ_ФОРМА

// Находит первую строку по структуре (Аналогично НайтиСтроку) в ДанныеФормыДерево
// Параметры:
//  ДФД  - ДанныеФормыДерево - Где искать
//	Критерии - Структура - Отбор поиска, аналогично НайтиСтроки
// Возвращаемое значение:
//   Число   - Идентификатор найденной строки. 0, если не найдена.
Функция НайтиВ_ДФД(ДФД, Критерии) Экспорт
	Результат = 0;
	Для каждого СтрокаДЗ Из ДФД.ПолучитьЭлементы() Цикл
		Совпали = Истина;
		Для каждого КиЗ Из Критерии Цикл
			Если КиЗ.Значение <> СтрокаДЗ[КиЗ.Ключ] Тогда
				Совпали = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Совпали Тогда
			Результат = СтрокаДЗ.ПолучитьИдентификатор();
			Прервать;
		Иначе
			Результат = НайтиВ_ДФД(СтрокаДЗ.Строки, Критерии);
			Если Результат > 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // НайтиВ_ДФД

// Устанавливает флаг в таблице формы в нужное значение
// Параметры:
//  Форма  - Управляемая форма - Форма, где меняются флаги
//  ТаблицаФормы  - Таблица формы - содержащая изменяемую колонку
//	ИмяПоля - Строка - на клиенте - путь к данным;
//			на сервере - список полей через запятую. Изменяется текущее, если оно в списке или список пуст.
//			Если текущее не найдено в списке - изменяется первое, если оно задано. По умолчанию "Пометка"
//	НовоеЗначение - Булево/Неопределено - Устанавливаемое значение. По умолчанию Истина.
//			В рехиме инвертирования - значение, подставляемое вместо Истина:
//			*Неопределено - Истина ==> Неопределено ==> Ложь ==> Истина; 
//			*Ложь - Истина ==> Ложь ==> Неопределено ==> Истина; 
//			*Истина - Истина ==> Ложь ==> Истина; 
//			*0 - 1 ==> 0 ==> 2 ==> 1; 
//			*1 - 1 ==> 0 ==> 1; 
//			*2 - 1 ==> 2 ==> 0 ==> 1; 
//	Инвертировать - Булево - режим инвертирования флагов. По умолчанию Ложь.
//	ИмяДанныхТаблицы - Строка - Имя данных формы, соответствующих таблице. По умолчанию "" - автоопределение.
//	МассивСтрокКИзменению - Массив - массив строк таблицы/дерева (ДанныеФормыЭлементДерева), в которых будет меняться флаг.
//			По умолчанию Неопределено = выделенные строки или (если выделена одна строка или ничего не выделено) = все строки.
// Возвращаемое значение - Массив - Строки данных формы с изменёнными флагами.
Функция УстановитьФлаги(Форма, ТаблицаФормы_, ИмяПоля = "Пометка", НовоеЗначение = Истина, Инвертировать = Ложь, ИмяДанныхТаблицы = "", МассивСтрокКИзменению = Неопределено) Экспорт
	Результат = Новый Массив;
	ИмяДанныхПоляВТаблице = СтрЗаменить(ИмяПоля, " ", "");
	#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
		ДопустимыеПоля = ИмяДанныхПоляВТаблице;
		ИмяДанныхПоляВТаблице = СтрЗаменить(ТаблицаФормы_.ТекущийЭлемент.ПутьКДанным, ".", Символы.ПС);
		ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(ИмяДанныхПоляВТаблице, СтрЧислоСтрок(ИмяДанныхПоляВТаблице));
		Если ИмяПоля <> "" Тогда
			Если СтрНайти("," + ДопустимыеПоля + ",", "," + ИмяДанныхПоляВТаблице + ",") = 0 Тогда
				ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(СтрЗаменить(ДопустимыеПоля, ",", Символы.ПС), 1);
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	#Область СТРОКИ_ДЛЯ_ФЛАГОВ
		МассивВЧёмМенять = Новый Массив;
		Если МассивСтрокКИзменению = Неопределено Тогда
			Если ИмяДанныхТаблицы = "" Тогда
				#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
					ИмяДанныхТаблицы = ТаблицаФормы_.ПутьКДанным;
				#Иначе
					ИмяДанныхТаблицы = "";
					ТестСтр = Новый Структура("Объект," + ТаблицаФормы_.Имя);
					ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
					Если ТестСтр[ТаблицаФормы_.Имя] = Неопределено Тогда
						Если ТестСтр.Объект <> Неопределено Тогда
							ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
							Если ТестСтр[ТаблицаФормы_.Имя] <> Неопределено Тогда
								ИмяДанныхТаблицы = "Объект." + ТаблицаФормы_.Имя;
							КонецЕсли;
						КонецЕсли;
					Иначе
						ИмяДанныхТаблицы = ТаблицаФормы_.Имя;
					КонецЕсли;
				#КонецЕсли
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяДанныхТаблицы) Тогда
				Колво = ТаблицаФормы_.ВыделенныеСтроки.Количество();
				ДанныеТаблицы = Вычислить("Форма." + ИмяДанныхТаблицы);
				Все = (Колво < 2) ИЛИ (Колво = ДанныеТаблицы.Количество());
				Если Все Тогда
					МассивВЧёмМенять = ДанныеТаблицы;
				Иначе
					Для каждого ВСтрока Из ТаблицаФормы_.ВыделенныеСтроки Цикл
						МассивВЧёмМенять.Добавить(ДанныеТаблицы.НайтиПоИдентификатору(ВСтрока));
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		Иначе
			МассивВЧёмМенять = МассивСтрокКИзменению;
		КонецЕсли;
	#КонецОбласти
	Для каждого СтрокаЗамены Из МассивВЧёмМенять Цикл
		ТекЗнч = СтрокаЗамены[ИмяДанныхПоляВТаблице];
		Если НЕ Инвертировать Тогда
			Если (ТекЗнч = Неопределено) ИЛИ (ТекЗнч = Истина) ИЛИ (ТекЗнч = Ложь) ИЛИ (ТекЗнч = 0) ИЛИ (ТекЗнч = 1) ИЛИ (ТекЗнч = 2) Тогда
				Если ТекЗнч <> НовоеЗначение Тогда
					Результат.Добавить(СтрокаЗамены);
					СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Результат.Добавить(СтрокаЗамены);
			Если ТекЗнч = Неопределено Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение <> Неопределено;
			ИначеЕсли ТекЗнч = Истина Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Истина, Ложь, НовоеЗначение);
			ИначеЕсли ТекЗнч = Ложь Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Ложь, Неопределено, Истина);
			ИначеЕсли ТекЗнч = 2 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 2, 0, 1);
			ИначеЕсли ТекЗнч = 1 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 1, 0, НовоеЗначение);
			ИначеЕсли ТекЗнч = 0 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 0, 2, 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // УстановитьФлаги
	
#КонецОбласти

#Область ФАЙЛОВАЯ_СИСТЕМА

//Выделяет расширение из полного имени файла
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - расширение файла (подстрока после последней точки)
Функция ПолучитьРасширение(Путь) Экспорт
	СпецСтрока = СтрЗаменить(Путь, ".", Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя собственно файла (с расширением)
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя файла (подстрока после последнего разделителя пути)
Функция ИмяФайла(Путь) Экспорт
	#Если Клиент Тогда
		РП = ПолучитьРазделительПутиКлиента();
	#Иначе
		РП = ПолучитьРазделительПутиСервера();
	#КонецЕсли 
	СпецСтрока = СтрЗаменить(Путь, РП, Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя каталога без завершающего слэша
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя каталога (подстрока до последнего разделитля пути исключительно)
Функция ИмяКаталога(Путь) Экспорт
	Возврат Лев(Путь, СтрДлина(Путь) - СтрДлина(ИмяФайла(Путь)) - 1)
КонецФункции

//Переименовывает файл, добавляя к его старому имени префикс
//Параметры:
//	Имя - Строка - полное имя файла. Возвращается новое полное имя.
//	Префикс - Строка - добавляется к имени файла после пути к каталогу и разделителя пути.
Процедура ДобавитьПрефиксИмениФайла(Имя, Префикс)
	СтароеИмяФайла = ИмяФайла(Имя);
	НовоеИмя = Лев(Имя, СтрДлина(Имя) - СтрДлина(СтароеИмяФайла)) + Префикс + СтароеИмяФайла;
	ПереместитьФайл(Имя, НовоеИмя);
	Имя = НовоеИмя
КонецПроцедуры

//Получает файл из заданного пути, проверяет, зашифрован ли он, если нет - зашифровывает,
//Затем помещает в заданный каталог
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	ПутьОткудаВзять - Строка - Полный путь к исходному файлу
//	ПутьКудаСохранить - Строка - Имя каталога, куда будет сохранён под тем же именем зашифрованный файл.
//Возвращаемое значение:
//	Строка - при успешной зашифровке - новое имя файла, при неуспешной - пустая
Функция ЗашифроватьФайл(ПутьОткудаВзять, ПутьКудаСохранить) Экспорт
	ИмяФайла_ = "";
	КШифровке = Новый Файл(ПутьОткудаВзять);
	Если КШифровке.Существует() Тогда
		РазмерФайла = КШифровке.Размер();
		Если РазмерФайла > 9 Тогда
			Каталог = ПутьКудаСохранить;
			ИмяФайла_ = Каталог + ИмяФайла(ПутьОткудаВзять);
			Если ПутьОткудаВзять <> ИмяФайла_ Тогда
				Перезаписать = Ложь;
				КопироватьФайл(ПутьОткудаВзять, ИмяФайла_)
			КонецЕсли;
			РазмерЧасти = РазмерФайла - 9;
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[1], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Строка_ = "ВОЛНА2015";
			Если НЕ Зашифрован Тогда
				УдалитьФайлы(МассивФайлов[1]);
				УдалитьФайлы(МассивФайлов[0]);
				РазмерЧасти = Цел(РазмерФайла/2);
				МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
				//МассивФайлов.Добавить(ПолучитьИмяВременногоФайла());
				МассивФайлов.Добавить(МассивФайлов[0]);
				Колво = МассивФайлов.ВГраница();
				ЗаменитьКонецСтроки(МассивФайлов[Колво], "." + (Колво + 1));
				ТекстСлава = Новый ТекстовыйДокумент;
				ТекстСлава.УстановитьТекст("ВОЛНА2015");
				ТекстСлава.Записать(МассивФайлов[Колво], КодировкаТекста.ANSI);
				//Надо расставить файлы по именам 2-3-1-4
				ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
				ЗаменитьКонецСтроки(МассивФайлов[1], ".3");
				ЗаменитьКонецСтроки(МассивФайлов[Колво - 1], ".1");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[0], "_");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "___");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[МассивФайлов.ВГраница() - 1], "__");
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			Для каждого Ё из МассивФайлов Цикл
				УдалитьФайлы(Ё)
			КонецЦикла
		КонецЕсли
	КонецЕсли;
	Возврат ИмяФайла_
КонецФункции

//Читает файл, расшифровывает его во временный, открывает
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	Путь - Строка - Путь к расщифровываемому файлу
//Возвращаемое значение:
//	Булево - Удалось открыть файл
Функция РасшифроватьФайл(Путь) Экспорт
	Результат = Ложь;
	КРасшифровке = Новый Файл(Путь);
	Если КРасшифровке.Существует() Тогда
		РазмерФайла = КРасшифровке.Размер();
		Если РазмерФайла > 11 Тогда
			ИмяФайла_ = ПолучитьИмяВременногоФайла(ПолучитьРасширение(Путь));
			КопироватьФайл(Путь,ИмяФайла_);
			РазмерЧасти = Окр((РазмерФайла - 9)/2);
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[2], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Ложь;
			Если Строка_ = "ОЛНА2015" Тогда
				//нечёт
				ДопМассивФайлов = РазделитьФайл(МассивФайлов[1], РазмерЧасти - 1);
				ПереместитьФайл(ДопМассивФайлов[0], МассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[0]);
				//МассивФайлов[1] = ДопМассивФайлов[0];
				Зашифрован = Истина
			КонецЕсли;
			Зашифрован = Зашифрован ИЛИ (Строка_ = "ВОЛНА2015");
			УдалитьФайлы(МассивФайлов[2]);
			МассивФайлов.Удалить(2);
			//Файлы объединяются в порядке имён - имя второго надо "уменьшить"
			//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "_");
			ЗаменитьКонецСтроки(МассивФайлов[1], ".1");
			ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
			Если Зашифрован Тогда
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			УдалитьФайлы(МассивФайлов[1]);
			УдалитьФайлы(МассивФайлов[0]);
			ЗапуститьПриложение(ИмяФайла_);
			Результат = Истина;
		КонецЕсли
	КонецЕсли;
	Возврат Результат;
КонецФункции
 
//Передаёт файл из сетевого каталога на ФТП.
//Параметры:
//	ПолноеИмяФайлаИсточника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаПриёмника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ЗаписатьФайлНаFTP(ПолноеИмяФайлаИсточника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаПриёмника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 
		FTPСоединение.Записать(ПолноеИмяФайлаИсточника, ИмяФайлаПриёмника);	
		Если УдалитьИсточник Тогда
			УдалитьФайлы(ПолноеИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		#Если Сервер Тогда
			ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
		#Иначе
			Сообщить("Ошибка записи файла  на ФТП:" + ОО);
		#КонецЕсли
	КонецПопытки;
КонецПроцедуры

//Передаёт файл с ФТП в сетевой каталог
//Параметры:
//	ПолноеИмяФайлаПриёмника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаИсточника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ПолучитьФайлСFTP(ПолноеИмяФайлаПриёмника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаИсточника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 	
		FTPСоединение.Получить(ИмяФайлаИсточника, ПолноеИмяФайлаПриёмника);
		Если УдалитьИсточник Тогда
			FTPСоединение.Удалить(ИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		#Если Сервер Тогда
			ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
		#Иначе
			Сообщить("Ошибка записи файла  на ФТП:" + ОО);
		#КонецЕсли
	КонецПопытки;
КонецПроцедуры

// Возвращает существование файла по пути
// Параметры:
//  Путь  - Строка - Путь к предполагаемому файлу
// Возвращаемое значение:
//   Булево   - Существование файла
Функция ФайлСуществует(Путь) Экспорт
	Файл = Новый Файл(Путь);
	Результат = Файл.Существует();
	Возврат Результат
КонецФункции // ФайлСуществует

#КонецОбласти

//Аналог ЕстьNull - чтобы писать формулу одной строкой и не делать доп.переменных
//Параметры:
//	Первое - Произвольное - Значение, сравниваемое с "нежелательным".
//	Второе - Произвольное - "Нежелательное" значение
//	Третье - Произвольное - Замена "нежелательному" значению.
//Возвращаемое значение:
//	Произвольное - Если Первое = Второму, то Третье, иначе - Первое.
Функция ЕслиПервоеВтороеРавныТоТретьеИначеПервое(Первое, Второе, Третье) Экспорт
	Возврат ?(Первое = Второе, Третье, Первое)
КонецФункции

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает индекс коллекции, соответствующий искомому значению
// Параметры:
//  Искомое  - Число, строка, иное значение, сравнимое на больше-меньше - значение, искомое в коллекции. Значения по умолчанию дают индекс для вставки.
//  Коллекция  - Массив, Таблица значений или иная коллекция - место поиска
//  ИмяРеквизита  - Строка - Имя колонки, в которой ищется Искомое. Для массива не используется. Коллекция должна быть отсортирована.
//  ЕслиНетРавного  - Произвольный - Что вернуть, если равное не найдено. "Меньший", "Больший"  (по умолчанию), "БлижайшийЕслиМежду_Меньший", "БлижайшийЕслиМежду_Больший", или значение, которое будет возвращено.
//  ЕслиМногоРавных  - Произвольный - Что вернуть, если равных несколько. "МеньшийИндекс" (по умолчанию), "БольшийИндекс", "Любой", или значение, которое будет возвращено.
//  СортировкаВозрастание  - Булево - Коллекция отсортирована по возрастанию.
//  Вектор  - Число - -1(по умолчанию) - считаем, что искомое ближе к началу коллекции, 1 - иначе.
// Возвращаемое значение:
//   Число   - Индекс найденного элемента коллекции
Функция ИндексПоловиннымДелением(Искомое, Коллекция, ИмяРеквизита, ЕслиНетРавного = "Больший", ЕслиМногоРавных = "МеньшийИндекс", СортировкаВозрастание = Истина, Вектор = -1) Экспорт
	ЭтоМассив = ТипЗнч(Коллекция) = Тип("Массив");
	Индекс1 = 0;
	Граница = Коллекция.Количество();
	Индекс2 = Граница;
	Результат = 0;
	МеньшийИндекс = ЕслиМногоРавных = "МеньшийИндекс";
	БольшийИндекс = ЕслиМногоРавных = "БольшийИндекс";
	НайденРавный = Ложь;
	Пока Индекс1 < Индекс2 Цикл
		Результат = Индекс1 + ШагПоловинногоДеления(Индекс2 - Индекс1 + 1, Вектор) - 1;
		Показатель = ?(ЭтоМассив, Коллекция[Результат], Коллекция[Результат][ИмяРеквизита]);
		ЭтоРавный = Искомое = Показатель;
		Если ЭтоРавный И ЕслиМногоРавных = "Любой" Тогда
			Прервать;
		ИначеЕсли ЭтоРавный И НайденРавный И НЕ МеньшийИндекс И НЕ БольшийИндекс Тогда
			Результат = ЕслиМногоРавных;
			Прервать;
		ИначеЕсли ЭтоРавный И МеньшийИндекс ИЛИ (Искомое < Показатель) = СортировкаВозрастание Тогда
			Индекс2 = Результат;
		Иначе
			Индекс1 = Результат + 1;
			Результат = Индекс1;
		КонецЕсли;
		НайденРавный = НайденРавный ИЛИ ЭтоРавный;
	КонецЦикла;
	Если НЕ НайденРавный Тогда
		ЭтоМеждуБольший = ЕслиНетРавного = "БлижайшийЕслиМежду_Больший";
		Если ЕслиНетРавного = "Меньший" Тогда
			Результат = Результат - 1;
		ИначеЕсли ЕслиНетРавного = "Больший" Тогда
		ИначеЕсли (ЕслиНетРавного = "БлижайшийЕслиМежду_Меньший") ИЛИ ЭтоМеждуБольший Тогда
			Если Граница < 2 Тогда
				Результат = 0;
			ИначеЕсли Результат > 0 Тогда
				Контрольное = ?(ЭтоМассив,
						Коллекция[Результат] + Коллекция[Результат - 1],
						Коллекция[Результат][ИмяРеквизита] +  Коллекция[Результат - 1][ИмяРеквизита]);
				Если (2 * Искомое > Контрольное) <> СортировкаВозрастание И ((2 * Искомое <> Контрольное) ИЛИ НЕ ЭтоМеждуБольший) Тогда
					Результат = Результат - 1;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Результат = Результат - 1;
		КонецЕсли;
	ИначеЕсли ЕслиМногоРавных = "БольшийИндекс" Тогда
		Результат = Результат - 1;
	КонецЕсли;
	Возврат Результат
КонецФункции // ИндексПоловиннымДелением

// Возвращает код записи в структуру основных параметров
//	ИменаКлючей - Строка - имена переменных, которые будут восстановлены из ключей, через запятую
//	ИмяСтруктуры - Строка - имя структуры, в которую будут добавлены ключи. По умолчанию Прм.
// Возвращаемое значение:
//   Строка   - Исполняемый код
Функция КодВосстановленияПараметровИзСтруктуры(ИменаКлючей, ИмяСтруктуры = "Прм")
	Результат = "";
	мКлючи = СтрРазделить(ИменаКлючей, ",", Ложь);
	Для каждого Ключ Из мКлючи Цикл
		Результат = Результат + Ключ + " = " + ИмяСтруктуры + "." + Ключ + ";" + Символы.ПС;
	КонецЦикла;
	Возврат Результат
КонецФункции // КодДобавленияПараметровВСтруктуру

// Возвращает код записи в структуру основных параметров
// Параметры:
//	ИменаКлючей - Строка - имена переменных, которые станут ключами, через запятую
//	ИмяСтруктуры - Строка - имя структуры, в которую будут добавлены ключи. По умолчанию Прм.
//	СоздатьСтруктуру - Булево - Структура будет предварительно создана
// Возвращаемое значение:
//   Строка   - Исполняемый код
Функция КодДобавленияПараметровВСтруктуру(ИменаКлючей, ИмяСтруктуры = "Прм", СоздатьСтруктуру = Ложь)
	Результат = ?(СоздатьСтруктуру, ИмяСтруктуры + " = Новый Структура;" + Символы.ПС, "");
	мКлючи = СтрРазделить(ИменаКлючей, ",", Ложь);
	Для каждого Ключ Из мКлючи Цикл
		Результат = Результат + ИмяСтруктуры + ".Вставить(""" + Ключ + """, " + Ключ + ");" + Символы.ПС;
	КонецЦикла;
	Возврат Результат
КонецФункции // КодДобавленияПараметровВСтруктуру

//"Клиент", "Сервер", и т.д. Старое название - РежимЗапуска
//Параметры:
//	КлиентИлиСерверВЦелом - Булево - Вернуть просто "Клиент" или "Сервер", не уточняя, какой именно. По умолчанию Ложь. 
//Возвращаемое значение:
//	Строка - Обозначение текущего места выполнения кода
Функция МестоВыполненияКода(КлиентИлиСерверВЦелом = Ложь) Экспорт
	Результат = "Странный";
	Если КлиентИлиСерверВЦелом Тогда
		#Если Клиент Тогда
			Результат = "Клиент";
		#ИначеЕсли Сервер Тогда
			Результат = "Сервер";
		#КонецЕсли
	КонецЕсли;
	Если Результат = "Странный" Тогда
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Результат = "ТолстыйКлиентОбычноеПриложение";
		#ИначеЕсли МобильноеПриложениеКлиент Тогда
			Результат = "МобильноеПриложениеКлиент";
		#ИначеЕсли МобильноеПриложениеСервер Тогда
			Результат = "МобильноеПриложениеСервер";
		#ИначеЕсли ТолстыйКлиентУправляемоеПриложение Тогда
			Результат = "ТолстыйКлиентУправляемоеПриложение";
		#ИначеЕсли Сервер Тогда
			Результат = "Сервер";
		#ИначеЕсли ВнешнееСоединение Тогда
			Результат = "ВнешнееСоединение";
		#ИначеЕсли ТонкийКлиент Тогда
			Результат = "ТонкийКлиент";
		#ИначеЕсли ВебКлиент Тогда
			Результат = "ВебКлиент";
		#КонецЕсли
	КонецЕсли;
	Возврат Результат
КонецФункции // МестоВыполненияКода()

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  МассивКоэффициентов - Массив - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Коэффициенты, Знач Точность = 2) Экспорт
	Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаКоэффициентов  = 0;
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Коэффициент = Коэффициенты[Индекс];
		АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Новый Массив(Коэффициенты.Количество());
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	// Погрешности округления отнесем на коэффициент с максимальным весом.
	Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
		Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Возвращает Истина, Если Значнние1 = Значение2 
//Параметры:
//	Значение1 - Произвольное сериализуемое - для сравнения
//	Значение2 - Произвольное сериализуемое - для сравнения
//	Возвращаемое значение:
//		Булево - равны ли параметры
Функция УниверсальныеЗначенияСовпадают(Значение1, Значение2) Экспорт
	Если Значение1 = Неопределено Или Значение2 = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Значение1 = Значение2
		Или ЗначениеВСтрокуXML(Значение1) = ЗначениеВСтрокуXML(Значение2);
КонецФункции

// Возвращает шаг половинного деления по длине отрезка. Предполагается, что ожидаемое значение в интервале задано нормальным распределением с пиком примерно в трети от одного из концов отрезка
// Параметры:
// ДлинаОтрезкаМасштабов   - Число - Длина отрезка
// Вектор   - Число - -1 или 1 или 0 (по умолчанию). 1 показывает, что пик распределения ближе к концу отрезка, -1 - что к началу, 0 - Строго пополам
// Возвращаемое значение:
//   Число   - Длина шага половинного деления (куда сделать ход). Например, для 7 возвратит 4.
Функция ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор) Экспорт
	Возврат ?(Вектор = 0, Цел((ДлинаОтрезкаМасштабов + 1)/ 2), (1 + Вектор) * (ДлинаОтрезкаМасштабов + 1) / 2 - Вектор * Pow(2, Цел(Log(ДлинаОтрезкаМасштабов + 1) / Log(2))) / 2)
КонецФункции // ШагПоловинногоДеления
 
#КонецОбласти

#Область БИБЛИОТЕКА_ФУНКЦИЙ_ПОВТ_ИСП

#Область ТИПЫ

//Возвращает описание типов "любая ссылка"
//Возвращаемое значение:
//	Описание типов - Описание типов, содержащее все ссылочные типы
Функция ВсеСсылочныеТипы() Экспорт
	Результат = Новый ОписаниеТипов(Документы.ТипВсеСсылки(), Перечисления.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, Справочники.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыВидовРасчета.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыОбмена.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыСчетов.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы());
	Возврат Новый ОписаниеТипов(Результат, Задачи.ТипВсеСсылки().Типы());
КонецФункции // ВсеСсылочныеТипы()

//!!!Похоже, не работает, т.к. ругается на первый параметр (Тип):Несоответствие типов (параметр номер '1') (Неверный тип параметра. Допустимы только примитивные типы, ссылки, Структура)
//Функция продублирована в ВОЛНА_ОбщегоНазначенияВС, но это по возможности надо исправить
//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//	Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//	Полностью - Булево или Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//		* ИмяТаблицы - Строка - Имя таблицы для запроса;
//		* Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//		* Метаданные - Объект метаданных - соответствующий объекту
//		* Менеджер - Менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//		Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//		Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение -  структура или строка -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
Функция ИмяТаблицыПоТипу(Тип_, Полностью = Ложь) Экспорт
	МетаХ = Метаданные.НайтиПоТипу(Тип_);
	Если МетаХ = Неопределено Тогда
		Результат = Неопределено
	ИначеЕсли Полностью = "Метаданные" Тогда
		Результат = МетаХ;
	Иначе
		ТекИмя = МетаХ.Имя;
		Полная = Новый Структура;
		НуженМенеджер = (СтрНайти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
		Если Метаданные.Документы.Содержит(МетаХ) Тогда
			СтрокаТипа = "Документ";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Документы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
			СтрокаТипа = "Справочник";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Справочники[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Перечисления.Содержит(МетаХ) Тогда
			СтрокаТипа = "Перечисление";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Перечисления[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовХарактеристик";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланСчетов";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовРасчета";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
			СтрокаТипа = "БизнесПроцесс";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
			СтрокаТипа = "Задача";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Задачи[ТекИмя]);
			КонецЕсли; 
		Иначе
			Результат = "";
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, СтрНайти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
			Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Текст,") > 0) Тогда
			Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
			Полная.Вставить("Метаданные", МетаХ);
		КонецЕсли;
		Результат = Полная;
		Если Результат.Количество() = 1 Тогда
			Для каждого КиЗ Из Полная Цикл
				Результат = КиЗ.Значение;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

#КонецОбласти

#Область ДЕРЕВО_МД
	
//Заполняет дерево метаданных по ветви метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ВетвьМД - Объект метаданных - Источник данных для заполнения	
//	Префикс - Строка - Указывается перед пользовательским представлением элемента	
//	СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента	для кода или запроса.
//	Очищать - Булево - Очистить дерево перед заполненияем
//	ЗаполнятьВетви - Булево - При Истина заполняет на всю глубину, при Ложь - без вложенных ветвей (намного быстрее, по умолчанию).	
Процедура ЗаполнитьДеревоМД(ВетвьДерева, ВетвьМД = Неопределено, Префикс = "", СброситьПрефикс = Ложь, Очищать = Ложь, ЗаполнятьВетви = Ложь) Экспорт
	ЭтоДуб = ТипЗнч(ВетвьДерева) = Тип("ДеревоЗначений");
	Если ЭтоДуб Тогда
		Если ВетвьДерева.Колонки.Найти("Представление") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("Представление");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("ТекстДляКода") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("ТекстДляКода");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("ТекстДляЗапроса") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("ТекстДляЗапроса");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("МД") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("МД",,, 0);
		КонецЕсли;
	КонецЕсли;
	Если Очищать Тогда
		ВетвьДерева.Строки.Очистить()
	КонецЕсли;
	Продолжать = (ВетвьДерева.Строки.Количество() = 0) ИЛИ НЕ ЭтоДуб;
	Если Продолжать Тогда
		Если ВетвьМД = Неопределено Тогда
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Справочники";
			НоваяСтрокаДерева.ТекстДляКода = "Справочники";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Справочник";
			НоваяСтрокаДерева.МД = Метаданные.Справочники;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Справочники);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Документы";
			НоваяСтрокаДерева.ТекстДляКода = "Документы";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Документ";
			НоваяСтрокаДерева.МД = Метаданные.Документы;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Документы);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Перечисления";
			НоваяСтрокаДерева.ТекстДляКода = "Перечисления";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Перечисление";
			НоваяСтрокаДерева.МД = Метаданные.Перечисления;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Перечисления);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы счетов";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыСчетов";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланСчетов";
			НоваяСтрокаДерева.МД = Метаданные.ПланыСчетов;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыСчетов);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы видов расчетов";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовРасчетов";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовРасчетов";
			НоваяСтрокаДерева.МД = Метаданные.ПланыВидовРасчета;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовРасчета);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы обмена";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыОбмена";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланОбмена";
			НоваяСтрокаДерева.МД = Метаданные.ПланыОбмена;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыОбмена);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы видов характеристик";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовХарактеристик";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовХарактеристик";
			НоваяСтрокаДерева.МД = Метаданные.ПланыВидовХарактеристик;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовХарактеристик);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры накопления";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыНакопления";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрНакопления";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыНакопления;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыНакопления);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры бухгалтерии";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыБухгалтерии";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрБухгалтерии";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыБухгалтерии;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыБухгалтерии);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры расчёта";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыРасчета";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрРасчета";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыРасчета;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыРасчета);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры сведений";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыСведений";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрСведений";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыСведений;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыСведений);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Бизнес-процессы";
			НоваяСтрокаДерева.ТекстДляКода = "БизнесПроцессы";
			НоваяСтрокаДерева.ТекстДляЗапроса = "БизнесПроцесс";
			НоваяСтрокаДерева.МД = Метаданные.БизнесПроцессы;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.БизнесПроцессы);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Задачи";
			НоваяСтрокаДерева.ТекстДляКода = "Задачи";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Задачи";
			НоваяСтрокаДерева.МД = Метаданные.Задачи;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Задачи);
			КонецЕсли; 
		Иначе
			Если ТипЗнч(ВетвьМД) <> Тип("КоллекцияОбъектовМетаданных") Тогда //ВетвьДерева.СПопыткой Тогда
				ПродолжитьЗаполнениеМД(ВетвьДерева, ВетвьМД);
			Иначе
				Для Каждого ОбъектМД Из ВетвьМД Цикл
					Если ВетвьДерева.Строки.Найти(ОбъектМД, "МД") = Неопределено Тогда
						НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
						НоваяСтрокаДерева.Представление = ОбъектМД.Синоним;
						Если ПустаяСтрока(НоваяСтрокаДерева.Представление) Тогда
							НоваяСтрокаДерева.Представление = ОбъектМД.Имя
						КонецЕсли;
						НоваяСтрокаДерева.Представление = "" + Префикс + НоваяСтрокаДерева.Представление;
						НоваяСтрокаДерева.ТекстДляКода = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляКода + ".") + ОбъектМД.Имя;
						НоваяСтрокаДерева.ТекстДляЗапроса = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляЗапроса + "." + ОбъектМД.Имя);
						НоваяСтрокаДерева.МД = ОбъектМД;
						//НоваяСтрокаДерева.СПопыткой = Истина;
						Если ЗаполнятьВетви Тогда
							ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры //ЗаполнитьМД

//Вспомогательная для следующей процедуры. Заполняет ветвь дерева значений по реквизиту объекта метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ОбъектМД - Объект метаданных - Источник данных для заполнения	
//	ИмяМД - Строка - Имя реквизита объекта метаданных, по которому надо заполнить ветвь	
//	Префикс - Строка - Указывается перед пользовательским представлением элемента	
//	СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента	для кода или запроса.
Процедура ВызватьЗаполнениеСПопыткой(ВетвьДерева, ОбъектМД, ИмяМД, Префикс = "", СброситьПрефикс = Ложь)
	Попытка
		Коллекция = ОбъектМД[ИмяМД];
	Исключение
		Коллекция = Неопределено
	КонецПопытки;
	Если Коллекция <> Неопределено Тогда
		ЗаполнитьДеревоМД(ВетвьДерева, Коллекция, Префикс, СброситьПрефикс,, Истина)
	КонецЕсли;
КонецПроцедуры
				
//Вспомогательная для предыдущей экспортной процедуры. Заполняет строку дерева по объекту метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ОбъектМД - Объект метаданных - Источник данных для заполнения	
Процедура ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД)
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Реквизиты");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "СтандартныеРеквизиты");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ТабличныеЧасти", "#");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Формы", "^", Истина);
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Макеты", "$", Истина);
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ЗначенияПеречисления");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Команды", ">", Истина);
	НоваяСтрокаДерева.Строки.Сортировать("Представление", Ложь, Новый СравнениеЗначений)
КонецПроцедуры //ПродолжитьЗаполнениеМД

#КонецОбласти 

#Область ЭТА_КОНФИГУРАЦИЯ
	
//Возвращает структуру с ключами ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО - есть ли 
// 	регистр ВОЛНА_ДопКонстанты и справочники ДополнительныеОбработки, ВОЛНА_ПереопределяемыеПроцедуры и ВнешниеОтчеты.
//Возвращаемое значение:
//	Структура - ключи ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО, отражающие наличие объектов внешних обработок и значений разного типа.
Функция ЕстьДопОбработки() Экспорт
	ИмяТипаПП = "ВОЛНА_ПереопределяемыеПроцедуры";
	ИмяТипаВО = "ВнешниеОбработки";
	ИмяТипаДО = "ДополнительныеОтчетыИОбработки";
	ИмяТипаДК = "ВОЛНА_ДопКонстанты";
	Возврат Новый Структура("ЕстьДК,ЕстьДО,ЕстьПП,ЕстьВО,ИмяТипаДК,ИмяТипаДО,ИмяТипаПП,ИмяТипаВО",
			Метаданные.РегистрыСведений.Найти(ИмяТипаДК) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаДО) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаПП) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаВО) <> Неопределено,
			ИмяТипаДК,
			ИмяТипаДО,
			ИмяТипаПП,
			ИмяТипаВО)
КонецФункции // ЕстьДопОбработки()

// РежимыСовместимости
// Возвращаемое значение:
//   Структура   - Ключи Режим (значение - текущий режим) и Р835 (булево, Истина - мы в допотопном 835, до поддержки строковых функций.)
Функция РежимСовместимости() Экспорт
	МетаК = Метаданные;
	Режим = МетаК.РежимСовместимости;
	МетаРС = Метаданные.СвойстваОбъектов.РежимСовместимости;
	Результат = Новый Структура("Режим,Р835", Режим, (Режим = МетаРС.Версия8_1) ИЛИ (Режим = МетаРС.Версия8_2_13) ИЛИ (Режим = МетаРС.Версия8_2_16) ИЛИ (Режим = МетаРС.Версия8_3_1)
			ИЛИ (Режим = МетаРС.Версия8_3_2) ИЛИ (Режим = МетаРС.Версия8_3_3) ИЛИ (Режим = МетаРС.Версия8_3_4) ИЛИ (Режим = МетаРС.Версия8_3_5));
	Возврат Результат
КонецФункции // РежимСовместимости

//Возвращает версию БСП
//Возвращаемое значение:
//	Строка - версия библиотеки стандартных подсистем
Функция ВерсияБСП() Экспорт
	Попытка
		Результат = Вычислить("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
	Исключение
		Результат = "Нет БСП";
	КонецПопытки;
	Возврат Результат
КонецФункции // ВерсияБСП()

//Возвращает информацию о наличии подсистемы
//Параметры:
//	ИмяПодсистемы - Строка - Имя искомой подсистемы
//Возвращаемое значение:
//	Булево - Подсистема есть
Функция ЕстьПодсистема(ИмяПодсистемы) Экспорт
	Возврат Подсистемы(Истина).Найти(ИмяПодсистемы) <> Неопределено
КонецФункции

// Возвращает линейный список подсистем
// Параметры:
//   Строки - Булево - Ложь = элементами являются метаданные (по умолчанию), а не строки
// Возвращаемое значение:
//      - Массив подистем или их имён.
Функция Подсистемы(Строки = Ложь, Родительская = Неопределено) Экспорт
	Если Родительская = Неопределено Тогда
		Родительская = Метаданные;
	КонецЕсли;
	Результат = Новый Массив;
	Для каждого ТекПодсистема Из Родительская.Подсистемы Цикл
		Результат.Добавить(?(Строки, ТекПодсистема.Имя, ТекПодсистема));
		Результат = ВОЛНА_ОбщегоНазначенияКС.СложитьМассивы(Результат, Подсистемы(Строки, ТекПодсистема));
	КонецЦикла;
	Возврат Результат
КонецФункции // Подсистемы

//Возвращает список картинок библиотеки (из макета, иначе не знаю, как получить) - префикс #Б:
//и из общих картинок - префикс #О:. Результат помещается в список значений, где представление - имя картинки,
//значение - имя картинки с префиксом, а картинка - сама картинка.
//Параметры:
//	СписокКартинокБиблиотеки - Строка - Список картинок библиотеки картинок с разделителем ПС. Способа прочитать этот список программно не нашёл, приходится передавать параметром.
//			Если не задан (пустая строка), производится попытка чтения из макета "КартинкиБиблиотеки"
//	ВставлятьКартинки - Булево - Вставлять в список сами картинки.
//Возвращаемое значение:
//	Список значений - список картинок из параметра и из общих картинок.
Функция ПолучитьСписокСтандартныхКартинок(СписокКартинокБиблиотеки = "", ВставлятьКартинки = Истина) Экспорт
	Результат = Новый СписокЗначений;
	Если СписокКартинокБиблиотеки = "" Тогда
		Попытка
			СписокКартинокБиблиотеки = Вычислить("ПолучитьМакет(""КартинкиБиблиотеки"").ПолучитьТекст()");
		Исключение
		КонецПопытки;
	КонецЕсли; 
	Для Ё = 1 По СтрЧислоСтрок(СписокКартинокБиблиотеки) Цикл
		ИмяК = СтрПолучитьСтроку(СписокКартинокБиблиотеки, Ё);
		Попытка
			ТКартинка = БиблиотекаКартинок[ИмяК];
			Результат.Добавить("#Б:" + ИмяК, ИмяК, Ложь, ?(ВставлятьКартинки, ТКартинка, ""));
		Исключение
		КонецПопытки;
	КонецЦикла; 
	Для каждого ТКартинка Из Метаданные.ОбщиеКартинки Цикл
		Результат.Добавить("#О:" + ТКартинка.Имя, ТКартинка.Синоним, Ложь, ?(ВставлятьКартинки, БиблиотекаКартинок[ТКартинка.Имя], ""));
	КонецЦикла; 
	Возврат Результат
КонецФункции // ПолучитьСписокСтандартныхКартинок()
 
#КонецОбласти

#КонецОбласти

#Область БИБЛИОТЕКА_ФУНКЦИЙ_СЕРВЕР
	
#Область ОТЛАДКА

//Читает набор записей и возвращает таблицу значений - его содержимое.
//Иногда может быть пригодна для чтения движений, уже записанных в базу.
//Параметры:
//	НаборЗаписей - Набор записей регистра - читаемый набор записей.
//Возвращаемое значение - Таблица значений - Куда выгружен прочитанный НЗ.
Функция ПрочитатьНаборЗаписейДляОтладки(НаборЗаписей, ВернутьКакБыло = Истина) Экспорт
	Попытка
		Если ВернутьКакБыло Тогда
			ВремТЗ = НаборЗаписей.Выгрузить();
			НаборЗаписей.Прочитать();
			Результат = НаборЗаписей.Выгрузить();
			НаборЗаписей.Загрузить(ВремТЗ);
		Иначе
			НаборЗаписей.Прочитать();
			Результат = НаборЗаписей.Выгрузить();
		КонецЕсли; 
	Исключение
		Результат = Ложь;
	КонецПопытки;	
	Возврат Результат
КонецФункции

#Конецобласти

#Область ЗАПИСЬ
	
// Записывает комплект в транзакции с попытками проведения и записи в разных режимах. Возвращает информацию по каждому объекту. Если хотя бы один не удалось записать никак - происходит откат транзакции.
// Параметры:
//  СооРежимыЗаписи  - Соответствие - Ключ = объект, значение = режим записи (Структура с ключами "Проведение", "Запись" и "ОДЗ" и булевыми значениями).
// Возвращаемое значение:
//   Соответствие   - Ключ = объект, значение = результат записи (см.ЗаписатьОбъект() + при Записан = Истина возможны
//			КакЗаписался = "НеМодифицирован" => запись не потребовалась + КакЗаписался = "ВнеРежима" => не был задан режим записи).
//			Может не содержать входящих объектов, если произошла ошибка и попытки записи были прекращены.			
Функция ЗаписатьКомплектВТранзакции(СооРежимыЗаписи) Экспорт
	Результат = Новый Соответствие;
	НачатьТранзакцию();
	Неудача = Ложь;
	Для каждого КиЗ Из СооРежимыЗаписи Цикл
		Если КиЗ.Ключ.Модифицированность() Тогда
			ТекУровень = ?(КиЗ.Значение.Проведение, "Проведение", ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить")));
			ТекстОшибки = "";
			Для СчПоп = 1 По 4 Цикл
				#Область ФОРМИРОВАНИЕ_ВЫЗОВА
					Если ТекУровень = "Проведение" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(КиЗ.Значение.Запись, ?(Киз.Значение.ОДЗ, "Все", Ложь), ?(Киз.Значение.ОДЗ, Истина, "НЕТ")),, Истина,, Ложь);
					ИначеЕсли ТекУровень = "Запись" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(Киз.Значение.ОДЗ, "Все", Ложь),,,, Ложь);
					ИначеЕсли ТекУровень = "ОДЗ" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, Истина,,,, Ложь);
					Иначе
						Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "Не задан режим записи", "ВнеРежима", ""));
						Прервать;
					КонецЕсли;
				#КонецОбласти
				Если ТекРез.Записан Тогда
					ТекРез.Вставить("ТекстОшибки", ТекстОшибки + Символы.ПС + Текрез.ТекстОшибки);
					Результат.Вставить(КиЗ.Ключ, ТекРез);
					Прервать;
				Иначе
					ТекстОшибки = ТекстОшибки + Символы.ПС + ТекРез.ТекстОшибки;
					ОтменитьТранзакцию();
					Если ТекРез.Стадия = "Проведение" Тогда
						ТекУровень = ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить"));
					ИначеЕсли ТекРез.Стадия = "Запись" Тогда
						ТекУровень = ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить");
					Иначе
						Неудача = Истина;
						Прервать;
					КонецЕсли;
					Если ТекУровень = "Прекратить" Тогда
						Неудача = Истина;
						Прервать;
					КонецЕсли;
					НачатьТранзакцию();
					Для каждого Проведённый Из Результат Цикл
						Если Проведённый.Значение.КакЗаписался <> "НеМодифицирован" И Проведённый.Значение.КакЗаписался <> "ВнеРежима" Тогда
							ЗаписатьОбъект(Проведённый.Ключ,
									Проведённый.Значение.КакЗаписался = "Записан в режиме загрузки",,
									Проведённый.Значение.КакЗаписался = "Проведён");
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "", "НеМодифицирован", ""));
		КонецЕсли;
		Если Неудача Тогда
			Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Ложь, ТекстОшибки, "ОШИБКА", ТекРез.Стадия));
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НЕ Неудача Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
	Возврат Результат
КонецФункции // ЗаписатьКомплектВТранзакции

//Запись объекта в базу в разных режимах
//Параметры:
//	Объект_				- Ссылка				- Что записывать
//	РежимЗагрузки		- Булево/Строка			- Режим "Обмен данными - Загрузка" загрузки при записи.
//			*"Не менять" (по умолчанию) - оставить как есть,
//			*"Все" - попробовать без "загрузки", если не получится - то с "загрузкой".
//			*Булево - установить указанный режим
//			Другие значения приведут к отказу от записи (кроме режима проведения).
//			При попытке проведения "Загрузка" всегда сбрасывается, на выходе из функции - восстанавливается как был.
//	ОтключитьМеханизмРегистрацииОбъектов - Булево/Неопределено - Отключить программную регистрацию на типовых планах обмена. Неопределено - не менять режим отключения.
//	ПопытатьсяПровести	- Булево	- Попытаться провести объект. По умолчанию ЛОЖЬ.
//	ПроверитьЧтоДок		- Булево	- Перед попыткой проведения проверить, документ ли это.
//  Сообщать			- Булево/Неопределено - Выдавать сообщения. Неопределено (по умолчанию) - сообщать только об ошибках.
//  Блокировать			- Булево - Использовать для записи управляемые блокировки. По умолчанию Ложь.
//Возвращаемое значение	- Структура с ключами:
//		* Записан		- Булево, удалось ли записать объект.
//		* ТекстОшибки	- Текст ошибки при записи. "", если ошибки нет.
//		* КакЗаписался	- Строка - "Не записан", "Проведён", "Записан штатно" или "Записан в режиме загрузки".
//		* Стадия		- Строка - "Блокировка", "Проведение", "Запись", "ОДЗ" или "" = стадия последней ошибочной попытки.
Функция ЗаписатьОбъект(
		Объект_,
		РежимЗагрузки = "Не менять",
		ОтключитьМеханизмРегистрацииОбъектов = Неопределено,
		ПопытатьсяПровести = Ложь,
		ПроверитьЧтоДок = Ложь,
		Сообщать = Неопределено,
		Блокировать = Ложь,
		ТолькоМодифицированный = Истина) Экспорт
	НеЗаписан = Истина;
	ПолноеСообщение = "";
	КакЗаписался = "Не записан";
	Стадия = "";
	Если ТолькоМодифицированный И НЕ Объект_.Модифицированность() Тогда
		КакЗаписался = "НеМодифицирован";
		НеЗаписан = Ложь;
	Иначе
		ТекОДЗ = Объект_.ОбменДанными.Загрузка;
		Если ОтключитьМеханизмРегистрацииОбъектов = Неопределено Тогда
		ИначеЕсли ОтключитьМеханизмРегистрацииОбъектов Тогда
			Объект_.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
		ИначеЕсли Объект_.ДополнительныеСвойства.Свойство("ОтключитьМеханизмРегистрацииОбъектов") Тогда
			Объект_.ДополнительныеСвойства.Удалить("ОтключитьМеханизмРегистрацииОбъектов");
		КонецЕсли; 
		Проводить = ?(ПопытатьсяПровести, ?(ПроверитьЧтоДок, Метаданные.Документы.Найти(Объект_.Метаданные()), Истина), Ложь);
		ВыводитьОшибки = ?(Сообщать = Неопределено, Истина, Сообщать);
		ВыводитьВсё = ?(Сообщать = Неопределено, Ложь, Сообщать);
		ВнешняяТранзакция = ТранзакцияАктивна();
		Отказ = Ложь;
		#Область БЛОКИРОВКА
			Если Блокировать Тогда
				НачатьТранзакцию();
				Попытка
					Блокировка = Новый БлокировкаДанных;
					ЭлементБлокировки = Блокировка.Добавить(Объект_.Метаданные().ПолноеИмя());
					ЭлементБлокировки.УстановитьЗначение("Ссылка", Объект_);
					Блокировка.Заблокировать();
					ВладелецСвойствОбъект = Объект_.ПолучитьОбъект();
					ЗаблокироватьДанныеДляРедактирования(ВладелецСвойствОбъект.Ссылка);
				Исключение
					Отказ = Истина;
					ООШ = ОписаниеОшибки();
					Стадия = "Блокировка";
					ПолноеСообщение = ПолноеСообщение + "ОШИБКА_БЛОКИРОВКИ:" + ООШ + Символы.ПС;
					Если ВыводитьОшибки Тогда
						Сообщить("Не удалось заблокировать " + Объект_ + " по причине: " + ООШ);
					КонецЕсли;
				КонецПопытки;
			КонецЕсли;
		#КонецОбласти
		//Попытка проведения
		Если Проводить И НЕ Отказ Тогда
			Попытка
				Объект_.ОбменДанными.Загрузка = Ложь;
				Объект_.Записать(РежимЗаписиДокумента.Проведение);
				Если ВыводитьВсё Тогда
					Сообщить("Проведён " + Объект_);
				КонецЕсли;
				НеЗаписан = Ложь;
				КакЗаписался = "Проведён";
			Исключение
				ООШ = ОписаниеОшибки();
				Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
				Стадия = "Проведение";
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОВЕДЕНИЯ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ проведён " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Попытка обычной записи
		Если НеЗаписан И НЕ Отказ
				И (РежимЗагрузки = Ложь
					ИЛИ РежимЗагрузки = "Все"
					ИЛИ РежимЗагрузки = "Не менять" И НЕ ТекОДЗ) Тогда
			Объект_.ОбменДанными.Загрузка = Ложь;
			Попытка
				Объект_.Записать();
				НеЗаписан = Ложь;
				Если ВыводитьВсё Тогда
					Сообщить("Записан в штатном режиме " + Объект_);
				КонецЕсли;
				КакЗаписался = "Записан штатно";
			Исключение
				ООШ = ОписаниеОшибки();
				Стадия = "Запись";
				Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОСТОЙ_ЗАПИСИ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ записан " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Попытка записи в режиме обмена данными
		Если НеЗаписан И НЕ Отказ
				И (РежимЗагрузки = Истина
					ИЛИ РежимЗагрузки = "Все"
					ИЛИ РежимЗагрузки = "Не менять" И ТекОДЗ) Тогда
			Объект_.ОбменДанными.Загрузка = Истина;
			Попытка
				Объект_.Записать();
				НеЗаписан = Ложь;
				Если ВыводитьВсё Тогда
					Сообщить("Записан в режиме загрузки " + Объект_);
				КонецЕсли;
				КакЗаписался = "Записан в режиме загрузки";
			Исключение
				ООШ = ОписаниеОшибки();
				Стадия = "ОДЗ";
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ЗАПИСИ_ЗАГРУЗКОЙ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ записан в режиме загрузки " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Завершение транзакции
		Если Блокировать Тогда
			Если НеЗаписан Тогда
				ОтменитьТранзакцию();
			Иначе
				ЗафиксироватьТранзакцию();
			КонецЕсли;
		КонецЕсли;
		Объект_.ОбменДанными.Загрузка = ТекОДЗ;
	КонецЕсли;
	Возврат Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", НЕ НеЗаписан, ПолноеСообщение, КакЗаписался, Стадия)
КонецФункции

#КонецОбласти

#Область ЗАПРОСЫ

//Тексты запросов см. КлиентСервер

// Заполняет незаданные параметры запроса заданными значениями
// Параметры:
//  Запрос_  - Запрос - с установленным текстом, в котором будут проверяться и устанавливаться параметры
//  Значения  - Любое значение - значение, по которому будут задаваться параметры.
//		*Структура - Имя параметра с ключом будет заполнено значением (только для незаполненных). Ненайденные будут заполнены значением по умолчанию (из ключа "ОСТАЛЬНЫЕ" или общего)
//		*Любое другое значение - будет непосредственно помещено во все незаполненные параметры
//		*Строка "#№#№#" (по умолчанию) - во все параметры будет помещён пустой массив
Процедура ЗаполнитьНезаполненныеПараметрыЗапроса(Запрос_, Значения = "#№#№#") Экспорт
	ПоУмолчанию = Новый Массив;
	Если Значения = "#№#№#" Тогда
		Значения = ПоУмолчанию;
		ТипСтр = Ложь;
	Иначе
		ТипЗн = ТипЗнч(Значения);
		ТипСтр = (ТипЗн = Тип("Структура")) ИЛИ (ТипЗн = Тип("ФиксированнаяСтруктура"));
	КонецЕсли;
	ПараметрыТекущегоЗапроса = Запрос_.НайтиПараметры();
	Для каждого ПараметрЗапроса Из ПараметрыТекущегоЗапроса Цикл
		ИмяПараметра =  ПараметрЗапроса.Имя;
		Если НЕ Запрос_.Параметры.Свойство(ИмяПараметра) Тогда
			Запрос_.УстановитьПараметр(ИмяПараметра, ?(ТипСтр, ?(Значения.Свойство(ИмяПараметра), Значения[ИмяПараметра], ?(Значения.Свойство("ОСТАЛЬНЫЕ"), Значения.ОСТАЛЬНЫЕ, ПоУмолчанию)), Значения));
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры // ЗаполнитьНезаполненныеПараметрыЗапроса

// Выполняет запрос, пока не будет соблюдено условие равенства нулю итога по заданной колонке.
// Параметры:
//  Запрос_  - Запрос - Запрос, повторяемый в цикле и готовый к выполнению.
//			Если ТабПараметр - строка, то в запросе д.б. задан МВТ.
//				В этом случае для ускорения  рекомендуется для контроля завершения использовать маленькую таблицу из одной строки, где итоги уже посчитаны запросом,
//				и указать её имя в следующем параметре. В запрос не имеет смысла помещать выборку данных - она не используется внутри функции.
//			Если ТабПараметр - таблица значений, МВТ не нужен, запрос должен содержать выборку данных, выгружающую контрольную таблицу.
//  ТабПараметр  - Строка/Таблица значений - Имя ВТ, выгружаемой для контроля завершения/Таблица, помещаемая в параметр (по ней же производится контроль завершения).
//  ИмяКонтрольнойКолонки  - Строка - Имя контрольной колонки. По умолчанию "НеГотово".  Цикл завершится, когда итог по колонке станет нулевым. 
//  ИмяПараметра  - Строка - Имя параметра, куда помещается таблица. По умолчанию "ТабПараметр". Не используется при работе с временной таблицей.
//  ОграничениеПовтора  - Число - Ограничение проходов цикла во избежание зацикливания. По умолчанию 100.
//Возвращаемое значение
//	Таблица значений	- выгрузка результата запроса/контрольная таблица. Контрольная колонка не удаляется для контроля оверцикла.
Функция ЗапросВЦикле(Запрос_, ТабПараметр = "ТабРезультат", ИмяКонтрольнойКолонки = "НеГотово", ИмяПараметра = "ТабПараметр", ОграничениеПовтора = 100) Экспорт
	ПройденоПовторов = 0;
	ЧерезВТ = ТипЗнч(ТабПараметр) = Тип("Строка");
	ТабКонтроль = ТабПараметр;
	Контроль = ?(ЧерезВТ, 1, ТабКонтроль.Итог(ИмяКонтрольнойКолонки));
	Пока (Контроль <> 0) И (ПройденоПовторов < ОграничениеПовтора) Цикл
		ПройденоПовторов = ПройденоПовторов + 1;
		Если ЧерезВТ Тогда
			Запрос_.Выполнить();
			ТабКонтроль = Запрос_.МенеджерВременныхТаблиц.Таблицы[ТабПараметр].ПолучитьДанные().Выгрузить();
		Иначе
			Запрос_.УстановитьПараметр(ИмяПараметра, ТабКонтроль);
			ТабКонтроль = Запрос_.Выполнить().Выгрузить();
		КонецЕсли;
		Контроль = ТабКонтроль.Итог(ИмяКонтрольнойКолонки);
	КонецЦикла;
	Возврат ТабКонтроль
КонецФункции // ЗапросВЦикле
 
//Выполняет запрос и возвращает значение из первой его ячейки
//Параметры:
//	Запрос_ - Запрос - Готовый к выполнению запрос
//	ЕслиНеНайдено - Произвольный - Значение, возвращаемое, если запрос вернул пустой результат
//Возвращаемое значение:
//	Произвольный - значение из первой ячейки запроса
Функция ПолучитьЕдинственноеЗначениеЗапроса(Запрос_, ЕслиНеНайдено = Неопределено) Экспорт
	ТабХ = Запрос_.Выполнить().Выгрузить();
	Возврат ?(ТабХ.Количество() = 0, ЕслиНеНайдено, ТабХ[0][0])
КонецФункции

//Создаёт запрос с заданным текстом. Удобно для применения в длинных выражениях с точками, где Новый не прокатит
//Параметры:
//	ТекстЗапроса - строка - текст запроса
//	Параметры - структура - параметры запроса (необязательный)
//	МВТ - менеджер временных таблиц - для установки в запрос (необязательный)
//Возвращаемое значение:
//	Запрос - сформированный запрос.
Функция СоздатьЗапрос(ТекстЗапроса_, Параметры = Неопределено, МВТ = Неопределено) Экспорт
	Результат = Новый Запрос(ТекстЗапроса_);
	Если НЕ (Параметры = Неопределено) Тогда
		Для Каждого КиЗ из Параметры Цикл
			Результат.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение)
		КонецЦикла
	КонецЕсли;
	Если НЕ (МВТ = Неопределено) Тогда
		Результат.МенеджерВременныхТаблиц = МВТ
	КонецЕсли;
	Возврат Результат
КонецФункции

// Возвращает по тексту запроса и параметрам запрос или готовый результат
// Параметры:
//  ТекстЗапроса_  - Строка/Запрос - Текст запроса или запрос
//	ОписаниеРезультата - Строка -
//		*Выборка - Выполнить запрос и вернуть выборку
//		*Выгрузка (по умолчанию) - Выполнить запрос и вернуть выгрузку
//		*Выполненный - Выполнить запрос и вернуть его
//		*Запрос - Создать запрос и вернуть без выполнения
//		*Значение - Вернуть первое значение из результата. При отсутствии - NULL.
//		*Массив - Вернуть выгрузку первой колонки
//		*Пакет - Вернуть результат выполнения пакета
//		*Результат - Вернуть результат запроса
//		*СПромежуточными - Вернуть ВыполнитьПакетСПромежуточнымиДанными.
//	Параметры - Структура - Параметры в запрос. Необязательный.
//	МВТ - Менеджер ВТ - для вставки в запрос. По умолчанию Неопределено = Без ВТ
//	ЗагрузитьВТ - Строка - описывает дополнительную загрузку ВТ. ИМена создаваемых ВТ и параметров, из которых ВТ загружаются, будут совпадать.
//		*Загрузить - Создать тексты и фактически загрузить в запрос все таблицы значений из параметров. Текст запроса не менять.
//		*Ничего (по умолчанию) - Не менять текст запроса и не загружать ВТ. Если в тексте запроса уже есть загрузки, они будут выполнены при выпонении запроса в общем порядке.
//		*ТекстВЗапрос - Добавить в начало запроса загрузку ВТ
// Возвращаемое значение:
//   Произвольный - возможные типы:
//		*Запрос - сконструированный запрос
//		*Результат запроса - результат запроса после его выполнения
//		*Выборка из результата запроса - выборка из результата запроса после его выполнения
//		*Таблица значений - выгрузка из результата запроса после его выполнения
//		*Дерево значений - выгрузка из результата запроса после его выполнения
//		*Массив - выгрузка колонки таблицы значений, полученной из результата запроса после его выполнения, либо результат выполнения пакета
//		*Строка - описание ошибки
//		*Прочие значения - как единственное значение, полученное в результате запроса (NULL при пустом результате).
Функция РезультатЗапроса(ТекстЗапроса_, ОписаниеРезультата = "Выгрузка", Параметры = Неопределено, МВТ = Неопределено, ЗагрузитьВТ = "Ничего") Экспорт
	Результат = NULL;
	Попытка
		СформироватьТекстыЗагрузчиков = (ЗагрузитьВТ = "Загрузить") ИЛИ (ЗагрузитьВТ = "ТекстВЗапрос");
		Если ТипЗнч(Параметры) = Тип("Структура") Тогда
			стрПараметров = Параметры;
		Иначе
			стрПараметров = Новый Структура;
		КонецЕсли;
		ТипТЗ = Тип("ТаблицаЗначений");
		Запрос_= ?(ТипЗнч(ТекстЗапроса_) = Тип("Запрос"), ТекстЗапроса_, Новый Запрос(ТекстЗапроса_));
		Если МВТ <> Неопределено Тогда
			Запрос_.МенеджерВременныхТаблиц = МВТ;
		КонецЕсли;
		ТекстПредварительногоЗапроса = "";
		Для каждого КиЗ Из стрПараметров Цикл
			Если СформироватьТекстыЗагрузчиков И (ТипЗнч(КиЗ.Значение) = ТипТЗ) Тогда
				ТекстПредварительногоЗапроса = ТекстПредварительногоЗапроса + ТаблицуЗначенийВоВременнуюТаблицуТекст(КиЗ.Значение, КиЗ.Ключ,,, КиЗ.Ключ);
			КонецЕсли;
			Запрос_.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
		КонецЦикла;
		Если ЗагрузитьВТ = "Загрузить" Тогда
			Стек = Запрос_.Текст;
			Запрос_.Текст = ТекстПредварительногоЗапроса;
			Запрос_.Выполнить();
			Запрос_.Текст = Стек;
		ИначеЕсли ЗагрузитьВТ = "ТекстВЗапрос" Тогда
			Запрос_.Текст = ТекстПредварительногоЗапроса + Запрос_.Текст;
		КонецЕсли;
		Если ОписаниеРезультата = "Запрос" Тогда
			Результат = Запрос_;
		Иначе
			Результат = Запрос_.Выполнить();
			Если ОписаниеРезультата = "Выборка" Тогда
				Результат = Результат.Выбрать();
			ИначеЕсли ОписаниеРезультата = "Выполненный" Тогда
				Результат = Запрос_;
			ИначеЕсли ОписаниеРезультата = "Пакет" Тогда
				Результат = Запрос_.ВыполнитьПакет();
			ИначеЕсли ОписаниеРезультата = "Результат" Тогда
			ИначеЕсли ОписаниеРезультата = "СПромежуточными" Тогда
				Результат = Запрос_.ВыполнитьПакетСПромежуточнымиДанными();
			Иначе
				Результат = Результат.Выгрузить();
				Если ОписаниеРезультата = "Значение" Тогда
					Если Результат.Количество() Тогда
						Результат = Результат[0][0];
					Иначе
						Результат = NULL;
					КонецЕсли;
				ИначеЕсли ОписаниеРезультата = "Массив" Тогда
					Результат = Результат.ВыгрузитьКолонку(Результат.Колонки[0].Имя);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Исключение
		ООШ = ОписаниеОшибки();
		Результат = "#ОШИБКА: " + ООШ;
	КонецПопытки;
	Возврат Результат
КонецФункции // РезультатЗапроса

//Помещает таблицу значений во временную таблицу
//	Таблица = таблица значений
//	Менеджер = менеджер временных таблиц. Сюда и попадает таблица.
//	ИмяВТ = строка, имя временной таблицы
//	Выразить = Типизировать в запросе колонки таблицы
Процедура ТаблицуЗначенийВоВременнуюТаблицу(Таблица, Менеджер, ИмяВТ, Выразить = Ложь) Экспорт
	ТекстЗапроса = ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить, Ложь);
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	Запрос.УстановитьПараметр("ТабПараметр", Таблица);
	Запрос.Выполнить()
КонецПроцедуры

//Возвращает текст запроса, размещающего таблицу значений во временную таблицу
//Параметры:
//	Таблица - таблица значений - источник данных.
//	Выразить - Булево - Типизировать в запросе колонки таблицы. По умолчанию Ложь.
//	ИмяВТ - строка - имя временной таблицы, куда будет загружена таблица
//	ВПакете - Булево - добавляет разделитель для вставки в пакет запросов, по умолчанию Истина
//	ИмяПараметра - Строка - Имя параметра, куда будет помещена таблица
//Возвращаемое значение:
//	Строка - Текст запроса, помещающего таблицу значений во временную таблицу.
Функция ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить = Ложь, ВПакете = Истина, ИмяПараметра = "ТабПараметр") Экспорт
	ТекстЗапроса = "";
	Для каждого Колонка из Таблица.Колонки Цикл
		ТекстЗапроса = ТекстЗапроса + "," + Символы.ПС + ?(Выразить, "	ВЫРАЗИТЬ(Таб." + Колонка.Имя + " КАК " +
				ТипДляЗапроса(ВОЛНА_ОбщегоНазначенияКС.ОписаниеТиповКоллекции(Таблица.ВыгрузитьКолонку(Колонка))) + ") КАК ",
				"	Таб.") + Колонка.Имя
	КонецЦикла;
	Возврат "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + Символы.ПС + "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС + "ИЗ" +
			Символы.ПС + "	&ТабПараметр КАК Таб" + ?(ВПакете, ВОЛНА_ОбщегоНазначенияКС.РазделительЗапросов(), "")
КонецФункции

//Возвращает строку - имя типа в виде, подходящем для запроса. Если тип - сложный, возвращается описание первого.
//Параметры:
//	ОписаниеТипа - описание типа,  по которому надо получить полное имя метаданных
//Возвращаемое значение:
//	Строка - Полное имя метаданных, пригодное для запроса
Функция ТипДляЗапроса(ОписаниеТипа) Экспорт
	Если ТипЗнч(ОписаниеТипа) = Тип("ОписаниеТипов") Тогда
		Описание = ОписаниеТипа;
		Тип_ = ОписаниеТипа.Типы()[0];
		Если Тип_ = Тип("Строка") Тогда
			Возврат "СТРОКА(" + ОписаниеТипа.КвалификаторыСтроки.Длина + ")"
		ИначеЕсли Тип_ = Тип("Число") Тогда
			Возврат "ЧИСЛО(" + ОписаниеТипа.КвалификаторыЧисла.Разрядность + ", " + ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти + ")"
		КонецЕсли
	ИначеЕсли ТипЗнч(ОписаниеТипа) = Тип("Тип") Тогда
		МТипов = Новый Массив;
		МТипов.Добавить(ОписаниеТипа);
		Описание = Новый ОписаниеТипов(МТипов)
	Иначе
		Возврат Строка(ОписаниеТипа)
	КонецЕсли;
	Попытка
		Возврат Описание.ПривестиЗначение(0).Метаданные().ПолноеИмя()
	Исключение
		Возврат СокрЛП(ОписаниеТипа)
	КонецПопытки
КонецФункции

#КонецОбласти

#Область КОЛЛЕКЦИИ

#Область ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
	
// Копирует колонку без данных в приёмник. Возвращает имя добавленной или найденной колонки.
// Параметры:
//  Приёмник  - Коллекция колонок дерева значений, таблицы значений - в которую будут добавлены колонки
//  Колонка  - КолонкаДерева значений, таблицы значений - которую надо перенести
//	ИмяКолонкиВПриёмнике - Строка - Имя соответствующей колонки в приёмнике. По умолчанию "" - имена совпадают.
//	Метод	- Число:
//		* 0 или 3 - Не проверять наличие в приёмнике. Если колонка там есть, при добавлении будет ошибка.
//		* 1 - Проверять наличие в приёмнике. Если колонка там есть, считаем, что всё ок.
//		* 2 - Проверять наличие в приёмнике. Если колонка там есть, старая колонка приёмника будет удалена.
//		* 4 - Проверять наличие в приёмнике. Если колонка там есть, колонка будет добавлена под корректным сгенерированным именем.
//	Возвращаемое значение:
//		Строка - имя колонки (найденной или добавленной);
Функция СкопироватьКолонку(Приёмник, Колонка, ИмяКолонкиВПриёмнике = "", Метод = 3) Экспорт
	Результат = ?(ИмяКолонкиВПриёмнике = "", Колонка.Имя, ИмяКолонкиВПриёмнике);
	Если (Метод = 3) ИЛИ (Метод = 0) Тогда
		НадоДобавить = Истина;
	Иначе
		Ё = 0;
		НадоДобавить = Ложь;
		Пока НЕ НадоДобавить Цикл
			СтараяКолонка = Приёмник.Найти(Результат);
			Если СтараяКолонка = Неопределено Тогда
				НадоДобавить = Истина;
			ИначеЕсли Метод = 4 Тогда
				Результат = Колонка.Имя + Ё;
				Ё = Ё + 1;
			ИначеЕсли Метод = 2 Тогда
				Приёмник.Удалить(СтараяКолонка);
			Иначе
				Прервать
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	Если НадоДобавить Тогда
		Приёмник.Добавить(Результат, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
	КонецЕсли;
	Возврат Результат
КонецФункции// ДобавитьНедостающиеКолонки
 
#КонецОбласти 

#Область ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область ОПЕРАЦИИ_С_ДВУМЯ_ТЗ
	
//Добавляет записи из ТабИсточник в конец ТабПриёмник.
//Одноимённые поля скопируются автоматически. Если копируется что-то лишнее, можно подкорректировать структурами или исключением. Поля, не попавшие в структуры и исключения, копируются "один в один".
//Если объединяем несколько таблиц, или проблемы с типами (например, таблицы по результатам запроса), надо использовать ОбъединитьТаблицы
//Параметры:
//	ТабИсточник - ТаблицаЗначений или иная коллекция - поддерживающая Добавить и  обращение к элементу коллекции через []
//	ТабПриёмник - ТаблицаЗначений или иная коллекция - поддерживающая обращение к элементу коллекции через []
//	СтруктураКопируемыхКолонок - структура - описывающая копирование (Ключ - имя колонки приёмника, Значение - имя колонки источника). Необязательна.
//	СтруктураВычисляемыхКолонок - структура - поля приёмника (Ключ), которые вычисляются формулой для функции Вычислить (Значение); Можно применять имена Строка и СтрокаНовая, а также имена параметров процедуры. Необязательна.
//	Исключаемые поля - список полей, не подлежащих копированию, через запятую. Необязательны.
Процедура ДобавитьЗаписиИзТаблицыВТаблицу(ТабИсточник, ТабПриёмник, СтруктураКопируемыхКолонок = Неопределено, СтруктураВычисляемыхКолонок = Неопределено, ИсключаемыеПоля = "") Экспорт
	ЕстьСКК = СтруктураКопируемыхКолонок <> Неопределено;
	ЕстьСВК = СтруктураВычисляемыхКолонок <> Неопределено;
	КолонкиПриёмника = ?(ЕстьСКК или ЕстьСВК, ТабПриёмник.Колонки, Неопределено);
	Если ЕстьСКК Тогда
		Для каждого КиЗ Из СтруктураКопируемыхКолонок Цикл
			Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
				КолонкиПриёмника.Добавить(КиЗ.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ЕстьСВК Тогда
		Для каждого КиЗ Из СтруктураВычисляемыхКолонок Цикл
			Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
				КолонкиПриёмника.Добавить(КиЗ.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Для каждого Строка из ТабИсточник Цикл
		СтрокаНовая = ТабПриёмник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаНовая, Строка,, ИсключаемыеПоля);
		Если ЕстьСКК Тогда
			Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Строка[Колонка.Значение]
			КонецЦикла;
		КонецЕсли;
		Если ЕстьСВК Тогда
			Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Вычислить(Колонка.Значение)
			КонецЦикла
		КонецЕсли; 
	КонецЦикла
КонецПроцедуры //ДобавитьЗаписиИзТаблицыВТаблицу

// Возвращает массив имён общих колонок двух таблиц
// Параметры:
//  Таб1  - ТаблицаЗначений, ДеревоЗначений, Структура с коллекцией объектов со строковым свойством "Имя" в ключе "Колонки" - Первая таблица
//  Таб2  - ТаблицаЗначений, ДеревоЗначений, Структура с массивом строк в ключе "Колонки" - Вторая таблица
//  ВключатьНомерСтроки  - Булево - Обрабатывать колонку с именем "НомерСтроки". По умолчанию Ложь.
// Возвращаемое значение:
//   Массив   - Строки - имена общих колонкок таблиц
Функция ОбщиеКолонки(Таб1, Таб2, ВключатьНомерСтроки = Ложь) Экспорт
	Результат = Новый Массив;
	Для Каждого Колонка Из Таб1.Колонки Цикл
		ТекИмя = Колонка.Имя;
		Если (ТекИмя <> "НомерСтроки") ИЛИ ВключатьНомерСтроки Тогда
			Если Таб2.Колонки.Найти(ТекИмя) <> Неопределено Тогда
				Результат.Добавить(ТекИмя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // ОбщиеКолонки

//Формирует разность двух таблиц с одинаковыми структурами колонок. Колонки сопоставляются по порядку в таблице (НЕ по имени!).
//Параметры:
//	ТаблицаВычитаемое - Таблица значений - строки которой считаются "Вычитаемыми"
//	ТаблицаУменьшаемое - Таблица значений - строки которой считаются "Положительными"
//	Сортировка - Строка - Имена колонко для сортировки результата
//	КПлюс - Число - Значение, которое возвратится в колонке "Знак" "положительных" строк
//Возвращаемое значение:
//	Таблица значений	- включает строки, встречающиеся только один раз в одной таблице. В добавленной колонке "Знак" в строках из "Вычитаемой" таблицы будет 0, "Уменьшаемой" - параметр КПлюс.
Функция РазницаТаблицЗначений(ТаблицаВычитаемое, ТаблицаУменьшаемое, Сортировка, КПлюс = 1) Экспорт
	ВсеКолонки = Список_Колонок(ТаблицаУменьшаемое);
	Результат = ТаблицаУменьшаемое.Скопировать();    
	Результат.Колонки.Добавить("Знак", Новый ОписаниеТипов("Число"));
	Результат.ЗаполнитьЗначения(КПлюс, "Знак");
	Для Счетчик = 1 По ТаблицаВычитаемое.Количество() Цикл 
		Результат.Вставить(0) 
	КонецЦикла;
	Для Счетчик = 0 По ТаблицаВычитаемое.Колонки.Количество() - 1 Цикл 
		Результат.ЗагрузитьКолонку(ТаблицаВычитаемое.ВыгрузитьКолонку(Счетчик), Счетчик) 
	КонецЦикла;
	Результат.Колонки.Добавить("Счёт");
	Результат.ЗаполнитьЗначения(1, "Счёт");
	Результат.Свернуть(ВсеКолонки, "Знак, Счёт");
	Результат = Результат.Скопировать(Новый Структура("Счёт", 1), ВсеКолонки + ", Знак");
	Результат.Сортировать(Сортировка);
	Возврат Результат;
КонецФункции

// Распределяет суммы из строк таблицы пропорционально базе из другой таблицы. Общие колонки являются измерениями, по ним идёт поиск базы. Различные - ресурсы, все они будут присутствовать в финальной строке.
// Параметры:
//  Суммы  - ТаблицаЗначений - Таблица, содержащая распределяемые суммы
//  База  - ТаблицаЗначений - Таблица, содержащая значения базы
//  КолонкиСумм  - Массив/Строка - Массив имён колонок, содержащих распределяемые суммы. По умолчанию "Сумма".
//  КолонкаБазы  - Строка - Имя колонки, содержащей базу. По умолчанию "База".
//  Обработчик  - "Менеджер" - Обработчик, выполняемый в момент, когда найдена строка и база к ней.
//			Использует ключи структуры Прм: РаспределяемаяСтрока (Строка из Суммы), КолонкиСумм, База (отбранные строки из База), ПолнаяБаза (База), КолонкаБазы, Параметры.
//  ПараметрыОбработчика  - Структура/Неопределено - Параметры, доступные в обработчике. По умолчанию Неопределено.
//	ПоместитьЗначенияБазыВРезультат - Строка - Вапиант переноса значения базы в результат. По умолчанию "Нет".
//			Возможные варианты:
//			*"Нет" - колонки КолонкаБазы в результате не будет
//			*"Пустая" - в колонку будут занесены нули.
//			*"КакЕсть" - в колонку будут занесены применённые коэффициенты, что будет наглядно. Итог по базе будет задублирован.
//			*Имя колонки сумм - Базу распределить пропорционально результату из указанной колонки. Медленнее, не наглядно, но итог по базе сойдётся.
//	ТочностьСумм - Число/Массив чисел - Число цифр после запятой в суммах. По умолчанию 2. 
//	ТочностьБазы - Число - Число цифр после запятой в базе. По умолчанию 3. 
// Возвращаемое значение:
//   Таблица значений   - Таблица - соединение со всеми колонками таблиц сумм и базы и с суммами, распределёнными пропорционально базе.
Функция РаспределитьПоБазе(Суммы, База, КолонкиСумм = "Сумма", КолонкаБазы = "База", Обработчик = "",
		ПараметрыОбработчика = Неопределено, ПоместитьЗначенияБазыВРезультат = "Нет", ТочностьСумм = 2, ТочностьБазы = 3, РаспределятьНаНулевуюБазуЕслиОднаСтрока = Ложь) Экспорт

	#Область ИНИЦИАЛИЗАЦИЯ
		ЕстьОбработчик = ЗначениеЗаполнено(Обработчик);
		Если ТипЗнч(КолонкиСумм) = Тип("Строка") Тогда
			ИменаКолонокСумм = СтрРазделить(КолонкиСумм, ",");
		Иначе
			ИменаКолонокСумм = ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(КолонкиСумм, Истина,, Истина);
		КонецЕсли;
		Точности = Новый Структура;
		ПараметрТочностиМассивом = ТипЗнч(ТочностьСумм) = Тип("Массив");
		Ё = 0;
		Для каждого ИмяКС Из ИменаКолонокСумм Цикл
			//Если База.Колонки.Найти(ИмяКС) <> Неопределено Тогда
			//	ИКССтрокой = ИКССтрокой + "," + ИмяКС;
			//КонецЕсли;
			Точности.Вставить(ИмяКС, ?(ПараметрТочностиМассивом, ТочностьСумм[Ё], ТочностьСумм));
			Ё = Ё + 1;
		КонецЦикла;
		//ИКССтрокой = Сред(ИКССтрокой, 2);
		Результат = ВыгрузитьКолонкиГрупповая(Новый Структура("Таб1,Таб2", Суммы, База));
		ИменаКолонокСумм.Добавить(КолонкаБазы);//Временно
		ИзмеренияРезультата = ВОЛНА_ОбщегоНазначенияКС.РазностьМассивов(Список_Колонок(Результат, "Массив"), ИменаКолонокСумм);
		КолонкиПоиска = ВОЛНА_ОбщегоНазначенияКС.РазностьМассивов(ОбщиеКолонки(База, Суммы), ИменаКолонокСумм);
		ИменаКолонокСумм.Удалить(ИменаКолонокСумм.ВГраница());
		ПараметрыКПередачеВОбработчик = Новый Структура("РаспределяемаяСтрока,КолонкиСумм,База,ПолнаяБаза,КолонкаБазы,Параметры",
				"", ИменаКолонокСумм, "", База, КолонкаБазы, ПараметрыОбработчика);
	#КонецОбласти 
	
	#Область РАСПРЕДЕЛЕНИЕ_СУММ
	    ОбратноеСоответствие = Новый Соответствие;
		Для Каждого СтрокаСумм из Суммы Цикл
			СтруктураОтбора = Новый Структура;
			Для Каждого ИмяКолонки Из КолонкиПоиска Цикл
				Если ЗначениеЗаполнено(СтрокаСумм[ИмяКолонки]) Тогда
					СтруктураОтбора.Вставить(ИмяКолонки, СтрокаСумм[ИмяКолонки]);
				КонецЕсли;
			КонецЦикла;
			ТекБаза = База.НайтиСтроки(СтруктураОтбора);
			Если ЕстьОбработчик Тогда
				ПараметрыКПередачеВОбработчик.Вставить("РаспределяемаяСтрока", СтрокаСумм);
				ПараметрыКПередачеВОбработчик.Вставить("База", ТекБаза);
				ВыполнитьКод(Обработчик, ПараметрыКПередачеВОбработчик);
			КонецЕсли; 
			МассивБазы = Новый Массив;
			Для каждого ТекСтр Из ТекБаза Цикл
				МассивБазы.Добавить(ТекСтр[КолонкаБазы]);
				Если ОбратноеСоответствие[ТекСтр] = Неопределено Тогда
					ОбратноеСоответствие.Вставить(ТекСтр, Новый Массив);
				КонецЕсли;
			КонецЦикла;
			Распределённые = Новый Структура;
			Если РаспределятьНаНулевуюБазуЕслиОднаСтрока И (МассивБазы.Количество() = 1) И (МассивБазы[0] = 0) Тогда
				МассивБазы[0] = 1;
			КонецЕсли;
			Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
				Если СтрокаСумм[ИмяКолонкиСуммы] <> 0 Тогда
					ТекРезультат = ВОЛНА_ОбщегоНазначенияКС.РаспределитьСуммуПропорциональноКоэффициентам(СтрокаСумм[ИмяКолонкиСуммы], МассивБазы, Точности[ИмяКолонкиСуммы]);
					Если ТекРезультат = Неопределено Тогда
						НоваяЗапись = Результат.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
						Для каждого ТекСтр Из ТекБаза Цикл
							ОбратноеСоответствие[ТекСтр].Добавить(НоваяЗапись);
						КонецЦикла;
						Прервать;
					Иначе
						Распределённые.Вставить(ИмяКолонкиСуммы, ТекРезультат);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
			Если Распределённые.Количество() > 0 Тогда
				Для ЁЖЖ = 0 По Распределённые[ИменаКолонокСумм[0]].ВГраница() Цикл
					НадоДобавитьЗапись = Ложь;
					Для каждого КиЗ Из Распределённые Цикл
						Если КиЗ.Значение[ЁЖЖ] <> 0 Тогда
							НадоДобавитьЗапись = Истина;
							Прервать;
						КонецЕсли; 
					КонецЦикла; 
					Если НадоДобавитьЗапись Тогда
						НоваяЗапись = Результат.Добавить();
//						Для каждого ТекСтр Из ТекБаза Цикл
						ОбратноеСоответствие[ТекБаза[ЁЖЖ]].Добавить(НоваяЗапись); //ТекСтр
//						КонецЦикла;
						ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
						ЗаполнитьЗначенияСвойств(НоваяЗапись, ТекБаза[ЁЖЖ]);
						Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
							НоваяЗапись[ИмяКолонкиСуммы] = 0;
						КонецЦикла; 
						Для каждого КиЗ Из Распределённые Цикл
							НоваяЗапись[КиЗ.Ключ] = КиЗ.Значение[ЁЖЖ];
						КонецЦикла; 
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЦикла;
	#КонецОбласти 
	ИКСВсеСтрокой = СтрСоединить(ИменаКолонокСумм);
	#Область БАЗУ_В_РЕЗУЛЬТАТ
		ПоследнийРесурс = КолонкаБазы;
		//Базы заносятся отдельными строками, т.к. если заносить базы вместе с распределёнными суммами, то при повторном использовании строки базы её сумма попадёт в результат повторно.
		Если ПоместитьЗначенияБазыВРезультат = "КакЕсть" Тогда
		ИначеЕсли ПоместитьЗначенияБазыВРезультат = "Нет" Тогда
			Результат.Колонки.Удалить(КолонкаБазы);
			ПоследнийРесурс = "";
		Иначе
			Результат.ЗаполнитьЗначения(0, КолонкаБазы);
			Если ПоместитьЗначенияБазыВРезультат <> "Пустая" Тогда
				Для каждого КиЗ Из ОбратноеСоответствие Цикл
					Если КиЗ.Ключ[КолонкаБазы] <> 0 Тогда
						НужнаНоваяЗаписьРезультатаТолькоСБазой = Ложь;
						Если КиЗ.Значение.Количество() = 0 Тогда
							НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
						Иначе
							МассивБазы = Новый Массив;
							Для каждого СтрСуммы Из КиЗ.Значение Цикл
								МассивБазы.Добавить(СтрСуммы[ПоместитьЗначенияБазыВРезультат]);
							КонецЦикла; 
							ТекРезультат = ВОЛНА_ОбщегоНазначенияКС.РаспределитьСуммуПропорциональноКоэффициентам(КиЗ.Ключ[КолонкаБазы], МассивБазы, ТочностьБазы);
							Если ТекРезультат = Неопределено Тогда
								НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
								Прервать;
							Иначе
								Для СчХ = 0 По ТекРезультат.ВГраница() Цикл
									КиЗ.Значение[СчХ][КолонкаБазы] = КиЗ.Значение[СчХ][КолонкаБазы] + ТекРезультат[СчХ];
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
						Если НужнаНоваяЗаписьРезультатаТолькоСБазой Тогда
							НоваяЗапись = Результат.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяЗапись, КиЗ.Ключ);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла; 
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти
	Результат.Свернуть(СтрСоединить(ИзмеренияРезультата), ИКСВсеСтрокой + ?((ИКСВсеСтрокой = "") ИЛИ (ПоследнийРесурс = ""), "", ",") + ПоследнийРесурс);
	Возврат Результат
КонецФункции // РаспределитьПоБазе

// Приводит колонки одной таблицы в соответствие другой.
// Параметры:
//  Приёмник  - Таблица значений или дерево значений - колонки которой меняются
//  Источник  - Таблица значений или дерево значений - колонки которой переносятся
//  Метод  - Число - метод переноса:
//			* 0 - Считать, что колонок источника заведомо нет в приёмнике и переносить без проверок;
//			* 1 - Добавить только недостающие колонки из источника;
//			* 2 - Удалить совпадающие по именам колонки в приёмнике и перенести все колонки источника;
//			* 3 - Удалить вообще все колонки приёмника и перенести все колонки источника. Используется, когда нельзя присвоить значение в источник (например, в реквизите формы).
//			* 4 - Проверять наличие колонки источника в приёмнике. Если колонка там есть, колонка источника будет добавлена под корректным сгенерированным именем.
//  НеДобавлятьКолонки  - Структура или Неопределено - Список колонок источника, не переносимых в приёмник. По умолчанию пустая строка.
//  СтруктураСоответствияКолонок  - Структура или Неопределено - Структура, в которой при Метод = 4 возвращается соответствие имён колонок (Ключ - имя в источнике, Значение - в приёмнике)
Процедура СкоррелироватьКолонкиТаблиц(Приёмник, Источник, Метод = 3, НеДобавлятьКолонки = "", СтруктураСоответствияКолонок = Неопределено) Экспорт
	Если (Метод = 4) И (СтруктураСоответствияКолонок = Неопределено) Тогда
		СтруктураСоответствияКолонок = Новый Структура;
	КонецЕсли;
	Если Метод = 3 Тогда
		Приёмник.Колонки.Очистить();
	КонецЕсли;
	Для каждого Колонка Из Источник.Колонки Цикл
		Если ВОЛНА_ОбщегоНазначенияКС.НайтиПодстроку(НеДобавлятьКолонки, Колонка.Имя, ",") = 0 Тогда
			НовоеИмя = СкопироватьКолонку(Приёмник.Колонки, Колонка,, Метод);
			Если Метод = 4 Тогда
				СтруктураСоответствияКолонок.Вставить(Колонка.Имя, НовоеИмя);
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла; 
КонецПроцедуры // СкоррелироватьКолонкиТаблиц()

#КонецОбласти 

#Область ПОЛУЧЕНИЕ_ТЗ

// Создаёт пустую таблицу значений с объединением колонок входящих
// Параметры:
//  СписокТаблиц  - СписокЗначений, Структура, Соответстввие, ТаблицаЗначений с колонкой Значение, и т.д. - В Значении содержатся объединяемые таблицы или деревья значений
//  ВернутьДерево  - Булево - При Истина возвращается ДеревоЗначений, при Ложь (по умолчанию) - ТаблицаЗначений
// Возвращаемое значение:
//   ТаблицаЗнчений или деревоЗначений   - Пустой объект с объединением колонок
Функция ВыгрузитьКолонкиГрупповая(СписокТаблиц, ВернутьДерево = Ложь) Экспорт
	Результат = ?(ВернутьДерево, Новый ДеревоЗначений, Новый ТаблицаЗначений);
	ОписаниеКолонок = Новый Структура;
	Для каждого Табличка Из СписокТаблиц Цикл
		Для каждого Колонка Из Табличка.Значение.Колонки Цикл
			Если ОписаниеКолонок.Свойство(Колонка.Имя) Тогда
				ОписаниеКолонок.Вставить(Колонка.Имя, Новый Структура("ТипЗначения,Заголовок,Ширина",
						ВОЛНА_ОбщегоНазначенияКС.ОбъединитьОписанияТипов(Колонка.ТипЗначения, ОписаниеКолонок[Колонка.Имя].ТипЗначения),
						Колонка.Заголовок,
						Макс(Колонка.Ширина, ОписаниеКолонок[Колонка.Имя].Ширина)));
			Иначе
				ОписаниеКолонок.Вставить(Колонка.Имя, Новый Структура("ТипЗначения,Заголовок,Ширина", Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина));
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	Для каждого КиЗ Из ОписаниеКолонок Цикл
		Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение.ТипЗначения, КиЗ.Значение.Заголовок, КиЗ.Значение.Ширина);
	КонецЦикла; 
	Возврат Результат
КонецФункции // ВыгрузитьКолонкиГрупповая

//ЗагрузитьТаблицуЗначенийИзТабличногоДокумента и из файла - в КлиентСервере, т.к. возможен массив структур

// Создаёт таблицу значений с заданными колонками. Может использоваться во внешнем соединении.
// Параметры:
//  СтруктураКолонок  - Структура или Неопределено - Ключ = имя колонки, Значение = Тип колонки (Тип или ОписаниеТипов, если иное - колонка произвольного типа).
// Возвращаемое значение:
//	Таблица значений - Пустая, с заданными колонками (имена и типы)
Функция СоздатьТаблицуЗначений(СтруктураКолонок = Неопределено) Экспорт
	Результат = Новый ТаблицаЗначений;
	ТипТип = Тип("Тип");
	ТипОТ = Тип("ОписаниеТипов");
	Если СтруктураКолонок <> Неопределено Тогда
		Для Каждого КиЗ Из СтруктураКолонок Цикл
			ТекТип = ТипЗнч(КиЗ.Значение);
			Если ТекТип = ТипОТ Тогда
				Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение)
			ИначеЕсли ТекТип = ТипТип Тогда
				МассивТ = Новый Массив;
				МассивТ.Добавить(КиЗ.Значение);
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МассивТ))
			Иначе
				Результат.Колонки.Добавить(КиЗ.Ключ)
			КонецЕсли
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначений()

// Создаёт таблицу значений с заданными строками колонками и значениями. Может использоваться во внешнем соединении.
// Параметры:
//  ИменаКолонок  - Строка - Имена колонок с разделителем ","
//	ТекстыЗначений - Строка - тексты значений колонок с разделителем
//	Разделитель - Строка - разделитель значений
//	ПрефиксФормулы - Строка - значение, начинающееся с этой строки, считается формулой.
//	ПараметрыВычисления  - Структура - Параметры, используемые при вычислении.
//Возвращаемое значение:
//	ТаблицаЗначений - Рассчитанная таблица значений. Например,
//		СоздатьТаблицуЗначенийИзСтрок("Кол1,Кол2", "1,Истина,17,СМОЛА,,ЧЕЛОВЕК") = ТЗ:
//		Кол1	Кол2
//		"1"		"Истина"
//		"17"	"СМОЛА"
//		""		"ЧЕЛОВЕК"
Функция СоздатьТаблицуЗначенийИзСтрок(ИменаКолонок, ТекстыЗначений = "", Разделитель = ",", ПрефиксФормулы = "FRML", ПараметрыВычисления = Неопределено) Экспорт
	Результат = Новый ТаблицаЗначений;
	СтрокаКолонок = СтрЗаменить(ИменаКолонок, ",", Символы.ПС);
	ЧКол = СтрЧислоСтрок(СтрокаКолонок);
	Если ЧКол > 0 Тогда
		Для Ё = 1 По ЧКол Цикл
			Результат.Колонки.Добавить(СтрПолучитьСтроку(СтрокаКолонок, Ё))
		КонецЦикла;
		СимволХрюквы = "##ХРЮКВА__№";
		СтрокаЗначений = СтрЗаменить(СтрЗаменить(ТекстыЗначений, Символы.ПС, СимволХрюквы), Разделитель, Символы.ПС);
		ЧЗнч = СтрЧислоСтрок(СтрокаЗначений);
		ТекКол = Чкол;
		Для Ё = 1 По ЧЗнч Цикл
			Если ТекКол = ЧКол Тогда
				НоваяСтрока = Результат.Добавить();
				ТекКол = 0
			КонецЕсли;
			ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(СтрокаЗначений, Ё), СимволХрюквы, Символы.ПС);
			Если Лев(ТекЗнч, СтрДлина(ПрефиксФормулы)) = ПрефиксФормулы Тогда
				ТекстКода =  Сред(ТекЗнч, СтрДлина(ПрефиксФормулы) + 1);
				НачТекст = "Результат =";
				Если Лев(ТекстКода, СтрДлина(НачТекст))<> НачТекст Тогда
					ТекстКода = НачТекст + ТекстКода;
				КонецЕсли;
				НоваяСтрока[ТекКол] = ВыполнитьКод(ТекстКода, ПараметрыВычисления, ТекстКода);
			Иначе
				НоваяСтрока[ТекКол] = ТекЗнч;
			КонецЕсли;
			ТекКол = ТекКол + 1
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначенийИзСтрок()

// Формирует Таблицу значений из Дерева значений
// Параметры:
//  Дерево  - ДеревоЗначений - Источник
//  Таблица  - ТаблицаЗначений - Приёмник. Можно не указывать, тогда вернёт созданную заново.
//  ИмяКолонкиИД  - Строка - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы, начиная с 1
//  ИмяКолонкиРодителя  - Строка - Имя колонки, куда будет помещён ИД родителей. По умолчанию "Родитель". Если колонки с таким именем нет, она не создаётся и все строки попадут на один уровень.
//	ЗначениеРодителя	- Число - Значение, указываемое в создаваемых подстроках текущей ветви как ИД родителя.
// Возвращаемое значение:
//   Таблица   - Таблица значений.
Функция ТаблицаЗначенийИзДерева(Дерево, Таблица = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = 0) Экспорт
	Если Таблица = Неопределено Тогда
		Таблица = Новый ТаблицаЗначений;
		Если ТипЗнч(Дерево) = Тип("ДеревоЗначений") Тогда
			СкоррелироватьКолонкиТаблиц(Таблица, Дерево, 3);
		Иначе
			Таблица.Колонки.Добавить("Значение", ВОЛНА_ОбщегоНазначенияКС.ВсеСсылочныеИПростыеТипы());
		КонецЕсли;
		Таблица.Колонки.Вставить(0, ИмяКолонкиРодителя);
		Если ИмяКолонкиИД <> "" Тогда
			Таблица.Колонки.Вставить(0, ИмяКолонкиИД);
		КонецЕсли; 
	КонецЕсли; 
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
	Для каждого Строчка Из Дерево.Строки Цикл
		НоваяСтрока = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			НоваяСтрока.Родитель = ЗначениеРодителя;
		КонецЕсли;
		Попытка
			ТекИД = Строчка[ИмяКолонкиИД];
		Исключение
			ТекИД = Таблица.Количество();
			Если НЕ НетКолонкиИД Тогда
				НоваяСтрока[ИмяКолонкиИД] = ТекИД;
			КонецЕсли;
		КонецПопытки;
		ТаблицаЗначенийИзДерева(Строчка, Таблица, ИмяКолонкиИД, ИмяКолонкиРодителя, ТекИД);
	КонецЦикла;
	Возврат Таблица
КонецФункции // ТаблицаЗначенийИзДерева()

// Преобразует массив структур в таблицу значений. Не работает, если в первой строке есть значения "Тип" или "Описания типов" (как данные таблицы).
// Параметры:
//  ФМассив  - Массив, Фиксированный массив - Массив строк ТЗ или структур, соответствующих строкам новой таблицы
//  ВзятьДанныеНачинаяСИндекса  - Число - Индекс элемента массива, начиная с которого идут загружаемые данные. Например, если в первой структуре - типы колонок, то надо указать 1. По умолчанию 0.
//  Типизация  - Строка/Таблица значений - Вариант типизации колонок:
//		*ПоТипамСодержащимсяВПервой - по умолчанию, также любое иное значение - Типы берутся из значений первой структуры (первая строка должна содержать типы);
//		*ПоТипамЗначенийПервой - Типы определяются как типы значений первой (с индексом ВзятьДанныеНачинаяСИндекса) структуры;
//		*ПоВсем - Типы определяются по значениям ключа из всех структур, начиная с ВзятьДанныеНачинаяСИндекса;
//		*Нет - не типизируется;
//		*ТаблицаЗначений - переменная для помещения результата. Если содержит таблицу, записи будут добавлены в конец только в части уже имеющихся реквизитов
//  ДлинаСтрок  - Число - Длина строк для типизации ПоТипамЗначенийПервой:
//		*-2 - По фактическим значениям
//		*-1 - Не ограничивать (По умолчанию)
//		*Прочее - устанавливается заданное значение.
// Возвращаемое значение:
//   Таблица значений   - собранная из массива
Функция ТЗизМассиваСтруктур(ФМассив, ВзятьДанныеНачинаяСИндекса = 0, Типизация = "ПоЗначениямПервой", ДлинаСтрок = -1) Экспорт
	Колво = ФМассив.Количество();
	ТТЗ = ТипЗнч(Типизация) = Тип("ТаблицаЗначений");
	Если Колво = 0 Тогда
		Результат = ?(ТТЗ, Типизация, Новый ТаблицаЗначений);
	Иначе
		НачИндекс = ВзятьДанныеНачинаяСИндекса;
		ЕстьДанные = Колво > ВзятьДанныеНачинаяСИндекса;
		ТПоПервой = Типизация = "ПоТипамЗначенийПервой";
		ТПоВсем = Типизация = "ПоВсем";
		ТНет = Типизация = "Нет";
		Если ЕстьДанные И ТПоПервой Тогда
			Результат = ТЗизСтруктуры(ФМассив[НачИндекс], Истина, ДлинаСтрок);
			НачИндекс = НачИндекс + 1;
		ИначеЕсли ЕстьДанные И ТПоВсем Тогда
			СТипы = Новый Структура;
			Для каждого КиЗ Из ФМассив[НачИндекс] Цикл
				СТипы.Вставить(КиЗ.Ключ, ВОЛНА_ОбщегоНазначенияКС.ПолучитьОписаниеТипаЗначения(КиЗ.Значение));
			КонецЦикла;
			Для СчСтр = НачИндекс + 1 По Колво - 1 Цикл
				Для каждого КиЗ Из ФМассив[СчСтр] Цикл
					СТипы.Вставить(КиЗ.Ключ, ВОЛНА_ОбщегоНазначенияКС.ОбъединитьОписанияТипов(
							ВОЛНА_ОбщегоНазначенияКС.ПолучитьОписаниеТипаЗначения(КиЗ.Значение), СТипы[КиЗ.Ключ]));
				КонецЦикла;
			КонецЦикла;
			МТипы = Новый Массив;
			МТипы.Добавить(СТипы);
			Результат = ТЗизМассиваСтруктур(МТипы, 1);
		ИначеЕсли ЕстьДанные И ТНет Тогда
			Результат = ТЗизСтруктуры(ФМассив[НачИндекс]);
			НачИндекс = НачИндекс + 1;
		ИначеЕсли ТТЗ Тогда
			Результат = Типизация;
		ИначеЕсли ТНет ИЛИ ТПоПервой ИЛИ ТПоВсем Тогда
			Результат = ТЗизСтруктуры(ФМассив[0]);
			Результат.Удалить(Результат[0]);
		Иначе
			ПерваяСтрока = ФМассив[0];
			Результат = СоздатьТаблицуЗначений(ПерваяСтрока);
		КонецЕсли;
		Для СчСтр = НачИндекс По Колво - 1 Цикл
			ЗаполнитьЗначенияСвойств(Результат.Добавить(), ФМассив[СчСтр]);
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ТЗизМассиваСтруктур

// Формирует таблицу значений из списка значений ячеек
// Параметры:
//  СписокЯчеек  - ТаблицаЗначений - Колонки НомерСтроки, ИмяКолонки, ЗначениеЯчейки.
//		Или, если такие имена не заданы - берутся три первые колонки в указанном порядке. Если нет только колонки НомерСтроки, то все данные грузятся в одну строку.
//  МэппингИмёнКолонок  - Соответствие/Структура/Неопределено - соответствие имён колонок значениям из колонки ИмяКолонки. Если задано, в результате будут только колонки из значений соответствия.
// Возвращаемое значение:
//   Таблица значений   - Содержит все колонки, перечисленные в ИмяКолонки, и столько строк, сколько разных значений в колонке НомерСтроки.
//		Если в колонке НомерСтроки найдены нечисловые значения, то в результате будет и колонка НомерСтроки, по значениям которой будут отсортированы строки.
//		Отсутствующие в исходной таблице значения в результате будут представлены как Неопределено
Функция ТЗизСпискаЯчеек(СписокЯчеек, МэппингИмёнКолонок = Неопределено) Экспорт
	
	#Область КОЛОНКИ_ИСТОЧНИКА
	    //Результат области: имена колонок источника в КолонкаНС, КолонкаИК, КолонкаЗЯ, если колонки НС нет, то ПервойНет = Истина
		КолонкиСписка = СписокЯчеек.Колонки;
		ПервыеТри = Ложь;
		ПервойНет = Ложь;
		КолонкаИК = КолонкиСписка.Найти("ИмяКолонки");
		КолонкаЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки");
		НетКИК = КолонкиСписка.Найти("ИмяКолонки") = Неопределено;
		НетКЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки") = Неопределено;
		Если НетКИК Тогда
			ИндексИК = -1;
			ПервыеТри = Истина;
		Иначе
			ИндексИК = КолонкиСписка.Индекс(КолонкаИК);
			КолонкаИК = "ИмяКолонки";
		КонецЕсли;
		Если НетКЗЯ Тогда
			ИндексЗЯ = -1;
			ПервыеТри = Истина;
		Иначе
			ИндексЗЯ = КолонкиСписка.Индекс(КолонкаЗЯ);
			КолонкаЗЯ = "ЗначениеЯчейки";
		КонецЕсли;
		Если ПервыеТри Тогда
			ИндексНС = ?(ИндексИК = 0 ИЛИ ИндексЗЯ = 0, ?(ИндексИК = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
			КолонкаНС = КолонкиСписка[ИндексНС].Имя;
			Если ИндексИК = -1 Тогда
				ИндексИК = ?(КолонкаНС = 0 ИЛИ ИндексЗЯ = 0, ?(КолонкаНС = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
				КолонкаИК = КолонкиСписка[ИндексИК].Имя;
			КонецЕсли;
			Если ИндексЗЯ = -1 Тогда
				КолонкаЗЯ = КолонкиСписка[?(КолонкаНС = 0 ИЛИ ИндексИК = 0, ?(КолонкаНС = 1 ИЛИ ИндексИК = 1, 2, 1), 0)].Имя;
			КонецЕсли;
		Иначе
			Если КолонкиСписка.Найти("НомерСтроки") = Неопределено Тогда
				ПервойНет = Истина;
			Иначе
				КолонкаНС = "НомерСтроки";
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти 
	
	Результат = Новый ТаблицаЗначений;
	#Область СТРОКИ_И_КОЛОНКИ
		Если ПервойНет Тогда
			ЕдинственнаяСтрока = Результат.Добавить();
		Иначе
			ИменаСтрок = СписокЯчеек.Скопировать(, КолонкаНС);
			ИменаСтрок.Свернуть(КолонкаНС);
			СтрокиРезультата = Новый Соответствие;
			Результат.Колонки.Добавить(КолонкаНС);
			Для каждого ИмяСтроки Из ИменаСтрок Цикл
				СтрокиРезультата.Вставить(ИмяСтроки[КолонкаНС], Результат.Добавить());
				СтрокиРезультата[ИмяСтроки[КолонкаНС]].НомерСтроки = ИмяСтроки[КолонкаНС];
			КонецЦикла;
		КонецЕсли;
		 
		ИменаКолонок = СписокЯчеек.Скопировать(, КолонкаИК);
		ИменаКолонок.Свернуть(КолонкаИК);
		Если МэппингИмёнКолонок = Неопределено Тогда
			КолонкиРезультата = Новый Соответствие;
			Для каждого ИмяКолонки Из ИменаКолонок Цикл
				НоваяКолонка = Результат.Колонки.Добавить(ИмяКолонки[КолонкаИК]);
				КолонкиРезультата.Вставить(ИмяКолонки[КолонкаИК], ИмяКолонки[КолонкаИК]);
			КонецЦикла;
		Иначе
			КолонкиРезультата = МэппингИмёнКолонок;
			Для каждого КиЗ Из КолонкиРезультата Цикл
			 	Результат.Колонки.Добавить(КиЗ.Значение);
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти
	
	#Область ЗНАЧЕНИЯ_ЯЧЕЕК
		Для каждого СтрЗЯ Из СписокЯчеек Цикл
			ТекИК = КолонкиРезультата[СтрЗЯ[КолонкаИК]];
			Если ТекИК <> Неопределено Тогда
				Если ПервойНет Тогда
					ТекСтр = ЕдинственнаяСтрока;
				Иначе
					ТекСтр = СтрокиРезультата[СтрЗЯ[КолонкаНС]];
				КонецЕсли;
				ТекСтр[КолонкиРезультата[СтрЗЯ[КолонкаИК]]] = СтрЗЯ[КолонкаЗЯ];
			КонецЕсли; 
		КонецЦикла;
	#КонецОбласти 
	Если НЕ ПервойНет Тогда
		Результат.Сортировать(КолонкаНС);
		Результат.Колонки.Удалить(КолонкаНС);
	КонецЕсли; 
	
	Возврат Результат
КонецФункции // ТЗизСпискаЯчеек

// Создаёт однострочную таблицу значений из структуры
// Параметры:
//  Источник  - Структура/Соответствие - Источник данных, ключи - имена колонок
//  Типизировать  - Булево - Истина - колонки типизируются (по умолчанию Ложь)
//  ДлинаСтрок  - Число - Ограничение длин строк (12 = Пофакту; -1 = Не ограничивать(По умолчанию))
// Возвращаемое значение:
//   Таблица значений   - Первая строка содержит значения из структуры
Функция ТЗизСтруктуры(Источник, Типизировать = Ложь, ДлинаСтрок = -1) Экспорт
	Результат = Новый ТаблицаЗначений;
	ТипСтрока = Тип("Строка");
	Если Типизировать Тогда
		Для каждого КиЗ Из Источник Цикл
			МТипы = Новый Массив;
			ТекТип = ТипЗнч(КиЗ.Значение);
			МТипы.Добавить(ТекТип);
			Если ТекТип = ТипСтрока И ДлинаСтрок <> -1 Тогда
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы,, Новый КвалификаторыСтроки(?(ДлинаСтрок = -2, СтрДлина(КиЗ.Значение), ДлинаСтрок))));
			Иначе
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы));
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для каждого КиЗ Из Источник Цикл
			Результат.Колонки.Добавить(КиЗ.Ключ);
		КонецЦикла;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(Результат.Добавить(), Источник);
	Возврат Результат
КонецФункции // ТЗизСтруктуры

#КонецОбласти

#Область ПРОЦЕДУРА_ОБЪЕДИНИТЬ_ТАБЛИЦЫ
	
//Вспомогательная к следующей экспортной процедуре
Процедура ЗаполнитьСтрокиПоСтруктурам(ТабПриёмник, ТабИсточник, СтруктураКопируемыхКолонок, СтруктураВычисляемыхКолонок)
	Для каждого СтрокаИсточник из ТабИсточник Цикл
		СтрокаПриёмник = ТабПриёмник.Добавить();
		Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = СтрокаИсточник[Колонка.Значение]
		КонецЦикла;
		Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = Вычислить(Колонка.Значение)
		КонецЦикла
	КонецЦикла
КонецПроцедуры

//Вспомогательная к следующей экспортной процедуре
Функция ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, Ключ, ТипНовой, ШиринаНовой = 0, ЭтоВычисляемая = Ложь)
	Если КолонкиРезультата.Свойство(Ключ) Тогда
		Если НЕ ЭтоВычисляемая Тогда
			КолонкиРезультата[Ключ].ТипЗначения = ВОЛНА_ОбщегоНазначенияКС.ОбъединитьОписанияТипов(КолонкиРезультата[Ключ].ТипЗначения, ТипНовой);
			Если КолонкиРезультата[Ключ].Ширина <> 0 Тогда
				КолонкиРезультата[Ключ].Ширина = Макс(КолонкиРезультата[Ключ].Ширина, ШиринаНовой);
			КонецЕсли;
		КонецЕсли; 
		Возврат Истина;
	Иначе
		Если ЭтоВычисляемая Тогда
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ,, 0));
		Иначе
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ, ТипНовой, ШиринаНовой));
		КонецЕсли; 
		Возврат Ложь;
	КонецЕсли; 
КонецФункции

// Объединяет несколько таблиц в одну с учётом типов колонок
// Параметры:
//  СтруктураТаблиц - Массив, структура, фиксированная структура (ФС), список значений или соответствие - Состоит из структур или ФС с информацией об объединяемых таблицах с полями:
//				Таблица - сама таблица (таблица значений или табличная часть);
//				СтруктураКопируемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - имя источника
//				СтруктураВычисляемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - формула с возможностью
//						применения переменных СтрокаИсточник, СтрокаПриёмник, ТабИсточник и ТабПриёмник;
//				ОсобыеПоля - строка с именами колонок через ПС или запятую;
//				ВзятьОсобые - Булево. Если Истина, то переносятся Особые поля и поля из СКК и СВК. Если ложь или не указан - переносятся поля из СКК и СВК, а также все поля, не перечисленные в Особых.
//			Если этот параметр - не массив, тогда структуры находятся в значениях.
// Возвращаемое значение:
//   Таблица значений   - Таблица, содержащая объединение таблиц по заданным правилам. Например, чтобы перенести все колонки "один в один", достаточно заполнить ключ "Таблица".
Функция ОбъединитьТаблицы(СтруктураТаблиц) Экспорт
	//Сформировать таблицу - результат: определить имена колонок, типы колонок.
	//Перенести данные таблиц.
	Результат = Новый ТаблицаЗначений;

	#Область ФОРМИРОВАНИЕ_МАССИВА_ОПИСАНИЙ_ТАБЛИЦ
	ТипПараметра = ТипЗнч(СтруктураТаблиц);
	Если (ТипПараметра = Тип("Структура")) ИЛИ (ТипПараметра = Тип("ФиксированнаяСтруктура"))
			ИЛИ (ТипПараметра = Тип("Соответствие")) ИЛИ (ТипПараметра = Тип("ФиксированноеСоответствие")) ИЛИ (ТипПараметра = Тип("СписокЗначений")) Тогда
		МассивТаблиц = Новый Массив;
		Для каждого КиЗ Из СтруктураТаблиц Цикл
			МассивТаблиц.Добавить(КиЗ.Значение);
		КонецЦикла; 
	ИначеЕсли (ТипПараметра = Тип("Массив")) ИЛИ (ТипПараметра = Тип("ФиксированныйМассив")) Тогда
		МассивТаблиц = СтруктураТаблиц;
	Иначе
		МассивТаблиц = Новый Массив;
	КонецЕсли;
	#КонецОбласти

	#Область Формирование_описаний_колонок
	//определяются для квалификаторов:
	//ЧастиДаты,Длина,ДопустимаяДлина,ЧислоРазрядов,ЧислоРазрядовДробнойЧасти,ДопустимыйЗнак,ДлинаСтроки,ДопустимаяДлина 
	КолонкиРезультата = Новый Структура;
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		Если ОписаниеТаблицы.Свойство("ВзятьОсобые") Тогда
			Если ТипЗнч(ОписаниеТаблицы.ВзятьОсобые) <> Тип("Булево") Тогда
				ОписаниеТаблицы.ВзятьОсобые = Ложь;
			КонецЕсли;
		Иначе
			ОписаниеТаблицы.Вставить("ВзятьОсобые", Ложь);
		КонецЕсли;
		Если НЕ ОписаниеТаблицы.Свойство("ОсобыеПоля") Тогда
			ОписаниеТаблицы.Вставить("ОсобыеПоля", "");
		КонецЕсли;
		Если ОписаниеТаблицы.Свойство("СтруктураКопируемыхКолонок") Тогда
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураКопируемыхКолонок Цикл
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ОписаниеКолонки.Значение);
				Если КолонкаИсточник = Неопределено Тогда
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Удалить(ОписаниеКолонки.Ключ);
				Иначе
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, КолонкаИсточник.ТипЗначения, КолонкаИсточник.Ширина);
					Если (НЕ ОписаниеТаблицы.ВзятьОсобые) И (СтрНайти(ОписаниеТаблицы.ОсобыеПоля, ОписаниеКолонки.Значение) = 0) Тогда
						//Иначе колонка задублируется под другим именем
						ОписаниеТаблицы.ОсобыеПоля = ОписаниеТаблицы.ОсобыеПоля + Символы.ПС + ОписаниеКолонки.Значение;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		Иначе
			ОписаниеТаблицы.Вставить("СтруктураКопируемыхКолонок", Новый Структура);
		КонецЕсли; 
		Если ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок") Тогда
			//Вычисляемая колонка не меняет типа колонки, если он ранее задан, а если колонка новая - то тип будет произвольный.
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураВычисляемыхКолонок Цикл
				ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, Неопределено,, Истина);
			КонецЦикла;
		КонецЕсли; 
		Если ОписаниеТаблицы.ВзятьОсобые Тогда
			СтрокаПолей = СтрЗаменить(ОписаниеТаблицы.ОсобыеПоля, ",", Символы.ПС);
			Для Ё = 1 По СтрЧислоСтрок(СтрокаПолей) Цикл
				ТекИмя = СтрПолучитьСтроку(СтрокаПолей, Ё);
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ТекИмя);
				Если КолонкаИсточник <> Неопределено Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла;
			ОписаниеТаблицы.ОсобыеПоля = "";
		Иначе
			Для каждого КолонкаИсточник Из ОписаниеТаблицы.Таблица.Колонки Цикл
				ТекИмя = КолонкаИсточник.Имя;
				Если (СтрНайти(ОписаниеТаблицы.ОсобыеПоля, ТекИмя) = 0) Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
	#КонецОбласти 
	
	Для каждого ОписаниеКолонки Из КолонкиРезультата Цикл
		Результат.Колонки.Добавить(ОписаниеКолонки.Ключ, ОписаниеКолонки.Значение.ТипЗначения, ОписаниеКолонки.Значение.Заголовок, ОписаниеКолонки.Значение.Ширина)
	КонецЦикла; 
	
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		ЗаполнитьСтрокиПоСтруктурам(Результат, ОписаниеТаблицы.Таблица, ОписаниеТаблицы.СтруктураКопируемыхКолонок,
				?(ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок"), ОписаниеТаблицы.СтруктураВычисляемыхКолонок, Новый Структура));
	КонецЦикла;
	
	Возврат Результат
КонецФункции // ОбъединитьТаблицы()
 
#КонецОбласти 

#Область ПРЕОБРАЗОВАНИЯ_В_ДРУГИЕ_ТИПЫ
	
// Записывает файл Excel с данными из таблицы значений.
// Параметры:
//  ИмяФайла  - Строка - Имя записываемого файла
//  ТабЗн  - Таблица значений - Данные для записи
// Возвращаемое значение:
//   Строка   - Описание ошибки. Пустое, если ошибки нет
Функция ExcelИзТаблицыЗначений(ИмяФайла_, ТабЗн, ВыводитьЗаголовки = Истина) Экспорт
	Результат = "";
	ТабДокумент = Новый ТабличныйДокумент;
	Попытка
		Если ВыводитьЗаголовки Тогда
			СчКол = 1;
			Для каждого Колонка Из ТабЗн.Колонки Цикл
				ТабДокумент.Область(1, СчКол, 1, СчКол).Текст = СокрЛП(Колонка.Имя);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЕсли;
		СчСтр = 1;
		Для каждого Строчка Из ТабЗн Цикл
			СчКол = 1;
			СчСтр = СчСтр + 1;
			Для каждого Колонка Из ТабЗн.Колонки Цикл
				ТабДокумент.Область(СчСтр, СчКол, СчСтр, СчКол).Текст = СокрЛП(Строчка[Колонка.Имя]);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЦикла;
		ТабДокумент.Записать(ИмяФайла_, ТипФайлаТабличногоДокумента.XLSX);
	Исключение
		Результат = ОписаниеОшибки();
	КонецПопытки;
	Возврат Результат
КонецФункции // ExcelИзТаблицыЗначений()

// Выгружает свёрнутую колонку таблицы значений
// Параметры:
//  ТЗначений  - Таблица значений - Откуда выгружать колонку
//  ИмяКолонки  - Строка - Имя выгружаемой колонки
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
// Возвращаемое значение:
//   Массив   - выгруженная свёрнутая колонка
Функция ВыгрузитьСвёрнутуюКолонку(ТЗначений, ИмяКолонки, УдалитьПустые = Ложь) Экспорт
	ВремТаб = ТЗначений.Скопировать(, ИмяКолонки);
	ВремТаб.Свернуть(ИмяКолонки);
	Если УдалитьПустые Тогда
		Результат = Новый Массив();
		Для каждого Строчка Из ВремТаб Цикл
			Если ЗначениеЗаполнено(Строчка[0]) Тогда
				Результат.Добавить(Строчка[0]);
			КонецЕсли; 
		КонецЦикла; 
	Иначе
		Результат = ВремТаб.ВыгрузитьКолонку(ИмяКолонки);
	КонецЕсли; 
	Возврат Результат
КонецФункции // ВыгрузитьСвёрнутуюКолонку()

// Формирует дерево значений из таблицы значений
// Параметры:
//  Таблица  - ТаблицаЗначений - Источник
//  ВетвьРодитель  - Строка дерева значений; любое другое значение будет преобразовано в дерево значений - Ветвь дерева, в которую будут добавляться строки
//  ИмяКолонкиИД  - Строка или Соответствие - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы. Может быть передано соответствие, где ключ - строка таблицы значений, а значение - её номер.
//  ИмяКолонкиРодителя  - Строка - Имя колонки, содержащей ИД родителей. По умолчанию "Родитель". Если колонки не обнаружено, все строки попадут в корень дерева.
//  ЗначениеРодителя  - Любое значение - ИД родителя, по которому будут искаться строки в таблице.
//	СтрокаЗапрещённыхПолей	- Строка	- Имена полей через запятую, которые не должны переноситься. Следует учитывать, что в дереве "Родитель" и "Строки" - реквизиты, и при наличии таких полей в источнике их надо запретить.
// Возвращаемое значение:
//   ВетвьРодитель   - Дерево значений или его строка (ветвь).
Функция ДеревоИзТаблицыЗначений(Таблица, ВетвьРодитель = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = "", СтрокаЗапрещённыхПолей = "") Экспорт
	Если ВетвьРодитель = Неопределено Тогда
		//Инициализация дерева
		ВетвьРодитель = Новый ДеревоЗначений;
		СкоррелироватьКолонкиТаблиц(ВетвьРодитель, Таблица, 3,
				?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиРодителя) = 0, "", ИмяКолонкиРодителя) + "," +
				?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиИД) = 0, "", ИмяКолонкиИД));
	КонецЕсли; 
	Если ТипЗнч(ИмяКолонкиИД) = Тип("Соответствие") Тогда
		НетКолонкиИД = Истина;
		СоответствиеНомеровСтрок = ИмяКолонкиИД;
	Иначе
		НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
		Если НетКолонкиИД Тогда
			СоответствиеНомеровСтрок = Новый Соответствие;
			Ё = 1;
			Для каждого Строчка Из Таблица Цикл
				СоответствиеНомеровСтрок.Вставить(Строчка, Ё);
				Ё = Ё + 1;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	//Обработка незаписываемых реквизитов дерева
	Если СтрокаЗапрещённыхПолей = "" Тогда
		Если Таблица.Колонки.Найти("Родитель") = Неопределено Тогда
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "";
			Иначе
				СтрокаЗапрещённыхПолей = "Строки";
			КонецЕсли; 
		Иначе
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "Родитель";
			Иначе
				СтрокаЗапрещённыхПолей = "Родитель,Строки";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Источник = ?(НетКолонкиРодителя, Таблица, Таблица.НайтиСтроки(Новый Структура(ИмяКолонкиРодителя, ЗначениеРодителя)));
	Для каждого Строчка Из Источник Цикл
		НоваяСтрока = ВетвьРодитель.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка,, СтрокаЗапрещённыхПолей);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			Если НетКолонкиИД Тогда
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, СоответствиеНомеровСтрок, ИмяКолонкиРодителя, СоответствиеНомеровСтрок[Строчка]);
			Иначе
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, ИмяКолонкиИД, ИмяКолонкиРодителя, Строчка[ИмяКолонкиИД]);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат ВетвьРодитель
КонецФункции // ДеревоИзТаблицыЗначений()
 
// Преобразует таблицу значений в фиксированный массив фиксированных структур.
// Для обычных массивов и структур следует использовать ОбщегоНазначения.
// Параметры:
//  ТЗначений  - Таблица значений - Преобразуемая таблица
//  ТипыКолонок  - Булево - В первом элементе возвращаемого массива структура типов колонок. По умолчанию Ложь (первый элемент - обычная строка).
// Возвращаемое значение:
//   ФиксированныйМассив   - Фиксированные структуры, соответствующие строкам
Функция МассивСтруктурИзТаблицы(ТЗначений, ТипыКолонок = Ложь) Экспорт
	Результат = Новый Массив;
	Заголовки = Список_Колонок(ТЗначений);
	Если ТипыКолонок Тогда
		Эмулятор = Новый Структура;
		Для каждого Колонка Из ТЗначений.Колонки Цикл
			Эмулятор.Вставить(Колонка.Имя, Колонка.ТипЗначения);
		КонецЦикла;
		Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
	КонецЕсли;
	Для каждого Строчка Из ТЗначений Цикл
		Эмулятор = Новый Структура(Заголовки);
		ЗаполнитьЗначенияСвойств(Эмулятор, Строчка);
		Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
	КонецЦикла;
	Возврат Новый ФиксированныйМассив(Результат)
КонецФункции // МассивСтруктурИзТаблицы

// Возвращает структуру, полученную из таблицы значений
// Параметры:
//  ТабЗНач - Таблица значений (табличная часть) или массив строк - источник данных
//  ИмяКолонкиКлючей - Строка - имя колонки,значения которой будут ключами (по умолчанию первая колонка).
//			Если указаны имена нескольких колонок через запятую, то ключом будет объединение строковых представлений колонок.
//  ИмяКолонкиЗначений - Строка - имя колонки,значения которой будут значениями (по умолчанию вторая (а если второй нет - первая) колонка).
//			м.б. "#ВсяСтрока" - значением будет вся строка.
//	ВернутьСоответствие - Булево - тип результата (Истина = Соответствие, Ложь(по умолчанию) = Структура). Автоопределений нет.
//	Колонки_ - колонки - колонки ТабЗнач. Если Неопределено (по умолчанию) - получаются из ТабЗнач.
// Возвращаемое значение:
//  Результат - Структура или соответствие - структура с ключами из колонки ключей и значениями из колонки значений
Функция СтруктураИзКолонокТаблицы(ТабЗНач, ИмяКолонкиКлючей = "", ИмяКолонкиЗначений = "", ВернутьСоответствие = Ложь, Колонки_ = Неопределено) Экспорт
	Если Колонки_ = Неопределено Тогда
		Колонки_ = ТабЗнач.Колонки;
	КонецЕсли; 
	Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
	Колонок = Колонки_.Количество();
	Если Колонок = 0 Тогда
		Возврат Результат
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяКолонкиКлючей) Тогда
		ИмяКолонкиКлючей_ = Колонки_[0].Имя;
		КлючСтрока = НЕ ВернутьСоответствие;
	Иначе
		ИмяКолонкиКлючей_ = ИмяКолонкиКлючей;
		КлючСтрока = (СтрНайти(ИмяКолонкиКлючей, ",") > 0) ИЛИ НЕ ВернутьСоответствие;
	КонецЕсли;
	ИменаКолонокКлючей = СтрРазделить(ИмяКолонкиКлючей_, ",", Ложь);
	ИмяКолонкиЗначений_ = ?(Не ЗначениеЗаполнено(ИмяКолонкиЗначений),
			?(Колонок = 1, Колонки_[0].Имя, Колонки_[1].Имя), ИмяКолонкиЗначений);
	ЭтоВсяСтрока = ИмяКолонкиЗначений_ = "#ВсяСтрока";
	Для Каждого Строчка Из ТабЗНач Цикл
		Если КлючСтрока Тогда
			Ключ = "";
			Для каждого ТекКлюч Из ИменаКолонокКлючей Цикл
				Ключ = Ключ + Строчка[ТекКлюч];
			КонецЦикла;
		Иначе
			Ключ = Строчка[ИмяКолонкиКлючей_];
		КонецЕсли;
		Результат.Вставить(Ключ, ?(ЭтоВсяСтрока, Строчка, Строчка[ИмяКолонкиЗначений_]))
	КонецЦикла;
	Возврат Результат
КонецФункции

// Возвращает структуру, созданную по строке таблицы значений
// Параметры:
//  Источник - Таблица значений - Таблица, значения заданной строки которой будут перенесены в структуру
//  ИндексСтроки - Число - Индекс строки, преобразуемой в структуру. Если превышает пределы таблицы = будет возвращена пустая структура
//  Ключи - Строка - Список имён колонок, преобразуемых в ключи
// Возвращаемое значение:
//   Структура   - преобразованная строка таблицы
Функция СтруктураИзСтрокиТЗ(Источник, ИндексСтроки = 0, Ключи = "") Экспорт
	Результат = Новый Структура(Ключи);
	Если Источник.Количество() > ИндексСтроки Тогда
		Если Ключи = "" Тогда
			Для каждого Колонка Из Источник.Колонки Цикл
				Результат.Вставить(Колонка.Имя, Источник[ИндексСтроки][Колонка.Имя]);
			КонецЦикла;
		Иначе
			ЗаполнитьЗначенияСвойств(Результат, Источник[ИндексСтроки]);
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураИзСтрокиТЗ

#КонецОбласти 

#Область ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
	
//Изменяет тип колонки таблицы значений и заполняет её заданным значением
//Параметры:
//	 ТабЗнач	- Таблица значений - В которой будет заполнена колонка
//	 Значение	- Произвольное - Которым будет заполнена колонка
//	 ИмяКолонки	- Строка - имя заполняемой колонки
//Возвращаемое значение:
//	Таблица значений - с заплненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
Функция ЗаполнитьЗначениеВКолонку(ТабЗнач, Значение, ИмяКолонки) Экспорт
	Если ТабЗнач.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
		ТабЗнач.Колонки.Удалить(ИмяКолонки)
	КонецЕсли;
	ТабЗнач.Колонки.Добавить(ИмяКолонки, ВОЛНА_ОбщегоНазначенияКС.ПолучитьОписаниеТипаЗначения(Значение));
	ТабЗнач.ЗаполнитьЗначения(Значение, ИмяКолонки);
	Возврат ТабЗнач
КонецФункции

//Приводит сумму колонки таблицы к нужному значению
//Параметры:
//	Таблица - таблица значений, строки дерева значений - коллекция, по колонке которой надо перераспределит сумму
//	Реквизит - Строка - Имя колонки, по которой распределяется сумма
//	Сумма - Число - распределяемая сумма
//	Точность - Число - количество знаков после запятой в рассчитанных суммах
Процедура ПривестиТабКСумме(Таблица, Реквизит, Сумма, Знач Точность = 2) Экспорт
	Если Сумма = 0 Тогда
		Таблица.ЗаполнитьЗначения(Сумма, Реквизит);
	ИначеЕсли Таблица.Итог(Реквизит) <> 0 Тогда
		Таблица.ЗагрузитьКолонку(ВОЛНА_ОбщегоНазначенияКС.РаспределитьСуммуПропорциональноКоэффициентам(Сумма, Таблица.ВыгрузитьКолонку(Реквизит), Точность));
	КонецЕсли;
КонецПроцедуры

// Возвращает таблицу значений с пронумерованными строками. Может использоваться как процедура.
// Параметры:
//  Таблица  - Таблица значений - подлежит нумерации
//  ИмяКолонки  - Строка - Имя колонки с номером
//  ПервыйНомер  - Число - номер первой строки
// Возвращаемое значение:
//   Таблица значений   - Та же, что и передана, но с колонкой номера строки.
Функция ПронумероватьТаблицуЗначений(Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1) Экспорт
	Результат = Таблица;
	Результат.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число"));
	Ё = ПервыйНомер;
	Для каждого СтрокаТ Из Результат Цикл
		СтрокаТ[ИмяКолонки] = Ё;
		Ё = Ё + 1;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ПронумероватьТаблицуЗначений

// Объединяет "смежные" интервалы дат из таблицы значений. Считается, что в таблице есть колонки начала периода, конца периода и измерения
// Параметры:
//  ТабЗн - Таблица значений - С колонками дат и измерений
//  ИмяКолонкиНачалаПериода - Строка - Имя колонки, в которой содержатся начала периодов
//  ИмяКолонкиОкончанияПериода - Строка - Имя колонки, в которой содержатся начала периодов
Процедура СвернутьПериоды(ТабЗн, ИмяКолонкиНачалаПериода, ИмяКолонкиОкончанияПериода) Экспорт
	ИменаКолонок = Список_Колонок(ТабЗн, "Массив");
	Индекс_ = ИменаКолонок.Найти(ИмяКолонкиНачалаПериода);
	Если Индекс_ <> Неопределено Тогда
		ИменаКолонок.Удалить(Индекс_);
	КонецЕсли;
	Индекс_ = ИменаКолонок.Найти(ИмяКолонкиОкончанияПериода);
	Если Индекс_ <> Неопределено Тогда
		ИменаКолонок.Удалить(Индекс_);
	КонецЕсли;
	Имена_Колонок = СтрСоединить(ИменаКолонок, ",");
	ТабЗн.Сортировать(?(Имена_Колонок = "", "", Имена_Колонок + ",") + ИмяКолонкиНачалаПериода);
	ПрошлаяСтрока = ТабЗн[0];
	МассивКУдалению = Новый Массив;
	Для Ё = 1 По ТабЗн.Количество() - 1 Цикл
		ЭтаСтрока = ТабЗн[Ё];
		Если ВОЛНА_ОбщегоНазначенияКС.ПореквизитноРавны(ПрошлаяСтрока, ЭтаСтрока, ИменаКолонок) И (ПрошлаяСтрока.Дата2 >= ЭтаСтрока.Дата1 - 1) Тогда
			Если ПрошлаяСтрока.Дата2 < ЭтаСтрока.Дата2 Тогда
				ПрошлаяСтрока.Дата2 = ЭтаСтрока.Дата2;
			КонецЕсли;
			МассивКУдалению.Добавить(ЭтаСтрока);
		Иначе
			ПрошлаяСтрока = ЭтаСтрока;
		КонецЕсли;
	КонецЦикла;
	ВОЛНА_ОбщегоНазначенияКС.УдалитьЛишниеСтроки(ТабЗн, МассивКУдалению);
КонецПроцедуры // СвернутьПериоды

//Возвращает свёрнутую таблицу значений (удобно использовать, когда нужна именно функция, а также при автоопределении измерений и ресурсов)
//Параметры:
//	 Табличка	- Таблица значений - Которая будет свёрнута
//	 Измерения	- Строка - Имена колонок измерений через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, не имеющие в составе типов Число
//			(или (Если НеопределённыйТип = "Проверить") с неопределённым типом и имеющими хотя бы одно значение, не являющееся числом).
//	 Ресурсы	- Строка - Имена колонок ресурсов через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, имеющие в составе типов Число
//			(или (Если НеопределённыйТип = "Проверить") с неопределённым типом и значениями типа только Число).
//	 НеопределённыйТип	- Строка - Имеет смысл только для автоопределения ресурсов и измерений.
//			*"Измерение" - Колонки с неопределённым типом считаются измерениями (по умолчанию)
//			*"Исключить" - Колонки с неопределённым типом не входят ни в измерения, ни в ресурсы
//			*"Проверить" - Колонки с неопределённым типом автоопределяются
//	 Исключаемые	- Строка - Список колонок, исключаемых из измерений и ресурсов.
//Возвращаемое значение:
//	Таблица значений (Табличка) - с заполненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
Функция СвернутьТаблицуЗначений(Табличка, Измерения = Неопределено, Ресурсы = Неопределено, НеопределённыйТип = "Измерение", Исключаемые = "") Экспорт
	АвтоИзмерения = Измерения = Неопределено;
	АвтоРесурсы = Ресурсы = Неопределено;
	мИсключаемые = СтрРазделить(Исключаемые, ",");
	Если АвтоИзмерения Тогда
		ТекИзмерения = ",";
	Иначе
		ТекИзмерения = "," + Измерения + ",";
		Для каждого Исключение_ Из мИсключаемые Цикл
			ТекИзмерения = СтрЗаменить(ТекИзмерения, "," + Исключение_ + ",", ",");
		КонецЦикла;
	КонецЕсли; 
	Если АвтоРесурсы Тогда
		ТекРесурсы = ",";
	Иначе
		ТекРесурсы = "," + Ресурсы + ",";
		Для каждого Исключение_ Из мИсключаемые Цикл
			ТекРесурсы = СтрЗаменить(ТекРесурсы, "," + Исключение_ + ",", ",");
		КонецЦикла;
	КонецЕсли; 
	Если АвтоИзмерения ИЛИ АвтоРесурсы Тогда
		Для каждого Колонка Из Табличка.Колонки Цикл
			ТипЧисло = Тип("Число");
			ТекИмя = Колонка.Имя;
			Это_Изм_Рес = "";
			Если (мИсключаемые.Найти(ТекИмя) = Неопределено)
					И ?(АвтоИзмерения, ИСТИНА, Найти(ТекИзмерения, "," + ТекИмя + ",") = 0)
					И ?(АвтоРесурсы, ИСТИНА, Найти(ТекРесурсы, "," + ТекИмя + ",") = 0)
					Тогда
				ТекТип = Колонка.ТипЗначения;
				Если ТекТип.Типы().Количество() = 0 Тогда
					Если НеопределённыйТип = "Проверить" Тогда
						Это_Изм_Рес = "Р";
						Для каждого Строчка Из Табличка Цикл
							Если ТипЗнч(Строчка[ТекИмя]) <> ТипЧисло Тогда
								Это_Изм_Рес = "И";
								Прервать;
							КонецЕсли; 
						КонецЦикла;
					ИначеЕсли НеопределённыйТип = "Измерение" Тогда
						Это_Изм_Рес = "И";
					КонецЕсли;
				ИначеЕсли ТекТип.СодержитТип(ТипЧисло) Тогда
					Это_Изм_Рес = "Р";
				Иначе
					Это_Изм_Рес = "И";
				КонецЕсли; 
			КонецЕсли;
			Если Это_Изм_Рес = "Р" Тогда
				Если АвтоРесурсы Тогда
					ТекРесурсы = ТекРесурсы + ТекИмя + ",";
				КонецЕсли;
			ИначеЕсли Это_Изм_Рес = "И" Тогда
				Если АвтоИзмерения Тогда
					ТекИзмерения = ТекИзмерения + ТекИмя + ",";
				КонецЕсли;
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	ТекИзмерения = Сред(ТекИзмерения, 2, СтрДлина(ТекИзмерения) - 2);
	ТекРесурсы = Сред(ТекРесурсы, 2, СтрДлина(ТекРесурсы) - 2);
	Табличка.Свернуть(ТекИзмерения, ТекРесурсы);
	Возврат Табличка
КонецФункции // ()

// Свёртывает таблицу значений с расширенными возможностями агрегатных функций. Колонки ресурса должны допускать тип результата агрегирования.
// В реквизитах остаётся одно из значений, в неопознанных ресурсах - Неопределено.
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Сворачиваемая таблица
//  КолонкиИзмерений  - Строка - Колонки измерений через запятую
//  КолонкиРесурсов  - Структура - Ключи = Имена колонк, значения = агрегатные функции:
//			*ЗНАЧЕНИЯ - Упаковка в значения списка значений
//			*МАКСИМУМ - Максимум
//			*МАССИВ - Упаковка значений в массив
//			*МИНИМУМ - Минимум
//			*ПРОИЗВ - Произведение
//			*Результат =  - Выполнение произввольного кода с переменными:
//				*ВсеИтоги (структура с текущими значениями итогов и ключами - именами ресурсов),
//				*Результат - текущий итог текущего ресурса. Стартовый итог = Неопределено.
//				*ТекЗначение - Текущее значение текущего ресурса строки таблицы,
//				*СтрокаТЗ - текущая строка таблицы значений.
//			*СООТВЕТСТВИЕ - Упаковка в ключи соответствия
//			*СТРУКТУРА - Упаковка в ключи структуры
//			*Структура - ключи Число,Ограничение,Разделитель,КонецОбрезанный - конкатенация указанного числа символов строк
//				(отрицательное - правых, ноль - полностью), общая длина на больше Ограничение, обрезанная итоговая строка заканчивается на указанный конец
//			*СУМКВ - Сумма квадратов
//			*СУММ - Сумма
// Возвращаемое значение:
//   Таблица значений   - Параметр1 свёрнутый
Функция СвернутьТабЗначенийРасширенно(ТабЗн, КолонкиИзмерений, КолонкиРесурсов) Экспорт
	Результат = ТабЗн;
	Итоги = Новый Структура;
	Колво = Результат.Количество();
	КУдалению = Новый Массив;
	КУдалению.Добавить(Результат.Добавить());//Техническая строка
	мИзмерения = СтрРазделить(КолонкиИзмерений, ",", Ложь);
	ТипСтруктура = Тип("Структура");
	ТипЧисло = Тип("Число");
	ЭтоДубль = Ложь;
	Результат.Сортировать(КолонкиИзмерений);
	Для каждого КиЗ Из КолонкиРесурсов Цикл
		Итоги.Вставить(КиЗ.Ключ, Неопределено);
	КонецЦикла;
	ТекСтрока = 0;
	Для Сч = 0 По Колво Цикл
		ПрошлаяСтрока = ТекСтрока;
		ТекСтрока = Результат[Сч];
		//ЗАПИСЬ АГРЕГАТОВ
		Если ЭтоДубль Тогда
			Если Сч = Колво Тогда
				ЭтоДубль = Ложь;
			Иначе
				Для каждого Измерение Из мИзмерения Цикл
					Если ТекСтрока[Измерение] <> ПрошлаяСтрока[Измерение] Тогда
						ЭтоДубль = Ложь;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
			Если ЭтоДубль Тогда
				КУдалению.Добавить(ПрошлаяСтрока);
			Иначе
				Для каждого КиЗ Из Итоги Цикл
					ПрошлаяСтрока[КиЗ.Ключ] = КиЗ. Значение;
					Итоги[КиЗ.Ключ] = Неопределено;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
		//АГРЕГИРОВАНИЕ
		Для каждого КиЗРесурс Из КолонкиРесурсов Цикл
			Если КиЗРесурс.Значение = "ЗНАЧЕНИЯ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый СписокЗначений;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить().Значение = ТекСтрока[КиЗ.Ключ];
			ИначеЕсли ТипЗнч(КиЗРесурс.Значение) = ТипСтруктура Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = "";
				КонецЕсли;
				Если КиЗРесурс.Значение.Число = 0 Тогда
					Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + ТекСтрока[КиЗ.Ключ];
				ИначеЕсли КиЗРесурс.Значение.Число < 0 Тогда
					Итоги[КиЗ.Ключ] = Прав(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число) + КиЗРесурс.Значение.Разделитель + Итоги[КиЗ.Ключ];
				Иначе
					Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + Лев(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число);
				КонецЕсли;
				Если СтрДлина(Итоги[КиЗ.Ключ]) > КиЗРесурс.Значение.Ограничение Тогда
					Итоги[КиЗ.Ключ] = Лев(Итоги[КиЗ.Ключ], КиЗРесурс.Значение.Ограничение - СтрДлина(КиЗРесурс.Значение.КонецОбрезанный)) + КиЗРесурс.Значение.КонецОбрезанный;
				КонецЕсли;
			ИначеЕсли КиЗРесурс.Значение = "МАССИВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Массив;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ]);
			ИначеЕсли КиЗРесурс.Значение = "МАКСИМУМ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = NULL;
				КонецЕсли;
				#Область ТЕКСТ_ЗАПРОСА
					Запрос = Новый Запрос(
							"ВЫБРАТЬ
							|	&Итог КАК Поле
							|
							|ОБЪЕДИНИТЬ ВСЕ
							|
							|ВЫБРАТЬ
							|	&ТекЗначение
							|
							|УПОРЯДОЧИТЬ ПО
							|	Поле УБЫВ");
				#КонецОбласти 
				Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
				Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
				Выборка = Запрос.Выполнить().Выбрать();
				Выборка.Следующий();
				Итоги[КиЗ.Ключ] = Выборка.Поле;
			ИначеЕсли КиЗРесурс.Значение = "МИНИМУМ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = ТекСтрока[КиЗ.Ключ];
				КонецЕсли;
				#Область ТЕКСТ_ЗАПРОСА
					Запрос = Новый Запрос(
							"ВЫБРАТЬ
							|	&Итог КАК Поле
							|
							|ОБЪЕДИНИТЬ ВСЕ
							|
							|ВЫБРАТЬ
							|	&ТекЗначение
							|
							|УПОРЯДОЧИТЬ ПО
							|	Поле");
				#КонецОбласти 
				Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
				Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
				Выборка = Запрос.Выполнить().Выбрать();
				Выборка.Следующий();
				Итоги[КиЗ.Ключ] = Выборка.Поле;
			ИначеЕсли КиЗРесурс.Значение = "ПРОИЗВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] * ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 1);
			ИначеЕсли КиЗРесурс.Значение = "СУММ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 0);
			ИначеЕсли КиЗРесурс.Значение = "СУМКВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ] * ТекСтрока[КиЗ.Ключ], 0);
			ИначеЕсли КиЗРесурс.Значение = "СООТВЕТСТВИЕ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Соответствие;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
			ИначеЕсли КиЗРесурс.Значение = "СТРУКТУРА" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Структура;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
			ИначеЕсли Лев(КиЗРесурс.Значение, 12) = "Результат = " Тогда
				Итоги[КиЗ.Ключ] = ВыполнитьКод(КиЗРесурс.Значение, Новый Структура("ВсеИтоги,ТекЗначение,СтрокаТЗ", Итоги, ТекСтрока[КиЗ.Ключ], ТекСтрока), Итоги[КиЗ.Ключ]);
			КонецЕсли;
		КонецЦикла;
		ЭтоДубль = Истина;
	КонецЦикла;
	ВОЛНА_ОбщегоНазначенияКС.УдалитьЛишниеСтроки(Результат, КУдалению);
	Возврат Результат
КонецФункции // СвернутьТабЗначенийРасширенно

//Возвращает свёрнутую с использованием запросных аггрегатных функций таблицу значений.
//Параметры:
//	ТабЗн - Таблица значений - сворачиваемая таблица, типизированная под запрос
//	КолонкиИзмерений - Строка - Список имён колонок измерений с разделителем строго "," или ", "
//	КолонкиРесурсов - Строка - Список имён колонок всех ресурсов с разделителем строго "," или ", "
//	КолонкиМаксимум - Строка - Список имён колонок ресурсов, аггрегируемых максимумом,
//			с разделителем ",". По умолчанию "".
//	КолонкиМинимум - Строка - Список имён колонок ресурсов, аггрегируемых минимумом,
//			с разделителем ",". По умолчанию "".
//	КолонкиКоличество - Строка - Список имён колонок ресурсов, аггрегируемых количеством,
//			с разделителем ",". По умолчанию "".
//	КолонкиКР - Строка - Список имён колонок ресурсов, аггрегируемых количеством различных,
//			с разделителем ",". По умолчанию "".
//	КолонкиСреднее - Строка - Список имён колонок ресурсов, аггрегируемых средним,
//			с разделителем ",". По умолчанию "". Остальные ресурсы будут аггрегированы суммой.
//Возвращаемое значение
//	Таблица значений - свёрнутая.
Функция СвернутьТЗЗапросом(ТабЗн, КолонкиИзмерений, КолонкиРесурсов, КолонкиМаксимум = "", КолонкиМинимум = "", КолонкиКоличество = "", КолонкиКР = "", КолонкиСреднее = "") Экспорт
	СтрокаИзмерений = ?(КолонкиИзмерений = "", """ИТОГ""",
			"Источник." + СтрЗаменить(СтрЗаменить(КолонкиИзмерений,
			", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
	СтрокаРесурсов = ?(КолонкиРесурсов = "", "0",
			"Источник." + СтрЗаменить(СтрЗаменить(КолонкиРесурсов,
			", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
	СтрокаАггрегированныхРесурсов = "";
	ТМП = СтрЗаменить(КолонкиРесурсов, ",", Символы.ПС);
	Для Ё = 1 По СтрЧислоСтрок(ТМП) Цикл
		ТекИмя = СтрПолучитьСтроку(ТМП, Ё);
		Аггрегат =?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(КолонкиМаксимум, ТекИмя) > 0, "МАКСИМУМ(",
				?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(КолонкиМинимум, ТекИмя) > 0, "МИНИМУМ(", ?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(КолонкиКР, ТекИмя) > 0, "КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ",
				?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(КолонкиКоличество, ТекИмя) > 0, "КОЛИЧЕСТВО(", ?(ВОЛНА_ОбщегоНазначенияКС.НайтиПодСтроку(КолонкиСреднее, ТекИмя) > 0, "СРЕДНЕЕ(", "СУММА(")))));
		СтрокаАггрегированныхРесурсов = СтрокаАггрегированныхРесурсов + "," + Символы.ПС + Аггрегат + "Источник." + ТекИмя + ") КАК " + ТекИмя;
	КонецЦикла; 
	Запрос = Новый Запрос(СтрЗаменить(СтрЗаменить(СтрЗаменить(
			"ВЫБРАТЬ
			|	Источник.Измерение1,
			|	Источник.Измерение2,
			|	Источник.Ресурс1 КАК Ресурс1,
			|	Источник.Ресурс2 КАК Ресурс2
			|ПОМЕСТИТЬ ВТ__Источник
			|ИЗ
			|	&Источник КАК Источник
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	Источник.Измерение1,
			|	Источник.Измерение2,
			|	СУММА(Источник.Ресурс1) КАК Ресурс1,
			|	СУММА(Источник.Ресурс2) КАК Ресурс2
			|ИЗ
			|	ВТ__Источник КАК Источник
			|
			|СГРУППИРОВАТЬ ПО
			|	Источник.Измерение1,
			|	Источник.Измерение2
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|УНИЧТОЖИТЬ ВТ__Источник", "Источник.Измерение1,
			|	Источник.Измерение2", СтрокаИзмерений), "СУММА(Источник.Ресурс1) КАК Ресурс1,
			|	СУММА(Источник.Ресурс2) КАК Ресурс2", Сред(СтрокаАггрегированныхРесурсов, 3)),
			"Источник.Ресурс1 КАК Ресурс1,
			|	Источник.Ресурс2 КАК Ресурс2", СтрокаРесурсов));
	Запрос.УстановитьПараметр("Источник", ТабЗн);
	Возврат Запрос.Выполнить().Выгрузить();
КонецФункции // СвернутьТЗЗапросом

//Устанавливает на заданную колонку тип по всем её значениям
//(допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗн - Таблица значений, содержащая колонку
//	ИмяКолонки - Имя типизируемой колонки
//	ИмяКолонкиТипов - Имя колонки, по значениям которой определяются типы. По умолчанию "", в этом случае тип определяется по колонке данных
Процедура ТипизироватьКолонку(ТабЗн, Знач ИмяКолонки, ИмяКолонкиТипов = "") Экспорт
	Если ТабЗн.Количество() > 0 Тогда
		Если ИмяКолонкиТипов = "" Тогда
			ИмяКолонкиТипов = ИмяКолонки;
		КонецЕсли;
		ЭтиКолонки = ТабЗн.Колонки;
		МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонкиТипов);
		НоваяКолонка = ЭтиКолонки.Добавить("Временное__Имя__Этой__Колонки",
				ВОЛНА_ОбщегоНазначенияКС.ОписаниеТиповКоллекции(МВыгрузка),
				ЭтиКолонки[ИмяКолонки].Заголовок, ЭтиКолонки[ИмяКолонки].Ширина);
		Если ИмяКолонкиТипов <> ИмяКолонки Тогда
			МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонки);
		КонецЕсли;
		ТабЗн.ЗагрузитьКолонку(МВыгрузка, "Временное__Имя__Этой__Колонки");
		ЭтиКолонки.Удалить(ИмяКолонки);
		ЭтиКолонки.Временное__Имя__Этой__Колонки.Имя = ИмяКолонки
	КонецЕсли
КонецПроцедуры

//Типизирует колонки таблицы значений по содержимому (допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗн - Таблица значений - типизируемая таблица
Процедура ТипизироватьТаблицу(ТабЗн) Экспорт
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из ТабЗн.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	Для Каждого Колонка Из МассивКолонок Цикл
		ТипизироватьКолонку(ТабЗн, Колонка)
	КонецЦикла;
КонецПроцедуры

#КонецОбласти 

//Возвращает список имён колонок таблицы или дерева значений через запятую
//Параметры:
//	ТабИлиДерево - Таблица, Временная таблица или дерево значений - Источник данных
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
//	Разделитель - Строка - раделитель для результата-строки. По умолчанию ",".
//Возвращаемое значение:
//	Строка, Масси в или Список значений - Список имён колонок. Строка - через запятую, список - с заголовками в представлениях.
Функция Список_Колонок(ТабИлиДерево, СтрокаМассивСписок = "Строка", Разделитель = ",") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя, Колонка.Заголовок);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат = Результат + Разделитель + Колонка.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, СтрДлина(Разделитель) + 1);
	КонецЕсли;
	Возврат Результат
КонецФункции // Список_Колонок()
 
#КонецОбласти 

// Дополняет стандартное дерево меню после восстановления пользовательских настроек
// Параметры:
//	Приёмник - ДеревоЗначений - Дополняемое
//	Источник - ДеревоЗначений - Дерево - источник новых строк. Все строки этого дерева будут перенесены в Источник: либо добавлены, либо с перезаписью существующих
//	ИменаКлючевыхКолонок - Строка - Имена колонок, по которым идентифицируются строки. Если не заполнен = строки будут всегда добавляться
//	ИменаКопируемыхКолонок - Строка - Имена колонок, значения которых будут переноситься в приёмник. Если не заполнен - переносятся все, имеющиеся в приёмнике.
//	ПерезаписыватьПустыеПоля - Булево - При Ложь переносятся только непустые значения. По умолчанию Истина.
Процедура ДополнитьДерево(Приёмник, Источник, ИменаКлючевыхКолонок = "", ИменаКопируемыхКолонок = "", ПерезаписыватьПустыеПоля = Истина)
	ИменаКолонокККопированию = ?(ЗначениеЗаполнено(ИменаКопируемыхКолонок), ИменаКопируемыхКолонок, Список_Колонок(Приёмник));
	ЕстьКлючи = ЗначениеЗаполнено(ИменаКлючевыхКолонок);
	Если ЕстьКлючи Тогда
		СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
	КонецЕсли;
	Для каждого Сучок Из Источник.Строки Цикл
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, Сучок);
		Если ЕстьКлючи Тогда
			Получатели = Приёмник.Строки.НайтиСтроки(СтруктураПоиска);
		Иначе
			Получатели = Новый Массив;
		КонецЕсли;
		Если Получатели.Количество() = 0 Тогда
			Получатели.Добавить(Приёмник.Строки.Добавить());
		КонецЕсли;
		Почтальон = Новый Структура(ИменаКолонокККопированию);
		ЗаполнитьЗначенияСвойств(Почтальон, Сучок);
		Если НЕ ПерезаписыватьПустыеПоля Тогда
			ВОЛНА_ОбщегоНазначенияКС.УдалитьПустыеЗначенияИзСтруктуры(Почтальон);
		КонецЕсли;
		Для каждого Получатель Из Получатели Цикл
			ЗаполнитьЗначенияСвойств(Получатель, Почтальон);
			ДополнитьДерево(Получатель, Сучок, ИменаКлючевыхКолонок, ИменаКолонокККопированию, ПерезаписыватьПустыеПоля);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

// Подводит итоги по строкам ветки дерева
// Параметры:
//  Ёлка  - Строка дерева значений - Ветка, строки которой надо итожить
//  Колонки  - Структура - Ключи = колонки, Значения = агрегатные функции:
//			*КОЛИЧЕСТВОНЕПУСТЫХ
//			*КОЛИЧЕСТВОРАЗЛИЧНЫХ
//			*МИНИМУМ
//			*МАКСИМУМ
//			*ПРОИЗВ
//			*СУММА
//			*СУММКВ
//		По умолчанию 1 колонка с именем = "Флаг" и значением = "Минимум"
//	ИтожитьПодчинённые - Булево - подводить итог подчинённых строк. По умолчанию Истина
Процедура ИтогСтрокДерева(Ёлка, Колонки = Неопределено, ИтожитьПодчинённые = Истина) Экспорт
	Если Ёлка.Строки.Количество() Тогда
		Если ИтожитьПодчинённые Тогда
			Для каждого Дочка Из Ёлка.Строки Цикл
				ИтогСтрокДерева(Дочка, Колонки, Истина);
			КонецЦикла;
		КонецЕсли;
		Если Колонки = Неопределено Тогда
			Колонки = Новый Структура("Флаг", "МИНИМУМ");
		КонецЕсли;
		Для каждого КиЗ Из Колонки Цикл
			Если КиЗ.Значение = "КОЛИЧЕСТВОНЕПУСТЫХ" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Если ЗначениеЗаполнено(Дочка[КиЗ.Ключ]) Тогда
						Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + 1;
					КонецЕсли;
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "КОЛИЧЕСТВОРАЗЛИЧНЫХ" Тогда
				ТМП = Новый Соответствие;
				Для каждого Дочка Из Ёлка.Строки Цикл
					ТМП.Вставить(Дочка[КиЗ.Ключ], 0);
				КонецЦикла;
				Ёлка[КиЗ.Ключ] = ТМП.Количество();
			ИначеЕсли КиЗ.Значение = "МИНИМУМ" ИЛИ КиЗ.Значение = "МАКСИМУМ" Тогда
				Порядок_ = ?(КиЗ.Значение = "МАКСИМУМ", " УБЫВ", "");
				Умолчание = NULL;
				ТМП = Новый ТаблицаЗначений;
				ТМП.Колонки.Добавить("Первая");
				Для каждого Дочка Из Ёлка.Строки Цикл
					ТМП.Добавить().Первая = Дочка[КиЗ.Ключ];
				КонецЦикла;
				ТМП.Сортировать("Первая" + Порядок_);
				Ёлка[КиЗ.Ключ] = ?(ТМП.Количество(), ТМП[0].Первая, Умолчание);
			ИначеЕсли КиЗ.Значение = "ПРОИЗВ" Тогда
				Ёлка[КиЗ.Ключ] = 1;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "СУММА" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ];
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "СУММКВ" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
				КонецЦикла;
			КонецЕсли;;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры // ИтогСтрокДерева

// Копирует содержимое одного дерева в другое, существующее
// Параметры:
//  Приёмник  - Дерево значений - Дерево значений, в которое будут добавлены новые данные
//  Источник  - Дерево значений - Дерево значений, из которого будут взяты данные
//  ИменаКлючевыхКолонок  - Строка - Имена колонок для поиска соответствующих строк. Если пустая (по умолчанию), считается, что соответствующих строк нет. Если найдено несколько строк, первая считается найденной.
//  СкоррелироватьКолонки  - Булево - Надо приводить в соответстввие колонки. По умолчанию Истина. Для ветвей приёмника и источника обязательно Ложь.
//  УсловиеОтбора  - Строка - Условие, только при соблюдении которого строки перенесутся. По умолчанию "" = перенос всех.
//			На уровне самого источника не проверяется, только в его строках и ниже. Переменные = имена колонок и СтрокаДЗ. Результат вычисления = Результат.
Процедура СкопироватьДерево(Приёмник, Источник, ИменаКлючевыхКолонок = "", СкоррелироватьКолонки = Истина, ИменаВсехКолонок = "", УсловиеОтбора = "") Экспорт
	Если СкоррелироватьКолонки Тогда
		СкоррелироватьКолонкиТаблиц(Приёмник, Источник, 1);
	КонецЕсли;
	ЭтиСтроки = Приёмник.Строки;
	Если ЗначениеЗаполнено(УсловиеОтбора) И НЕ ЗначениеЗаполнено(ИменаВсехКолонок) Тогда
		ИменаВсехКолонок = Список_Колонок(?(ТипЗнч(Источник) = Тип("ДеревоЗначений"), Источник, Источник.Владелец()));
	КонецЕсли;
	Для каждого СтрокаДЗ Из Источник.Строки Цикл
		СтрокаПриёмник = "";
		Если ЗначениеЗаполнено(УсловиеОтбора) Тогда
			СтрПрм = Новый Структура(ИменаВсехКолонок);
			ЗаполнитьЗначенияСвойств(СтрПрм, СтрокаДЗ);
			СтрПрм.Вставить("СтрокаДЗ", СтрокаДЗ);
			СтрокаОк = ВыполнитьКод(УсловиеОтбора, СтрПрм, Ложь);
		Иначе
			СтрокаОк = Истина;
		КонецЕсли;
		Если СтрокаОк Тогда
			Если ИменаКлючевыхКолонок <> "" Тогда
				СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаДЗ);
				МассивНайденныхСтрок = ЭтиСтроки.НайтиСтроки(СтруктураПоиска);
				Если МассивНайденныхСтрок.Количество() > 0 Тогда
					СтрокаПриёмник = МассивНайденныхСтрок[0];
				КонецЕсли; 
			КонецЕсли; 
			Если СтрокаПриёмник = "" Тогда
				СтрокаПриёмник = ЭтиСтроки.Добавить();
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокаПриёмник, СтрокаДЗ);
			СкопироватьДерево(СтрокаПриёмник, СтрокаДЗ, ИменаКлючевыхКолонок, Ложь, ИменаВсехКолонок, УсловиеОтбора);
		КонецЕсли;
	КонецЦикла; 
КонецПроцедуры // СкопироватьДерево

#КонецОбласти

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возвращает запрос с временной таблицей, содержащей заданные колонки
// Параметры:
//  МассивОбъектов  - Массив или одиночный объект или соответствие - У кого брать реквизиты. Соответствие д.б. в формате (Тип -> Массив объектов)
//  СписокКолонок_  - Строка с разделителем "," или Массив - список имён колонок таблицы-результата
//  Мэппинг  - Соответствие или Строка - (Тип -> Структура(Имя колонки таблицы -> ИмяРеквизита) или Текст запроса для объекта заданного типа). ИмяРеквизита м.б. в формате "ЗНАЧ = [Фиксированное значение или параметр]"
//  ДопПараметры  - Структура - Будет добавлена к параметрам запроса, по умолчанию Неопределено - параметры не добавляются.
// Возвращаемое значение:
//   Запрос   - Запрос со сформированной временной таблицей ВТ_Ответ
Функция РеквизитыРазнотипныхОбъектов(МассивОбъектов, СписокКолонок_ = "Номер,Дата", Мэппинг = Неопределено, ДопПараметры = Неопределено) Экспорт
	СоответствиеТипов = ?(ТипЗнч(МассивОбъектов) = Тип("Соответствие"), МассивОбъектов, ВОЛНА_ОбщегоНазначенияКС.РазбитьПоТипам(ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(МассивОбъектов)));
	Колонки = ?(ТипЗнч(СписокКолонок_) = Тип("Строка"), СтрРазделить(СписокКолонок_, ",", Ложь), СписокКолонок_);
	ТекстЗапроса = "";
	Для каждого ИмяКолонки Из Колонки Цикл
		ТУдалить_ТекстЗапроса= ТУдалить_ТекстЗапроса+ ", NULL КАК " + ИмяКолонки;
	КонецЦикла; 
	ТекстЗапроса = "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + " ПОМЕСТИТЬ ВТ_Ответ ГДЕ ЛОЖЬ" + Символы.ПС;
	Запрос = Новый Запрос(ТекстЗапроса);
	СчПараметров = 0;
	Для каждого КиЗ Из СоответствиеТипов Цикл
		Попытка
			МетаХ = КиЗ.Значение[0].Метаданные();
			ТипОбъекта = ?(Вычислить("ОбщегоНазначения.ЭтоДокумент(МетаХ)"), "Документ", ?(Вычислить("ОбщегоНазначения.ЭтоСправочник(МетаХ)"), "Справочник", ?(Вычислить("ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаХ)"), "ПланВидовХарактеристик", "Прочее")));
		Исключение
			МетаХ = Неопределено;
			ТипОбъекта = "Прочее";
			//ЭтоДокумент = Ложь;
		КонецПопытки;
		ТекМэппинг = ?(Мэппинг = Неопределено, Неопределено, Мэппинг[ТипЗнч(КиЗ.Значение[0])]);
		Если ТипЗнч(ТекМэппинг) = Тип("Строка") Тогда
			ИмяПараметра = "Параметр_" + СчПараметров;
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ " + СтрЗаменить(ТекМэппинг, "[СсылкиНаОбъекты]", ИмяПараметра) + Символы.ПС;
			Запрос.УстановитьПараметр(ИмяПараметра, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		ИначеЕсли ТипОбъекта = "Прочее" Тогда
			Если ТекМэппинг = Неопределено Тогда
				Если Колонки.Найти("Ссылка") <> Неопределено Тогда
					Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
						ЧастныйТекст = "";
						Для каждого Колонка Из Колонки Цикл
							Если Колонка = "Ссылка" Тогда
								ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
								Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение);
								СчПараметров = СчПараметров + 1;
							Иначе
								ЧастныйТекст = ЧастныйТекст + ", NULL";
							КонецЕсли; 
						КонецЦикла; 
						ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
					КонецЦикла; 
				КонецЕсли; 
			Иначе
				Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
					ЧастныйТекст = "";
					Для каждого Колонка Из Колонки Цикл
						Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
							ЧастныйТекст = ЧастныйТекст + ", NULL";
						ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
							ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
						Иначе
							ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
							Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение[ТекМэппинг[Колонка]]);
							СчПараметров = СчПараметров + 1;
						КонецЕсли; 
					КонецЦикла; 
					ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
				КонецЦикла; 
			КонецЕсли; 
		Иначе
			ЧастныйТекст = "";
			Для каждого Колонка Из Колонки Цикл
				Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
					ЧастныйТекст = ЧастныйТекст + ", Док." + Колонка;
				ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
					ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
				Иначе
					ЧастныйТекст = ЧастныйТекст + ", Док." + ТекМэппинг[Колонка];
				КонецЕсли; 
			КонецЦикла; 
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2) + " ИЗ " + ТипОбъекта + "." + МетаХ.Имя + " КАК Док ГДЕ Док.Ссылка В(&Параметр_" + СчПараметров + ")" + Символы.ПС;
			Запрос.УстановитьПараметр("Параметр_" + СчПараметров, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		КонецЕсли;
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	Если ДопПараметры <> Неопределено Тогда
		Для каждого КиЗ Из ДопПараметры Цикл
			Запрос.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
		КонецЦикла; 
	КонецЕсли; 
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.Выполнить();
	Возврат Запрос
КонецФункции // РеквизитыРазнотипныхОбъектов()

#КонецОбласти 

#Область СКД
	
//Возвращает таблицу значений - результат выполнения СКД
//Параметры:
//	СКД - СхемаКомпоновкиДанных - СхемаКомпоновкиДанных
//	НастройкиСКД - Настройки СДК - применяемые при выполнении 
//	ВозможностьПрерыванияПользователем - Булево - Параметр запуска процессора вывода, разрешающий прерывание пользователем
//	НаборыОбъекты - Структура - Источники данных для подстановки в НаборДанныхОбъект. По умолчанию Неопределено.
//	МВТ - МенеджерВременныхТаблиц - Для процессора компоновки. По умолчанию Неопределено.
//Возвращаемое значение:
//	ТаблицаЗначений - Результат выполнения СКД
Функция ТаблицаСКД(СКД, НастройкиСКД = Неопределено, ВозможностьПрерыванияПользователем = Ложь, НаборыОбъекты = Неопределено, МВТ = Неопределено) Экспорт
	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = СКД.НастройкиПоУмолчанию;
	КонецЕсли; 
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиСКД,,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных_ = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных_.Инициализировать(МакетКомпоновки, НаборыОбъекты,,Истина,, МВТ);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	Результат = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных_, ВозможностьПрерыванияПользователем);
	Возврат Результат
КонецФункции

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
#Область ЗАМЕНА_ССЫЛОК

//Вспомогательная для функций замены. Выводит сообщение об ошибке.
//Параметры:
//	Информация - Соответствие - с ключом Описание или Причина.Описание
//	Контекст - Произвольный - Дополнение для вывода после описания причины.
Процедура СообщитьОбОшибкеПриЗаписи(Информация, Контекст)
	Причина = ?(Информация.Причина = Неопределено, Информация, Информация.Причина);
	Сообщить(Причина.Описание + Контекст, СтатусСообщения.Важное);
КонецПроцедуры

//Вспомогательная для следующей экспортной процедуры. Выполняет разовую замену.
//Параметры:
//	ГдеМенять - Произвольный, поддерживающий изменяемые реквизиты - Объект, в котором будет произведена замена
//	Реквизит - Строка - Имя реквизита, в котором будет произведена замена
//	Замены - [Фиксированное] соответствие - Соответствие правильных значений (значения) заменяемым (ключи)
//	Лог - Строка - Комментарий о проделанной работе. По умолчанию "-" - не комментировать
//Возвращаемое значение:
//	Произвольный - значение после замены
Функция ЗаменитьСсылку(ГдеМенять, Реквизит, Замены, Лог = "-")
	ТекЗнч = ГдеМенять[Реквизит];
	ПравильныйЭлемент = Замены[ТекЗнч];
	Если ПравильныйЭлемент <> Неопределено Тогда
		ГдеМенять[Реквизит] = ПравильныйЭлемент;
		Если Лог <> "" Тогда
			Попытка
				ГдеМенятьСтрокой = "" + ГдеМенять;
			Исключение
				ГдеМенятьСтрокой = "" + ТипЗнч(ГдеМенять);
			КонецПопытки;
			Лог = Лог + "В " + Реквизит + " объекта " + ГдеМенятьСтрокой + " " + ТекЗнч + " заменён на " + ПравильныйЭлемент;
		КонецЕсли; 
	КонецЕсли;
	Возврат ПравильныйЭлемент
КонецФункции // ЗаменитьСсылку()
 
//Заменяет значения по таблице замен и помечает на удаление заменяемые значения.
//Параметры:
//	ЗаменяемыеЗначения - Таблица значений - с колонками ЧтоЗаменять, НаЧтоЗаменять, Пометка (флаг необходимости замены) и ПометитьНаУдаление.
//	НайденныеСсылки - Таблица значений - с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВТранзакции - Булево - Выполнять в единой транзакции все замены.
//	БезКонтроля - Булево - Включает режим записи "Загрузка", отменяющий многие контроли при записи и ускоряющий её.
//	ОтменитьРегистрациюВОбменах - Булево - Устанавливает у объектов допсвойство, в типовых конфигурациях блокирующее регистрацию в планах обмена.
//	Лог				-	Строка	-	отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//	Булево - Замена завершена без ошибок
Функция ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление(ЗаменяемыеЗначения, НайденныеСсылки, ВТранзакции = Истина, БезКонтроля = Ложь, ОтменитьРегистрациюВОбменах = Истина, Лог = "-") Экспорт
	Заменяемые = Новый Соответствие;
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.Пометка Тогда
			Заменяемые.Вставить(Стр.ЧтоЗаменять, Стр.НаЧтоЗаменять);
		КонецЕсли;
	КонецЦикла;
	БезОшибок = ЗаменитьСсылкиПоСоответствию(Заменяемые, НайденныеСсылки, ВТранзакции, БезКонтроля, ОтменитьРегистрациюВОбменах, Лог);
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.ПометитьНаУдаление Тогда
			Объект_ = Стр.ЧтоЗаменять.ПолучитьОбъект();
			Если НЕ Объект_.ПометкаУдаления Тогда
				Объект_.ПометкаУдаления = Истина;
				Объект_.ОбменДанными.Загрузка = БезКонтроля;
				Попытка
					Объект_.Записать();
					Если Лог <> "-" Тогда
						Лог = Лог + "Помечен на удаление " + Объект_;
					КонецЕсли; 
				Исключение
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при пометке на удаление)");
					БезОшибок = Ложь;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат БезОшибок
КонецФункции // ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление()

//Заменяет ссылки из таблицы по заданным соответствиям
//Параметры:
//	Заменяемые		-	Соответствие		-	Ключ - заменяемое, Значение - замещающее значение
//	ТаблицаСсылок		-	Таблица значений	-	с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВыполнятьВТранзакции			-	Булево	-	Если Истина (по умолчанию), то одна общая транзакция,
//										Ложь - транзакции по каждому объекту данных.
//										Истина - быстрее и сохраняет целостность, Ложь - помехоустойчивей и надёжнее.
//	ОтключатьКонтрольЗаписи		-	Булево	-	Записывать в режиме загрузки. По умолчанию Истина.
//	ОтменитьРегистрациюВОбменах	-	Булево	-	Записывать без регистрации в обменах данных. По умолчанию Истина.
//	Лог				-	Строка	-	отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//	Булево - Замены выполнены без ошибок
Функция ЗаменитьСсылкиПоСоответствию(Заменяемые, ТаблицаСсылок, ВыполнятьВТранзакции = Истина, ОтключатьКонтрольЗаписи = Истина, ОтменитьРегистрациюВОбменах = Истина, Лог = "-") Экспорт
	МетаВсё = Метаданные;
	МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
	Непериод = МетаСвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
	РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
	АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	БылиИсключения = Ложь;
	МетаРБ = МетаВсё.РегистрыБухгалтерии;
	МетаРС = МетаВсё.РегистрыСведений;
	МетаРР = МетаВсё.РегистрыРасчета;
	МетаРН = МетаВсё.РегистрыНакопления;
	МетаСпр = МетаВсё.Справочники;
	МетаДок = МетаВсё.Документы;
	МетаПВХ = МетаВсё.ПланыВидовХарактеристик;
	МетаПВР = МетаВсё.ПланыВидовРасчета;
	МетаПСЧ = МетаВсё.ПланыСчетов;
	МетаПОБ = МетаВсё.ПланыОбмена;
	МетаБПР = МетаВсё.БизнесПроцессы;
	МетаЗад = МетаВсё.Задачи;
	МетаКон = МетаВсё.Константы;
	МетаПос = МетаВсё.Последовательности;
	МетаОРе = МетаВсё.ОбщиеРеквизиты;
	Если ВыполнятьВТранзакции Тогда
		НачатьТранзакцию();
	КонецЕсли;
	ОбрабатываемаяСсылка = Неопределено;
	ПараметрыХ = Новый Структура;
	Для Каждого РегистрБухгалтерии ИЗ МетаРБ Цикл
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Субконто", РегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто);
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Корреспонденция", РегистрБухгалтерии.Корреспонденция);		
	КонецЦикла;
	//ПараметрыХ.Вставить("Объект", Неопределено);	
	ТабЗамен = ТаблицаСсылок.Скопировать(ТаблицаССылок.НайтиСтроки(Новый Структура("Включено", Истина)), "Данные,Ссылка");
	ТабЗамен.Свернуть("Данные,Ссылка");
	ТабЗамен.Сортировать("Данные,Ссылка");
	ТабЗамен.Индексы.Добавить("Данные,Ссылка");
	ТабДанных = ТабЗамен.Скопировать(,"Данные");
	ТабДанных.Свернуть("Данные");
	ИнфоМД = Новый Соответствие;
	ИнфоОР = Новый Соответствие;
	Данных = ТабДанных.Количество();
	Сч = 0;
	Для каждого СтрокаДанных Из ТабДанных Цикл
		Если Лог <> "-" Тогда
			Сч = Сч + 1;
			Лог = Лог + "Строка " + Сч + " из " + Данных;
		КонецЕсли; 
		Замены = ТабЗамен.НайтиСтроки(Новый Структура("Данные", СтрокаДанных.Данные));
		//Построить соответствие замен для конкретных данных
		ТекЗамены = Новый Соответствие;
		Для каждого СтрокаЗамен Из Замены Цикл
			ТекЗамены.Вставить(СтрокаЗамен.Ссылка, Заменяемые[СтрокаЗамен.Ссылка]);
		КонецЦикла;
		//И перебор по реквизитам данных
		СтроковыйТип = СтрЗаменить(СтрокаДанных.Данные, ".", Символы.ПС);
		МетаХ = ?(СтрПолучитьСтроку(СтроковыйТип, 1) = "РегистрСведенийКлючЗаписи",
				МетаРС.Найти(СтрПолучитьСтроку(СтроковыйТип, 2)), СтрокаДанных.Данные.Метаданные());
		ИнфоЭтиМД = ИнфоМД[МетаХ];
		Если ИнфоЭтиМД = Неопределено Тогда
			ИнфоЭтиМД = Новый Структура;
			ИнфоЭтиМД.Вставить("ЭтоСпр",  МетаСпр.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоДок",  МетаДок.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоБПлан",  МетаПВХ.Содержит(МетаХ)
					  ИЛИ МетаПСЧ.Содержит(МетаХ)
					  ИЛИ МетаПВР.Содержит(МетаХ)
					  ИЛИ МетаБПР.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоЗадача",  МетаЗад.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоРС",  МетаРС.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоКонст",  МетаКон.Содержит(МетаХ));
			ИнфоПослед = Новый Соответствие;
			ИнфоЭтиМД.Вставить("Послед", ИнфоПослед);
			ИнфоЭтиМД.Вставить("Движения", Новый Соответствие);
		Иначе
			ИнфоПослед = ИнфоЭтиМД.Послед;
		КонецЕсли; 
		Если ИнфоЭтиМД.ЭтоКонст Тогда
			Константы[МетаХ.Имя].Установить(Заменяемые[ТекЗамены[0].Ссылка]);
		ИначеЕсли ИнфоЭтиМД.ЭтоРС Тогда
			СтруктураИзмерений = Новый Структура;
			НаборЗаписей = РегистрыСведений[МетаХ.Имя].СоздатьНаборЗаписей();
			Для Каждого Измерение ИЗ МетаХ.Измерения Цикл
				НаборЗаписей.Отбор[Измерение.Имя].Установить(СтрокаДанных.Данные[Измерение.Имя]);
				СтруктураИзмерений.Вставить(Измерение.Имя);
			КонецЦикла;
			Если МетаХ.ПериодичностьРегистраСведений <> Непериод Тогда
				НаборЗаписей.Отбор["Период"].Установить(СтрокаДанных.Данные.Период);
			КонецЕсли;
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ТаблицаНабора = НаборЗаписей.Выгрузить();
			НаборЗаписей.Очистить();
			Если ОтключатьКонтрольЗаписи Тогда
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
			КонецЕсли;
			Если Не ВыполнятьВТранзакции Тогда
				НачатьТранзакцию();
			КонецЕсли;
			Попытка
				НаборЗаписей.Записать();
				Для каждого СтрокаНабора Из ТаблицаНабора Цикл
					Для Каждого Колонка ИЗ ТаблицаНабора.Колонки Цикл
						ПравильныйЭЛемент = ЗаменитьСсылку(СтрокаНабора, Колонка.Имя, ТекЗамены, Лог);
						Если СтруктураИзмерений.Свойство(Колонка.Имя) И (ПравильныйЭЛемент <> Неопределено) Тогда
							НаборЗаписей.Отбор[Колонка.Имя].Установить(ПравильныйЭЛемент);
						КонецЕсли;
					КонецЦикла; 
				КонецЦикла;
				НаборЗаписей.Загрузить(ТаблицаНабора);
				НаборЗаписей.Записать();
				Если Не ВыполнятьВТранзакции Тогда
					ЗафиксироватьТранзакцию();
				КонецЕсли; 
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи регистра сведений)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ОтменитьТранзакцию();
				КонецЕсли;
			КонецПопытки;
		ИначеЕсли ИнфоЭтиМД.ЭтоСпр ИЛИ ИнфоЭтиМД.ЭтоДок ИЛИ ИнфоЭтиМД.ЭтоБПлан ИЛИ ИнфоЭтиМД.ЭтоЗадача Тогда
			ИсключенияВДанных = Ложь;
			Попытка
				ТекОбъект = СтрокаДанных.Данные.ПолучитьОбъект();
				Если ОтменитьРегистрациюВОбменах Тогда
					ТекОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				КонецЕсли; 
				//Для каждого Замена Из Заменяемые Цикл //ТекЗамены Цикл
				//	Ссылка = Замена.Ключ;
				//	ПравильныйЭлемент = Замена.Значение;
				Если ИнфоЭтиМД.ЭтоСпр Тогда //А здесь 80000
					//Если МетаХ.Владельцы.Содержит(Ссылка.Метаданные()) И ТекОбъект.Владелец = Ссылка Тогда
					ЗаменитьСсылку(ТекОбъект, "Владелец", ТекЗамены, Лог);
					Если МетаХ.Иерархический Тогда
						ЗаменитьСсылку(ТекОбъект, "Родитель", ТекЗамены, Лог);
					КонецЕсли;
				КонецЕсли;
				Для Каждого Реквизит Из МетаОРе Цикл //Замедляет, часто запускается! 300 тыс раз при 2000 данных и 3000 пар замен!
					Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
					КонецЕсли; 
				КонецЦикла;
				Для Каждого Реквизит Из МетаХ.Реквизиты Цикл
					//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда //2,7 млн, 5%
					ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
				КонецЦикла;
				Для Каждого ТЧ ИЗ МетаХ.ТабличныеЧасти Цикл
					Если ТекОбъект[ТЧ.Имя].Количество() < 200 Тогда
						//Маленькие ТЧ проще перебрать, избавившись от проверок типов и доп. цикла
						Для каждого Строка_ТЧ_ Из ТекОбъект[ТЧ.Имя] Цикл
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
								ЗаменитьСсылку(Строка_ТЧ_, Реквизит.Имя, ТекЗамены, Лог);
							КонецЦикла; 
						КонецЦикла;
					Иначе
						//В больших ТЧ лучше ограничить число колонок
						Для каждого КиЗ Из ТекЗамены Цикл
							ПравильныйЭлемент = КиЗ.Значение;
							Ссылка = КиЗ.Ключ;
							ТипСсылки = ТипЗнч(Ссылка);
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл //5 млн 7%
								Если Реквизит.Тип.СодержитТип(ТипСсылки) Тогда //10 млн, 10%
									СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									Пока СтрокаТабЧасти <> Неопределено Цикл
										СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
										СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									КонецЦикла;
								КонецЕсли; //2%
							КонецЦикла;
						КонецЦикла; 
					КонецЕсли;
				КонецЦикла;
				Если ИнфоЭтиМД.ЭтоЗадача Тогда
					Для Каждого Реквизит Из МетаХ.РеквизитыАдресации Цикл
						//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
					КонецЦикла;
				КонецЕсли;
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов объекта)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ИсключенияВДанных = Истина;
				КонецЕсли;
			КонецПопытки;
			Если НЕ ИсключенияВДанных Тогда
				КЗаписи = Новый Массив;
				Попытка
					Если ИнфоЭтиМД.ЭтоДок Тогда
						Для Каждого Движение ИЗ МетаХ.Движения Цикл
							ТекВидДвиж = ИнфоЭтиМД.Движения[Движение];
							Если ТекВидДвиж = Неопределено Тогда
								Если МетаРС.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Истина;
									ТекВидДвиж = "РС";
								ИначеЕсли МетаРН.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РН";
								ИначеЕсли МетаРБ.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Истина;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РБ";
								Иначе
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Истина;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РР";
								КонецЕсли; 
								ИнфоЭтиМД.Движения.Вставить(Движение, ТекВидДвиж);
							Иначе
								ЭтоДвижениеРегистраБухгалтерии = ТекВидДвиж = "РБ";
								ЭтоДвижениеРегистраРасчета = ТекВидДвиж = "РР";
								ЭтоДвижениеРегистраСведений = ТекВидДвиж = "РС";
							КонецЕсли;
							ЕстьКорреспонденция = ЭтоДвижениеРегистраБухгалтерии и ПараметрыХ[Движение.Имя + "Корреспонденция"];
							НаборЗаписей  = ТекОбъект.Движения[Движение.Имя];
							НаборЗаписей.Прочитать(); //1698 запусков 4%
							НадоЗаписывать = Ложь;
							ТаблицаНабора = НаборЗаписей.Выгрузить();
							ТеККолво = ТаблицаНабора.Количество();
							Если ТеККолво = 0 Тогда
								Продолжить;
							ИначеЕсли ТекКолво < 200 Тогда
								Для каждого ТекЗапись Из ТаблицаНабора Цикл
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если ЕстьКорреспонденция И НЕ Измерение.Балансовый Тогда // (Измерение.ПризнакУчета <> Неопределено) Тогда
											ИмяРекв = Измерение.Имя + "Дт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
											ИмяРекв = Измерение.Имя + "Кт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										Иначе
											ИмяРекв = Измерение.Имя;
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если ЭтоДвижениеРегистраСведений Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											//Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЗаменитьСсылку(ТекЗапись, Ресурс.Имя, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если ЗаменитьСсылку(ТекЗапись, Реквизит.Имя, ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубДт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе							
												СубКт = "Субконто" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;						
										КонецЦикла;
										//Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Если ЕстьКорреспонденция Тогда
												Если ЗаменитьСсылку(ТекЗапись, "СчетДт", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, "СчетКт", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе
												Если ЗаменитьСсылку(ТекЗапись, "Счет", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;
										//КонецЕсли;
									КонецЕсли;
									Если ЭтоДвижениеРегистраРасчета Тогда
										Если ЗаменитьСсылку(ТекЗапись, "ВидРасчета", ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЕсли;
								КонецЦикла; 
							Иначе
								Для каждого КиЗ Из ТекЗамены Цикл
									ПравильныйЭлемент = КиЗ.Значение;
									Ссылка = КиЗ.Ключ;
									масИменКолонок = Новый Массив;
									// Получим имена измерений, которые могут содержать ссылку
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЕстьКорреспонденция И (Измерение.ПризнакУчета <> Неопределено) Тогда
												масИменКолонок.Добавить(Измерение.Имя + "Дт");
												масИменКолонок.Добавить(Измерение.Имя + "Кт");
											Иначе
												масИменКолонок.Добавить(Измерение.Имя);
											КонецЕсли;
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если ЭтоДвижениеРегистраСведений Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
												масИменКолонок.Добавить(Ресурс.Имя);
											КонецЕсли;
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											масИменКолонок.Добавить(Реквизит.Имя);
										КонецЕсли;
									КонецЦикла;
									// Произведем замены в таблице
									Для Каждого ИмяКолонки Из масИменКолонок Цикл //4 млн 3%
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки); //3,7 млн, 8%
										Пока СтрокаТабЧасти <> Неопределено Цикл //3,7 млн 2%
											СтрокаТабЧасти[ИмяКолонки] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки);
										КонецЦикла;
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубКт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												КонецЦикла;								
											Иначе							
												СубДт = "Субконто" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;							
											КонецЕсли;						
										КонецЦикла;
										Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Для Каждого СтрокаТабЧасти Из ТаблицаНабора Цикл
												Если ЕстьКорреспонденция Тогда
													Если СтрокаТабЧасти.СчетДт = Ссылка Тогда
														СтрокаТабЧасти.СчетДт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
													Если СтрокаТабЧасти.СчетКт = Ссылка Тогда
														СтрокаТабЧасти.СчетКт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												Иначе
													Если СтрокаТабЧасти.Счет = Ссылка Тогда
														СтрокаТабЧасти.Счет = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												КонецЕсли;
											КонецЦикла;
										КонецЕсли;
									КонецЕсли;
									Если ЭтоДвижениеРегистраРасчета Тогда //2% 600000
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										Пока СтрокаТабЧасти <> Неопределено Цикл
											СтрокаТабЧасти["ВидРасчета"] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										КонецЦикла;
									КонецЕсли;
								КонецЦикла; 
							КонецЕсли;
							Если НадоЗаписывать Тогда
								НаборЗаписей.Загрузить(ТаблицаНабора);
								Если ОтключатьКонтрольЗаписи Тогда
									НаборЗаписей.ОбменДанными.Загрузка = Истина;
								КонецЕсли;
								КЗаписи.Добавить(НаборЗаписей);
								//НаборЗаписей.Записать();
							КонецЕсли;
						КонецЦикла;
						Для Каждого Последовательность ИЗ МетаПос Цикл
							//Последовательностей мало, а по уму тоже надо в массив выностить
							ТекПослед = ИнфоПослед[Последовательность];
							Если ТекПослед = Неопределено Тогда
								ТекПослед = Последовательность.Документы.Содержит(МетаХ);
								ИнфоПослед.Вставить(Последовательность, ТекПослед);
								НадоЗаписывать = Ложь;
								НаборЗаписи = Последовательности[Последовательность.Имя].СоздатьНаборЗаписей();
								НаборЗаписи.Отбор.Регистратор.Установить(СтрокаДанных.Данные);
								НаборЗаписи.Прочитать();
								Если НаборЗаписи.Количество() > 0 Тогда
									Для Каждого Измерение ИЗ Последовательность.Измерения Цикл
										Если ЗаменитьСсылку(НаборЗаписи[0], Измерение.Имя, ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
										//Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) И НаборЗаписи[0][Измерение.Имя]=Ссылка Тогда
										Если НадоЗаписывать Тогда
											Если ОтключатьКонтрольЗаписи Тогда
												НаборЗаписи.ОбменДанными.Загрузка = Истина;
											КонецЕсли;
											КЗаписи.Добавить(НаборЗаписей);
											//НаборЗаписи.Записать();
										КонецЕсли;
									КонецЦикла; 
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли; 
				Исключение	
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов движений)");
					БылиИсключения = Истина;
					Если ВыполнятьВТранзакции Тогда
						Прервать; //На откат
					Иначе
						ИсключенияВДанных = Истина;
					КонецЕсли;
				КонецПопытки;
				Если НЕ ИсключенияВДанных Тогда
					Если ОтключатьКонтрольЗаписи Тогда
						ТекОбъект.ОбменДанными.Загрузка = Истина;
					КонецЕсли;
					Если Не ВыполнятьВТранзакции Тогда
						НачатьТранзакцию();
					КонецЕсли;
					Попытка
						Для каждого ТекЗапись Из КЗаписи Цикл
							ТекЗапись.Записать();
						КонецЦикла; 
						ТекОбъект.Записать();
						Если Не ВыполнятьВТранзакции Тогда
							ЗафиксироватьТранзакцию();
						КонецЕсли; 
					Исключение
						СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи движений или объекта)");
						БылиИсключения = Истина;
						Если ВыполнятьВТранзакции Тогда
							Прервать; //На откат
						Иначе
							ОтменитьТранзакцию();
						КонецЕсли;
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Сообщить("Ссылки типа " + МетаХ + " не заменяются!!");
		КонецЕсли; 
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя(); //Надо (А надо ли?) реализовать с переходом на сервер
		#КонецЕсли
	КонецЦикла;
	Если ВыполнятьВТранзакции Тогда
		Если БылиИсключения Тогда
			ОтменитьТранзакцию();
		Иначе
			ЗафиксироватьТранзакцию();
		КонецЕсли;	
	КонецЕсли;
	Возврат Не БылиИсключения;
КонецФункции //ЗаменитьСсылкиПоСоответствию

#КонецОбласти 

// Возвращает таблицу найденных ссылок по массиву искомых ссылок. Также является вспомогательной для функций замены.
// Параметры:
//  Ссылки  - Массив, список значений или ссылка - искомые ссылки
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоМассиву(Ссылки) Экспорт
	Если ТипЗнч(Ссылки) = Тип("СписокЗначений") Тогда
		МассивЗаменяемых = Ссылки.ВыгрузитьЗначения();
	Иначе
		МассивЗаменяемых = Ссылки;
		ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(МассивЗаменяемых, Истина);
	КонецЕсли;
	НайденныеСсылки = НайтиПоСсылкам(МассивЗаменяемых);
	НайденныеСсылки.Колонки[0].Имя = "Ссылка";
	НайденныеСсылки.Колонки[1].Имя = "Данные";
	НайденныеСсылки.Колонки[2].Имя = "Метаданные";
	НайденныеСсылки.Колонки.Добавить("Включено", Новый ОписаниеТипов("Булево"));
	НайденныеСсылки.ЗаполнитьЗначения(Истина, "Включено");
	Возврат НайденныеСсылки;
КонецФункции // НайтиСсылкиПоМассиву()
 
// Возвращает таблицу найденных ссылок по таблице замен с колонками ЧтоЗаменять и Пометка
// Параметры:
//	ТабЗамен - Таблица значений - с колонками Пометка и ЧтоЗаменять
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоТаблицеЗамен(ТабЗамен) Экспорт
	ТабЗаменяемых = ТабЗамен.Скопировать(ТабЗамен.НайтиСтроки(Новый Структура("Пометка", Истина)), "ЧтоЗаменять");
	ТабЗаменяемых.Свернуть("ЧтоЗаменять");
	МассивЗаменяемых = ТабЗаменяемых.ВыгрузитьКолонку("ЧтоЗаменять");
	Если МассивЗаменяемых.Количество() = 0 Тогда
		Сообщить("Не выбрано ни одного значения для поиска!");
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	Возврат НайтиСсылкиПоМассиву(МассивЗаменяемых)
КонецФункции

// Получает ссылку нового или существующего объекта, а если она пустая, то устанавливает её и возвращает новую ссылку.
// Параметры:
//  ПроверяемыйОбъект  - Объект: СправочникОбъект, ДокументОбъект, и т.д. - ссылка на который проверяется
// Возвращаемое значение:
//   Ссылка   -  на объект
Функция СсылкаНаОбъект(ПроверяемыйОбъект) Экспорт
	Если ПроверяемыйОбъект.ЭтоНовый() Тогда
		Результат = ПроверяемыйОбъект.ПолучитьСсылкуНового();
		Если СокрЛП(Результат.УникальныйИдентификатор()) = "00000000-0000-0000-0000-000000000000" Тогда
			Результат = ИмяТаблицыОбъектаПоТипу(ТипЗнч(Результат), "Менеджер").ПолучитьСсылку(Новый УникальныйИдентификатор);//ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
			ПроверяемыйОбъект.УстановитьСсылкуНового(Результат);
		КонецЕсли; 
	Иначе
		Результат = ПроверяемыйОбъект.Ссылка;
	КонецЕсли; 
	Возврат Результат
КонецФункции // СсылкаНаОбъект

#КонецОбласти 

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ

#Область РАСШИФРОВКА

// Заполняет в структуру имена и значения полей расшифровки
// Параметры:
//  Приёмник  - Структура - ключ = имя поля, значение = значение поля
//  ЭлементРасшифровки  - ЭлементРасшифровкиКомпоновкиДанных - поле или группировка, у которого будут искаться родительские поля
Процедура ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, ЭлементРасшифровки) Экспорт
	ТекТип = ТипЗнч(ЭлементРасшифровки);
	Рекурсировать = Ложь;
	Если ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхПоля") Тогда
		Для каждого Поле Из ЭлементРасшифровки.ПолучитьПоля() Цикл
			Приёмник.Вставить(Поле.Поле, Поле.Значение);
		КонецЦикла;
		Рекурсировать = Истина;
	ИначеЕсли ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхГруппировка") Тогда
		Рекурсировать = Истина;
	КонецЕсли;
	Если Рекурсировать Тогда
		Для каждого Родитель_ Из ЭлементРасшифровки.ПолучитьРодителей() Цикл
			ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, Родитель_);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры // ПоляРасшифровкиВСтруктуруРекурсивно

#КонецОбласти
	
#КонецОбласти

#Область УПРАВЛЯЕМАЯ_ФОРМА

// Преобразует таблицу значений в динамический список. ВНИМАНИЕ! Колонки ДС не обновляются, их надо обновлять функцией СоздатьКолонкиТаблицы.
// Параметры:
//  ДинСписок  - Динамический список - Реквизит формы, приёмник
//  ТабИсточник  - Таблица значений - Источник данных. Не проверялось для больших таблиц.
//  ТипизироватьКолонки  - Строка - Список через запятую имён колонок или "ВСЕ". Если пустая строка (по умолчанию) - ни одна колонка не типизируется.
//			Типизация влияет на применение, например, вида сравнения "в иерархии".
//  ИмяПоляКлюча  - Строка - Имя специального поля поле с уникальным номером строки. По умолчанию "КлючСтроки". Если пустое - поле ключа не создаётся
Процедура ДинамическийСписокИзТаблицыЗначений(ДинСписок, ТабИсточник, ТипизироватьКолонки = "", ИмяПоляКлюча = "КлючСтроки") Экспорт
	ПерваяСтрока = Истина;
	#Область ТИПИЗАЦИЯ
		Если ТипизироватьКолонки <> "" Тогда
			#Область ТАБЛИЦА_ПРИМЕРНЫХ_ЗНАЧЕНИЙ
				ОбозначениеПараметра = Новый Цвет;
				ТабЗнТипы = ТабИсточник.СкопироватьКолонки();
				ТабЗнТипы = Новый ТаблицаЗначений;
				Для каждого Колонка Из ТабИсточник.Колонки Цикл
					ТабЗнТипы.Колонки.Добавить(Колонка.Имя);
				КонецЦикла;
				ТабЗнТипы.Добавить();
				СтруктураТипизируемыхКолонок = Новый Структура(ТипизироватьКолонки);
				Для каждого Колонка Из ТабИсточник.Колонки Цикл
					ИмяКолонки = Колонка.Имя;
					ТекТипы = Колонка.ТипЗначения.Типы();
					Если ТекТипы.Количество() И ?(ТипизироватьКолонки = "ВСЕ", Истина, СтруктураТипизируемыхКолонок.Свойство(ИмяКолонки)) Тогда
						ЁХ = 0;
						Для каждого Тек_Тип Из ТекТипы Цикл
							Если ЁХ = ТабЗнТипы.Количество() Тогда
								ТабЗнТипы.Добавить();
							КонецЕсли;
							ТабЗнТипы[ЁХ][ИмяКолонки] = ВОЛНА_ОбщегоНазначенияКС.ПримерноеЗначение(
									Тек_Тип,
									Колонка.ТипЗначения.КвалификаторыЧисла,
									Колонка.ТипЗначения.КвалификаторыСтроки,
									Колонка.ТипЗначения.КвалификаторыДаты);
							ЁХ = ЁХ + 1;
						КонецЦикла;
					Иначе
						ТабЗнТипы[0][ИмяКолонки] = ОбозначениеПараметра;
					КонецЕсли;
				КонецЦикла;
			#КонецОбласти
			#Область ТЕКСТ_ТИПИЗАЦИИ
				ТекстТипизации = "";
				Для каждого Строчка Из ТабЗнТипы Цикл
					ТекстПоСтроке = "";
					Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
						ТекЗнч = Строчка[Колонка.Имя];
						ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС
								+ ?(ЗначениеЗаполнено(ТекЗнч) И ТекЗнч <> ОбозначениеПараметра, ТекЗнч, "&ПараметрПусто")
								+ ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
					КонецЦикла;
					Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
						ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "0"
								+ ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
					КонецЕсли;
					ПерваяСтрока = Ложь;
					ТекстТипизации = ТекстТипизации + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС + "ГДЕ ЛОЖЬ" + Символы.ПС;
				КонецЦикла;
			#КонецОбласти
		КонецЕсли;
	#КонецОбласти
	#Область ФОРМИРОВАНИЕ_ТЕКСТА_И_ПАРАМЕТРОВ_ЗАПРОСА
		#Область ТЕКСТ_ПАРАМЕТРОВ_И_ПАРАМЕТРЫ
			ЁХ = 0;
			ТУдалить_ТекстЗапроса= ТекстТипизации;
			НовыеПараметры = Новый Структура;
			Для каждого Строчка Из ТабИсточник Цикл
				ТекстПоСтроке = "";
				Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
					ИмяКолонки = Колонка.Имя;
					ИмяПараметра = "Строчка" + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0")) + ИмяКолонки;
					ТекЗнч = Строчка[Колонка.Имя];
					НовыеПараметры.Вставить(ИмяПараметра, ТекЗнч);
					ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "&" + ИмяПараметра
							+ ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
				КонецЦикла;
				Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
					ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0"))
							+ ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
				КонецЕсли;
				ПерваяСтрока = Ложь;
				ТекстЗапроса = ТекстЗапроса + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС;
				ЁХ = ЁХ + 1;
			КонецЦикла;
		#КонецОбласти
		#Область БАЗОВЫЙ_И_ФИНАЛЬНЫЙ_ТЕКСТ
			ДинСписок.ТекстЗапроса = Сред(ТекстЗапроса, 16);
			Если СтрНайти(ДинСписок.ТекстЗапроса, "&ПараметрПусто") > 0 Тогда
				ДинСписок.Параметры.УстановитьЗначениеПараметра("ПараметрПусто", Неопределено);
			КонецЕсли;
			Для каждого КиЗ Из НовыеПараметры Цикл
				ДинСписок.Параметры.УстановитьЗначениеПараметра(КиЗ.Ключ, КиЗ.Значение);
			КонецЦикла;
		#КонецОбласти
	#КонецОбласти
КонецПроцедуры // ДинамическийСписокИзТаблицыЗначений

// Формирует реквизит и элемент формы под загрузку заданной таблицы (в т.ч. колонки), а затем загружает туда таблицу
// Параметры:
//  УФорма  - ФормаКлиентскогоПриложения - Форма, которой принадлежит таблица или дерево
//  ИмяПриёмника  - Строка - Имя элемента, соответствующего загружаемой таблице
//  ТабИсточник  - Таблица или дерево значений - Имя реквизита и элемента, соответствующего загружаемой таблице
//	Загружать	- Строка -
//		*"Загрузка" - через Загрузить (только для таблиц значений)
//		*"ЗначВРеквФормы" - через ЗначениеВРеквизитФормы (по умолчанию). Только для одноуровневого пути.
//		*"Нет" - не выполнять
//  ТолькоЭлементы  - Булево - Не выполнять изменение реквизитов формы. По умолчанию Ложь.
// Возвращаемое значение:
//  Массив - имена колонок
Функция СоздатьКолонкиТаблицы(УФорма, ИмяПриёмника, ТабИсточник, Загружать = "ЗначВРеквФормы", ТолькоЭлементы = Ложь) Экспорт
	Результат = Новый Массив;
	МассивДобавляемыхРеквизитов = Новый Массив;
	ПутьКПриёмнику = УФорма.Элементы[ИмяПриёмника].ПутьКДанным;
	#Область РЕКВИЗИТЫ
		Если НЕ ТолькоЭлементы Тогда
			Для Каждого Колонка Из ТабИсточник.Колонки Цикл 
				РеквизитФормы = Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ПутьКПриёмнику, Колонка.Имя); 
				МассивДобавляемыхРеквизитов.Добавить(РеквизитФормы);
				Результат.Добавить(Колонка.Имя);
			КонецЦикла;
			МассивУдаляемыхРеквизитов = Новый Массив;
			Для Каждого РеквизитХ Из УФорма.ПолучитьРеквизиты(ПутьКПриёмнику) Цикл 
				МассивУдаляемыхРеквизитов.Добавить(ПутьКПриёмнику + "." + РеквизитХ.Имя); 
			КонецЦикла;
			УФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов, МассивУдаляемыхРеквизитов);
		КонецЕсли;
	#КонецОбласти
	#Область ЭЛЕМЕНТЫ
		МассивУдаляемыхРеквизитов = Новый Массив;
		Для Каждого КолонкаХ Из УФорма.Элементы[ИмяПриёмника].ПодчиненныеЭлементы Цикл
			МассивУдаляемыхРеквизитов.Добавить(КолонкаХ);
		КонецЦикла;
		Для Каждого КолонкаХ Из МассивУдаляемыхРеквизитов Цикл
			УФорма.Элементы.Удалить(КолонкаХ);
		КонецЦикла;
		Для Каждого Колонка Из ТабИсточник.Колонки Цикл
			Попытка
				Элемент = УФорма.Элементы.Добавить(ИмяПриёмника + "_" + Колонка.Имя, Тип("ПолеФормы"), УФорма.Элементы[ИмяПриёмника]); 
				Элемент.Заголовок = Колонка.Имя;
				Если Колонка.ТипЗначения = Новый ОписаниеТипов("Булево") Тогда
					Элемент.Вид = ВидПоляФормы.ПолеФлажка;
					Элемент.ВидФлажка = ВидФлажка.Флажок;
					Элемент.РежимРедактирования = РежимРедактированияКолонки.Непосредственно;
				Иначе
					Элемент.Вид = ВидПоляФормы.ПолеВвода;
				КонецЕсли;
				Элемент.ПутьКДанным = ПутьКПриёмнику + "." + Колонка.Имя;
			Исключение
				ООш = ОписаниеОшибки();
				Сообщить("Не удалось добавить колонку " + Колонка.Имя + " по причине: " + ООш)
			КонецПопытки;
		КонецЦикла;
	#КонецОбласти 
	Если Загружать <> "Нет" Тогда
		Если Загружать = "Загрузка" Тогда
			ТекстКода = "УФорма." + ПутьКПриёмнику + ".Загрузить(ТабИсточник)";
		Иначе
			ТекстКода = "УФорма.ЗначениеВРеквизитФормы(ТабИсточник, """ + ПутьКПриёмнику + """);";
		КонецЕсли;
		Выполнить(ТекстКода);
	КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьКолонкиТаблицы

#КонецОбласти 

#КонецОбласти

#КонецОбласти

