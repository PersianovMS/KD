#Область БИБЛИОТЕКА_ФУНКЦИЙ_ВС

#Область ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//	ТекстКодаПараметр - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//	ПрямоеОбращение - Строка, Массив - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//			"-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//	Журнал - Булево - Выполнять в попытке и ошибку записать в журнал
//	ИмяПроцесса - Строка - Параметр записи журнала
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке.
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКодНаСервере(
		ТекстКодаПараметр,
		Прм = Неопределено,
		Результат = Неопределено,
		РежимВычисления = Ложь,
		ПрямоеОбращение = "-В",
		Журнал = Ложь,
		ИмяПроцесса = "",
		ПрефиксОшибки = "") Экспорт
	Результат_ = Результат;
	#Область ЗАЩИТА
		//Предполагается, что обычным пользователям доступ к выполнению функции ограничен, так как иначе УстановитьПривилегированныйРежим, и всё доступно.
		//А вот от легального входа ограниченного пользователя внешним соединением с последующим запуском этой функции нужна защита.
		//Специальная роль (которой можно и не делать) ИЛИ Запуск тонкого/толстого клиента ИЛИ Фоновое задание без пользователя.
		//Хотя внешнее соединение тоже может запустить реглзадание, и тут пока нет защиты, хотя ВС должен быть админом для запуска РЗ.
		Попытка
			МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
		Исключение
			МожноВычислять = Ложь;
		КонецПопытки;
		Если ТекущийРежимЗапуска() <> Неопределено ИЛИ
				ИмяПользователя() = "" Тогда
			МожноВычислять = Истина;
		Иначе
			Попытка
				МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
			Исключение
				МожноВычислять = Ложь;
			КонецПопытки;
		КонецЕсли;
	#КонецОбласти
	Если МожноВычислять Тогда
		Результат_ = ВОЛНА_ОбщегоНазначенияКС.ВыполнитьКод(ТекстКодаПараметр, Прм, Результат, РежимВычисления, ПрямоеОбращение, Журнал, ИмяПроцесса, ПрефиксОшибки)
	КонецЕсли;
	Возврат Результат_
КонецФункции

#Конецобласти

#Область КОЛЛЕКЦИИ

#Область ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
	
// В таблице значений заменяет пустые значения на значения по умолчанию из структуры
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Произвольная
//  ЗначенияПоУмолчанию  - Структура - Ключи совпадают с именами колонок, где будет замена. Значения - новые значения.
//	ПрефиксФормулы - значение, начинающееся с этой строки, считается формулой. Обращение к данным строки - Строчка.
Процедура ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию(ТабЗн, ЗначенияПоУмолчанию, ПрефиксФормулы = "FRML") Экспорт
	ДлинаПрефикса = СтрДлина(ПрефиксФормулы);
	Для каждого Строчка Из ТабЗн Цикл
		Для каждого КиЗ Из ЗначенияПоУмолчанию Цикл
			Если НЕ ЗначениеЗаполнено(Строчка[КиЗ.Ключ]) Тогда
				Строчка[КиЗ.Ключ] = ?(Лев(КиЗ.Значение, ДлинаПрефикса) = ПрефиксФормулы, Вычислить(Сред(КиЗ.Значение, ДлинаПрефикса + 1)), КиЗ.Значение);
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
КонецПроцедуры // ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию()

#КонецОбласти 

#КонецОбласти

#КонецОбласти

#Область МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
	
// Запускает менеджер (обработчик) реквизита или события.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"Т:" (рус) - строка,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Имя реквизита, по которому вести распознавание.
//  Родитель  - Родитель, внутри которого вести распознавание.
//  Владелец  - Владелец, внутри которого вести распознавание.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция РассчитатьМенеджерНаСервере(
		Менеджер,
		ПараметрыМенеджера = Неопределено,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		СообщатьСюда = Неопределено) Экспорт
	ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	ЕстьДопИнструменты = ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.ЕстьДопОбработки();
	ТипМенеджера = ТипЗнч(Менеджер);
	Результат = Менеджер;
	ТекстКода = "";
	Распознать = "";
	Если ПараметрыМенеджера = Неопределено Тогда
		ПараметрыМенеджера = Новый Структура; 
	КонецЕсли; 
	
	Если ТипМенеджера = Тип("Строка") Тогда
		//Это строка
		ТекПрефикс = Лев(Менеджер, 2);
		Если ТекПрефикс = "Т:" Тогда
			Результат = Сред(Менеджер, 3);//Получить строку без лишних заморочек
		ИначеЕсли Лев(Менеджер, 11) = "Результат =" Тогда
			ТекстКода = Менеджер;
		ИначеЕсли ТекПрефикс = "F:" Тогда
			ИмяФайла = Сред(Менеджер, 3);
			Результат = ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		ИначеЕсли ТекПрефикс = "В:" Тогда
			Результат = ВыполнитьКод(СтрЗаменить(Сред(Менеджер, 3), Символ(10), " "), ПараметрыМенеджера,, Истина);
		ИначеЕсли ТекПрефикс = "Р:" Тогда
			Распознать = Сред(Менеджер, 3); 
		Иначе
			ПрогКод = СтрЗаменить(Менеджер, Символ(10), " ");
			Попытка
				Результат = ВыполнитьКод(ПрогКод, ПараметрыМенеджера,, Истина);
			Исключение
				Распознать = Менеджер;
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьПП, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаПП), Неопределено) Тогда
		//Это ПП
		ТекстКода = "Результат = Справочники.ВОЛНА_ПереопределяемыеПроцедуры.ВычислитьФункцию(Менеджер,, ПараметрыМенеджера,
				|?(ПараметрыМенеджера.Свойство(""ПолучитьСКД""), ПараметрыМенеджера.ПолучитьСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьНастройкиСКД""), ПараметрыМенеджера.ПолучитьНастройкиСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьПараметры""), ПараметрыМенеджера.ПолучитьПараметры, Ложь));"
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьВО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаВО), Неопределено) Тогда
		//Это ВО
		Если БезопасныйРежим() Тогда
			Результат = Неопределено;
			ДобавитьОшибку(ПараметрыМенеджера, "В безопасном режиме нельзя прочитать временный файл и запустить внешнюю обработку!");
		Иначе
			ТекстКода = "ЭтоОбработка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Менеджер, ""ВидОбработки"") = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
					|Если ЭтоОбработка Тогда
					|	Попытка
					|		ИмяФайла = ПолучитьИмяВременногоФайла();
					|		ДвоичныеДанные = Менеджер.ХранилищеВнешнейОбработки.Получить();
					|		ДвоичныеДанные.Записать(ИмяФайла);
					|		Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, ПараметрыМенеджера);
					|	Исключение
					|		ООШ = ОписаниеОшибки();
					|		ДобавитьОшибку(ПараметрыМенеджера, ООШ);
					|		Результат = Менеджер;
					|	КонецПопытки;
					|КонецЕсли;"
		КонецЕсли; 
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьДО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаДО), Неопределено) Тогда
		//Это ДО
		ТекстКода = "ПараметрыКоманды = Новый Структура(""ДополнительнаяОбработкаСсылка,ИдентификаторКоманды,ОбъектыНазначения"",
				|		Менеджер, ?(ПараметрыМенеджера.Свойство(""ИмяКоманды""), ПараметрыМенеджера.ИмяКоманды, ""ЗапуститьМенеджер""),
				|		?(ПараметрыМенеджера.Свойство(""ОбъектыНазначения""), ПараметрыМенеджера.ОбъектыНазначения, Новый Массив));
				|Если ПараметрыМенеджера.Свойство(""АдресВременногоХранилища"") Тогда
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды, ПараметрыМенеджера.АдресВременногоХранилища);
				|	Результат = ПолучитьИзВременногоХранилища(ПараметрыМенеджера.АдресВременногоХранилища);
				|Иначе
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды);
				|	Результат = ПараметрыКоманды.Результат;
				|КонецЕсли;
				|Если ПараметрыКоманды.Свойство(""ОписаниеОшибки"") Тогда
				|	ДобавитьОшибку(ПараметрыМенеджера, ПараметрыКоманды.ОписаниеОшибки);
				|КонецЕсли";
	ИначеЕсли ОбработкаИсключения <> "" Тогда
		Попытка
			ВыполнитьКод(ОбработкаИсключения, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли;
	Если Распознать <> "" Тогда
		Результат = РаспознатьЗначение(Распознать, ТипыДляРаспознавания, ПоРеквизиту, Родитель, Владелец);
	ИначеЕсли ТекстКода <> "" Тогда
		Попытка
			ВыполнитьКод(ТекстКода, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли; 
	
	Если ПараметрыМенеджера.Свойство("ОписаниеОшибки") Тогда
		ТекстСообщения = ПараметрыМенеджера.ОписаниеОшибки;
		Если ЕстьСтрокаТабло Тогда
			СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;		
		ПараметрыМенеджера.Вставить("ПоследняяОшибка", ПараметрыМенеджера.ОписаниеОшибки);
		ПараметрыМенеджера.Удалить("ОписаниеОшибки");
	КонецЕсли; 
	Возврат Результат;
КонецФункции // РассчитатьМенеджерНаСервере()

//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим уже д.б. проверен. Вспомогательная для РассчитатьМенеджерНаСервере.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом
Функция ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_)
	ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяФайла);
	Возврат ВнешняяОбработка.ЗапуститьМенеджер(Параметры_);
КонецФункции
 
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим проверяется этой функцией. Вспомогательная для РассчитатьМенеджерНаСервере.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод. В ключе "ОписаниеОшибки" возвращается строка - список ошибок выполнения.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом. При ошибке - Неопределено.
Функция ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, Параметры_)
	Если БезопасныйРежим() Тогда
		Результат = Неопределено;
		ДобавитьОшибку(Параметры_, "В безопасном режиме нельзя прочитать " + ИмяФайла);
	Иначе
		Попытка
			Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_);
		Исключение
			Результат = Неопределено;
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(Параметры_, "Обработка " + ИмяФайла + " не была выполнена по причине:" + ООШ);
		КонецПопытки;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Вспомогательная для РассчитатьМенеджерНаСервере.
// Добавляет переданную строку в ключ ОписаниеОшибки структуры параметров.
//Параметры:
//	Параметры_	- Структура - в ключ ОписаниеОшибки которой будет дописано сообщение;
//	Описание	-	Текст описания ошибки, записываемый в структуру
Процедура ДобавитьОшибку(Параметры_, Описание)
	Если Параметры_.Свойство("ОписаниеОшибки") Тогда
		Параметры_.ОписаниеОшибки = Параметры_.ОписаниеОшибки + "; " + Описание;
	Иначе
		Параметры_.Вставить("ОписаниеОшибки", Описание);
	КонецЕсли; 
КонецПроцедуры

//Возвращает результат распознавания строкового значения
//Параметры:
//	Значение_ - Строка - Распознаваемое значение в строковом выражении
//	ТипыИлиМенеджеры - Менеджер ссылочного значения или массив таких менеджеров или тип/массивТипов - типы, в которых ищется ссылочное значение. Если опущен, то возвращается простое нессылочное значение.
//	ПоРеквизиту - Строка - Имя реквизита, в котором ищется значение.
//	Родитель - ЛюбаяСсылка - Если требуется поиск по родителю, то задавать сюда. По умолчанию Неопределено (поиск не используется). Для поиска документа по номеру в этот реквизит надо поместить дату.
//	Владелец - ЛюбаяСсылка - Если требуется поиск по владельцу, то задавать сюда. По умолчанию Неопределено (поиск не используется)
//	АпострофЭтоСтрока - Булево - По умолчанию Истина. Значение, начинающееся с апострофа, будет считаться строкой.
//	НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//Возвращаемое значение:
//	Произвольный - Распознанное значение
Функция РаспознатьЗначение(Значение_, ТипыИлиМенеджеры = "", ПоРеквизиту = "", Родитель = Неопределено, Владелец = Неопределено, АпострофЭтоСтрока = Истина, НеРаспознаватьУИДБезТипа = Ложь) Экспорт
	Результат = Значение_;
	ВРЕГ_ = Врег(Значение_);
	Если АпострофЭтоСтрока И Лев(ВРЕГ_, 1) = "'"  Тогда
		Результат = Сред(Значение_, 2);
	Иначе
		Распознан = Ложь;
		ЭтоСтрока = Ложь;
		ЭтоЧисло = Ложь;
		ЭтоДата = Ложь;
		ЭтоБулево = Ложь;
		ЭтоУниверсал = ТипыИлиМенеджеры = "";
		Если НЕ ЭтоУниверсал Тогда
			мТиМ = ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(ТипыИлиМенеджеры);
			ТипТип = Тип("Тип");
			ТипСтрока = Тип("Строка");
			ТипДата = Тип("Дата");
			ТипЧисло = Тип("Число");
			ТипБулево = Тип("Булево");
			Для каждого ТекТиМ Из мТиМ Цикл
				ТекТип = ТипЗнч(ТекТиМ);
				ОбработатьТип = Ложь;
				Если ТекТип = ТипСтрока Тогда
					ВР_Т = Врег(ТекТиМ);
					Если ВР_Т = "СТРОКА" Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ВР_Т = "БУЛЕВО" Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ВР_Т = "ЧИСЛО" Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ВР_Т = "ДАТА" Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				Иначе
					Если ТекТиМ = ТипСтрока Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ТекТиМ = ТипБулево Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ТекТиМ = ТипЧисло Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ТекТиМ = ТипДата Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				КонецЕсли;
				Если ОбработатьТип Тогда
					Если ТекТип = ТипТип Тогда
						Менеджер = ИмяТаблицыОбъектаПоТипу(ТекТиМ, "Менеджер"); //ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
					ИначеЕсли ТекТип = ТипСтрока Тогда
						Менеджер = Вычислить(ТекТиМ);
					Иначе
						Менеджер = ТекТиМ;
					КонецЕсли; 
					ТипМенеджера = СтрПолучитьСтроку(СтрЗаменить(Менеджер, ".", Символы.ПС), 1);
					ЭтоУИД_ = ВОЛНА_ОбщегоНазначенияКС.ЭтоУИД(Значение_);
					Если ЭтоУИД_ Тогда
						ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение_));
						Если Лев(Строка(ТекСсылка), 18) = "<Объект не найден>" Тогда
							ЭтоУИД_ = Ложь
						Иначе
							Результат = ТекСсылка
						КонецЕсли
					КонецЕсли;
					Если НЕ ЭтоУИД_ И (Менеджер <> Неопределено) Тогда
						Если ТипМенеджера = "ПеречислениеМенеджер" Тогда //"Перечисления"
							//Перечисления грузим особо
							Результат = Менеджер.ПустаяСсылка();
							Если НЕ ПустаяСтрока(Значение_) Тогда
								ЗначенияП = Результат.Метаданные().ЗначенияПеречисления;
								ЗначениеПеречисления = ЗначенияП.Найти(Значение_);
								Если ЗначениеПеречисления = Неопределено Тогда
									Для каждого ЗначениеПеречисления Из ЗначенияП Цикл
										Если ЗначениеПеречисления.Синоним = Значение_ Тогда
											Прервать;
										КонецЕсли; 
									КонецЦикла; 
								КонецЕсли; 
								Если ЗначениеПеречисления <> Неопределено Тогда
									Результат = Менеджер[ЗначениеПеречисления.Имя];
								КонецЕсли; 
							КонецЕсли; 
						Иначе
							Если ПоРеквизиту = "" Тогда
								ПоРеквизиту = ?((ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), "Номер",   //"БизнесПроцессы" "Документы" "Задачи"
										?((ТипМенеджера = "ПланОбменаМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"), "Код", "Наименование"))
							КонецЕсли;
							ИскатьПоНомеру = ?(ПоРеквизиту = "Номер", (ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоКоду = ?(ПоРеквизиту = "Код", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер"), Ложь);
							ИскатьПоНаименованию = ?(ПоРеквизиту = "Наименование", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоРодителю = ?(Родитель = Неопределено, Ложь, (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"));
							ИскатьПОВладельцу = ?(Владелец = Неопределено, Ложь, ТипМенеджера = "СправочникМенеджер");
							Нашлось = Неопределено;
							Если ИскатьПоНомеру Тогда
								Если ТипМенеджера = "ДокументМенеджер" Тогда
									Нашлось = Менеджер.НайтиПоНомеру(Значение_, ?(Родитель = Неопределено, ТекущаяДата(), Родитель))
								Иначе
									Нашлось = Менеджер.НайтиПоНомеру(Значение_)
								КонецЕсли;
							ИначеЕсли ИскатьПоКоду Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Родитель)
									КонецЕсли
								Иначе
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь,, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_)
									КонецЕсли
								КонецЕсли
							ИначеЕсли ИскатьПоНаименованию Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина,, Владелец)
								Иначе
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина)
								КонецЕсли
							Иначе
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_,, Владелец)
								Иначе
									Попытка
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_)
									Исключение
										Нащлось = Ложь;
									КонецПопытки;
								КонецЕсли
							КонецЕсли;
							Если ЗначениеЗаполнено(Нашлось) Тогда
								Результат = Нашлось;
							КонецЕсли; 
						КонецЕсли
					КонецЕсли;
					Если Результат <> Значение_ Тогда
						Распознан = Истина;
						Прервать
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
		Если НЕ Распознан Тогда
			//Возвращается простое значение. Сначала - отработка насильственных типов
			Если (ВРЕГ_ = "ДА" ИЛИ ВРЕГ_ = "ИСТИНА") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Истина;
			ИначеЕсли (ВРЕГ_ = "НЕТ" ИЛИ ВРЕГ_ = "ЛОЖЬ") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Ложь;
			Иначе
				Если ЭтоУниверсал Тогда
					Попытка
						Результат = Вычислить(Значение_);
						Распознан = Истина;
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если НЕ Распознан Тогда
					Если ЭтоУниверсал ИЛИ ЭтоДата Тогда
						Попытка
							ЭтоТолькоВремя = Сред(Значение_, 2, 1) = ":" ИЛИ Сред(Значение_, 3, 1) = ":";
							СтрокаДатаВремя = СтрЗаменить(Значение_, " ", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ":", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, "/", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ".", Символы.ПС);
							Если ЭтоТолькоВремя Тогда
								День    = 1;
								Месяц   = 1;
								Год     = 1;
								Час     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 1, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 2, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3))), 0);
							Иначе
								День    = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Месяц   = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2)));
								Год     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3)));
								Час     = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 3, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 4))), 0);
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 4, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 5))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 5, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 6))), 0);
							КонецЕсли;
							Если ЗначениеЗаполнено(Дата(Год, Месяц, День, Час, Минута, Секунда))  Тогда
								Если Год < 100 И НЕ ЭтоТолькоВремя Тогда
									Год = 2000 + Год
								КонецЕсли
							КонецЕсли;
							Результат = Дата(Год, Месяц, День, Час, Минута, Секунда);
							Распознан = Истина;
						Исключение
						КонецПопытки
					КонецЕсли;
					Если НЕ Распознан Тогда
						Если ЭтоУниверсал ИЛИ ЭтоЧисло Тогда
							Попытка
								Результат = Число(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение_, " ", ""), " ", ""), ",", "."));
								Распознан = Истина;
							Исключение
							КонецПопытки;
						КонецЕсли;
						Если НЕ Распознан Тогда
						    Если ЭтоСтрока Тогда
								Результат = Строка(Значение_);
							ИначеЕсли ЭтоБулево Тогда
								Результат = НЕ ПустаяСтрока(Значение_);
							Иначе
								Если ?(НеРаспознаватьУИДБезТипа, Ложь, ВОЛНА_ОбщегоНазначенияКС.ЭтоУИД(Значение_)) Тогда
									Результат = UUIDToСсылка(Значение_);
								КонецЕсли;
							КонецЕсли;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции //РаспознатьЗначение

#КонецОбласти 

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возвращает структуру реквизитов регистра, где ключ - имя реквизита, а значение - вид реквизита
// Параметры:
//  Регистр  - Строка - Строка вида "РегистрыСведений.АдресныеСведения" или объект регистра, по которому нужна структура.
//  Фильтр  - Строка - "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты" (по умолчанию) или только часть её в том же формате.
//  РазделятьВиды  - Булево - При Истина ключами будут "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", а значениями = структуры с ключами=именами м значениями=видами,
//			а при ЛОЖЬ (по умолчанию) - одна структура с ключами=именами и значениями=видами.
//  ЗначениеКлючей  - Произвольный - Значение, которое будет подставляться вместо видов. Если NULL или не обозначено - см.РазделятьВиды.
// Возвращаемое значение:
//   Структура   - Структура с ключами - имена реквизитов.
Функция СтруктураЗаписиРегистра(Регистр, Фильтр = "", РазделятьВиды = Ложь, ЗначениеКлючей = NULL) Экспорт
	Результат = Новый Структура;
	МетаДашка = Метаданные;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаМесяцРР = Неопределено;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаДашка = Вычислить("МетаДашка." + Регистр);
	СтруктураВозврата = Новый Структура(?(Фильтр = "", "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", Фильтр));
	Для каждого КиЗ Из СтруктураВозврата Цикл
		Для каждого Реквизит Из МетаДашка[КиЗ.Ключ] Цикл
			Результат.Вставить(Реквизит.Имя, ?(ЗначениеКлючей = NULL, КиЗ.Ключ, ЗначениеКлючей));
		КонецЦикла;
		Если РазделятьВиды Тогда
			СтруктураВозврата[КиЗ.Ключ] = Результат;
			Результат = Новый Структура;
		КонецЕсли;
	КонецЦикла;
	Если РазделятьВиды Тогда
		Результат = СтруктураВозврата;
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураЗаписиРегистра

// Загоняет в структуру все реквизиты объекта
// Параметры:
//  Чьих  - любая ссылка - ссылка на объект для чтения в структуру
//  Табчасти  - Булево - считывать ли табчасти
//  ТабчастиПредставлением  - Булево - Вставлять в результат вместо ТЧ строку "Табличная часть". По умолчанию ЛОЖЬ = возвращается табчасть.
//  Общие  - Булево - Включать в результат общие реквизиты.
// Возвращаемое значение:
//   Структура   - ключ - имя реквизита, значение - значение реквизита. Если Чьих не ссылка - ключ "Предмет", а значение - Чьих.
Функция СформироватьСтруктуруВсехРеквизитов(Чьих, Табчасти = Ложь, ТабчастиПредставлением = Ложь, Общие = Истина) Экспорт
	Попытка
		МетаХ = Чьих.Метаданные();
	Исключение
		МетаХ = Неопределено;
	КонецПопытки;
	Если МетаХ = Неопределено Тогда
		Возврат Новый Структура("Предмет", Чьих);
	Иначе
		Результат = Новый Структура;
		Для каждого Реквизит Из МетаХ.Реквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла; 
		Для каждого Реквизит Из МетаХ.СтандартныеРеквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла;
		Если Общие Тогда
			МетаВсё = Метаданные;
			МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
			ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
			РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
			АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
			ИнфоОР = Неопределено;
			Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
				//ЭлементР = Реквизит.Состав.Найти(МетаХ);
				Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
					//?(ЭлементР = Неопределено, Ложь, (ЭлементР.Использование = ИОР.Авто) ИЛИ (ЭлементР.Использование = ИОР.Использовать)) Тогда
					Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
		Если ТабЧасти Тогда
			Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
				Результат.Вставить(ТЧ.Имя, ?(ТабчастиПредставлением, "Табличная часть", Чьих[ТЧ.Имя]));
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
КонецФункции //  СформироватьСтруктуруВсехРеквизитов()

#Область РеквизитыОбъектаПоТипамИлиЗначениям
	
// Возвращает соответствие, где ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
// Параметры:
//  Источник  - Объект или ссылка, допускающие применение Метаданные() - Объект, в котором ищутся типы или значения
//  ТипыИлиЗначения  - Массив - Типы или значения, которые ищутся.
//  ИскатьВСтандартных  - Булево - Надо ли искать в стандартных реквизитах. По умолчанию Истина.
//  ИскатьВОбщих  - Булево - Надо ли искать в общих реквизитах. По умолчанию Истина.
//  ИскатьВТабЧастях  - Булево - Надо ли искать в табчастях. По умолчанию Истина.
// Возвращаемое значение:
//   Соответствие   - ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
Функция РеквизитыОбъектаПоТипамИлиЗначениям(Источник, ТипыИлиЗначения, ИскатьВСтандартных = Истина, ИскатьВОбщих = Истина, ИскатьВТабЧастях = Истина) Экспорт
	ТипТип = Тип("Тип");
	Результат = Новый Соответствие;
	Для каждого ТекЗнч Из ТипыИлиЗначения Цикл
		Результат.Вставить(ТекЗнч, Новый Массив);
	КонецЦикла; 
	МетаХ = Источник.Метаданные();
	РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.Реквизиты, ТипТип);
	Если ИскатьВСтандартных Тогда
		РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.СтандартныеРеквизиты, ТипТип);
	КонецЕсли;
	Если ИскатьВОбщих Тогда
		МетаВсё = Метаданные;
		МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
		ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
		РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
		АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
		ИнфоОР = Неопределено;
		Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
			//ЭлементР = Реквизит.Состав.Найти(МетаХ);
			Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
				РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(Реквизит), ТипТип);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Если ИскатьВТабЧастях Тогда
		Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
			РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ТЧ.Реквизиты, ТипТип, ТЧ.Имя + ".");
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // РеквизитыОбъектаПоТипамИлиЗначениям
 
//Вспомогательная для РеквизитыОбъектаПоТипамИлиЗначениям
// Параметры:
//  Приёмник  - Соответствие - Ключ = обрабатываемое значение, значение - массив имён реквизитов, найденных по значению
//  Источник  - Объект или ссылка - Объект, в котором ищутся значения
//  МетаКоллекция  - Коллекция объектов метаданных - Коллекция, по которой ищутся типы или значения
//  ТипТип  - Тип - Тип("Тип") - уже вычисленный
//  Префикс  - Строка - префикс имени реквизита (путь к родителю)
Процедура РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Приёмник, Источник, МетаКоллекция, ТипТип, Префикс = "")
	Для каждого Реквизит Из МетаКоллекция Цикл
		Для каждого КиЗ Из Приёмник Цикл
			ТекЗнч = КиЗ.Ключ;
			ЭтоТип = ТекЗнч = ТипТип;
			Если ?(ЭтоТип, Реквизит.Тип.СодержитТип(ТекЗнч), Источник[Реквизит.Имя] = ТекЗнч) Тогда
				КиЗ.Значение.Добавить(Префикс + Реквизит.Имя);
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла;
КонецПроцедуры // РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям

// Возвращает, применяется ли общий реквизит для объекта метаданных
// Параметры:
//  МетаХ  - Объект метаданных - для которого проверяется использование общего реквизита
//  ОРеквизит  - Объект метаданных Общий реквизит - для которого проверяется использование общего реквизита
//  ИспользованияОР  - Соответствие - Соответствие, где ключ - ОР, а значение - соответствие, где ключ - метаданные, а значение - булево, использование. Если Неопределено, рассчитывается и возвращается при необходимости.
//  ИОР  - Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  АИОРИ  - Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  РДОРР  - Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
// Возвращаемое значение:
//   Булево   - Истина, если реквизит используется
Функция ОбщийРеквизитИспользуется(МетаХ, ОРеквизит, ИспользованияОР = Неопределено, ИОР = Неопределено,
		АИОРИ = Неопределено, РДОРР = Неопределено) Экспорт
	Если (РДОРР = Неопределено) ИЛИ (ИОР = Неопределено) ИЛИ (АИОРИ = Неопределено) Тогда
		МСО = Метаданные.СвойстваОбъектов;
		РДОРР = МСО.РазделениеДанныхОбщегоРеквизита.Разделять;
		ИОР = МСО.ИспользованиеОбщегоРеквизита;
		АИОРИ = МСО.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли; 
	Если ИспользованияОР = Неопределено Тогда
		ИспользованияОР = Новый Соответствие;
	КонецЕсли; 
	Получен = Ложь;
	Использование_ = ИспользованияОР[ОРеквизит];
	Если Использование_ = Неопределено Тогда
		Использование_ = Новый Соответствие;
		ИспользованияОР.Вставить(ОРеквизит, Использование_);
		Результат = Неопределено;
	Иначе
		Результат = Использование_[МетаХ];
		Получен = Результат <> Неопределено;
	КонецЕсли;
	Если НЕ Получен Тогда
		ЭлементР = ОРеквизит.Состав.Найти(МетаХ);//Замедляет!!!!!! 40% при 250 тыс. запусках (а откуда столько? 250К Общих реквизитов????)
		Результат = Ложь;
		Если ЭлементР <> Неопределено Тогда
			ТекИсп = ЭлементР.Использование;
			Если ТекИсп = ИОР.Авто Тогда
				Если ОРеквизит.АвтоИспользование = АИОРИ Тогда //200000 запусков
					Результат = Истина;
				КонецЕсли; 
			ИначеЕсли ТекИсп = ИОР.Использовать Тогда
				Результат = Истина;
			КонецЕсли; 
			Если ОРеквизит.РазделениеДанных = РДОРР Тогда
				Если Строка(ОРеквизит.УсловноеРазделение) <> "" Тогда
					Попытка
						Результат = Результат И Константы[ОРеквизит.УсловноеРазделение.Имя].Получить();
					Исключение
						
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Использование_.Вставить(МетаХ, Результат);
	Возврат Результат
КонецФункции // ОбщийРеквизитИспользуется

#КонецОбласти 
 
#КонецОбласти 

#Область СКД
	
//Возвращает элементы структуры настроек схемы компоновки данных по их именам
//Параметры:
//  СтруктураСКД  - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - головной элемент структуры СКД (структура, таблица, строки или колонки),  в которой будет поиск
//  Имена  - Строка или Массив (массив изменяется в процессе!) - Через запятую или в массиве - имена элементов, которые надо найти. Имена у искомых элементов д.б. настроены в конфигураторе.
//  Результат  - Структура - Если структура уже есть, и в неё надо добавить элементы, то она передаётся в этом параметре. Она же будет возвращена.
//Возвращаемое значение:
//   Структура   - ключи - переданные имена, разобранные из строки, значения - найденные элементы
Функция НайтиЭлементыСтруктурыКДПоИменам(СтруктураСКД, Имена, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый Структура;
	КонецЕсли;
	МассивХ = ?(ТипЗнч(Имена) = Тип("Массив"), Имена, СтрРазделить(Имена, ",", Ложь));
	Для каждого СтрокаСтруктуры Из СтруктураСКД Цикл
		Индех = МассивХ.Найти(СтрокаСтруктуры.Имя);
		Если Индех <> Неопределено Тогда
			Результат.Вставить(СтрокаСтруктуры.Имя, СтрокаСтруктуры);
			МассивХ.Удалить(Индех);
		КонецЕсли; 
		//Если Флаги.Свойство(СтрокаСтруктуры.Идентификатор) Тогда
		//	СтрокаСтруктуры.Использование = Флаги[СтрокаСтруктуры.Идентификатор];
		//КонецЕсли;
		Если МассивХ.Количество() Тогда
			Тест = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
			ЗаполнитьЗначенияСвойств(Тест, СтрокаСтруктуры);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Колонки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Строки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Структура, МассивХ, Результат);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // НайтиЭлементыСтруктурыКДПоИменам
 
#Область КОПИРОВАНИЕ_ГРУППИРОВКИ_СКД
	
//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию выбранных полей
//Параметры:
//	СтруктураПриёмник - ВыбранныеПоляКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ВыбранноеПолеКомпоновкиДанных или АвтоВыбранноеПолеКомпоновкиДанных или ГруппаВыбранныхПолейКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьВыбранныеПоля(СтруктураПриёмник, Элемент) Экспорт
	Если Тип(Элемент) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Расположение = Элемент.Расположение; 
		НовЭлемент.Поле = Элемент.Поле; 
		Для каждого Элемент Из Элемент.Выбор.Элементы Цикл 
			ДобавитьВыбранныеПоля(НовЭлемент.Выбор.Элементы, Элемент); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Переносит свойства переданного элемента в соответствующий элемент параметров вывода приёмника.
//Параметры:
//	СтруктураПриёмник - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЗначениеПараметраКомпоновкиДанных или ЗначениеПараметраНастроекКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПараметрыВывода(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Найти(Строка(Элемент.Параметр)); 
	НовЭлемент.Значение = Элемент.Значение; 
	НовЭлемент.Использование = Элемент.Использование; 
	Для каждого Элемент Из Элемент.ЗначенияВложенныхПараметров Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.ЗначенияВложенныхПараметров, Элемент); 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию отборов
//Параметры:
//	СтруктураПриёмник - ОтборКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементОтбораКомпоновкиДанных или ГруппаЭлементовОтбораКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьОтбор(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.ВидСравнения = Элемент.ВидСравнения; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.ЛевоеЗначение = Элемент.ЛевоеЗначение; 
		НовЭлемент.ПравоеЗначение = Элемент.ПравоеЗначение; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
		НовЭлемент.ТипГруппы = Элемент.ТипГруппы; 
		Для каждого ЭлементОтбора Из Элемент.Элементы Цикл 
			ДобавитьОтбор(НовЭлемент.Отбор.Элементы, ЭлементОтбора); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию условного оформления
//Параметры:
//	СтруктураПриёмник - УсловноеОформлениеКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементУсловногоОформленияКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьУсловноеОформление(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Добавить(); 
	НовЭлемент.Представление = Элемент.Представление; 
	НовЭлемент.Использование = Элемент.Использование; 
	//отбор 
	Для каждого ЭлементОтбор Из Элемент.Отбор.Элементы Цикл 
		ДобавитьОтбор(НовЭлемент.Отбор.Элементы,ЭлементОтбор); 
	КонецЦикла; 
	//оформление 
	Для каждого ЭлементОформление Из Элемент.Оформление.Элементы Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.Оформление.Элементы,ЭлементОформление); 
	КонецЦикла; 
	//поля 
	Для каждого ЭлементПоле Из Элемент.Поля.Элементы Цикл 
		НовЭлементПоле = НовЭлемент.Поля.Элементы.Добавить(); 
		НовЭлементПоле.Использование = ЭлементПоле.Использование; 
		НовЭлементПоле.Поле = ЭлементПоле.Поле; 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию порядка
//Параметры:
//	СтруктураПриёмник - ПорядокКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементПорядкаКомпоновкиДанных или АвтоЭлементПорядкаКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПорядок(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
		НовЭлемент.ТипУпорядочивания = Элемент.ТипУпорядочивания; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции

//Копирует элемент структуры СКД в другую (или эту же) структуру СКД.
//Содрана https://forum.infostart.ru/forum9/topic47305/
//Параметры:
//	СтруктураПриёмник - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - куда будет помещён новый элемент
//	ЭлементИсточник - ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных или НастройкиВложенногоОбъектаКомпоновкиДанных - Копируемый элемент структуры настроек СКД.
//			Для некоторых типов м.б. не проверено :(
//	ОткудаУдалитьНаСтаромМесте - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - Коллекция, из которой надо удалять старый элемент (Неопределено по умолчанию - не удалять).
//Возвращаемое значение:
//	Того же типа, что и ЭлементИсточник - Добавленный элемент
Функция СкопироватьЭлементВСтруктуруСКД(СтруктураПриёмник, ЭлементИсточник, ОткудаУдалитьНаСтаромМесте = Неопределено) Экспорт 
	
	ЭтоВТаблице = ТипЗнч(СтруктураПриёмник) = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных");
	Результат = ?(ЭтоВТаблице, СтруктураПриёмник.Добавить(), СтруктураПриёмник.Добавить(ТипЗнч(ЭлементИсточник)));
	
	//выбор 
	Для каждого Элемент Из ЭлементИсточник.Выбор.Элементы Цикл 
		ДобавитьВыбранныеПоля(Результат.Выбор.Элементы, Элемент) 
	КонецЦикла; 
	//использование 
	Результат.Использование = ЭлементИсточник.Использование; 
	//имя 
	Результат.Имя = ЭлементИсточник.Имя; 
	//отбор 
	Для каждого Элемент Из ЭлементИсточник.Отбор.Элементы Цикл 
		ДобавитьОтбор(Результат.Отбор.Элементы, Элемент); 
	КонецЦикла; 
	// параметры вывода 
	Для каждого Элемент Из ЭлементИсточник.ПараметрыВывода.Элементы Цикл 
		ДобавитьПараметрыВывода(Результат.ПараметрыВывода.Элементы,Элемент); 
	КонецЦикла; 
	//поля группировки 
	Для каждого Элемент Из ЭлементИсточник.ПоляГруппировки.Элементы Цикл 
		Если ТипЗнч(Элемент) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
			НовЭлемент.КонецПериода = Элемент.КонецПериода; 
			НовЭлемент.НачалоПериода = Элемент.НачалоПериода; 
			НовЭлемент.Поле = Элемент.Поле; 
			НовЭлемент.ТипГруппировки = Элемент.ТипГруппировки; 
			НовЭлемент.ТипДополнения = Элемент.ТипДополнения; 
		ИначеЕсли ТипЗнч(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
		КонецЕсли; 
	КонецЦикла; 
	//порядок 
	Для каждого Элемент Из ЭлементИсточник.Порядок.Элементы Цикл 
		ДобавитьПорядок(Результат.Порядок.Элементы, Элемент); 
	КонецЦикла; 
	//условное оформление 
	Для каждого Элемент Из ЭлементИсточник.УсловноеОформление.Элементы Цикл 
		ДобавитьУсловноеОформление(Результат.УсловноеОформление.Элементы, Элемент); 
	КонецЦикла; 
	
	//обход структуры рекурсивно 
	ТМП = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
	ЗаполнитьЗначенияСвойств(ТМП, ЭлементИсточник);
	Для каждого Подчинённый Из ТМП.Структура Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Структура, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Строки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Строки, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Колонки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Колонки, Подчинённый) 
	КонецЦикла; 
	
	Если ОткудаУдалитьНаСтаромМесте <> Неопределено Тогда
		ОткудаУдалитьНаСтаромМесте.Удалить(ЭлементИсточник);
	КонецЕсли;
	Возврат Результат
КонецФункции 

#КонецОбласти 

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
//Возвращает ссылку по строке УИД
//Параметры:
//	УУИД - Строка - 36 значный УИД
//	НайтиВсе - Булево - Найти все ссылки и вернуть массив. При Ложь будет возвращена первая найденная.
//Возвращаемое значение:
//	Массив/Ссылка/Неопределено - Если НайтиВсе - будет массив, иначеесли найдена ссылка - найденная ссылка, если не найдено ничего - неопределено.
Функция UUIDToСсылка(УУИД, НайтиВсе = Ложь) Экспорт
	Результат = Новый Массив;
	ГдеИщем = Новый Соответствие;
	ГдеИщем.Вставить(Справочники, Метаданные.Справочники);
	ГдеИщем.Вставить(Документы, Метаданные.Документы);
	ГдеИщем.Вставить(ПланыВидовХарактеристик, Метаданные.ПланыВидовХарактеристик);
	ГдеИщем.Вставить(ПланыСчетов, Метаданные.ПланыСчетов);
	ГдеИщем.Вставить(ПланыВидовРасчета, Метаданные.ПланыВидовРасчета);
	ГдеИщем.Вставить(БизнесПроцессы, Метаданные.БизнесПроцессы);
	ГдеИщем.Вставить(Задачи, Метаданные.Задачи);
	ГдеИщем.Вставить(ПланыОбмена, Метаданные.ПланыОбмена);
	НУИД = Новый УникальныйИдентификатор(УУИД);
	Для Каждого ВидМетаданных Из ГдеИщем Цикл
		Для каждого л_Менеджер из ВидМетаданных.Значение Цикл
			л_Ссылка = ВидМетаданных.Ключ[л_Менеджер.Имя].ПолучитьСсылку(НУИД);
			//Элементы.ГруппаСсылки.Заголовок = ТипЗнч(л_Ссылка);
			Если л_Ссылка.ПолучитьОбъект() <> Неопределено Тогда
				Если НайтиВсе Тогда
					Результат.Добавить(л_Ссылка);
				Иначе
					Возврат л_Ссылка
				КонецЕсли; 
			КонецЕсли
		КонецЦикла
	КонецЦикла;
	Возврат ?(НайтиВсе, Результат, Неопределено)
КонецФункции

// Возвращает ссылки по УИД, но поиск происходит только по заданным типам
// Параметры:
//  УУИДы  - Строка или Массив строк - УИДы, по которым надо найти ссылку
//  ГдеИскать  - Массив - Допустимые типы ссылки
// Возвращаемое значение:
//   Массив   - Найденные ссылки или Неопределено
Функция СсылкиЗаданногоТипаПоУИД(УИДы, ГдеИскать) Экспорт
	ЧтоИскать = ВОЛНА_ОбщегоНазначенияКС.ПреобразоватьВМассив(УИДы);
	мГдеИскать = Новый Массив;
	Для каждого ТекТип Из ГдеИскать Цикл
		мГдеИскать.Добавить(ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер").Менеджер);//ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
	КонецЦикла;
	Результат = Новый Массив;
	Для каждого УИД Из ЧтоИскать Цикл
		ТекСсылка = Неопределено;
		Для каждого Менеджер Из мГдеИскать Цикл
			ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИД));
			Если ТекСсылка <> Неопределено Тогда
				Прервать;
			КонецЕсли;
			Результат.Добавить(ТекСсылка);
		КонецЦикла; 
	КонецЦикла;
	Возврат Результат
КонецФункции // СсылкиЗаданногоТипаПоУИД()
 
#КонецОбласти 

#Область СТРОКОВЫЕ

//Создаёт тестер маски.
//Параметры:
//	Маска - Строка - Маска для проверки. По умолчанию - маска проверки даты. Описание синтаксиса маски в функции ПроверитьСтроку
//Возвращаемое значение
//	 ЗначениеXDTO - для тестирования строки по маске
Функция ЗначениеXDTOдляПроВеркиСтроки(Маска = "\d{2}\.\d{2}\.\d{4}") Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Маска + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
КонецФункции // XDTOдляПроВеркиСтроки()
 
// Возврщает дерево процедур и функций модуля с учётом областей.
// Параметры:
//  ТекстМодуля - Строка - Текст модуля, в котором ищутся методы. Считается, что структурирован: не содержит ошибок, заголоврк и ркончание процедур и функций в отдельных строках с начала, ЭКСПОРТ не с новой строки. 
//  ТолькоЭкспорт - Булево - Выбирать только экспортные процедуры
//  ОбластьРодитель - Строка - Имя области, внутри которой ищутся процедуры. Допускается, что в модуле м.б. несколько областей с этим именем. Сам родитель в дерево не попадает. По умолчанию "" - обрабатывается весь модуль.
//  ТегМеню - Строка - Префикс строки (после знака комментария), идентифицирующий в модуле строку представления в дереве. Эта строка может быть в любом месте метода и не включается в другие тексты. По умолчанию "МЕНЮ:".
//	Приёмник - Дерево/Строка дерева - приёмник для дотройки ветви по модулю.
// Возвращаемое значение:
//   Дерево значений   - Список методов модуля с колонками
//		*Представление = для представления в дереве = имя или из строчки с ТегМеню
//		*Имя = Имя метода
//		*Описание = Начальный комментарий до Параметров
//		*ПолноеОписание = Весь начальный комментарий и заголовок метода с параметрами.
//		*Текст = текст метода от заголовка
//		*Вид = Функция или Процедура
//		*Экспорт = Булево
//		*Параметры = Список параметров в составе заголовка
Функция ДеревоМетодовМодуля(ТекстМодуля, ТолькоЭкспорт = Истина, ОбластьРодитель = "", ТегМеню = "МЕНЮ:", Приёмник = Неопределено) Экспорт
	Результат = ?(Приёмник = Неопределено, Новый ДеревоЗначений, Приёмник);
	#Область КОЛОНКИ
		Если Результат.Колонки.Найти("Представление") = Неопределено Тогда
			Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("ПолноеОписание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
			Результат.Колонки.Добавить("Экспорт", Новый ОписаниеТипов("Булево")); 
			Результат.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		КонецЕсли;
	#КонецОбласти
	Стек = Новый Массив;
	Коммент = Ложь; //Строка в теле комментария перед функцией
	Сброс = Истина; //Перед обработкой следующей строки обнулить данные записи
	Тело = Ложь; //Строка в теле функции
	СложныйКоммент = ""; //Комментарий, включающий область
	Заголовок = 0; //0 - это не заголовок, 1 - обработка заголовка до первой скобки, 2 - до второй скобки, 3 - после второй скобки
	Ветка = Результат;
	ДлТМ = СтрДлина(ТегМеню);
	РазрешеноЧтение = ОбластьРодитель = ""; //Строка внутри разрешённой области-родителя
	ИменаКолонок = ВОЛНА_ОбщегоНазначенияСервер.Список_Колонок(Результат);
	#Область ОПИСАНИЕ
		//Вне тела и заголовка метода:
		//	чтение построчно;
		//	[Nпс]// - в начале строки включает режим комментария до конца строки. Включает и продолжает режим описания.
		//	[Nпс]//[Nпс]Параметры отключает режим краткого описания, режим полного остаётся.
		//	[Nпс]& игнорируются.
		//	[Nпс]#Область - прерывают режим описания с отменой. Добавляют уровень подменю.
		//	[Nпс]#КонецОбласти - прерывают режим описания с отменой. Переводят в подменю на уровень выше.
		//	[Nпс][Асинх|][Nпс]Процедура|Функция[Nпс][ИМЯ]( - прерывают режим описаний с принятием. Переводят в режим чтения заголовка, имени и параметров.
		//  Прочие - прерывают режим описания с отменой. Потом игнорируются.
		//В заголовке метода:
		//	чтение посимвольно;
		//	// - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
		//	" - включает/выключает ре.жим текста. В режиме текста ищется только ", а запись заголовка продолжается.
		//	) - Закрывает чтение заголовка и параметров. Проверяется )[Nпс]Экспорт[Nпс].Включает режим тела процедуры/ функции. Не работает в режиме текста
		//В теле метода:
		//	Чтение поиском.
		//	[N*][Nпс]КонецПроцедуры|КонецФункции[Nпс] - завершает запись текста и режим тела метода и переводит в режим "Вне".
		//			Не работает, если внутри режима тела нечёт двойных кавычек вне комментариев. Не работает после символов комментария вне текста.
		//	" - включает/выключает режим текста. В режиме текста ищется только ", а запись текста продолжается.
		//	// - отключает проверку и запись заголовка до конца строки. Не работает в режиме текста
	#КонецОбласти
	Для Ё = 1 По СтрЧислоСтрок(ТекстМодуля) Цикл
		Если Сброс Тогда
			Сброс = Ложь;
			Тело = Ложь;
			Заготовка = Новый Структура(ИменаКолонок);
			//Если СложныйКоммент <> "" Тогда
				Заготовка.Вставить("ПолноеОписание", СложныйКоммент);
			//КонецЕсли;
			Заготовка.Вставить("Текст", "");
			Заготовка.Вставить("Экспорт", Ложь);
			СложныйКоммент = "";
		КонецЕсли;
		ТекСтрока = СокрЛП(СтрПолучитьСтроку(ТекстМодуля, Ё));
		НРегСтрока = НРег(ТекСтрока);
		Готово = Ложь; //Создать строку дерева после обработки строки модуля
		ВТекст = Ложь; //Вставить строку в текст метода
		ВКоммент = Ложь; // Вставить строку в текст комментария
		Если Лев(ТекСтрока, 2) = "//" Тогда
			ТекКоммент = СокрЛП(Сред(ТекСтрока, 3));
			Если Лев(ТекКоммент, ДлТМ) = ТегМеню Тогда
				Заготовка.Вставить("Представление", Сред(ТекКоммент, ДлТМ + 1));
			ИначеЕсли НЕ Тело Тогда
				Если НЕ Коммент Тогда
					Коммент = Истина;
					Заготовка.Вставить("ПолноеОписание", "");
				КонецЕсли;
				Если Лев(ТекКоммент, 9) = "Параметры" Тогда
					Заготовка.Вставить("Описание", Сред(Заготовка.ПолноеОписание, 2));
				КонецЕсли;
				ВКоммент = Истина;
			Иначе
				ВТекст = Истина;
			КонецЕсли; 
		ИначеЕсли Лев(ТекСтрока, 1) = "&" Тогда
			ВТекст = Тело;
		//ИначеЕсли Тело Тогда
		//	ВТекст = Тело;
		Иначе
			Если Лев(НРегСтрока, 5) = "асинх" И Не ЗначениеЗаполнено(Сред(НРегСтрока, 6, 1)) Тогда
				ТекСтрока = СокрЛП(Сред(ТекСтрока, 7));
				НРегСтрока = СокрЛП(Сред(НРегСтрока, 7));
			КонецЕсли;
			ЭтоПроц = Лев(НРегСтрока, 9) = "процедура";
			ЭтоФ = Лев(НРегСтрока, 7) = "функция";
			ЭтоОбл = Лев(НРегСтрока, 8) = "#область";
			ЭтоКОбл = Лев(НРегСтрока, 13) = "#конецобласти";
			ЭтоКПроц = Лев(НРегСтрока, 14) = "конецпроцедуры";
			ЭтоКФ = Лев(НРегСтрока, 12) = "конецфункции";
			Если ЭтоПроц ИЛИ ЭтоФ ИЛИ (Заголовок > 0) Тогда
				Тело = Истина;
				Если ЭтоПроц Или ЭтоФ Тогда
					Заготовка.Вставить("Текст", ТекСтрока);
					Заготовка.Вставить("Вид", ?(ЭтоФ, "Функция", "Процедура"));
					Квант = СокрЛП(Сред(ТекСтрока, ?(ЭтоФ, 9, 11)));
					Заголовок = 1;
					ПроверитьДругиеВарианты = Ложь;
				Иначе
					ПроверитьДругиеВарианты = Заголовок = 3; //Новая строка после скобки может быть новым оператором
					ВТекст = Истина;
					Квант = ТекСтрока;
				КонецЕсли;
				ВКоммент = НЕ ПроверитьДругиеВарианты; //Если нет других вариантов - это заголовок метода, он должен попадать в полный коммент
				//Имя метода
				Если Заголовок = 1 Тогда
					ПСкобки = СтрНайти(Квант, "(");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Имя", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 2;
						Заготовка.Вставить("Параметры", "");
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 2 Тогда
					ПСкобки = СтрНайти(Квант, ")");
					Если ПСкобки = 0 Тогда
						Заготовка.Вставить("Параметры", Заготовка.Параметры + Квант + Символы.ПС);
					Иначе
						Заготовка.Вставить("Параметры", Заготовка.Параметры + Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 3;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 3 Тогда
					Заголовок = 0;
					Заготовка.Вставить("Экспорт", НРег(Лев(Квант, 7)) = "экспорт");
				КонецЕсли;
			Иначе
				ПроверитьДругиеВарианты = Истина;
			КонецЕсли;
			Если ПроверитьДругиеВарианты Тогда
				ВТекст = Тело;
				Если ЭтоОбл И НЕ Тело Тогда
					Сброс = Истина;
					Готово = РазрешеноЧтение;
					Заготовка.Вставить("Вид", "Подменю");
					Заготовка.Вставить("Имя", СокрЛП(Сред(ТекСтрока, 10)));
					Если (Заготовка.Имя = ОбластьРодитель) И (ОбластьРодитель <> "") Тогда
						РазрешеноЧтение = Истина;
					КонецЕсли;
				ИначеЕсли ЭтоКОбл И НЕ Тело Тогда
					Сброс = Истина;
					Если Стек.Количество() = 0 Тогда
						РазрешеноЧтение = Ложь;
					Иначе
						Колво = Ветка.Строки.Количество();
						КомментВОбласти = "";
						УдалитьПодменю = (Колво = 0) ИЛИ ((Колво = 1) И ТолькоЭкспорт);
						УдаляемоеПодменю = Ветка;
						КомментВнутриОбласти = Заготовка.ПолноеОписание;
						Ветка = Стек[Стек.ВГраница()];
						Стек.Удалить(Стек.ВГраница());
						Если УдалитьПодменю Тогда
							СложныйКоммент = "" + УдаляемоеПодменю.ПолноеОписание + Символы.ПС + "#Область" + УдаляемоеПодменю.Имя + Символы.ПС + КомментВнутриОбласти + Символы.ПС + ТекСтрока;
							Если Колво = 1 Тогда
								ЗаполнитьЗначенияСвойств(Ветка.Строки.Добавить(), УдаляемоеПодменю.Строки[0]);
							КонецЕсли;
							Ветка.Строки.Удалить(УдаляемоеПодменю);
						КонецЕсли;
					КонецЕсли; 
				ИначеЕсли ЭтоКПроц ИЛИ ЭтоКФ Тогда
					Готово = Истина;
					Сброс = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Коммент И НЕ Тело Тогда
				Заготовка.Вставить("ПолноеОписание", "");
				Заготовка.Вставить("Описание", "");
			КонецЕсли;
			Коммент = Ложь;
		КонецЕсли;
		Если ВКоммент Тогда
			Заготовка.Вставить("ПолноеОписание", Заготовка.ПолноеОписание + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если ВТекст Тогда
			Заготовка.Вставить("Текст", Заготовка.Текст + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если Готово Тогда
			Если РазрешеноЧтение Тогда
				ЭтоПодменю = Заготовка.Вид = "Подменю";
				Если ЭтоПодменю ИЛИ Заготовка.Экспорт ИЛИ НЕ ТолькоЭкспорт Тогда
					Если ПустаяСтрока(Заготовка.Представление) Тогда
						Заготовка.Вставить("Представление", Заготовка.Имя);
					КонецЕсли;
					НоваяСтрока = Ветка.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Заготовка);
					Если ЭтоПодменю Тогда
						Стек.Добавить(Ветка);
						Ветка = НоваяСтрока;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Готово = Ложь;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ДеревоМетодовМодуля

#КонецОбласти

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ

// Получает табличный документ из двоичных данных Excel или Excel
// Параметры:
//  ДДилиФайл  - ДвоичныеДанные/Строка - ДД, полученные, например, из хранилища или макета/путь к файлу
//  Расширение  - Строка - расширение Excel (нужно только для ДД), по умолчанию xlsx
// Возвращаемое значение:
//   Табличный документ   - Прочитанный из Excel
Функция ТДизExcel(ДДилиФайл, Расширение = "xlsx") Экспорт
	ТекТип = ТипЗнч(ДДилиФайл);
	ЭтоДД = ТекТип = Тип("ДвоичныеДанные");
	Если ТекТип = Тип("Строка") Тогда
		ПутьКФайлуИсточнику = ДДилиФайл;
	ИначеЕсли ЭтоДД Тогда
		ПутьКФайлуИсточнику = ПолучитьИмяВременногоФайла(Расширение);
		ДДилиФайл.Записать(ПутьКФайлуИсточнику);
		ФайлГотов = Истина;
	Иначе
		ПутьКФайлуИсточнику = ДДилиФайл;
	КонецЕсли;
	Результат = Новый ТабличныйДокумент;
	Если ЗначениеЗаполнено(ПутьКФайлуИсточнику) Тогда
		Результат.ИспользуемоеИмяФайла = ПутьКФайлуИсточнику;
		Результат.Прочитать(ПутьКФайлуИсточнику);
	КонецЕсли;
	Если ЭтоДД Тогда
		УдалитьФайлы(ПутьКФайлуИсточнику);
	КонецЕсли;
	Возврат Результат
КонецФункции // ТДизExcel

#Область РАСШИФРОВКА

// Возвращает структуру полей расшифровки ячейки
// Параметры:
//	ИР  - Идентификатор расшифровки КД - ИД для получения данных
//	ДанныеРасшифровки  - Адрес данных расшифровки КД во временном хранилище/ДанныеРасшифровки - Источник получения данных
//	ВключитьНастройки  - Булево - Включить в объект ключ Настройки_ = Структура настроек пасшифровки. Включает только верхний уровень.
//	ВключитьДРО  - Булево - Включить в объект ключ ДРО_ = Данные расшифровки
// Возвращаемое значение:
//	Структура   - Ключи = имена полей, значения = значения полей 
Функция ПоляТекущейРасшифровки(ИР, ДанныеРасшифровки, ВключитьНастройки = Истина, ВключитьДРО = Ложь) Экспорт
	Результат_ = Новый Структура;
	Если ИР <> Неопределено Тогда
		_ДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки);
		эДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки).Элементы[ИР];
		ВОЛНА_ОбщегоНазначенияСервер.ПоляРасшифровкиВСтруктуруРекурсивно(Результат_, эДРО);
		Если эДРО.ПолучитьПоля()[0].Поле = "Результат" Тогда
			//ПолучитьИзВременногоХранилища(ДанныеРасшифровки).Элементы[ИР].ПолучитьРодителей()[0].ПолучитьПоля()[1].Значение
			Для каждого Родитель_ Из эДРО.ПолучитьРодителей() Цикл
				Для каждого ПолеРодителя Из Родитель_.ПолучитьПоля() Цикл
					Результат_.Вставить(ПолеРодителя.Поле, ПолеРодителя.Значение);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		Если ВключитьДРО Тогда
			Результат_.Вставить("ДРО_", _ДРО);
		КонецЕсли;
		Если ВключитьНастройки Тогда
			ТекНастройки = Новый Структура;
			Для каждого ТекЭлемент Из _ДРО.Настройки.ПараметрыДанных.Элементы Цикл
				ТекНастройки.Вставить(СокрЛП(ТекЭлемент.Параметр), ТекЭлемент.Значение);
			КонецЦикла;
			Результат_.Вставить("Настройки_", ТекНастройки);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат_
КонецФункции // ДанныеТекущейРасшифровки

#КонецОбласти
	
#КонецОбласти 

//Возвращает массив видов характеристик, содержащих заданный тип
//ПВХ - строка с именем ПВХ, Тип - Тип
//Параметры:
//	ПВХ - строка -  имя плана вида характеристик
//	Тип - Тип -  искомый тип
//Возвращаемое значение:
//	Массив - виды характеристик, содержащие заданный тип.
Функция ВыбратьПВХСодержащиеТип(ПВХ, Тип) Экспорт
	Массив = Новый Массив;
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	ОбъектыСвойств.Ссылка,
	|	ОбъектыСвойств.ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик." + ПВХ + " КАК ОбъектыСвойств");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(Тип) Тогда
			Массив.Добавить(Выборка.Ссылка)
		КонецЕсли
	КонецЦикла;
	Возврат Массив
КонецФункции

// Формирует записи регистра сведений по переданной таблице значений.
// Параметры:
//	ИмяРегистра - Строка - Имя регистра сведений.
//  ТабЗнач  - Таблица значений - пригодная для загрузки в регистр. При вызове с клиента - массив структур.
//  Перезаписать  - Булево - при Истина регистр будет предварительно очищен, при Ложь (по умолчанию) - нет. При вызове с клиента только Ложь.
//  МаксКолвоДляЗаписиПоОдной  - Число - Оптимизационный параметр. При большом кол-ве записей быстрее записать весь регистр, чем писать записи по одной.
//		Границу определяет этот параметр. По умолчанию 50. При вызове с клиента должен быть больше числа записей - т.е. запись всего регистра вернёт ошибку.
Процедура ЗагрузитьРСИзТаблицы(ИмяРегистра, ТабЗнач, Перезаписать = Ложь, МаксКолвоДляЗаписиПоОдной = 50) Экспорт
	ТабДляЗаписи = ТабЗнач;
	Если Перезаписать Тогда
		ПоОдной = Ложь;
	Иначе
		ПоОдной = ТабЗнач.Количество() <= МаксКолвоДляЗаписиПоОдной;
		Если НЕ ПоОдной Тогда
			ТабДляЗаписи = ВОЛНА_ОбщегоНазначенияСервер.СоздатьЗапрос(
					"ВЫБРАТЬ Рег.* ИЗ РегистрСведений." + ИмяРегистра + " КАК Рег").Выполнить().Выгрузить();
			ВОЛНА_ОбщегоНазначенияСервер.ДобавитьЗаписиИзТаблицыВТаблицу(ТабЗнач, ТабДляЗаписи);
		КонецЕсли;
	КонецЕсли;
	Если ПоОдной Тогда
		Для каждого СтрокаТ Из ТабДляЗаписи Цикл
			ТекЗапись = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(ТекЗапись, СтрокаТ);
			ТекЗапись.Записать();
		КонецЦикла; 
	Иначе
		Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
		Набор.Загрузить(ТабДляЗаписи);
		Набор.Записать(Истина);
	КонецЕсли;
КонецПроцедуры // ЗагрузитьРСИзТаблицы

//!!!Похоже, не работает в модуле повтисп т.к. ругается на первый параметр (Тип):Несоответствие типов (параметр номер '1') (Неверный тип параметра. Допустимы только примитивные типы, ссылки, Структура)
//Функция продублирована сюда, но это по возможности надо исправить
//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//	Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//	Полностью - Булево или Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//		* ИмяТаблицы - Строка - Имя таблицы для запроса;
//		* Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//		* Метаданные - Объект метаданных - соответствующий объекту
//		* Менеджер - Менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//		Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//		Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение -  структура или строка -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
Функция ИмяТаблицыОбъектаПоТипу(Тип_, Полностью = Ложь) Экспорт
	МетаХ = Метаданные.НайтиПоТипу(Тип_);
	Если МетаХ = Неопределено Тогда
		Результат = Неопределено
	ИначеЕсли Полностью = "Метаданные" Тогда
		Результат = МетаХ;
	Иначе
		ТекИмя = МетаХ.Имя;
		Полная = Новый Структура;
		НуженМенеджер = (СтрНайти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
		Если Метаданные.Документы.Содержит(МетаХ) Тогда
			СтрокаТипа = "Документ";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Документы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
			СтрокаТипа = "Справочник";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Справочники[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Перечисления.Содержит(МетаХ) Тогда
			СтрокаТипа = "Перечисление";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Перечисления[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовХарактеристик";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланСчетов";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовРасчета";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
			СтрокаТипа = "БизнесПроцесс";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
			СтрокаТипа = "Задача";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Задачи[ТекИмя]);
			КонецЕсли; 
		Иначе
			Результат = "";
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, СтрНайти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
			Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Текст,") > 0) Тогда
			Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, СтрНайти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
			Полная.Вставить("Метаданные", МетаХ);
		КонецЕсли;
		Результат = Полная;
		Если Результат.Количество() = 1 Тогда
			Для каждого КиЗ Из Полная Цикл
				Результат = КиЗ.Значение;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

// Возвращает массив иерархии объекта. Первый элемент - сам объект, последний - высший родитель
// Параметры:
//  СсылочныйОбъект  - ЛюбаяСсылка с реквизитом Родитель - Объект, мерархию которого надо получить
// Возвращаемое значение:
//   Массив   - Ссылки на объект и по очереди все его родители
Функция МассивИерархии(СсылочныйОбъект) Экспорт
	Результат = Новый Массив;
	ИмяТаблицы = ИмяТаблицыОбъектаПоТипу(ТипЗнч(СсылочныйОбъект)); //ВОЛНА_ОбщегоНазначенияПовтИспСеансВС.
	Родитель = СсылочныйОбъект;
	Пока ЗначениеЗаполнено(Родитель) Цикл
		Результат.Добавить(Родитель);
		#Область ТЕКСТ_ЗАПРОСА
			Родитель = ВОЛНА_ОбщегоНазначенияСервер.ПолучитьЕдинственноеЗначениеЗапроса(ВОЛНА_ОбщегоНазначенияСервер.СоздатьЗапрос(
					СтрЗаменить(
						"ВЫБРАТЬ
						|	Банки.Родитель
						|ИЗ
						|	Справочник.Банки КАК Банки
						|ГДЕ
						|	Банки.Ссылка = &Ссылка", "Справочник.Банки", ИмяТаблицы), Новый Структура("Ссылка", Родитель)));
		#КонецОбласти 
	КонецЦикла;
	Возврат Результат
КонецФункции // МассивИерархии

//Сериализует заданное значение в XML
//Параметры:
//	Значение - Произвольный - Сериализуемое
// Возвращаемое значение:
//	Строка - XML текст
Функция ПолучитьXML(Значение) Экспорт
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(Запись, Значение);
	Возврат Запись.Закрыть();
КонецФункции

//Определяет имя метаданных значения перечисления
//Параметры:
//	ЗначениеПеречисления - ПеречислениеСсылка.* - Ссылка, по которой надо вернуть имя
//Возвращаемое значение:
//	Строка - Имя МД значения перечисления
Функция ПолучитьИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
	ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
	ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя  
КонецФункции

//Копирует отбор набора записей в отбор другого НЗ того же регистра
//Параметры:
//	Приёмник - Набор записей или иной объект, содержащий Отбор. - Объект для настройки отбора
//	Источник - Набор записей или иной объект, содержащий Отбор. - Откуда берётся отбор для настройки
Процедура СкопироватьОтборы(Приёмник, Источник) Экспорт
	Для каждого ЭлементОтбора_ из Источник.Отбор Цикл
		ЭлементПриёмник = Приёмник.Отбор.Найти(ЭлементОтбора_.Имя);
		ЭлементПриёмник.Использование = ЭлементОтбора_.Использование;
		ЭлементПриёмник.ВидСравнения = ЭлементОтбора_.ВидСравнения;
		ЭлементПриёмник.Значение = ЭлементОтбора_.Значение;
		ЭлементПриёмник.ЗначениеС = ЭлементОтбора_.ЗначениеС;
		ЭлементПриёмник.ЗначениеПо = ЭлементОтбора_.ЗначениеПо
	КонецЦикла
КонецПроцедуры

//Возвращает список значений с именами временных таблиц МВТ.
Функция СписокВременныхТаблиц(МВТ) Экспорт
	Результат = Новый СписокЗначений;
	Если ТипЗнч(МВТ) = Тип("МенеджерВременныхТаблиц") Тогда
		Для каждого ВТаб Из МВТ.Таблицы Цикл
			Результат.Добавить(ВТаб.ПолноеИмя, ВТаб.ПолноеИмя);
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции // СписокВременныхТаблиц()

#КонецОбласти

