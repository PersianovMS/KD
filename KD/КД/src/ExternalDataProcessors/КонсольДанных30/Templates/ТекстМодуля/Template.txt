#Область БИБЛИОТЕКА_ФУНКЦИЙ

#Область ОТЛАДКА

//Читает набор записей и возвращает таблицу значений - его содержимое.
//Иногда может быть пригодна для чтения движений, уже записанных в базу.
//Параметры:
//	НаборЗаписей - Набор записей регистра - читаемый набор записей.
//Возвращаемое значение - Таблица значений - Куда выгружен прочитанный НЗ.
Функция ПрочитатьНаборЗаписейДляОтладки(НаборЗаписей, ВернутьКакБыло = Истина) Экспорт
	Попытка
		Если НаборЗаписей.Количество() = 0 Тогда
			Если ВернутьКакБыло Тогда
				ВремТЗ = НаборЗаписей.Выгрузить();
				НаборЗаписей.Прочитать();
				Результат = НаборЗаписей.Выгрузить();
				НаборЗаписей.Загрузить(ВремТЗ);
			Иначе
				НаборЗаписей.Прочитать();
				Результат = НаборЗаписей.Выгрузить();
			КонецЕсли; 
		КонецЕсли;	
	Исключение
		Результат = Ложь;
	КонецПопытки;	
	Возврат Результат
КонецФункции

//Выполняет код и возвращает рассчитанное значение
//Параметры:
//	ТекстКода - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКод(ТекстКода, Прм = Неопределено, Результат = Неопределено, РежимВычисления = Ложь) Экспорт
	Результат = Неопределено;
	Если РежимВычисления Тогда
		Результат = Вычислить(ТекстКода);
	Иначе
		Выполнить(ТекстКода);
	КонецЕсли; 
	Возврат Результат
КонецФункции

//Генерит ошибку для запуска конфигуратора
Процедура ПерейтиВКонфигуратор() Экспорт
	Ы = 1/0
КонецПроцедуры

//Выполняет произвольный код, и об ошибках делает запись в журнал. Возвращает текст ошибки
// Параметры:
//	ТекстКода - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	ИмяПроцесса - Строка - Параметр записи журнала
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке.
//Возвращаемое значение:
//		Неопределено, Строка - Описание ошибки. Если ошибки нет - Неопределено
Функция ВыполнитьКодСЗаписьюОшибкиВЖурнал(ТекстКода = "", Прм = Неопределено, ИмяПроцесса = "", ПрефиксОшибки = "") Экспорт
	Результат = Неопределено;
	Попытка
		Выполнить(ТекстКода);
	Исключение
		Результат = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ПрефиксОшибки + Результат);
	КонецПопытки;
	Возврат Результат
КонецФункции // СформироватьФайлы

#Конецобласти

#Область МЕНЕДЖЕРЫ
	
// Запускает менеджер (обработчик) реквизита или события.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  Прм (ПараметрыМенеджера)  - Структура - Параметры, передаваемые для применения в менеджере
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция ЗапуститьМенеджер(
		Менеджер,
		ПараметрыМенеджера,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено) Экспорт
	ЕстьДопИнструменты = ЕстьДопОбработки();
	ТипМенеджера = ТипЗнч(Менеджер);
	Результат = Менеджер;
	ТекстКода = "";
	Распознать = "";
	
	Если ТипМенеджера = Тип("Строка") Тогда
		//Это строка
		ТекПрефикс = Лев(Менеджер, 2);
		Если Лев(Менеджер, 11) = "Результат =" Тогда
			ТекстКода = Менеджер;
		ИначеЕсли ТекПрефикс = "F:" Тогда
			ИмяФайла = Сред(Менеджер, 3);
			Результат = ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		ИначеЕсли ТекПрефикс = "В:" Тогда
			Результат = ВыполнитьКод(СтрЗаменить(Сред(Менеджер, 3), Символ(10), " "), ПараметрыМенеджера,, Истина);
		ИначеЕсли ТекПрефикс = "Р:" Тогда
			Распознать = Сред(Менеджер, 3); 
		Иначе
			ПрогКод = СтрЗаменить(Менеджер, Символ(10), " ");
			Попытка
				Результат = ВыполнитьКод(ПрогКод, ПараметрыМенеджера,, Истина);
			Исключение
				Распознать = Менеджер;
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьПП, Тип(ЕстьДопИнструменты.ИмяТипаПП), Неопределено) Тогда
		//Это ПП
		ТекстКода = "Результат = Справочники.ВОЛНА_ПереопределяемыеПроцедуры.ВычислитьФункцию(Менеджер,, ПараметрыМенеджера,
				|?(ПараметрыМенеджера.Свойство(""ПолучитьСКД""), ПараметрыМенеджера.ПолучитьСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьНастройкиСКД""), ПараметрыМенеджера.ПолучитьНастройкиСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьПараметры""), ПараметрыМенеджера.ПолучитьПараметры, Ложь));"
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьВО, Тип(ЕстьДопИнструменты.ИмяТипаВО), Неопределено) Тогда
		//Это ВО
		Если БезопасныйРежим() Тогда
			Результат = Неопределено;
			ДобавитьОшибку(ПараметрыМенеджера, "В безопасном режиме нельзя прочитать временный файл и запустить внешнюю обработку!");
		Иначе
			ТекстКода = "ЭтоОбработка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Менеджер, ""ВидОбработки"") = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
					|Если ЭтоОбработка Тогда
					|	Попытка
					|		ИмяФайла = ПолучитьИмяВременногоФайла();
					|		ДвоичныеДанные = Менеджер.ХранилищеВнешнейОбработки.Получить();
					|		ДвоичныеДанные.Записать(ИмяФайла);
					|		Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, ПараметрыМенеджера);
					|	Исключение
					|		ООШ = ОписаниеОшибки();
					|		ДобавитьОшибку(ПараметрыМенеджера, ООШ);
					|		Результат = Менеджер;
					|	КонецПопытки;
					|КонецЕсли;"
		КонецЕсли; 
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьДО, Тип(ЕстьДопИнструменты.ИмяТипаДО), Неопределено) Тогда
		//Это ДО
		ТекстКода = "ПараметрыКоманды = Новый Структура(""ДополнительнаяОбработкаСсылка,ИдентификаторКоманды,ОбъектыНазначения"",
				|		Менеджер, ?(ПараметрыМенеджера.Свойство(""ИмяКоманды""), ПараметрыМенеджера.ИмяКоманды, ""ЗапуститьМенеджер""),
				|		?(ПараметрыМенеджера.Свойство(""ОбъектыНазначения""), ПараметрыМенеджера.ОбъектыНазначения, Новый Массив));
				|Если ПараметрыМенеджера.Свойство(""АдресВременногоХранилища"") Тогда
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды, ПараметрыМенеджера.АдресВременногоХранилища);
				|	Результат = ПолучитьИзВременногоХранилища(ПараметрыМенеджера.АдресВременногоХранилища);
				|Иначе
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды);
				|	Результат = ПараметрыКоманды.Результат;
				|КонецЕсли;
				|Если ПараметрыКоманды.Свойство(""ОписаниеОшибки"") Тогда
				|	ДобавитьОшибку(ПараметрыМенеджера, ПараметрыКоманды.ОписаниеОшибки);
				|КонецЕсли";
	ИначеЕсли ОбработкаИсключения <> "" Тогда
		Попытка
			ВыполнитьКод(ОбработкаИсключения, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли;
	Если Распознать <> "" Тогда
		Результат = РаспознатьЗначение(Распознать, ТипыДляРаспознавания, ПоРеквизиту, Родитель, Владелец);
	ИначеЕсли ТекстКода <> "" Тогда
		Попытка
			ВыполнитьКод(ТекстКода, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли; 
	
	Если ПараметрыМенеджера.Свойство("ОписаниеОшибки") Тогда
		Сообщить(ПараметрыМенеджера.ОписаниеОшибки);
		ПараметрыМенеджера.Вставить("ПоследняяОшибка", ПараметрыМенеджера.ОписаниеОшибки);
		ПараметрыМенеджера.Удалить("ОписаниеОшибки");
	КонецЕсли; 
	Возврат Результат;
КонецФункции // ЗапуститьМенеджер()

//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим уже д.б. проверен. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом
Функция ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_)
	ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяФайла);
	Возврат ВнешняяОбработка.ЗапуститьМенеджер(Параметры_);
КонецФункции
 
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим проверяется этой функцией. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод. В ключе "ОписаниеОшибки" возвращается строка - список ошибок выполнения.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом. При ошибке - Неопределено.
Функция ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, Параметры_)
	Если БезопасныйРежим() Тогда
		Результат = Неопределено;
		ДобавитьОшибку(Параметры_, "В безопасном режиме нельзя прочитать " + ИмяФайла);
	Иначе
		Попытка
			Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_);
		Исключение
			Результат = Неопределено;
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(Параметры_, "Обработка " + ИмяФайла + " не была выполнена по причине:" + ООШ);
		КонецПопытки;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Вспомогательная для ЗапуститьМенеджер.
// Добавляет переданную строку в ключ ОписаниеОшибки структуры параметров.
//Параметры:
//	Параметры_	- Структура - в ключ ОписаниеОшибки которой будет дописано сообщение;
//	Описание	-	Текст описания ошибки, записываемый в структуру
Процедура ДобавитьОшибку(Параметры_, Описание)
	Если Параметры_.Свойство("ОписаниеОшибки") Тогда
		Параметры_.ОписаниеОшибки = Параметры_.ОписаниеОшибки + "; " + Описание;
	Иначе
		Параметры_.Вставить("ОписаниеОшибки", Описание);
	КонецЕсли; 
КонецПроцедуры

#КонецОбласти 

#Область ИНТЕРАКТИВ

#Если Клиент Тогда

// Предлагает выбрать реквизит заданного объекта и возвращает его имя
// Параметры:
//  ЧейРеквизит  - Произвольный - Объект, реквизит которого будет предложен к выбору
// Возвращаемое значение:
//   Строка   - Имя ТЧ и реквизита, например "Банк" или "Товары.Количество"
Функция ИмяВыбранногоРеквизита(ЧейРеквизит) Экспорт
	Результат = "НЕ ГОТОВО";
	//Реализовать одним из двух вариантов:
	//А) открыть дерево МД в нужной ветке
	//Б) прочитать МД со значениями (для ТЧ и ТЗ - первой строки)
	//Также должны отрабатываться ситуации для таблицы значений, массива, списка значений, структуры и их фиксиков.
	Возврат Результат
КонецФункции // ИмяВыбранногоРеквизита()
 
// Возвращает ответ, данный пользователем несколько раз (для предотвращения случайных опаснх действий)
//
// Параметры:
//  Кнопки  - РежимДиалогаВопрос; СписокЗначений - параметр функции Вопрос, по умолчанию РежимДиалогаВопрос.ДаНет
//  КоличествоПовторов  - Число - Количество попыток (сколько раз спросить)
//  ТекстВопроса  -  Строка; ФорматированнаяСтрока - параметр функции Вопрос
//  ТаймАут  - Число - параметр функции Вопрос
//  КнопкаПоУмолчанию  - Произвольный - параметр функции Вопрос
//  Заголовок  - Строка; ФорматированнаяСтрока - параметр функции Вопрос
//  КнопкаТаймАута  - Произвольный - параметр функции Вопрос
//
// Возвращаемое значение:
//   Произвольный   - Если пользователь назвал во всех попытках одно значение - то оно, если нет - неопределено
//
Функция СпроситьТрижды(Кнопки = Неопределено, КоличествоПовторов = 3, ТекстВопроса = "", ТаймАут = 0, КнопкаПоУмолчанию = Неопределено, Заголовок = "Хитрый вопрос", КнопкаТаймАута = Неопределено) Экспорт
	Если Кнопки = Неопределено Тогда
		Кнопки = РежимДиалогаВопрос.ДаНет;
	КонецЕсли;
	Результат = Неопределено;
	Для Ё = 1 По КоличествоПовторов Цикл
		Если ТипЗнч(Кнопки) = Тип("СписокЗначений") Тогда
			ПеремешатьСписок(Кнопки);	
		КонецЕсли; 
		Промежуточный = Вопрос(ТекстВопроса, Кнопки, ТаймАут, КнопкаПоУмолчанию, Заголовок, КнопкаТаймАута);
		Если Результат = Неопределено Тогда
			Результат = Промежуточный;
		ИначеЕсли Результат <> Промежуточный Тогда
			Результат = Неопределено;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Возврат Результат;
КонецФункции // СпроситьТрижды()
#КонецЕсли
	
#КонецОбласти 

#Область КОЛЛЕКЦИИ

#Область ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
	
//Возвращает количество элементов коллекции-параметра, а если параметр - не коллекция, то
//	* -2, если значение - пустая ссылка
//	* -1 - иначе
//Параметры:
//	Коллекция - Произвольная коллекция - Кого посчитают :)
Функция КоличествоКоллекции(Коллекция) Экспорт
	Попытка
		КолвоПараметров = Коллекция.Количество();
	Исключение
		КолвоПараметров = -1;
		Попытка
			Если Коллекция.Пустая() Тогда КолвоПараметров = -2 КонецЕсли
		Исключение
		КонецПопытки;
	КонецПопытки;
	Возврат КолвоПараметров
КонецФункции

// Выгружает колонку коллекции (не обязательно ТЗ!) в строку с разделителями. Можно использовать, например, для получения строки для Свернуть.
// Параметры:
//  Коллекция		- любая коллекция с колонками (реквизитами строк) - источник данных
//  ИмяРеквизита	- строка - имя реквизита, из которого будет сформирована строка
//  Разделитель		- любое значение, преобразуемое в строку - разделитель для строки-результата
// Возвращаемое значение:
//   Строка   - строка с разделителями, содержащая представления заданного реквизита строк
Функция КолонкуКоллекцииВСтрокуСРазделителями(Коллекция, ИмяРеквизита, Разделитель = ",") Экспорт
	Результат = "";
	Для каждого Строчка Из Коллекция Цикл
		Результат = Результат + Разделитель + Строчка[ИмяРеквизита];
	КонецЦикла;
	Возврат Сред(Результат, СтрДлина(Разделитель) + 1);
КонецФункции // КолонкуКоллекцииВСтрокуСРазделителями()
 
//Удаляет заданные элементы из коллекции
//Параметры:
//	пКоллекция - Произвольная коллекция - откуда удалить элементы
//	пмЛишниеСтроки - Массив - Удаляемые элементы
Процедура УдалитьЛишниеСтроки(пКоллекция, пмЛишниеСтроки) Экспорт
	Для каждого ТекСтрока Из пмЛишниеСтроки Цикл
		пКоллекция.Удалить(ТекСтрока);
	КонецЦикла;
КонецПроцедуры

// Копирует колонку без данных в приёмник. Возвращает имя добавленной или найденной колонки.
// Параметры:
//  Приёмник  - Коллекция колонко дерева значений, таблицы значений - в которую будут добавлены колонки
//  Колонка  - КолонкаДерева значений, таблицы значений - которую надо перенести
//	ИмяКолонкиВПриёмнике - Строка - Имя соответствующей колонки в приёмнике. По умолчанию "" - имена совпадают.
//	Метод	- Число:
//		* 0 или 3 - Не проверять наличие в приёмнике. Если колонка там есть, при добавлении будет ошибка.
//		* 1 - Проверять наличие в приёмнике. Если колонка там есть, считаем, что всё ок.
//		* 2 - Проверять наличие в приёмнике. Если колонка там есть, старая колонка приёмника будет удалена.
//		* 4 - Проверять наличие в приёмнике. Если колонка там есть, колонка будет добавлена под корректным сгенерированным именем.
Функция СкопироватьКолонку(Приёмник, Колонка, ИмяКолонкиВПриёмнике = "", Метод = 3) Экспорт
	Результат = ?(ИмяКолонкиВПриёмнике = "", Колонка.Имя, ИмяКолонкиВПриёмнике);
	Если (Метод = 3) ИЛИ (Метод = 0) Тогда
		НадоДобавить = Истина;
	Иначе
		Ё = 0;
		НадоДобавить = Ложь;
		Пока НЕ НадоДобавить Цикл
			СтараяКолонка = Приёмник.Найти(Результат);
			Если СтараяКолонка = Неопределено Тогда
				НадоДобавить = Истина;
			ИначеЕсли Метод = 4 Тогда
				Результат = Колонка.Имя + Ё;
				Ё = Ё + 1;
			ИначеЕсли Метод = 2 Тогда
				Приёмник.Удалить(СтараяКолонка);
			Иначе
				Прервать
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	Если НадоДобавить Тогда
		Приёмник.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
	КонецЕсли;
	Возврат Результат
КонецФункции// ДобавитьНедостающиеКолонки
 
#КонецОбласти 

#Область ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область ПРОЦЕДУРА_ОБЪЕДИНИТЬ_ТАБЛИЦЫ
	
//Вспомогательная к следующей экспортной процедуре
Процедура ЗаполнитьСтрокиПоСтруктурам(ТабПриёмник, ТабИсточник, СтруктураКопируемыхКолонок, СтруктураВычисляемыхКолонок)
	Для каждого СтрокаИсточник из ТабИсточник Цикл
		СтрокаПриёмник = ТабПриёмник.Добавить();
		Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = СтрокаИсточник[Колонка.Значение]
		КонецЦикла;
		Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = Вычислить(Колонка.Значение)
		КонецЦикла
	КонецЦикла
КонецПроцедуры

//Вспомогательная к следующей экспортной процедуре
Функция ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, Ключ, ТипНовой, ШиринаНовой = 0, ЭтоВычисляемая = Ложь)
	Если КолонкиРезультата.Свойство(Ключ) Тогда
		Если НЕ ЭтоВычисляемая Тогда
			КолонкиРезультата[Ключ].ТипЗначения = ОбъединитьОписанияТипов(КолонкиРезультата[Ключ].ТипЗначения, ТипНовой);
			Если КолонкиРезультата[Ключ].Ширина <> 0 Тогда
				КолонкиРезультата[Ключ].Ширина = Макс(КолонкиРезультата[Ключ].Ширина, ШиринаНовой);
			КонецЕсли;
		КонецЕсли; 
		Возврат Истина;
	Иначе
		Если ЭтоВычисляемая Тогда
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ,, 0));
		Иначе
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ, ТипНовой, ШиринаНовой));
		КонецЕсли; 
		Возврат Ложь;
	КонецЕсли; 
КонецФункции

// Объединяет несколько таблиц в одну с учётом типов колонок
// Параметры:
//  СтруктураТаблиц - Массив, структура, фиксированная структура (ФС), список значений или соответствие - Состоит из структур или ФС с информацией об объединяемых таблицах с полями:
//				Таблица - сама таблица (таблица значений или табличная часть);
//				СтруктураКопируемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - имя источника
//				СтруктураВычисляемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - формула с возможностью
//						применения переменных СтрокаИсточник, СтрокаПриёмник, ТабИсточник и ТабПриёмник;
//				ОсобыеПоля - строка с именами колонок через ПС или запятую;
//				ВзятьОсобые - Булево. Если Истина, то переносятся Особые поля и поля из СКК и СВК. Если ложь или не указан - переносятся поля из СКК и СВК, а также все поля, не перечисленные в Особых.
//			Если этот параметр - не массив, тогда структуры находятся в значениях.
// Возвращаемое значение:
//   Таблица значений   - Таблица, содержащая объединение таблиц по заданным правилам. Например, чтобы перенести все колонки "один в один", достаточно заполнить ключ "Таблица".
Функция ОбъединитьТаблицы(СтруктураТаблиц) Экспорт
	//Сформировать таблицу - результат: определить имена колонок, типы колонок.
	//Перенести данные таблиц.
	Результат = Новый ТаблицаЗначений;

	#Область ФОРМИРОВАНИЕ_МАССИВА_ОПИСАНИЙ_ТАБЛИЦ
	ТипПараметра = ТипЗнч(СтруктураТаблиц);
	Если (ТипПараметра = Тип("Структура")) ИЛИ (ТипПараметра = Тип("ФиксированнаяСтруктура"))
			ИЛИ (ТипПараметра = Тип("Соответствие")) ИЛИ (ТипПараметра = Тип("ФиксированноеСоответствие")) ИЛИ (ТипПараметра = Тип("СписокЗначений")) Тогда
		МассивТаблиц = Новый Массив;
		Для каждого КиЗ Из СтруктураТаблиц Цикл
			МассивТаблиц.Добавить(КиЗ.Значение);
		КонецЦикла; 
	ИначеЕсли (ТипПараметра = Тип("Массив")) ИЛИ (ТипПараметра = Тип("ФиксированныйМассив")) Тогда
		МассивТаблиц = СтруктураТаблиц;
	Иначе
		МассивТаблиц = Новый Массив;
	КонецЕсли;
	#КонецОбласти

	#Область Формирование_описаний_колонок
	//определяются для квалификаторов:
	//ЧастиДаты,Длина,ДопустимаяДлина,ЧислоРазрядов,ЧислоРазрядовДробнойЧасти,ДопустимыйЗнак,ДлинаСтроки,ДопустимаяДлина 
	КолонкиРезультата = Новый Структура;
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		Если ОписаниеТаблицы.Свойство("ВзятьОсобые") Тогда
			Если ТипЗнч(ОписаниеТаблицы.ВзятьОсобые) <> Тип("Булево") Тогда
				ОписаниеТаблицы.ВзятьОсобые = Ложь;
			КонецЕсли;
		Иначе
			ОписаниеТаблицы.Вставить("ВзятьОсобые", Ложь);
		КонецЕсли;
		Если НЕ ОписаниеТаблицы.Свойство("ОсобыеПоля") Тогда
			ОписаниеТаблицы.Вставить("ОсобыеПоля", "");
		КонецЕсли;
		Если ОписаниеТаблицы.Свойство("СтруктураКопируемыхКолонок") Тогда
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураКопируемыхКолонок Цикл
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ОписаниеКолонки.Значение);
				Если КолонкаИсточник = Неопределено Тогда
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Удалить(ОписаниеКолонки.Ключ);
				Иначе
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, КолонкаИсточник.ТипЗначения, КолонкаИсточник.Ширина);
					Если (НЕ ОписаниеТаблицы.ВзятьОсобые) И (Найти(ОписаниеТаблицы.ОсобыеПоля, ОписаниеКолонки.Значение) = 0) Тогда
						//Иначе колонка задублируется под другим именем
						ОписаниеТаблицы.ОсобыеПоля = ОписаниеТаблицы.ОсобыеПоля + Символы.ПС + ОписаниеКолонки.Значение;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		Иначе
			ОписаниеТаблицы.Вставить("СтруктураКопируемыхКолонок", Новый Структура);
		КонецЕсли; 
		Если ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок") Тогда
			//Вычисляемая колонка не меняет типа колонки, если он ранее задан, а если колонка новая - то тип будет произвольный.
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураВычисляемыхКолонок Цикл
				ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, Неопределено,, Истина);
			КонецЦикла;
		КонецЕсли; 
		Если ОписаниеТаблицы.ВзятьОсобые Тогда
			СтрокаПолей = СтрЗаменить(ОписаниеТаблицы.ОсобыеПоля, ",", Символы.ПС);
			Для Ё = 1 По СтрЧислоСтрок(СтрокаПолей) Цикл
				ТекИмя = СтрПолучитьСтроку(СтрокаПолей, Ё);
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ТекИмя);
				Если КолонкаИсточник <> Неопределено Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла;
			ОписаниеТаблицы.ОсобыеПоля = "";
		Иначе
			Для каждого КолонкаИсточник Из ОписаниеТаблицы.Таблица.Колонки Цикл
				ТекИмя = КолонкаИсточник.Имя;
				Если (Найти(ОписаниеТаблицы.ОсобыеПоля, ТекИмя) = 0) Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
	#КонецОбласти 
	
	Для каждого ОписаниеКолонки Из КолонкиРезультата Цикл
		Результат.Колонки.Добавить(ОписаниеКолонки.Ключ, ОписаниеКолонки.Значение.ТипЗначения, ОписаниеКолонки.Значение.Заголовок, ОписаниеКолонки.Значение.Ширина)
	КонецЦикла; 
	
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		ЗаполнитьСтрокиПоСтруктурам(Результат, ОписаниеТаблицы.Таблица, ОписаниеТаблицы.СтруктураКопируемыхКолонок,
				?(ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок"), ОписаниеТаблицы.СтруктураВычисляемыхКолонок, Новый Структура));
	КонецЦикла;
	
	Возврат Результат
КонецФункции // ОбъединитьТаблицы()
 
#КонецОбласти 

#Область ПРЕОБРАЗОВАНИЯ_В_ДРУГИЕ_ТИПЫ
	
// Записывает файл Excel с данными из таблицы значений
// Параметры:
//  ИмяФайла  - Строка - Имя записываемого файла
//  ТабЗначений  - Таблица значений - Данные для записи
// Возвращаемое значение:
//   Строка   - Описание ошибки. Пустое, если ошибки нет
Функция ExcelИзТаблицыЗначений(ИмяФайла_, ТабЗначений, ВыводитьЗаголовки = Истина) Экспорт
	Результат = "";
	ТабДокумент = Новый ТабличныйДокумент;
	Попытка
		Если ВыводитьЗаголовки Тогда
			СчКол = 1;
			Для каждого Колонка Из ТабЗначений.Колонки Цикл
				ТабДокумент.Область(1, СчКол, 1, СчКол).Текст = СокрЛП(Колонка.Имя);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЕсли;
		СчСтр = 1;
		Для каждого Строчка Из ТабЗначений Цикл
			СчКол = 1;
			СчСтр = СчСтр + 1;
			Для каждого Колонка Из ТабЗначений.Колонки Цикл
				ТабДокумент.Область(СчСтр, СчКол, СчСтр, СчКол).Текст = СокрЛП(Строчка[Колонка.Имя]);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЦикла;
		ТабДокумент.Записать(ИмяФайла_, ТипФайлаТабличногоДокумента.XLSX);
	Исключение
		Результат = ОписаниеОшибки();
	КонецПопытки;
	Возврат Результат
КонецФункции // ExcelИзТаблицыЗначений()

// Формирует дерево значений из таблицы значений
// Параметры:
//  Таблица  - ТаблицаЗначений - Источник
//  ВетвьРодитель  - Строка дерева значений; любое другое значение будет преобразовано в дерево значений - Ветвь дерева, в которую будут добавляться строки
//  ИмяКолонкиИД  - Строка или Соответствие - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы. Может быть передано соответствие, где ключ - строка таблицы значений, а значение - её номер.
//  ИмяКолонкиРодителя  - Строка - Имя колонки, содержащей ИД родителей. По умолчанию "Родитель". Если колонки не обнаружено, все строки попадут в корень дерева.
//  ЗначениеРодителя  - Любое значение - ИД родителя, по которому будут искаться строки в таблице.
//	СтрокаЗапрещённыхПолей	- Строка	- Имена полей через запятую, которые не должны переноситься. Следует учитывать, что в дереве "Родитель" и "Строки" - реквизиты, и при наличии таких полей в источнике их надо запретить.
// Возвращаемое значение:
//   ВетвьРодитель   - Дерево значений или его строка (ветвь).
Функция ДеревоИзТаблицыЗначений(Таблица, ВетвьРодитель = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = "", СтрокаЗапрещённыхПолей = "") Экспорт
	Если ВетвьРодитель = Неопределено Тогда
		//Инициализация дерева
		ВетвьРодитель = Новый ДеревоЗначений;
		СкоррелироватьКолонкиТаблиц(ВетвьРодитель, Таблица, 3,
				?(НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиРодителя) = 0, "", ИмяКолонкиРодителя) + "," +
				?(НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиИД) = 0, "", ИмяКолонкиИД));
	КонецЕсли; 
	Если ТипЗнч(ИмяКолонкиИД) = Тип("Соответствие") Тогда
		НетКолонкиИД = Истина;
		СоответствиеНомеровСтрок = ИмяКолонкиИД;
	Иначе
		НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
		Если НетКолонкиИД Тогда
			СоответствиеНомеровСтрок = Новый Соответствие;
			Ё = 1;
			Для каждого Строчка Из Таблица Цикл
				СоответствиеНомеровСтрок.Вставить(Строчка, Ё);
				Ё = Ё + 1;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	//Обработка незаписываемых реквизитов дерева
	Если СтрокаЗапрещённыхПолей = "" Тогда
		Если Таблица.Колонки.Найти("Родитель") = Неопределено Тогда
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "";
			Иначе
				СтрокаЗапрещённыхПолей = "Строки";
			КонецЕсли; 
		Иначе
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "Родитель";
			Иначе
				СтрокаЗапрещённыхПолей = "Родитель,Строки";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Источник = ?(НетКолонкиРодителя, Таблица, Таблица.НайтиСтроки(Новый Структура(ИмяКолонкиРодителя, ЗначениеРодителя)));
	Для каждого Строчка Из Источник Цикл
		НоваяСтрока = ВетвьРодитель.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка,, СтрокаЗапрещённыхПолей);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			Если НетКолонкиИД Тогда
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, СоответствиеНомеровСтрок, ИмяКолонкиРодителя, СоответствиеНомеровСтрок[Строчка]);
			Иначе
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, ИмяКолонкиИД, ИмяКолонкиРодителя, Строчка[ИмяКолонкиИД]);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат ВетвьРодитель
КонецФункции // ДеревоИзТаблицыЗначений()
 
// Возвращает структуру, полученную из таблицы значений
//
// Параметры:
//  ТабЗНач - Таблица значений (табличная часть) - источник данных
//  ИмяКолонкиКлючей - Строка - имя колонки,значения которой будут ключами (по умолчанию первая колонка)
//  ИмяКолонкиЗначений - Строка - имя колонки,значения которой будут значениями (по умолчанию вторая (а если второй нет - первая) колонка)
// Возвращаемое значение:
//  Результат - Структура или соответствие - структура с ключами из колонки ключей и значениями из колонки значений
Функция СтруктураИзКолонокТаблицы(ТабЗНач, ИмяКолонкиКлючей = "", ИмяКолонкиЗначений = "", ВернутьСоответствие = Ложь) Экспорт
	Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
	Колонок = ТабЗнач.Колонки.Количество();
	Если Колонок = 0 Тогда
		Возврат Результат
	КонецЕсли;
	ИмяКолонкиКлючей_ = ?(Не ЗначениеЗаполнено(ИмяКолонкиКлючей), ТабЗнач.Колонки[0].Имя, ИмяКолонкиКлючей);
	ИмяКолонкиЗначений_ = ?(Не ЗначениеЗаполнено(ИмяКолонкиЗначений),
			?(Колонок = 1, ТабЗнач.Колонки[0].Имя, ТабЗнач.Колонки[0].Имя), ИмяКолонкиЗначений);
	Для Каждого Строчка Из ТабЗНач Цикл
		Результат.Вставить(Строчка[ИмяКолонкиКлючей_], Строчка[ИмяКолонкиЗначений_])
	КонецЦикла;
	Возврат Результат
КонецФункции

// Выгружает свёрнутую колонку таблицы значений
// Параметры:
//  ТЗначений  - Таблица значений - Откуда выгружать колонку
//  ИмяКолонки  - Строка - Имя выгружаемой колонки
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
// Возвращаемое значение:
//   Массив   - выгруженная свёрнутая колонка
Функция ВыгрузитьСвёрнутуюКолонку(ТЗначений, ИмяКолонки, УдалитьПустые = Ложь) Экспорт
	ВремТаб = ТЗначений.Скопировать(, ИмяКолонки);
	ВремТаб.Свернуть(ИмяКолонки);
	Если УдалитьПустые Тогда
		Результат = Новый Массив();
		Для каждого Строчка Из ВремТаб Цикл
			Если ЗначениеЗаполнено(Строчка[0]) Тогда
				Результат.Добавить(Строчка[0]);
			КонецЕсли; 
		КонецЦикла; 
	Иначе
		Результат = ВремТаб.ВыгрузитьКолонку(ИмяКолонки);
	КонецЕсли; 
	Возврат Результат
КонецФункции // ВыгрузитьСвёрнутуюКолонку()
 
#КонецОбласти

#Область ПОЛУЧЕНИЕ_ТЗ
	
//Загружает содержимое табличного документа в таблицу значений.
//Параметры:
//	ТабДокумент - Табличный документ - Источник
//	СтрокаТипов - Число - Номер строки, где расположены типы. 0 - типы не загружаются. По умолчанию - 1. Строка типов должна содержать имя менеджера (например, Справочники.Номенклатура)
//	СтрокаЗаголовков - Число - Номер строки, содержащей заголовки колонок. По умолчанию - 2
//	СтрокаДанных -Число - Номер строки, с которой начинаются данные. По умолчанию = 3
//	Типизировать - Булево - Если Истина, то колонки будут типизированы, что необходимо для использования ТЗ в параметре запроса и удобно для ручного выбора значения. По умолчанию = Ложь
//	Ширина - Число - Ширина таблицы в ТД. По умолчанию = 0, в этом случае определяется автоматически.
//	Высота - Число - Номер последней строки от начала ТД, используемой загрузки данных. По умолчанию 0. В этом случае загружается вся таблица.
//	Распознавание - Число -
//			* 0 - не распознавать
//			* 1 - распознавание только при заданном типе
//			* 2 - распознавание всегда (по умолчанию)
//Возвращаемое значение
//	Таблица значений - загруженная из ТД с распознаванием значений
Функция ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(ТабДокумент, СтрокаТипов = 1, СтрокаЗаголовков = 2, СтрокаДанных = 3, Типизировать = Ложь, Ширина = 0, Высота = 0, Распознавание = 2) Экспорт
	ТекШирина_ = ?(Ширина = 0, ТабДокумент.ШиринаТаблицы, Ширина);
	ТекВысота_ = ?(Высота = 0, ТабДокумент.ВысотаТаблицы, Высота);
	Результат = Новый ТаблицаЗначений;
	Для СчКол = 1 По ТекШирина_ Цикл
		ТекТекст_ = ТабДокумент.Область(СтрокаЗаголовков, СчКол).Текст;
		Если ТекТекст_ = "" Тогда
			ТекШирина_ = СчКол - 1;
			Прервать
		Иначе
			Результат.Колонки.Добавить(ТекТекст_)
		КонецЕсли
	КонецЦикла;	
	Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
		НоваяСтрока_ = Результат.Добавить();
		Для СчКол = 1 По ТекШирина_ Цикл
			ТекТип = ?(СтрокаТипов = 0, "", ТабДокумент.Область(СтрокаТипов, СчКол).Текст);
			НоваяСтрока_[ТабДокумент.Область(СтрокаЗаголовков, СчКол).Текст] =
					?((Распознавание = 0) ИЛИ ((ТекТип = "") И (Распознавание = 1)), ТабДокумент.Область(СчСтр, СчКол).Текст,
					РаспознатьЗначение(ТабДокумент.Область(СчСтр, СчКол).Текст, ТекТип));
		КонецЦикла	
	КонецЦикла;
	Если Типизировать Тогда
		ТипизироватьТаблицу(Результат)
	КонецЕсли;
	Возврат Результат
КонецФункции

// Формирует Таблицу значений из Дерева значений
// Параметры:
//  Дерево  - ДеревоЗначений - Источник
//  Таблица  - ТаблицаЗначений - Приёмник. Можно не указывать, тогда вернёт созданную заново.
//  ИмяКолонкиИД  - Строка - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы, начиная с 1
//  ИмяКолонкиРодителя  - Строка - Имя колонки, куда будет помещён ИД родителей. По умолчанию "Родитель". Если колонки с таким именем нет, она не создаётся и все строки попадут на один уровень.
//	ЗначениеРодителя	- Число - Значение, указываемое в создаваемых подстроках текущей ветви как ИД родителя.
// Возвращаемое значение:
//   Таблица   - Таблица значений.
Функция ТаблицаЗначенийИзДерева(Дерево, Таблица = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = 0) Экспорт
	Если Таблица = Неопределено Тогда
		Таблица = Новый ТаблицаЗначений;
		Если ТипЗнч(Дерево) = Тип("ДеревоЗначений") Тогда
			СкоррелироватьКолонкиТаблиц(Таблица, Дерево, 3);
		Иначе
			Таблица.Колонки.Добавить("Значение", ВсеСсылочныеИПростыеТипы());
		КонецЕсли;
		Таблица.Колонки.Вставить(0, ИмяКолонкиРодителя);
		Если ИмяКолонкиИД <> "" Тогда
			Таблица.Колонки.Вставить(0, ИмяКолонкиИД);
		КонецЕсли; 
	КонецЕсли; 
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
	Для каждого Строчка Из Дерево.Строки Цикл
		НоваяСтрока = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			НоваяСтрока.Родитель = ЗначениеРодителя;
		КонецЕсли;
		Попытка
			ТекИД = Строчка[ИмяКолонкиИД];
		Исключение
			ТекИД = Таблица.Количество();
			Если НЕ НетКолонкиИД Тогда
				НоваяСтрока[ИмяКолонкиИД] = ТекИД;
			КонецЕсли;
		КонецПопытки;
		ТаблицаЗначенийИзДерева(Строчка, Таблица, ИмяКолонкиИД, ИмяКолонкиРодителя, ТекИД);
	КонецЦикла;
	Возврат Таблица
КонецФункции // ТаблицаЗначенийИзДерева()

// Создаёт таблицу значений с заданными колонками. Может использоваться во внешнем соединении.
// Параметры:
//  СтруктураКолонок  - Структура или Неопределено - Ключ = имя колонки, Значение = Тип колонки (Тип или ОписаниеТипов, если пустое, колонка произвольного типа.
// Возвращаемое значение:
//	Таблица значений - Пустая, с заданными колонками (имена и типы)
Функция СоздатьТаблицуЗначений(СтруктураКолонок = Неопределено) Экспорт
	Результат = Новый ТаблицаЗначений;
	ТипТип = Тип("Тип");
	ТипОТ = Тип("ОписаниеТипов");
	Если СтруктураКолонок <> Неопределено Тогда
		Для Каждого КиЗ Из СтруктураКолонок Цикл
			ТекТип = ТипЗнч(КиЗ.Значение);
			Если ТекТип = ТипОТ Тогда
				Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение)
			ИначеЕсли ТекТип = ТипТип Тогда
				МассивТ = Новый Массив;
				МассивТ.Добавить(КиЗ.Значение);
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МассивТ))
			Иначе
				Результат.Колонки.Добавить(КиЗ.Ключ)
			КонецЕсли
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначений()

// Создаёт таблицу значений с заданными строками колонками и значениями. Может использоваться во внешнем соединении.
// Параметры:
//  ИменаКолонок  - Строка - Имена колонок с разделителем ","
//	ТекстыЗначений - Строка - тексты значений колонок с разделителем
//	Разделитель - Строка - разделитель значений
//	ПрефиксФормулы - значение, начинающееся с этой строки, считается формулой.
//Возвращаемое значение:
//	ТаблицаЗначений - Рассчитанная таблица значений. Например,
//		СоздатьТаблицуЗначенийИзСтрок("Кол1,Кол2", "1,Истина,17,СМОЛА,,ЧЕЛОВЕК") = ТЗ:
//		Кол1	Кол2
//		"1"		"Истина"
//		"17"	"СМОЛА"
//		""		"ЧЕЛОВЕК"
Функция СоздатьТаблицуЗначенийИзСтрок(ИменаКолонок, ТекстыЗначений = "", Разделитель = ",", ПрефиксФормулы = "FRML") Экспорт
	Результат = Новый ТаблицаЗначений;
	СтрокаКолонок = СтрЗаменить(ИменаКолонок, ",", Символы.ПС);
	ЧКол = СтрЧислоСтрок(СтрокаКолонок);
	Если ЧКол > 0 Тогда
		Для Ё = 1 По ЧКол Цикл
			Результат.Колонки.Добавить(СтрПолучитьСтроку(СтрокаКолонок, Ё))
		КонецЦикла;
		СимволХрюквы = "##ХРЮКВА__№";
		СтрокаЗначений = СтрЗаменить(СтрЗаменить(ТекстыЗначений, Символы.ПС, СимволХрюквы), Разделитель, Символы.ПС);
		ЧЗнч = СтрЧислоСтрок(СтрокаЗначений);
		ТекКол = Чкол;
		Для Ё = 1 По ЧЗнч Цикл
			Если ТекКол = ЧКол Тогда
				НоваяСтрока = Результат.Добавить();
				ТекКол = 0
			КонецЕсли;
			ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(СтрокаЗначений, Ё), СимволХрюквы, Символы.ПС);
			НоваяСтрока[ТекКол] = ?(Найти(ТекЗнч, ПрефиксФормулы) = 1, Вычислить(Сред(ТекЗнч, СтрДлина(ПрефиксФормулы) + 1)), ТекЗнч);
			ТекКол = ТекКол + 1
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначенийИзСтрок()

#КонецОбласти

#Область ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
	
// В таблице значений заменяет пустые значения на значения по умолчанию из структуры
// Параметры:
//  ТабЗначений  - ТаблицаЗначений - Произвольная
//  ЗначенияПоУмолчанию  - Структура - Ключи совпадают с именами колонок, где будет замена. Значения - новые значения.
//	ПрефиксФормулы - значение, начинающееся с этой строки, считается формулой. Обращение к данным строки - Строчка.
Процедура ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию(ТабЗначений, ЗначенияПоУмолчанию, ПрефиксФормулы = "FRML") Экспорт
	ДлинаПрефикса = СтрДлина(ПрефиксФормулы);
	Для каждого Строчка Из ТабЗначений Цикл
		Для каждого КиЗ Из ЗначенияПоУмолчанию Цикл
			Если НЕ ЗначениеЗаполнено(Строчка[КиЗ.Ключ]) Тогда
				Строчка[КиЗ.Ключ] = ?(Лев(КиЗ.Значение, ДлинаПрефикса) = ПрефиксФормулы, Вычислить(Сред(КиЗ.Значение, ДлинаПрефикса + 1)), КиЗ.Значение);
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
КонецПроцедуры // ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию()

//Изменяет тип колонки таблицы значений и заполняет её заданным значением
//Параметры:
//	 ТабЗнач	- Таблица значений - В которой будет заполнена колонка
//	 Значение	- Которым будет заполнена колонка
//	 ИмяКолонки	- имя заполняемой колонки
//Возвращаемое значение:
//	Таблица значений - с заплненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
Функция ЗаполнитьЗначениеВКолонку(ТабЗнач, Значение, ИмяКолонки) Экспорт
	Если ТабЗнач.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
		ТабЗнач.Колонки.Удалить(ИмяКолонки)
	КонецЕсли;
	ТабЗнач.Колонки.Добавить(ИмяКолонки, ПолучитьОписаниеТипаЗначения(Значение));
	ТабЗнач.ЗаполнитьЗначения(Значение, ИмяКолонки);
	Возврат ТабЗнач
КонецФункции

//Возвращает свёрнутую таблицу значений (удобно использовать, когда нужна именно функция)
Функция СвернутьТаблицуЗначений(Табличка, Измерения, Ресурсы) Экспорт
	Табличка.Свернуть(Измерения, Ресурсы);
	Возврат Табличка
КонецФункции // ()

//Устанавливает на заданную колонку тип по всем её значениям
//(допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗн - Таблица значений, содержащая колонку
//	ИмяКолонки - Имя типизируемой колонки
//	ИмяКолонкиТипов - Имя колонки, по значениям которой определяются типы. По умолчанию "", в этом случае тип определяется по колонке данных
Процедура ТипизироватьКолонку(ТабЗн, Знач ИмяКолонки, ИмяКолонкиТипов = "") Экспорт
	Если ТабЗн.Количество() > 0 Тогда
		Если ИмяКолонкиТипов = "" Тогда
			ИмяКолонкиТипов = ИмяКолонки;
		КонецЕсли;
		ЭтиКолонки = ТабЗн.Колонки;
		МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонкиТипов);
		НоваяКолонка = ЭтиКолонки.Добавить("Временное__Имя__Этой__Колонки",
				ОписаниеТиповКоллекции(МВыгрузка),
				ЭтиКолонки[ИмяКолонки].Заголовок, ЭтиКолонки[ИмяКолонки].Ширина);
		Если ИмяКолонкиТипов <> ИмяКолонки Тогда
			МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонки);
		КонецЕсли;
		ТабЗн.ЗагрузитьКолонку(МВыгрузка, "Временное__Имя__Этой__Колонки");
		ЭтиКолонки.Удалить(ИмяКолонки);
		ЭтиКолонки.Временное__Имя__Этой__Колонки.Имя = ИмяКолонки
	КонецЕсли
КонецПроцедуры

//Типизирует колонки таблицы значений по содержимому (допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗначений - Таблица значений - типизируемая таблица
Процедура ТипизироватьТаблицу(ТабЗначений_) Экспорт
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из ТабЗначений_.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	Для Каждого Колонка Из МассивКолонок Цикл
		ТипизироватьКолонку(ТабЗначений_, Колонка)
	КонецЦикла;
КонецПроцедуры

//Приводит сумму колонки таблицы к нужному значению
//Параметры:
//	Таблица - таблица значений, строки дерева значений - коллекция, по колонке которой надо перераспределит сумму
//	Реквизит - Строка - Имя колонки, по которой распределяется сумма
//	Сумма - Число - распределяемая сумма
//	Точность - Число - количество знаков после запятой в рассчитанных суммах
Процедура ПривестиТабКСумме(Таблица, Реквизит, Сумма, Знач Точность = 2) Экспорт
	Если Сумма = 0 Тогда
		Таблица.ЗаполнитьЗначения(Сумма, Реквизит);
	ИначеЕсли Таблица.Итог(Реквизит) <> 0 Тогда
		Таблица.ЗагрузитьКолонку(РаспределитьСуммуПропорциональноКоэффициентам(Сумма, Таблица.ВыгрузитьКолонку(Реквизит), Точность));
	КонецЕсли;
КонецПроцедуры
	
#КонецОбласти 

#Область ОПЕРАЦИИ_С_ДВУМЯ_ТЗ
	
//Добавляет записи из ТабИсточник в конец ТабПриёмник.
//Одноимённые поля скопируются автоматически. Если копируется что-то лишнее, можно подкорректировать структурами или исключением. Поля, не попавшие в структуры и исключения, копируются "один в один".
//Если объединяем несколько таблиц, или проблемы с типами (например, таблицы по результатам запроса), надо использовать ОбъединитьТаблицы
//Параметры:
//	ТабИсточник - ТаблицаЗначений или иная коллекция - поддерживающая Добавить и  обращение к элементу коллекции через []
//	ТабПриёмник - ТаблицаЗначений или иная коллекция - поддерживающая обращение к элементу коллекции через []
//	СтруктураКопируемыхКолонок - структура - описывающая копирование (Ключ - имя колонки приёмника, Значение - имя колонки источника). Необязательна.
//	СтруктураВычисляемыхКолонок - структура - поля приёмника (Ключ), которые вычисляются формулой для функции Вычислить (Значение); Можно применять имена Строка и СтрокаНовая, а также имена параметров процедуры. Необязательна.
//	Исключаемые поля - список полей, не подлежащих копированию, через запятую. Необязательны.
Процедура ДобавитьЗаписиИзТаблицыВТаблицу(ТабИсточник, ТабПриёмник, СтруктураКопируемыхКолонок = Неопределено, СтруктураВычисляемыхКолонок = Неопределено, ИсключаемыеПоля = "") Экспорт
	Для каждого Строка из ТабИсточник Цикл
		СтрокаНовая = ТабПриёмник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаНовая, Строка,, ИсключаемыеПоля);
		Если СтруктураКопируемыхКолонок <> Неопределено Тогда
			Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Строка[Колонка.Значение]
			КонецЦикла;
		КонецЕсли;
		Если СтруктураВычисляемыхКолонок <> Неопределено Тогда
			Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Вычислить(Колонка.Значение)
			КонецЦикла
		КонецЕсли; 
	КонецЦикла
КонецПроцедуры //ДобавитьЗаписиИзТаблицыВТаблицу

//Формирует разность двух таблиц с одинаковыми структурами колонок. Колонки сопоставляются по порядку в таблице (НЕ по имени!).
//Параметры:
//	ТаблицаВычитаемое - Таблица значений - строки которой считаются "Вычитаемыми"
//	ТаблицаУменьшаемое - Таблица значений - строки которой считаются "Положительными"
//	Сортировка - Строка - Имена колонко для сортировки результата
//	КПлюс - Число - Значение, которое возвратится в колонке "Знак" "положительных" строк
//Возвращаемое значение:
//	Таблица значений	- включает строки, встречающиеся только один раз в одной таблице. В добавленной колонке "Знак" в строках из "Вычитаемой" таблицы будет 0, "Уменьшаемой" - параметр КПлюс.
Функция РазницаТаблицЗначений(ТаблицаВычитаемое, ТаблицаУменьшаемое, Сортировка, КПлюс = 1) Экспорт
	ВсеКолонки = СписокКолонок(ТаблицаУменьшаемое);
	Результат = ТаблицаУменьшаемое.Скопировать();    
	Результат.Колонки.Добавить("Знак", Новый ОписаниеТипов("Число"));
	Результат.ЗаполнитьЗначения(КПлюс, "Знак");
	Для Счетчик = 1 По ТаблицаВычитаемое.Количество() Цикл 
		Результат.Вставить(0) 
	КонецЦикла;
	Для Счетчик = 0 По ТаблицаВычитаемое.Колонки.Количество() - 1 Цикл 
		Результат.ЗагрузитьКолонку(ТаблицаВычитаемое.ВыгрузитьКолонку(Счетчик), Счетчик) 
	КонецЦикла;
	Результат.Колонки.Добавить("Счёт");
	Результат.ЗаполнитьЗначения(1, "Счёт");
	Результат.Свернуть(ВсеКолонки, "Знак, Счёт");
	Результат = Результат.Скопировать(Новый Структура("Счёт", 1), ВсеКолонки + ", Знак");
	Результат.Сортировать(Сортировка);
	Возврат Результат;
КонецФункции

// Приводит колонки одной таблицы в соответствие другой.
// Параметры:
//  Приёмник  - Таблица значений или дерево значений - колонки которой меняются
//  Источник  - Таблица значений или дерево значений - колонки которой переносятся
//  Метод  - Число - метод переноса:
//			* 0 - Считать, что колонок источника заведомо нет в приёмнике и переносить без проверок;
//			* 1 - Добавить только недостающие колонки из источника;
//			* 2 - Удалить совпадающие по именам колонки в приёмнике и перенести все колонки источника;
//			* 3 - Удалить вообще все колонки приёмника и перенести все колонки источника. Используется, когда нельзя присвоить значение в источник (например, в реквизите формы).
//			* 4 - Проверять наличие колонки источника в приёмнике. Если колонка там есть, колонка источника будет добавлена под корректным сгенерированным именем.
//  СтруктураСоответствияКолонок  - Структура или Неопределено - Структура, в которой при Метод = 4 возвращается соответствие имён колонок (Ключ - имя в источнике, Значение - в приёмнике)
Процедура СкоррелироватьКолонкиТаблиц(Приёмник, Источник, Метод = 3, НеДобавлятьКолонки = "", СтруктураСоответствияКолонок = Неопределено) Экспорт
	Если (Метод = 4) И (СтруктураСоответствияКолонок = Неопределено) Тогда
		СтруктураСоответствияКолонок = Новый Структура;
	КонецЕсли;
	Если Метод = 3 Тогда
		Приёмник.Колонки.Очистить();
	КонецЕсли;
	Для каждого Колонка Из Источник.Колонки Цикл
		Если НайтиПодстроку(НеДобавлятьКолонки, Колонка.Имя, ",") = 0 Тогда
			НовоеИмя = СкопироватьКолонку(Приёмник.Колонки, Колонка,, Метод);
			Если Метод = 4 Тогда
				СтруктураСоответствияКолонок.Вставить(Колонка.Имя, НовоеИмя);
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла; 
КонецПроцедуры // СкоррелироватьКолонкиТаблиц()

// Возвращает массив имён общих колонок двух таблиц
// Параметры:
//  Таб1  - ТаблицаЗначений, ДеревоЗначений, Структура с коллекцией объектов со строковым свойством "Имя" в ключе "Колонки" - Первая таблица
//  Таб2  - ТаблицаЗначений, ДеревоЗначений, Структура с массивом строк в ключе "Колонки" - Вторая таблица
//  ВключатьНомерСтроки  - Булево - Обрабатывать колонку с именем "НомерСтроки". По умолчанию Ложь.
// Возвращаемое значение:
//   Массив   - Строки - имена общих колонкок таблиц
Функция ОбщиеКолонки(Таб1, Таб2, ВключатьНомерСтроки = Ложь) Экспорт
	Результат = Новый Массив;
	Для Каждого Колонка Из Таб1.Колонки Цикл
		ТекИмя = Колонка.Имя;
		Если ТекИмя <> "НомерСтроки" Тогда
			Если Таб2.Колонки.Найти(ТекИмя) <> Неопределено Тогда
				Результат.Добавить(ТекИмя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // ОбщиеКолонки
 
#КонецОбласти 

//Возвращает список имён колонок таблицы или дерева значений через запятую
//Параметры:
//	ТабИлиДерево - Таблица или дерево значений - Источник данных
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
//Возвращаемое значение:
//	Строка, Масси в или Список значений - Список имён колонок. Строка - через запятую, список - с заголовками в представлениях.
Функция СписокКолонок(ТабИлиДерево, СтрокаМассивСписок = "Строка") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя, Колонка.Заголовок);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат = Результат + "," + Колонка.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, 2);
	КонецЕсли;
	Возврат Результат
КонецФункции // СписокКолонок()
 
#КонецОбласти

#Область МАССИВЫ

//Удаляет дубли из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
//Параметры:
//	Массив - Массив - Исходный массив
//Возвращаемое значение - массив без дублей. Он же в параметре Массив, что позволяет использовать функцию как процедуру.
Функция СвернутьМассив(Массив) Экспорт
	Размер = Массив.Количество();
	Для Ё = 1 По Размер Цикл
		ТекИндекс = Размер - Ё;
		Если Массив.Найти(Массив[ТекИндекс]) <> ТекИндекс Тогда
			Массив.Удалить(ТекИндекс)
		КонецЕсли;
	КонецЦикла;
	Возврат Массив
КонецФункции

//Проверяет, является ли параметр массивом, и если не является преобразует его в массив с единственным значением
//Параметры:
//	Что - Произвольное значение - источник данных
//	ПеределатьВМассивЕслиКоллекция - Булево - Если Истина, элементы коллекции из параметра Что будут добавлены в результат.
//		Д.б. установлена, если надо сложить два массива. При Ложь значение Что будет добавлено в конец массива. По умолчанию Ложь.
//	ПеременнаяДляПолученияРезультата - Произвольный - Переменная, в которую будет передано возвращаемое значение,
//		если невозможно исползовать как функцию. Сюда же передаётся начальный массив, к которому будут добавлены значения.
//		Если в эту переменную передать не массив, значение будет потеряно.
//Возвращаемое значение:
//	Массив - Массив из ПеременнаяДляПолученияРезультата, или новый массив
Функция ПреобразоватьВМассив(Что, ПеределатьВМассивЕслиКоллекция = Ложь, ПеременнаяДляПолученияРезультата = Неопределено) Экспорт
	ТипМассив = Тип("Массив");
	Если ТипЗнч(ПеременнаяДляПолученияРезультата) <> ТипМассив Тогда
		ПеременнаяДляПолученияРезультата = Новый Массив;
	КонецЕсли;
	Результат = ПеременнаяДляПолученияРезультата;
	Если ПеределатьВМассивЕслиКоллекция Тогда
		Попытка
			Для каждого Элемент_ Из Что Цикл
				Результат.Добавить(Элемент_);
			КонецЦикла;
		Исключение
			Результат = Новый Массив;
			Результат.Добавить(Что);
		КонецПопытки;
	ИначеЕсли ТипЗнч(Что) = ТипМассив Тогда
		Результат = Что
	Иначе
		Результат.Добавить(Что);
	КонецЕсли;
	Возврат Результат
КонецФункции

//Складывает два массива (добавляет в новый массив элементы сначала первого, потом втогрого), при необходимости - со свёрткой
//Параметры:
//	Массив1 - массив - первое слагаемое
//	Массив2 - массив - второе слагаемое
//	Свернуть - Булево - Удалить дубли
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
//	РезультатВПервый - Булево - Не создавать новый массив, а всё сложить в первый
//Возвращаемое значение:
//	Массив - Элементы первого, за ними элементы второго массива. При свёртке из дублей попадает только первый.
Функция СложитьМассивы(Массив1, Массив2, Свернуть = Истина, УдалитьПустые = Ложь, РезультатВПервый = Ложь) Экспорт
	Если РезультатВПервый Тогда
		Результат = ?(Свернуть, СвернутьМассив(Массив1), Массив1);
		Если УдалитьПустые Тогда
			УдалитьПустыеИзМассива(Результат); 
		КонецЕсли; 
	Иначе
		Результат = СложитьМассивы(Новый Массив, Массив1, Свернуть, УдалитьПустые, Истина);
	КонецЕсли; 
	Для Каждого Элемент Из Массив2 Цикл
		Если ?(?(УдалитьПустые, ЗначениеЗаполнено(Элемент), Истина), ?(Свернуть, Результат.Найти(Элемент) = Неопределено, Истина), Ложь) Тогда
			Результат.Добавить(Элемент);
		Конецесли
	КонецЦикла;
	Возврат Результат
КонецФункции

// Удаляет незаполненные элементы из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
// Параметры:
//  Массив_  - Массив - Проверяемый массив
// Возвращаемое значение:
//   Массив   - Тот же массив, что и был передан, но без пустых значений.
Функция УдалитьПустыеИзМассива(Массив_) Экспорт
	ВГр = Массив_.ВГраница();
	Для Ё = 1 По ВГр Цикл
		Если НЕ ЗначениеЗаполнено(Массив_[ВГр - Ё]) Тогда
			Массив_.Удалить(ВГр - Ё)
		КонецЕсли; 
	КонецЦикла; 
	Возврат Массив_
КонецФункции // УдалитьПустыеИзМассива
 
//Преобразует массив в список значений.
//Параметры:
//	Массив - Массив - источник данных
//	Свернуть - Булево - при Истина будет взято только первое из повторяющихся значений.
//	ПометкаПоУмолчанию - Булево - Пометка для установки в элементы списка. По умолчанию Ложь.
//	КартинкаПоУмолчанию - Картинка или Неопределено - Картинка для установки в элементы списка. Если Неопределено (по умолчанию) - картинка не устанавливается.
//	Результат - Список значений или Неопределено (по умолчанию) - переменная для возврата результата для работы 
//			в режиме процедуры, когда список надо не присвоить, а разместить в существующий. При неопределено будет создан новый список.
//Результат - для работы  в режиме процедуры, когда список надо не присвоить, а разместить в существующий.
//Возвращаемое значение:
//	Список значений - где значение - элемент массива, представление - строковое представление элемента, картинка и пометка из параметров.
Функция СписокИзМассива(Массив, Свернуть = Истина, ПометкаПоУмолчанию = Ложь, КартинкаПоУмолчанию = Неопределено, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый СписокЗначений;
	КонецЕсли; 
	Если КартинкаПоУмолчанию = Неопределено Тогда
		КартинкаПоУмолчанию = Новый Картинка
	КонецЕсли;
	Для каждого Элемент из Массив Цикл
		Если ?(Свернуть, Результат.НайтиПоЗначению(Элемент) = Неопределено, Истина) Тогда
			Результат.Добавить(Элемент, СокрЛП(Элемент), ПометкаПоУмолчанию, КартинкаПоУмолчанию)
		КонецЕсли
	КонецЦикла;
	Возврат Результат
КонецФункции
	
//Аналог ВыгрузитьКолонку для коллекций, не поддерживающих ВыгрузитьКолонку
//Параметры:
//	  Коллекция - Произвольная коллекция, имеющая колонки у элементов - источник данных
//	  ИмяВыгружаемойКолонки - Строка - Имя выгружаемой колонки
//Возвращаемое значение:
//	  Массив - Значения из выгружаемой колонки
Функция КолонкуКоллекцииВМассив(Коллекция, ИмяВыгружаемойКолонки) Экспорт
	Результат = Новый Массив;
	Для каждого Элемент из Коллекция Цикл
		Результат.Добавить(Элемент[ИмяВыгружаемойКолонки])
	КонецЦикла;
	Возврат Результат
КонецФункции

#КонецОбласти

#Область СПИСОК_ЗНАЧЕНИЙ
	
//Возвращает табличный документ, в который выведен список значений
//Параметры:
//	  Список - Список значений - Выводимый в таблицу
//Возвращаемое значение:
//	  Табличный документ - Значения из выгружаемой колонки
Функция ВывестиСписокВТабличныйДокумент(Список) Экспорт
	Результат = Новый ТабличныйДокумент;
	РазмерСписка = Список.Количество();
	Результат.Область(1, 1, РазмерСписка, 4).СодержитЗначение = Истина;
	Результат.Область(1, 1, РазмерСписка, 4).ШиринаКолонки = 70;
	Для Ё = 1 По РазмерСписка Цикл
		Элемент = Список[Ё - 1];
		Результат.Область(Ё, 1, Ё, 1).Значение = Элемент.Представление;
		Результат.Область(Ё, 1, Ё, 1).Расшифровка = Элемент.Значение;
		Результат.Область(Ё, 2, Ё, 2).Значение = Элемент.Пометка;
		Результат.Область(Ё, 3, Ё, 3).Значение = Элемент.Картинка
	КонецЦикла;
	Результат.ТолькоПросмотр = Истина;
	Результат.Защита = Истина;
	Возврат Результат
КонецФункции

// Перемешивает строки списка значений
// Параметры:
//  Список_  - Список значений - строки которого надо перемешать
Процедура ПеремешатьСписок(Список_) Экспорт
	СлуГен = Новый ГенераторСлучайныхЧисел(Секунда(ТекущаяДата()));
	Колво = Список_.Количество() - 1;
	Для Ё = 0 По Колво Цикл
		Список_.Сдвинуть(Список_[Ё], СлуГен.СлучайноеЧисло(0, Колво) - Ё);
	КонецЦикла; 
КонецПроцедуры // ПеремешатьСписок()
 
#КонецОбласти 

#Область СТРУКТУРА
	
//Читает значение заданного ключа из структуры с проверками на наличие структуры и ключа.
//Параметры:
//	Структура_ - Структура - из которой будет прочитано значение.
//	ИмяСвойства - Строка - искомый ключ
//	ЗначениеЕслиНет - Произвольный -  Значение, возвращаемое, если прочитать не вышло
//	ПроверитьЧтоЭтоСтруктура - Булево - Если ложь, без проверки принимается, что тип параметра "Структура_" - структура.
//Возвращаемое значение -  Произвольный -  значение ключа
Функция ЧтСтрукт(Структура_, ИмяСвойства, ЗначениеЕслиНет = Неопределено, ПроверитьЧтоЭтоСтруктура = Ложь) Экспорт
	ТекТип = ТипЗнч(Структура_);
	Возврат ?(?(ПроверитьЧтоЭтоСтруктура, ТекТип = Тип("Структура") ИЛИ ТекТип = Тип("ФиксированнаяСтруктура"), Истина),
			?(Структура_.Свойство(ИмяСвойства), Структура_[ИмяСвойства], ЗначениеЕслиНет), ЗначениеЕслиНет)
КонецФункции

// Добавляет КиЗы источника в приёмник
// Параметры:
//  Приёмник - Структура или Неопределено - Одно из слагаемых. Если Неопределено, то возвращается копия источника независимо от РежимПроцедуры.
//  Источник  - Структура - Второе слагаемое
//	РежимПроцедуры - Булево - Если Истина, результат сложения окажется в Приёмнике, а вернётся Истина.
//		Если Ложь (по умолчанию), то Приёмник и Источник не изменятся, а результат будет возвращён.
// Возвращаемое значение:
//   Структура или Булево   - описание выше
Функция ДополнитьСтруктуру(Приёмник = Неопределено, Источник, РежимПроцедуры = Ложь) Экспорт
	Результат = ?(Приёмник = Неопределено, Новый Структура, ?(РежимПроцедуры, Приёмник, ДополнитьСтруктуру(Неопределено, Приёмник)));
	Для каждого КиЗ Из Источник Цикл
		Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
	КонецЦикла; 
	Возврат ?(РежимПроцедуры, Истина, Результат)
КонецФункции // ДополнитьСтруктуру()

#КонецОбласти 

// Копирует содержимое одного дерева в другое, существующее
// Параметры:
//  Приёмник  - Дерево значений - Дерево значений, в которое будут добавлены новые данные
//  Источник  - Дерево значений - Дерево значений, из которого будут взяты данные
//  ИменаКлючевыхКолонок  - Строка - Имена колонок для поиска соответствующих строк. Если пустая (по умолчанию), считается, что соответствующих строк нет. Если найдено несколько строк, первая считается найденной.
//  СкоррелироватьКолонки  - Булево - Надо приводить в соответстввие колонки. По умолчанию Истина. Для ветвей приёмника и источника обязательно Ложь.
Процедура СкопироватьДерево(Приёмник, Источник, ИменаКлючевыхКолонок = "", СкоррелироватьКолонки = Истина) Экспорт
	Если СкоррелироватьКолонки Тогда
		СкоррелироватьКолонкиТаблиц(Приёмник, Источник, 1);
	КонецЕсли;
	ЭтиСтроки = Приёмник.Строки;
	Для каждого СтрокаДЗ Из Источник.Строки Цикл
		СтрокаПриёмник = "";
		Если ИменаКлючевыхКолонок <> "" Тогда
			СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
			ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаДЗ);
			МассивНайденныхСтрок = ЭтиСтроки.НайтиСтроки(СтруктураПоиска);
			Если МассивНайденныхСтрок.Количество() > 0 Тогда
				СтрокаПриёмник = МассивНайденныхСтрок[0];
			КонецЕсли; 
		КонецЕсли; 
		Если СтрокаПриёмник = "" Тогда
			СтрокаПриёмник = ЭтиСтроки.Добавить();
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(СтрокаПриёмник, СтрокаДЗ);
		СкопироватьДерево(СтрокаПриёмник, СтрокаДЗ, ИменаКлючевыхКолонок, Ложь);
	КонецЦикла; 
КонецПроцедуры // СкопироватьДерево

#КонецОбласти

#Область СТРОКОВЫЕ

// Возвращает строку с разделителями без заданных элементов, например "Коля ,Вася , Галя", " Вася" = > "Коля,Галя"
// Лишние пробелы будут устранены.
// Параметры:
//	СтрокаСРазделителями- Любое значение, преобразуемое в строку - Исходная строка
//	УдаляемыеЭлементы	- Любое значение, преобразуемое в строку - удаляемые элементы с разделителями
//	Разделитель			- Любое значение, преобразуемое в строку - Разделитель, общий для СтрокаСРазделителями и УдаляемыеЭлементы
// Возвращаемое значение:
//	Строка   - строка с разделителями без указанных элементов
Функция УдалитьЭлементыИзСтрокиСРазделителями(СтрокаСРазделителями, УдаляемыеЭлементы, Разделитель = ",") Экспорт
	ЧтоУдалять = СтрЗаменить(УдаляемыеЭлементы, Разделитель, Символы.ПС);
	Результат = ИскоренитьПодстроку(ИскоренитьПодстроку(СтрокаСРазделителями,
			" " + Разделитель, Разделитель), Разделитель + " ", Разделитель);
	Для Ё = 1 По СтрЧислоСтрок(ЧтоУдалять) Цикл
		ЧтоМенять = СтрПолучитьСтроку(ЧтоУдалять, Ё);
		Результат = СтрЗаменить(Результат, ЧтоМенять + Разделитель, "");
		Результат = СтрЗаменить(Результат, Разделитель + ЧтоМенять, "");
		Если Результат = ЧтоМенять Тогда
			Результат = "";
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // УдалитьЭлементыИзСтрокиСРазделителями()
 
// Заменяет в исходной строке все заданные значения на заданные значения замен с повторением,
// пока не исчезнут заменяемые значения. По умолчанию - для замены лишних пробелов.
// Параметры:
//  НачСтрока  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПодстрокаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, которую искоренить;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, на которую заменить;
// Возвращаемое значение:
//   Строка   - Строка без заменяемой подстроки (после всех замен)
Функция ИскоренитьПодстроку(НачСтрока, ПодстрокаЧтоМенять = "  ", НаЧтоМенять = " ") Экспорт
	Результат = Строка(НачСтрока);
	Пока Найти(Результат, ПодстрокаЧтоМенять) > 0 Цикл
		Результат = СтрЗаменить(Результат, ПодстрокаЧтоМенять, НаЧтоМенять);
	КонецЦикла;
	Возврат Результат
КонецФункции // ИскоренитьПодстроку()
 
//Преобразует имя переменной в строку представления
//заменой заглавных букв на строчные с пробелом
// Параметры:
//  ИмяПеременной  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПропуститьНедопустимые  - Булево - При Истина (по умолчанию) символы, недопустимые в имени переменной, будут заменены на пробел,
//			а следующий символ - на заглавный, при Ложь - будут обработаны как допустимый символ;
// Возвращаемое значение:
//   Строка   - Исходная строка с заменой:
//			* СтрочнаяЗаглавная ==> СтрочнаяПробелСтрочная
//			* Подчёркивания (Кроме краевых) ==> Пробел
//			* СтрочнаяЗаглавныеСтрочная ==> СтрочнаяПробелЗаглавныеКромеПоследнейПробелСтрочнаяСтрочная
//			* СтрочнаяЗаглавныеНеКраевоеПодчёркивание ==> СтрочнаяПробелЗаглавныеПробел и т.д.
Функция ИмяПеременнойВСтроку(ИмяПеременной, ПропуститьНедопустимые = Истина) Экспорт
	Заглавные = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	Строчные = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Допустимые = "_1234567890";
	Цифры = "1234567890";
	ТекДлина = СтрДлина(ИмяПеременной) + 1;
	Результат = "";
	Буфер = "";
	ПрошлаяСерия = 0;
	Серия = 0; //1 - строчные, 2 - заглавные, 3 - символы
	Для Ё = 1 По ТекДлина Цикл
		ПрошлаяСерия = Серия;
		Если Ё = ТекДлина Тогда
			КВставке = "";
			Серия = 0;
		Иначе
			ТекСимвол = Сред(ИмяПеременной, Ё, 1);
			Если ТекСимвол = "_" Тогда
				КВставке = ?(ПустаяСтрока(Прав(Буфер, 1)), "", " ");
				Серия = 3;
			ИначеЕсли Найти(Цифры, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 3;
			ИначеЕсли Найти(Строчные, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 1;
			ИначеЕсли Найти(Заглавные, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 2;
			Иначе
				КВставке = ?(ПропуститьНедопустимые, ?(ПустаяСтрока(Прав(Буфер, 1)), "", " "), ТекСимвол);
				Серия = 3;
			КонецЕсли;
		КонецЕсли;
		Если ПрошлаяСерия <> Серия Тогда
			Если ПрошлаяСерия = 0 Тогда
			ИначеЕсли ПрошлаяСерия = 2 Тогда
				Если Серия = 1 Тогда
					ТекСлово = Лев(Буфер, СтрДлина(Буфер) - 1);
					Буфер = НРег(Прав(Буфер, 1)) + КВставке;
				Иначе
					ТекСлово = Буфер;
					Буфер = КВставке;
				КонецЕсли; 
				Если СтрДлина(ТекСлово) = 1 Тогда
					ТекСлово = НРег(ТекСлово);
				КонецЕсли;
				Результат = Результат + " " + ТекСлово;
			Иначе
				Результат = Результат + " " + СокрЛП(Буфер);
				Буфер = КВставке;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат Сред(Результат, 2)
КонецФункции

//Преобразует строку представления в имя переменной
//заменой строчных букв с пробелом на заглавные
// Параметры:
//  Строка_  - Любое значение, преобразуемое в строку - Исходная строка;
// Возвращаемое значение:
//   Строка   - Строка без запретных символов и с заменой " символ" на ВРег(символ)
Функция СтрокуВИмяПеременной(Строка_) Экспорт
	Результат = "";
	Источник = Строка_;
	СтарДл = - 1;
	Пока Истина Цикл
		ТекДл = СтрДлина(Источник);
		Если ТекДл = СтарДл Тогда
			Прервать
		КонецЕсли;
		СтарДл = ТекДл;
		Источник = СтрЗаменить(Источник, "  ", " ");
	КонецЦикла; 
	Допустимые = "_АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	ДопустимыеВсе = "1234567890" + Допустимые;
	ФлВРег = Истина;
	Для Ё = 1 По СтрДлина(Источник) Цикл
		ТекСимв = Сред(Источник, Ё, 1);
		Если Найти(?(Ё = 1, Допустимые, ДопустимыеВсе), ТекСимв) > 0 Тогда
			ФлВРег = Ложь;
			Результат = Результат + ?(ФлВРег, ВРег(ТекСимв), ТекСимв);
		Иначе
			ФлВРег = Истина;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции

// Заменяет конец строки новым набором символов той же длины
// Параметры:
//  ГдеМенять  - Любое значение, преобразуемое в строку - Исходная строка;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Новый конец строки;
Процедура ЗаменитьКонецСтроки(ГдеМенять, НаЧтоМенять)Экспорт
	ГдеМенять = Лев(ГдеМенять, СтрДлина(ГдеМенять) - СтрДлина(НаЧтоМенять)) + НаЧтоМенять
КонецПроцедуры

//Ищет строку в составе другой строки, но только как подстроку между разделителями без краевых пробелов
//Возвращает номер найденной подстроки или 0
// Параметры:
//  ГдеИскать  - Любое значение, преобразуемое в строку - В которой будет поиск;
//  ЧтоИскать  - Строка - Искомая строка;
//  Разделитель  - Строка - Разделитель частей в ГдеИскать;
// Возвращаемое значение:
//   Строка   - Строка без запретных символов и с заменой " символ" на ВРег(символ)
Функция НайтиПодСтроку(ГдеИскать, ЧтоИскать, Разделитель = ",") Экспорт
	Возврат Найти(Разделитель + ГдеИскать + Разделитель, Разделитель + ЧтоИскать + Разделитель)
	//Результат = СтрРазделить(ГдеИскать, Разделитель).Найти(ЧтоИскать);
	//Возврат ?(Результат = Неопределено, 0, Результат + 1);
КонецФункции

//Находит число символов до заданной подстроки. Если подстроки нет, берётся вся строка.
// Параметры:
//	ГдеИскать - Строка - в которой ищем
//	ИскомыйТекст - Строка - которую ищем
// Возвращаемое значение:
//	Число - колво символов до подстроки. СлужебнаяНайтиКолвоСимволовДоВхождения("12345", "234") = 1
Функция НайтиКолвоСимволовДоВхождения(ГдеИскать, ИскомыйТекст) Экспорт
	Результат = Найти(ГдеИскать, ИскомыйТекст) - 1;
	Возврат ?(Результат < 0, СтрДлина(ГдеИскать), Результат)
КонецФункции // СлужебнаяНайтиКолвоСимволовДоВхождения()

// СтрЗаменить, но без учёта регистра
// Параметры:
//  ГдеМенять  - Строка - в котрой надо сделать замены, например, аБабА
//  ЧтоМенять  - Строка - которую надо найти и обезвредить, например, АБА
//  НаЧтоМенять  - Строка - Которая появится вместо искомой, например, АА
// Возвращаемое значение:
//   Строка   - с заменами, в примере - ААБА
Функция СтрЗаменитьБезУчётаРегистра(ГдеМенять, ЧтоМенять, НаЧтоМенять) Экспорт
	НачСтрока = ГдеМенять;
	Результат = "";
	ДлинаЧтоЗаменять = СтрДлина(ЧтоМенять);
	Пока Истина Цикл
		ПозВхождения = Найти(ВРег(НачСтрока), ВРег(ЧтоМенять));
		Если ПозВхождения = 0 Тогда
			Результат = Результат + НачСтрока;
			Прервать;
		КонецЕсли;
		Результат = Результат + Лев(НачСтрока, ПозВхождения - 1) + НаЧтоМенять;
		НачСтрока = Сред(НачСтрока, ПозВхождения + ДлинаЧтоЗаменять);
	КонецЦикла; 
	Возврат Результат;
КонецФункции // СтрЗаменитьБезУчётаРегистра()

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
Функция СтрРазделить_(ЧтоДелим, Разделитель = ",", ВключатьПустые = Истина) Экспорт
	Хрюква = "/°|°\";
	ХрюкваР = "/°-|-°\";
	ИзувеченнаяСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(ЧтоДелим, Разделитель, ХрюкваР), Символы.ПС, Хрюква), ХрюкваР, Символы.ПС);
	Результат = Новый Массив;
	Для Ё = 1 По СтрЧислоСтрок(ИзувеченнаяСтрока) Цикл
		ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(ИзувеченнаяСтрока, Ё), Хрюква, Символы.ПС);
		Если ВключатьПустые ИЛИ НЕ ПустаяСтрока(ТекЗнч) Тогда
			Результат.Добавить(ТекЗнч);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // СтрРазделить()

//Создаёт тестер маски.
//Параметры:
//	Маска - Строка - Маска для проверки. По умолчанию - маска проверки даты. Описание синтаксиса маски в функции ПроверитьСтроку
Функция ЗначениеXDTOдляПроВеркиСтроки(Маска = "\d{2}\.\d{2}\.\d{4}") Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Маска + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
КонецФункции // XDTOдляПроВеркиСтроки()
 
//Проверяет строку на соответствие маске
//источник - инфостарт
//Параметры:
//	Строчка - строка/Массив - проверяемые строки
//	Тестер - значение XDTO - Тестер строки по маске. Если Неопределено - создаётся.
//	Маска - строка - шаблон, на соответствие которому проверяется
//		. - любой символ
//		+ - один или более раз, пример ".+" - один или более любой символ.
//		* - ноль или более раз, пример ".*" - любое количество любых символов (даже ни одного).
//		[n-m] - символ от m до n, пример: "[0-9]+" - одна или более цифр(а).
//		\d - цифра, пример \d+ - одна или более цифр(а).
//		\D - не цифра.
//		\s - пробельный символ - ТАБ, пробел, перенос строки, возврат каретки и т.п.
//		\S - непробельный символ.
//		\w - буква, цифра, подчеркивание.
//		\W - не буква, не цифра и не подчеркивание соответственно.
//		^ - начало текста, например "^\d+" - строка начинается с цифры.
//		$ - конец текста, например "\D+$" - строка заканчивается НЕ цифрой.
//		{m,n} - шаблон для от m до n символов, например "\d{2,4}" - от двух до четырех цифр. Можно указать одну и всего цифру для строгого соответвия.
//		\ - экранирует спецсимволы. Например, "\." - символ точки.
//	По умолчанию - маска проверки даты "\d{2}\.\d{2}\.\d{4}"
//Возвращаемое значение - Булево - Строка соответствует шаблону или массив, если передан массив.
Функция ПроверитьСтроку(Строчка, Маска = "\d{2}\.\d{2}\.\d{4}", Тестер = Неопределено) Экспорт
	Если Тестер = Неопределено Тогда
		Тестер = ЗначениеXDTOдляПроВеркиСтроки(Маска)
	КонецЕсли;

	Результат = Новый Массив;
	Для каждого ТекЗначение Из ПреобразоватьВМассив(Строчка) Цикл
	    Попытка
	        Тестер.TestItem = Строчка;
	        Результат.Добавить(Истина);
	    Исключение
	        Результат.Добавить(Ложь);
	    КонецПопытки;
	КонецЦикла; 
	Возврат ?(Результат.Количество() = 1, Результат[0], Результат)
КонецФункции

//Проверяет, подойдёт ли строчка для преобразования в УИД
// Параметры:
//  Строчка  - Любое значение, преобразуемое в строку - Проверяемая строка.
// Возвращаемое значение:
//   Булево   - Истина, если подходит для УИД. Считаются подходящими символами "-", 0-9, a-f, A-F.
Функция ЭтоУИД(Строчка)
	Возврат ПроверитьСтроку(НРег(Строчка), "[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]");
КонецФункции // ЭтоУИД()
 
//Возвращает сочетание клавиш по строковому обозначению
//Параметры:
//	СтроковоеОбозначениеСочетания - Строка - Расшифровываемое сочетание
//Возвращаемое значение
//	СочетаниеКлавиш - распознанное сочетание или Неопределено
Функция СочетаниеКлавишПоСтроке(СтроковоеОбозначениеСочетания) Экспорт
	Результат = Неопределено;
	Ктрл = Ложь;
	Шифт = Ложь;
	Алт = Ложь;
	Код = СтрЗаменить(СтроковоеОбозначениеСочетания, " ", "");
	
	ТекТекст = "Ctrl+";
	Поз = Найти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Ктрл = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли; 
	
	ТекТекст = "Shift+";
	Поз = Найти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Шифт = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли; 
	
	ТекТекст = "Alt+";
	Поз = Найти(Код, ТекТекст);
	Если Поз > 0 Тогда
		Алт = Истина;
		Код = СтрЗаменить(Код, ТекТекст, "");
	КонецЕсли;
	
	Попытка
		Клав = Клавиша[Код];
	Исключение
		Клав = "";
	КонецПопытки;
	
	Если Клав <> "" Тогда
		Результат = Новый СочетаниеКлавиш(Клав, Алт, Ктрл, Шифт);
	КонецЕсли; 
	
КонецФункции // СочетаниеКлавишПоСтроке()

// Возврщает дерево процедур и функций модуля с учётом областей
// Параметры:
//  ТекстМодуля - Строка - Текст модуля, в котором ищутся методы
//  ТолькоЭкспорт - Булево - Выбирать только экспортные процедуры
//  ОбластьРодитель - Строка - Имя области, внутри которой ищутся процедуры. Допускается, что в модуле м.б. несколько областей с этим именем. Сам родитель в дерево не попадает. По умолчанию "" - обрабатывается весь модуль.
//  ТегМеню - Строка - Префикс строки (после знака комментария), идентифицирующий в модуле строку представления в дереве. Эта строка может быть в любом месте метода и не включается в другие тексты. По умолчанию "МЕНЮ:".
// Возвращаемое значение:
//   Дерево значений   - Список методов модуля с колонками "Представление", "Имя", "Описание", "ПолноеОписание", "Текст", "Вид", "Экспорт" и "Параметры"
Функция ДеревоМетодовМодуля(ТекстМодуля, ТолькоЭкспорт = Истина, ОбластьРодитель = "", ТегМеню = "МЕНЮ:") Экспорт
	Результат = Новый ДеревоЗначений;
	#Область КОЛОНКИ
		Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("ПолноеОписание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Экспорт", Новый ОписаниеТипов("Булево")); 
		Результат.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
	#КонецОбласти
	
	Стек = Новый Массив;
	Коммент = Ложь; //Строка в теле комментария перед функцией
	Сброс = Истина; //Перед обработкой следующей строки обнулить данные записи
	Тело = Ложь; //Строка в теле функции
	СложныйКоммент = ""; //Комментарий, включающий область
	Заголовок = 0; //0 - это не заголовок, 1 - обработка заголовка до первой скобки, 2 - до второй скобки, 3 - после второй скобки
	Ветка = Результат;
	ДлТМ = СтрДлина(ТегМеню);
	РазрешеноЧтение = ОбластьРодитель = ""; //Строка внутри разрешённой области-родителя
	Для Ё = 1 По СтрЧислоСтрок(ТекстМодуля) Цикл
		Если Сброс Тогда
			Сброс = Ложь;
			Заготовка = Новый Структура(СписокКолонок(Результат));
			Если СложныйКоммент <> "" Тогда
				Заготовка.Вставить("ПолноеОписание", СложныйКоммент);
			КонецЕсли;
			СложныйКоммент = "";
		КонецЕсли;
		ТекСтрока = СокрЛП(СтрПолучитьСтроку(ТекстМодуля, Ё));
		Готово = Ложь; //Создать строку дерева после обработки строки модуля
		ВТекст = Ложь; //Вставить строку в текст метода
		ВКоммент = Ложь; // Вставить строку в текст комментария
		Если Лев(ТекСтрока, 2) = "//" Тогда
			ТекКоммент = СокрЛП(Сред(ТекСтрока, 3));
			Если Лев(ТекКоммент, ДлТМ) = ТегМеню Тогда
				Заготовка.Вставить("Представление", Сред(ТекКоммент, ДлТМ + 1));
			ИначеЕсли НЕ Тело Тогда
				Если НЕ Коммент Тогда
					Коммент = Истина;
					Заготовка.Вставить("ПолноеОписание", "");
				КонецЕсли;
				Если Лев(ТекКоммент, 9) = "Параметры" Тогда
					Заготовка.Вставить("Описание", Сред(Заготовка.ПолноеОписание, 2));
				КонецЕсли;
				ВКоммент = Истина;
			Иначе
				ВТекст = Истина;
			КонецЕсли; 
		ИначеЕсли Лев(ТекСтрока, 1) = "&" Тогда
			ВТекст = Тело;
		Иначе
			ЭтоПроц = НРег(Лев(ТекСтрока, 9)) = "процедура";
			ЭтоФ = НРег(Лев(ТекСтрока, 7)) = "функция";
			ЭтоОбл = НРег(Лев(ТекСтрока, 8)) = "#область";
			ЭтоКПроц = НРег(Лев(ТекСтрока, 14)) = "конецпроцедуры";
			ЭтоКФ = НРег(Лев(ТекСтрока, 12)) = "конецфункции";
			ЭтоКОбл = НРег(Лев(ТекСтрока, 13)) = "#конецобласти";
			Если ЭтоПроц ИЛИ ЭтоФ ИЛИ (Заголовок > 0) Тогда
				Тело = Истина;
				Если ЭтоПроц Или ЭтоФ Тогда
					Заготовка.Вставить("Текст", ТекСтрока);
					Заготовка.Вставить("Вид", ?(ЭтоФ, "Функция", "Процедура"));
					Квант = СокрЛП(Сред(ТекСтрока, ?(ЭтоФ, 9, 11)));
					Заголовок = 1;
					ПроверитьДругиеВарианты = Ложь;
				Иначе
					ПроверитьДругиеВарианты = Заголовок = 3; //Новая строка после скобки может быть новым оператором
					ВТекст = Истина;
					Квант = ТекСтрока;
				КонецЕсли;
				ВКоммент = НЕ ПроверитьДругиеВарианты; //Если нет других вариантов - это заголовок метода, он должен попадать в полный коммент
				//Имя метода
				Если Заголовок = 1 Тогда
					ПСкобки = Найти(Квант, "(");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Имя", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 2;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 2 Тогда
					ПСкобки = Найти(Квант, ")");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Параметры", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 3;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 3 Тогда
					Заголовок = 0;
					Заготовка.Вставить("Экспорт", НРег(Лев(Квант, 7)) = "экспорт");
				КонецЕсли;
			Иначе
				ПроверитьДругиеВарианты = Истина;
			КонецЕсли;
			Если ПроверитьДругиеВарианты Тогда
				ВТекст = Тело;
				Если ЭтоОбл Тогда
					Сброс = Истина;
					Готово = РазрешеноЧтение;
					Заготовка.Вставить("Вид", "Подменю");
					Заготовка.Вставить("Имя", СокрЛП(Сред(ТекСтрока, 10)));
					Если (Заготовка.Имя = ОбластьРодитель) И (ОбластьРодитель <> "") Тогда
						РазрешеноЧтение = Истина;
					КонецЕсли;
				ИначеЕсли ЭтоКОбл Тогда
					Сброс = Истина;
					Если Стек.Количество() = 0 Тогда
						РазрешеноЧтение = Ложь;
					Иначе
						Колво = Результат.Строки.Количество();
						КомментВОбласти = "";
						УдалитьПодменю = (Колво = 0) ИЛИ ((Колво = 1) И ТолькоЭкспорт);
						УдаляемоеПодменю = Результат;
						КомментВнутриОбласти = Заготовка.ПолноеОписание;
						Результат = Стек[Стек.ВГраница()];
						Стек.Удалить(Стек.ВГраница());
						Если УдалитьПодменю Тогда
							СложныйКоммент = "" + УдаляемоеПодменю.ПолноеОписание + Символы.ПС + "#Область" + УдаляемоеПодменю.Имя + Символы.ПС + КомментВнутриОбласти + Символы.ПС + ТекСтрока;
							Если Колво = 1 Тогда
								ЗаполнитьЗначенияСвойств(Результат.Строки.Добавить(), УдаляемоеПодменю.Строки[0]);
							КонецЕсли;
							Результат.Удалить(УдаляемоеПодменю);
						КонецЕсли;
					КонецЕсли; 
				ИначеЕсли ЭтоКПроц ИЛИ ЭтоКФ Тогда
					Готово = Истина;
					Сброс = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Коммент И НЕ Тело Тогда
				Заготовка.Вставить("ПолноеОписание", "");
				Заготовка.Вставить("Описание", "");
			КонецЕсли;
			Коммент = Ложь;
		КонецЕсли;
		Если ВКоммент Тогда
			Заготовка.Вставить("ПолноеОписание", Заготовка.ПолноеОписание + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если ВТекст Тогда
			Заготовка.Вставить("Текст", Заготовка.Текст + ТекСтрока);
		КонецЕсли;
		Если Готово Тогда
			Если РазрешеноЧтение Тогда
				ЭтоПодменю = Заготовка.Вид = "Подменю";
				Если ЭтоПодменю ИЛИ Заготовка.Экспорт ИЛИ НЕ ТолькоЭкспорт Тогда
					Если ПустаяСтрока(Заготовка.Представление) Тогда
						Заготовка.Вставить("Представление", Заготовка.Имя);
					КонецЕсли;
					НоваяСтрока = Результат.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Заготовка);
					Если ЭтоПодменю Тогда
						Стек.Добавить(Результат);
						Результат = НоваяСтрока;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Готово = Ложь;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ДеревоМетодовМодуля

#КонецОбласти

#Область ФАЙЛОВАЯ_СИСТЕМА

//Выделяет расширение из полного имени файла
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - расширение файла (подстрока после последней точки)
Функция ПолучитьРасширение(Путь) Экспорт
	СпецСтрока = СтрЗаменить(Путь, ".", Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя собственно файла (с расширением)
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя файла (подстрока после последнего разделителя пути)
Функция ИмяФайла(Путь) Экспорт
	#Если Клиент Тогда
		РП = ПолучитьРазделительПутиКлиента();
	#Иначе
		РП = ПолучитьРазделительПутиСервера();
	#КонецЕсли 
	СпецСтрока = СтрЗаменить(Путь, РП, Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя каталога без завершающего слэша
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя каталога (подстрока до последнего разделитля пути исключительно)
Функция ИмяКаталога(Путь) Экспорт
	Возврат Лев(Путь, СтрДлина(Путь) - СтрДлина(ИмяФайла(Путь)) - 1)
КонецФункции

//Переименовывает файл, добавляя к его старому имени префикс
//Параметры:
//	Имя - Строка - полное имя файла. Возвращается новое полное имя.
//	Префикс - Строка - добавляется к имени файла после пути к каталогу и разделителя пути.
Процедура ДобавитьПрефиксИмениФайла(Имя, Префикс)
	СтароеИмяФайла = ИмяФайла(Имя);
	НовоеИмя = Лев(Имя, СтрДлина(Имя) - СтрДлина(СтароеИмяФайла)) + Префикс + СтароеИмяФайла;
	ПереместитьФайл(Имя, НовоеИмя);
	Имя = НовоеИмя
КонецПроцедуры

//Получает файл из заданного пути, проверяет, зашифрован ли он, если нет - зашифровывает,
//Затем помещает в заданный каталог
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	ПутьОткудаВзять - Строка - Полный путь к исходному файлу
//	ПутьКудаСохранить - Строка - Имя каталога, куда будет сохранён под тем же именем зашифрованный файл.
//Возвращаемое значение:
//	Строка - при успешной зашифровке - новое имя файла, при неуспешной - пустая
Функция ЗашифроватьФайл(ПутьОткудаВзять, ПутьКудаСохранить) Экспорт
	ИмяФайла_ = "";
	КШифровке = Новый Файл(ПутьОткудаВзять);
	Если КШифровке.Существует() Тогда
		РазмерФайла = КШифровке.Размер();
		Если РазмерФайла > 9 Тогда
			Каталог = ПутьКудаСохранить;
			ИмяФайла_ = Каталог + ИмяФайла(ПутьОткудаВзять);
			Если ПутьОткудаВзять <> ИмяФайла_ Тогда
				Перезаписать = Ложь;
				КопироватьФайл(ПутьОткудаВзять, ИмяФайла_)
			КонецЕсли;
			РазмерЧасти = РазмерФайла - 9;
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[1], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Строка_ = "ВОЛНА2015";
			Если НЕ Зашифрован Тогда
				УдалитьФайлы(МассивФайлов[1]);
				УдалитьФайлы(МассивФайлов[0]);
				РазмерЧасти = Цел(РазмерФайла/2);
				МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
				//МассивФайлов.Добавить(ПолучитьИмяВременногоФайла());
				МассивФайлов.Добавить(МассивФайлов[0]);
				Колво = МассивФайлов.ВГраница();
				ЗаменитьКонецСтроки(МассивФайлов[Колво], "." + (Колво + 1));
				ТекстСлава = Новый ТекстовыйДокумент;
				ТекстСлава.УстановитьТекст("ВОЛНА2015");
				ТекстСлава.Записать(МассивФайлов[Колво], КодировкаТекста.ANSI);
				//Надо расставить файлы по именам 2-3-1-4
				ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
				ЗаменитьКонецСтроки(МассивФайлов[1], ".3");
				ЗаменитьКонецСтроки(МассивФайлов[Колво - 1], ".1");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[0], "_");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "___");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[МассивФайлов.ВГраница() - 1], "__");
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			Для каждого Ё из МассивФайлов Цикл
				УдалитьФайлы(Ё)
			КонецЦикла
		КонецЕсли
	КонецЕсли;
	Возврат ИмяФайла_
КонецФункции

//Читает файл, расшифровывает его во временный, открывает
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	Путь - Строка - Путь к расщифровываемому файлу
//Возвращаемое значение:
//	Булево - Удалось открыть файл
Функция РасшифроватьФайл(Путь) Экспорт
	Результат = Ложь;
	КРасшифровке = Новый Файл(Путь);
	Если КРасшифровке.Существует() Тогда
		РазмерФайла = КРасшифровке.Размер();
		Если РазмерФайла > 11 Тогда
			ИмяФайла_ = ПолучитьИмяВременногоФайла(ПолучитьРасширение(Путь));
			КопироватьФайл(Путь,ИмяФайла_);
			РазмерЧасти = Окр((РазмерФайла - 9)/2);
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[2], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Ложь;
			Если Строка_ = "ОЛНА2015" Тогда
				//нечёт
				ДопМассивФайлов = РазделитьФайл(МассивФайлов[1], РазмерЧасти - 1);
				ПереместитьФайл(ДопМассивФайлов[0], МассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[0]);
				//МассивФайлов[1] = ДопМассивФайлов[0];
				Зашифрован = Истина
			КонецЕсли;
			Зашифрован = Зашифрован ИЛИ (Строка_ = "ВОЛНА2015");
			УдалитьФайлы(МассивФайлов[2]);
			МассивФайлов.Удалить(2);
			//Файлы объединяются в порядке имён - имя второго надо "уменьшить"
			//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "_");
			ЗаменитьКонецСтроки(МассивФайлов[1], ".1");
			ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
			Если Зашифрован Тогда
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			УдалитьФайлы(МассивФайлов[1]);
			УдалитьФайлы(МассивФайлов[0]);
			ЗапуститьПриложение(ИмяФайла_);
			Результат = Истина;
		КонецЕсли
	КонецЕсли;
	Возврат Результат;
КонецФункции
 
//Передаёт файл из сетевого каталога на ФТП.
//Параметры:
//	ПолноеИмяФайлаИсточника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаПриёмника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ЗаписатьФайлНаFTP(ПолноеИмяФайлаИсточника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаПриёмника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 
		FTPСоединение.Записать(ПолноеИмяФайлаИсточника, ИмяФайлаПриёмника);	
		Если УдалитьИсточник Тогда
			УдалитьФайлы(ПолноеИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
	КонецПопытки;
КонецПроцедуры

//Передаёт файл с ФТП в сетевой каталог
//Параметры:
//	ПолноеИмяФайлаПриёмника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаИсточника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ПолучитьФайлСFTP(ПолноеИмяФайлаПриёмника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаИсточника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 	
		FTPСоединение.Получить(ИмяФайлаИсточника, ПолноеИмяФайлаПриёмника);
		Если УдалитьИсточник Тогда
			FTPСоединение.Удалить(ИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
	КонецПопытки;
КонецПроцедуры

#КонецОбласти

#Область ТИПЫ

//Возвращает булево, равен ли тип значения обозначенному строкой.
//Параметры:
//	 Значение - произвольный - проверяемое значение
//	 СтрокаОбозначенияТипа - Строка - строковое обозначение типа, например, СправочникСсылка.Банки
//Возвращаемое значение:
//	 Истина - тип значения совпадает с типом, полученным по строке
Функция ТипРавен(Значение, СтрокаОбозначенияТипа) Экспорт
	Результат = Ложь;
	Попытка
		Результат = ТипЗнч(Значение) = Тип(СтрокаОбозначенияТипа)
	Исключение
	КонецПопытки;
	Возврат Результат
КонецФункции //ТипРавен

//Получает пустую ссылку по строке типа (результату метода ПолноеИмя)
//Параметры:
//	  ТипОбъекта - Строка - полное имя метаданных
//Возвращаемое значение:
//	  Ссылка - Пустая ссылка метаданных
Функция ПолучитьПустуюСсылкуТипа(ТипОбъекта) Экспорт
	СтрокаСсылки = СтрЗаменить(ТипОбъекта, ".", "Ссылка.");
	Возврат Новый(Тип(СтрокаСсылки)) 
КонецФункции //ПолучитьПустуюСсылкуТипа

//Определяет ширину колонки для отображения типа. Для типов неопределённой длины берётся ширина 50.
//Параметры:
//	ОписаниеТипов - Описание типов - для которого требуется определить ширину колонки
//Первый параметр - описание типов, для этого описания определяется ширина.
//Возвращаемое значение:
//	Число - Ширина колонки
Функция ОпределитьШиринуКолонкиПоТипу(ОписаниеТипов) Экспорт
	Если ОписаниеТипов.КвалификаторыДаты = Неопределено	Тогда
		Ширина = 0
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		Ширина = 8
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
		Ширина = 10
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.ДатаВремя Тогда
		Ширина = 19
	Иначе
		Ширина = 0
	КонецЕсли;
	Если ОписаниеТипов.КвалификаторыДвоичныхДанных = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыСтроки = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыСтроки.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыЧисла = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыЧисла.Разрядность;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Для каждого Тип из ОписаниеТипов.Типы() Цикл
		Если Строка(Тип) = "Булево" Тогда
			Ширина_ = 2
		ИначеЕсли Строка(Тип) = "Null" Тогда
			Ширина_ = 4
		ИначеЕсли Строка(Тип) = "Неопределено" Тогда
			Ширина_ = 1
		ИначеЕсли Строка(Тип) = "Число" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Строка" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Дата" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Тип" Тогда
			Ширина_ = 24
		Иначе
			Ширина_ = СтрДлина(Строка(Новый(Тип)))
		КонецЕсли;
		Ширина = ?(Ширина < Ширина_, Ширина_, Ширина)
	КонецЦикла;
КонецФункции //ОпределитьШиринуКолонкиПоТипу

//Определяет тип значения и формирует описание типа по нему.
//Параметры:
//	Значение_ - Произвольный - по которому надо сформировать ОписаниеТипа
//Возвращаемое значение:
//	ОписаниеТипа - которому принадлежит заданное значение
Функция ПолучитьОписаниеТипаЗначения(Значение_) Экспорт
	Тип_ = ТипЗнч(Значение_);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип_);
	Если Тип_ = Тип("Число") Тогда
		//Определить квалификатор числа
		ДоЗапятой = Макс(1, 1 + Цел(Log10(?(Значение_ > 0, Значение_, ?(Значение_ < 0, -Значение_, 1)))));
		ПослеЗапятой = СтрДлина(Значение_ - Цел(Значение_)) - 2;
		//Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой + ПослеЗапятой + 1, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Возврат Новый ОписаниеТипов(МассивТипов, Квалификатор_)
	ИначеЕсли Тип_ = Тип("Строка") Тогда
		//Определить квалификатор строки
		//Квалификатор_ = Новый КвалификаторыСтроки(СтрДлина(Значение_), ДопустимаяДлина.Фиксированная);
		ТекДлина = СтрДлина(Значение_);
		Квалификатор_ = Новый КвалификаторыСтроки(?(ТекДлина = 0, 1, ТекДлина), ДопустимаяДлина.Фиксированная); //Чтобы нулевая длина не стала неограниченной
		Возврат Новый ОписаниеТипов(МассивТипов, , Квалификатор_)
	ИначеЕсли Тип_ = Тип("Дата") Тогда
		//Определить квалификатор даты
		Квалификатор_ = Новый КвалификаторыДаты(?((Час(Значение_) = 0) И (Минута(Значение_) = 0) И (Секунда(Значение_) = 0), ЧастиДаты.Дата,
				?((Год(Значение_) = 0) И (Месяц(Значение_) = 0) И (День(Значение_) = 0), ЧастиДаты.Время, ЧастиДаты.ДатаВремя)));
		Возврат Новый ОписаниеТипов(МассивТипов, , , Квалификатор_)
	ИначеЕсли Тип_ = Тип("ДвоичныеДанные") Тогда
		//Определить квалификатор двоичных данных
		Квалификатор_ = Новый КвалификаторыДвоичныхДанных(Значение_.Размер(), ДопустимаяДлина.Переменная);
		Возврат Новый ОписаниеТипов(МассивТипов, , , , Квалификатор_)
	Иначе
		Возврат Новый ОписаниеТипов(МассивТипов)
	КонецЕсли
КонецФункции

//Создаёт "суммарное" описание типов из двух
//Параметры:
//	ОТ1 - Описание типов - слагаемое
//	ОТ2 - Описание типов - слагаемое
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОбъединитьОписанияТипов(ОТ1, ОТ2) Экспорт
	ОТ_Итог = Новый ОписаниеТипов;
	Если ТипЗнч(ОТ1) = Тип("ОписаниеТипов") и ТипЗнч(ОТ2) = Тип("ОписаниеТипов") Тогда
		//ОТ2 = Новый ОписаниеТипов;
		//ОТ1 = Новый ОписаниеТипов;
		Менять = Ложь;
		Если ОТ1.КвалификаторыДаты.ЧастиДаты <> ОТ2.КвалификаторыДаты.ЧастиДаты Тогда
			КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
			Менять = Истина
		Иначе
			КвалификаторДаты = ОТ1.КвалификаторыДаты
		КонецЕсли;
		МенятьД = ОТ2.КвалификаторыДвоичныхДанных.Длина > ОТ1.КвалификаторыДвоичныхДанных.Длина;
		Размер = ?(МенятьД, ОТ2.КвалификаторыДвоичныхДанных.Длина, ОТ1.КвалификаторыДвоичныхДанных.Длина);
		МенятьДД = ((ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная) И НЕ (ОТ1.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная));
		Менять = Менять Или МенятьД или МенятьДД;
		Если МенятьДД Или МенятьД Тогда
			КвалификаторДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Размер, ?(МенятьДД или (ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная), ДопустимаяДлина.Переменная, ДопустимаяДлина.Фиксированная))
		Иначе
			КвалификаторДвоичныхДанных = ОТ1.КвалификаторыДвоичныхДанных
		КонецЕсли;
		МенятьД = ОТ2.КвалификаторыСтроки.Длина > ОТ1.КвалификаторыСтроки.Длина;
		Размер = ?(МенятьД, ОТ2.КвалификаторыСтроки.Длина, ОТ1.КвалификаторыСтроки.Длина);
		МенятьДД = ((ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная)
				И НЕ (ОТ1.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная))
				ИЛИ (ОТ2.КвалификаторыСтроки.Длина <> ОТ1.КвалификаторыСтроки.Длина);
		Менять = Менять Или МенятьД или МенятьДД;
		Если МенятьДД Или МенятьД Тогда
			КвалификаторСтроки = Новый КвалификаторыСтроки(Размер, ?(МенятьДД или (ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная), ДопустимаяДлина.Переменная, ДопустимаяДлина.Фиксированная))
		Иначе
			КвалификаторСтроки = ОТ1.КвалификаторыСтроки
		КонецЕсли;
		МенятьД = ОТ1.КвалификаторыЧисла.Разрядность < ОТ2.КвалификаторыЧисла.Разрядность;
		МенятьДД = ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
		ЗнакОТ2аЛюбой = (ОТ2.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
		ЗнакОТ1аЛюбой = (ОТ1.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
		Менять = Менять Или МенятьД или МенятьДД или (ЗнакОТ2аЛюбой и НЕ ЗнакОТ1аЛюбой);
		Если МенятьД или МенятьДД или (ЗнакОТ2аЛюбой и НЕ ЗнакОТ1аЛюбой) Тогда
			КвалификаторЧисла = Новый КвалификаторыЧисла(
					?(МенятьД, ОТ2.КвалификаторыЧисла.Разрядность, ОТ1.КвалификаторыЧисла.Разрядность)
					+ ?(МенятьДД, ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти, 0),
					?(МенятьДД, ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти, ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти),
					?(ЗнакОТ2аЛюбой Или ЗнакОТ1аЛюбой, ДопустимыйЗнак.Любой, ДопустимыйЗнак.Неотрицательный))
		Иначе
			КвалификаторЧисла = ОТ1.КвалификаторыЧисла
		КонецЕсли;
		Типы = ОТ1.Типы();
		Для каждого Тип из ОТ2.Типы() Цикл
			Если Типы.Найти(Тип) = Неопределено Тогда
				Менять = Истина;
				Типы.Добавить(Тип)
			КонецЕсли
		КонецЦикла;
		Если Менять Тогда
			ОТ_Итог = Новый ОписаниеТипов(Типы, КвалификаторЧисла, КвалификаторСтроки, КвалификаторДаты, КвалификаторДвоичныхДанных)
		Иначе
			ОТ_Итог = ОТ1
		КонецЕсли
	КонецЕсли;
	Возврат ОТ_Итог
КонецФункции //ОбъединитьОписанияТипов (ПодключитьОписаниеТипов)

//Возвращает объединённое описание типов всех значений коллекции
//Параметры:
//	Коллекция - Произвольная коллекция - по элементам которой будет формироваться описание типов
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОписаниеТиповКоллекции(Коллекция) Экспорт
	Если Коллекция.Количество() = 0 Тогда
		Возврат ПолучитьОписаниеТипаЗначения(Неопределено)
	Иначе
		Результат = ПолучитьОписаниеТипаЗначения(Коллекция[0]);
		Для каждого Единица из Коллекция Цикл
			Результат = ОбъединитьОписанияТипов(Результат, ПолучитьОписаниеТипаЗначения(Единица))
		КонецЦикла;
		Возврат Результат
	КонецЕсли
КонецФункции

//Возвращает описание типов "любая ссылка"
//Возвращаемое значение:
//	Описание типов - Описание типов, содержащее все ссылочные типы
Функция ВсеСсылочныеТипы() Экспорт
	Результат = Новый ОписаниеТипов(Документы.ТипВсеСсылки(), Перечисления.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, Справочники.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыВидовРасчета.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыОбмена.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, ПланыСчетов.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылки().Типы());
	Результат = Новый ОписаниеТипов(Результат, БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы());
	Возврат Новый ОписаниеТипов(Результат, Задачи.ТипВсеСсылки().Типы());
КонецФункции // ВсеСсылочныеТипы()

//Возвращает описание типов "любая ссылка"
//Параметры:
//	ВключитьСписокЗначений - Булево - При Истина (по умолчанию) результат включает список значений
//Возвращаемое значение:
//	Описание типов - любая ссылка + Булево + Дата + Число + Строка + (Опционально) Список значений
Функция ВсеСсылочныеИПростыеТипы(ВключитьСписокЗначений = Истина) Экспорт
	МассивТипов = Новый Массив();
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	Если ВключитьСписокЗначений Тогда
		МассивТипов.Добавить(Тип("СписокЗначений"));
	КонецЕсли; 
	Возврат Новый ОписаниеТипов(ВсеСсылочныеТипы(), МассивТипов,, Новый КвалификаторыЧисла(31, 7, ДопустимыйЗнак.Любой),
			Новый КвалификаторыСтроки(2000, ДопустимаяДлина.Переменная), Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя),
			Новый КвалификаторыДвоичныхДанных(2000, ДопустимаяДлина.Переменная));
КонецФункции // ВсеСсылочныеТипы()

//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//	Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//	Полностью - Булево или Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//		* ИмяТаблицы - Строка - Имя таблицы для запроса;
//		* Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//		* Метаданные - Объект метаданных - соответствующий объекту
//		* Менеджер - Менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//		Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//		Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение -  структура или строка -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
Функция ИмяТаблицыОбъектаПоТипу(Тип_, Полностью = Ложь) Экспорт
	МетаХ = Метаданные.НайтиПоТипу(Тип_);
	Если МетаХ = Неопределено Тогда
		Результат = Неопределено
	ИначеЕсли Полностью = "Метаданные" Тогда
		Результат = МетаХ;
	Иначе
		ТекИмя = МетаХ.Имя;
		Полная = Новый Структура;
		НуженМенеджер = (Найти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
		Если Метаданные.Документы.Содержит(МетаХ) Тогда
			СтрокаТипа = "Документ";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Документы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
			СтрокаТипа = "Справочник";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Справочники[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовХарактеристик";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланСчетов";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовРасчета";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
			СтрокаТипа = "БизнесПроцесс";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
			СтрокаТипа = "Задача";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Задачи[ТекИмя]);
			КонецЕсли; 
		Иначе
			Результат = "";
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, Найти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
			Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, Найти("," + Полностью + ",", ",Текст,") > 0) Тогда
			Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, Найти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
			Полная.Вставить("Метаданные", МетаХ);
		КонецЕсли;
		Результат = Полная;
		Если Результат.Количество() = 1 Тогда
			Для каждого КиЗ Из Полная Цикл
				Результат = КиЗ.Значение;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

// Разбивает массив на несколько массивов однотипных значений, помещаемых в Соответствие
// Параметры:
//  ИсходныйМассив  - Массив - Массив разнотипных объектов
// Возвращаемое значение:
//   Соответствие   - ключи - типы, значения - массивы однотипных значений
Функция РазбитьПоТипам(ИсходныйМассив) Экспорт
	СоответствиеТипов = Новый Соответствие;
	Если ТипЗнч(ИсходныйМассив) = Тип("Массив") Тогда
		Для каждого Док Из ИсходныйМассив Цикл
			ТекТип = ТипЗнч(Док);
			Если СоответствиеТипов[ТекТип] = Неопределено Тогда
				СоответствиеТипов.Вставить(ТекТип, Новый Массив);
			КонецЕсли;
			СоответствиеТипов[ТекТип].Добавить(Док);
		КонецЦикла;
	Иначе
		СоответствиеТипов.Вставить(ТипЗнч(ИсходныйМассив), ПреобразоватьВМассив(ИсходныйМассив));
	КонецЕсли;
	Возврат СоответствиеТипов;
КонецФункции // РазбитьПоТипам()

#КонецОбласти

#Область ЗАПРОСЫ

//Создаёт запрос с заданным текстом. Удобно для применения в длинных выражениях с точками, где Новый не прокатит
//Параметры:
//	ТекстЗапроса - строка - текст запроса
//	Параметры - структура - параметры запроса (необязательный)
//	МВТ - менеджер временных таблиц - для установки в запрос (необязательный)
//Возвращаемое значение:
//	Запрос - сформированный запрос.
Функция СоздатьЗапрос(ТекстЗапроса_, Параметры = Неопределено, МВТ = Неопределено) Экспорт
	Результат = Новый Запрос(ТекстЗапроса_);
	Если НЕ (Параметры = Неопределено) Тогда
		Для Каждого КиЗ из Параметры Цикл
			Результат.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение)
		КонецЦикла
	КонецЕсли;
	Если НЕ (МВТ = Неопределено) Тогда
		Результат.МенеджерВременныхТаблиц = МВТ
	КонецЕсли;
	Возврат Результат
КонецФункции

//Выполняет запрос и возвращает значение из первой его ячейки
//Параметры:
//	Запрос_ - Запрос - Готовый к выполнению запрос
//	ЕслиНеНайдено - Произвольный - Значение, возвращаемое, если запрос вернул пустой результат
//Возвращаемое значение:
//	Произвольный - значение из первой ячейки запроса
Функция ПолучитьЕдинственноеЗначениеЗапроса(Запрос_, ЕслиНеНайдено = Неопределено) Экспорт
	ТабХ = Запрос_.Выполнить().Выгрузить();
	Возврат ?(ТабХ.Количество() = 0, ЕслиНеНайдено, ТабХ[0][0])
КонецФункции

//Возвращает строку - имя типа в виде, подходящем для запроса. Если тип - сложный, возвращается описание первого.
//Параметры:
//	ОписаниеТипа - описание типа,  по которому надо получить полное имя метаданных
//Возвращаемое значение:
//	Строка - Полное имя метаданных, пригодное для запроса
Функция ТипДляЗапроса(ОписаниеТипа) Экспорт
	Если ТипЗнч(ОписаниеТипа) = Тип("ОписаниеТипов") Тогда
		Описание = ОписаниеТипа;
		Тип_ = ОписаниеТипа.Типы()[0];
		Если Тип_ = Тип("Строка") Тогда
			Возврат "СТРОКА(" + ОписаниеТипа.КвалификаторыСтроки.Длина + ")"
		ИначеЕсли Тип_ = Тип("Число") Тогда
			Возврат "ЧИСЛО(" + ОписаниеТипа.КвалификаторыЧисла.Разрядность + ", " + ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти + ")"
		КонецЕсли
	ИначеЕсли ТипЗнч(ОписаниеТипа) = Тип("Тип") Тогда
		МТипов = Новый Массив;
		МТипов.Добавить(ОписаниеТипа);
		Описание = Новый ОписаниеТипов(МТипов)
	Иначе
		Возврат Строка(ОписаниеТипа)
	КонецЕсли;
	Попытка
		Возврат Описание.ПривестиЗначение(0).Метаданные().ПолноеИмя()
	Исключение
		Возврат СокрЛП(ОписаниеТипа)
	КонецПопытки
КонецФункции

//Возвращает текст запроса, размещающего таблицу значений во временную таблицу
//Параметры:
//	Таблица = таблица значений
//	Выразить = Типизировать в запросе колонки таблицы
//	ИмяВТ = строка, имя временной таблицы
//	ВПакете = добавляет окончание для вставки в пакет запросов
//Возвращаемое значение:
//	Строка - Текст запроса, помещающего таблицу значений во временную таблицу.
Функция ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить = Ложь, ВПакете = Истина) Экспорт
	ТекстЗапроса = "";
	Для каждого Колонка из Таблица.Колонки Цикл
		ТекстЗапроса = ТекстЗапроса + "," + Символы.ПС + ?(Выразить, "	ВЫРАЗИТЬ(Таб." + Колонка.Имя + " КАК " +
				ТипДляЗапроса(ОписаниеТиповКоллекции(Таблица.ВыгрузитьКолонку(Колонка))) + ") КАК ",
				"	Таб.") + Колонка.Имя
	КонецЦикла;
	Возврат "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + Символы.ПС + "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС + "ИЗ" +
			Символы.ПС + "	&ТабПараметр КАК Таб" + ?(ВПакете, Символы.ПС + ";" + Символы.ПС + "////////////////////////////////////////////////////" + Символы.ПС, "")
КонецФункции

//Помещает таблицу значений во временную таблицу
//	Таблица = таблица значений
//	Менеджер = менеджер временных таблиц. Сюда и попадает таблица.
//	ИмяВТ = строка, имя временной таблицы
//	Выразить = Типизировать в запросе колонки таблицы
Процедура ТаблицуЗначенийВоВременнуюТаблицу(Таблица, Менеджер, ИмяВТ, Выразить = Ложь) Экспорт
	ТекстЗапроса = ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить, Ложь);
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	Запрос.УстановитьПараметр("ТабПараметр", Таблица);
	Запрос.Выполнить()
КонецПроцедуры

// Заполняет незаданные параметры запроса заданными значениями
// Параметры:
//  Запрос_  - Запрос - с установленным текстом, в котором будут проверяться и устанавливаться параметры
//  Значения  - Любое значение - значение, по которому будут задаваться параметры.
//		*Структура - Имя параметра с ключом будет заполнено значением (только для незаполненных). Ненайденные будут заполнены значением по умолчанию (из ключа "ОСТАЛЬНЫЕ" или общего)
//		*Любое другое значение - будет непосредственно помещено во все незаполненные параметры
//		*Строка "#№#№#" (по умолчанию) - во все параметры будет помещён пустой массив
Процедура ЗаполнитьНезаполненныеПараметрыЗапроса(Запрос_, Значения = "#№#№#") Экспорт
	ПоУмолчанию = Новый Массив;
	Если Значения = "#№#№#" Тогда
		Значения = ПоУмолчанию;
		ТипСтр = Ложь;
	Иначе
		ТипЗн = ТипЗнч(Значения);
		ТипСтр = (ТипЗн = Тип("Структура")) ИЛИ (ТипЗн = Тип("ФиксированнаяСтруктура"));
	КонецЕсли;
	ПараметрыТекущегоЗапроса = Запрос_.НайтиПараметры();
	Для каждого ПараметрЗапроса Из ПараметрыТекущегоЗапроса Цикл
		ИмяПараметра =  ПараметрЗапроса.Имя;
		Если НЕ Запрос_.Параметры.Свойство(ИмяПараметра) Тогда
			Запрос_.УстановитьПараметр(ИмяПараметра, ?(ТипСтр, ?(Значения.Свойство(ИмяПараметра), Значения[ИмяПараметра], ?(Значения.Свойство("ОСТАЛЬНЫЕ"), Значения.ОСТАЛЬНЫЕ, ПоУмолчанию)), Значения));
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры // ЗаполнитьНезаполненныеПараметрыЗапроса

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
#Область ЗАМЕНА_ССЫЛОК

//Вспомогательная для следующей экспортной процедуры. Выполняет разовую замену.
//Параметры:
//	ГдеМенять - Произвольный, поддерживающий изменяемые реквизиты - Объект, в котором будет произведена замена
//	Реквизит - Строка - Имя реквизита, в котором будет произведена замена
//	Замены - [Фиксированное] соответствие - Соответствие правильных значений (значения) заменяемым (ключи)
//	Комментировать - Булево - Выводить сообщения о замене
//	ВТабло - Булево - Ложь = Комментарий пойдёт в строку состояния, Истина - в табло
//Возвращаемое значение:
//	Произвольный - значение после замены
Функция ЗаменитьСсылку(ГдеМенять, Реквизит, Замены, Комментировать, ВТабло)
	ТекЗнч = ГдеМенять[Реквизит];
	ПравильныйЭлемент = Замены[ТекЗнч];
	Если ПравильныйЭлемент <> Неопределено Тогда
		ГдеМенять[Реквизит] = ПравильныйЭлемент;
		Если Комментировать Тогда
			Попытка
				ГдеМенятьСтрокой = "" + ГдеМенять;
			Исключение
				ГдеМенятьСтрокой = "" + ТипЗнч(ГдеМенять);
			КонецПопытки;
			Прокомментировать("В " + Реквизит + " объекта " + ГдеМенятьСтрокой + " " + ТекЗнч + " заменён на " + ПравильныйЭлемент, ВТабло);
		КонецЕсли; 
	КонецЕсли;
	Возврат ПравильныйЭлемент
КонецФункции // ЗаменитьСсылку()
 
//Вспомогательная для следующей экспортной процедуры. Выводит сообщение об ошибке.
//Параметры:
//	Информация - Соответствие - с ключом Описание или Причина.Описание
//	Контекст - Произвольный - Дополнение для вывода после описания причины.
Процедура СообщитьОбОшибкеПриЗаписи(Информация, Контекст)
	Причина = ?(Информация.Причина = Неопределено, Информация, Информация.Причина);
	Сообщить(Причина.Описание + Контекст, СтатусСообщения.Важное);
КонецПроцедуры

//Вспомогательная для следующей экспортной процедуры и функции ЗаменитьСсылку. Выводит комментарий на экран.
//Параметры:
//	КВыводу - Произвольный - То, что будет выведено.
//	ВТабло - Булево - Истина = в табло, Ложь - в строку состояния.
Процедура Прокомментировать(КВыводу, ВТабло)
	Если ВТабло Тогда
		Сообщить(КВыводу);
	Иначе
		#Если Клиент Тогда
		Состояние(КВыводу);
		#КонецЕсли
	КонецЕсли; 
КонецПроцедуры

//Заменяет значения по таблице замен и помечает на удаление заменяемые значения.
//Параметры:
//	ЗаменяемыеЗначения - Таблица значений - с колонками ЧтоЗаменять, НаЧтоЗаменять, Пометка (флаг необходимости замены) и ПометитьНаУдаление.
//	НайденныеСсылки - Таблица значений - с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВТранзакции - Булево - Выполнять в единой транзакции все замены.
//	БезКонтроля - Булево - Включает режим записи "Загрузка", отменяющий многие контроли при записи и ускоряющий её.
//	ОтменитьРегистрациюВОбменах - Булево - Устанавливает у объектов допсвойство, в типовых конфигурациях блокирующее регистрацию в планах обмена.
//	Комментировать - Строка - "Нет", "ВТабло" или "ВСоответствие". По умолчанию - "Нет".
//Возвращаемое значение:
//	Булево - Замена завершена без ошибок
Функция ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление(ЗаменяемыеЗначения, НайденныеСсылки, ВТранзакции = Истина, БезКонтроля = Ложь, ОтменитьРегистрациюВОбменах = Истина, Комментировать = "Нет") Экспорт
	Заменяемые = Новый Соответствие;
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.Пометка Тогда
			Заменяемые.Вставить(Стр.ЧтоЗаменять, Стр.НаЧтоЗаменять);
		КонецЕсли;
	КонецЦикла;
	ВТабло = ВРег(Комментировать) = "ТАБЛО";
	Комментировать_ = ВРег(Комментировать) <> "НЕТ";
	БезОшибок = ЗаменитьСсылкиПоСоответствию(Заменяемые, НайденныеСсылки, ВТранзакции, БезКонтроля, ОтменитьРегистрациюВОбменах, Комментировать);
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.ПометитьНаУдаление Тогда
			Объект_ = Стр.ЧтоЗаменять.ПолучитьОбъект();
			Если НЕ Объект_.ПометкаУдаления Тогда
				Объект_.ПометкаУдаления = Истина;
				Объект_.ОбменДанными.Загрузка = БезКонтроля;
				Попытка
					Объект_.Записать();
					Если Комментировать_ Тогда
						Прокомментировать("Помечен на удаление " + Объект_, ВТабло);
					КонецЕсли; 
				Исключение
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при пометке на удаление)");
					БезОшибок = Ложь;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат БезОшибок
КонецФункции // ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление()

//Заменяет ссылки из таблицы по заданным соответствиям
//Параметры:
//	Заменяемые		-	Соответствие		-	Ключ - заменяемое, Значение - замещающее значение
//	ТаблицаСсылок		-	Таблица значений	-	с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВыполнятьВТранзакции			-	Булево	-	Если Истина (по умолчанию), то одна общая транзакция,
//										Ложь - транзакции по каждому объекту данных.
//										Истина - быстрее и сохраняет целостность, Ложь - помехоустойчивей и надёжнее.
//	ОтключатьКонтрольЗаписи		-	Булево	-	Записывать в режиме загрузки. По умолчанию Истина.
//	ОтменитьРегистрациюВОбменах	-	Булево	-	Записывать без регистрации в обменах данных. По умолчанию Истина.
//	Комментировать				-	Строка	-	"Нет", "Табло" или "Состояние". По умолчанию - "Нет".
//Возвращаемое значение:
//	Булево - Замены выполнены без ошибок
Функция ЗаменитьСсылкиПоСоответствию(Заменяемые, ТаблицаСсылок, ВыполнятьВТранзакции = Истина, ОтключатьКонтрольЗаписи = Истина, ОтменитьРегистрациюВОбменах = Истина, Комментировать = "Нет") Экспорт
	БылиИсключения = Ложь;
	Если ВыполнятьВТранзакции Тогда
		НачатьТранзакцию();
	КонецЕсли;
	ОбрабатываемаяСсылка = Неопределено;
	ПараметрыХ = Новый Структура;
	Для Каждого РегистрБухгалтерии ИЗ Метаданные.РегистрыБухгалтерии Цикл
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Субконто", РегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто);
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Корреспонденция", РегистрБухгалтерии.Корреспонденция);		
	КонецЦикла;
	//ПараметрыХ.Вставить("Объект", Неопределено);	
	ТабЗамен = ТаблицаСсылок.Скопировать(ТаблицаССылок.НайтиСтроки(Новый Структура("Включено", Истина)), "Данные,Ссылка");
	ТабЗамен.Свернуть("Данные,Ссылка");
	ТабЗамен.Сортировать("Данные,Ссылка");
	ТабЗамен.Индексы.Добавить("Данные,Ссылка");
	ТабДанных = ТабЗамен.Скопировать(,"Данные");
	ТабДанных.Свернуть("Данные");
	ИОР = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита;
	ИнфоМД = Новый Соответствие;
	Комментировать_ = ВРег(Комментировать) <> "НЕТ";
	ВТабло = ВРег(Комментировать) = "ТАБЛО";
	Данных = ТабДанных.Количество();
	Сч = 0;
	Для каждого СтрокаДанных Из ТабДанных Цикл
		Если Комментировать_ Тогда
			Сч = Сч + 1;
			Прокомментировать("Строка " + Сч + " из " + Данных, ВТабло);
		КонецЕсли; 
		Замены = ТабЗамен.НайтиСтроки(Новый Структура("Данные", СтрокаДанных.Данные));
		//Построить соответствие замен для конкретных данных
		ТекЗамены = Новый Соответствие;
		Для каждого СтрокаЗамен Из Замены Цикл
			ТекЗамены.Вставить(СтрокаЗамен.Ссылка, Заменяемые[СтрокаЗамен.Ссылка]);
		КонецЦикла;
		//И перебор по реквизитам данных
		СтроковыйТип = СтрЗаменить(СтрокаДанных.Данные, ".", Символы.ПС);
		МетаХ = ?(СтрПолучитьСтроку(СтроковыйТип, 1) = "РегистрСведенийКлючЗаписи",
				Метаданные.РегистрыСведений.Найти(СтрПолучитьСтроку(СтроковыйТип, 2)), СтрокаДанных.Данные.Метаданные());
		ИнфоЭтиМД = ИнфоМД[МетаХ];
		Если ИнфоЭтиМД = Неопределено Тогда
			ИнфоЭтиМД = Новый Структура;
			ИнфоЭтиМД.Вставить("ЭтоСпр",  Метаданные.Справочники.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоДок",  Метаданные.Документы.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоБПлан",  Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ)
					  ИЛИ Метаданные.ПланыСчетов.Содержит(МетаХ)
					  ИЛИ Метаданные.ПланыВидовРасчета.Содержит(МетаХ)
					  ИЛИ Метаданные.БизнесПроцессы.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоЗадача",  Метаданные.Задачи.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоРС",  Метаданные.РегистрыСведений.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоКонст",  Метаданные.Константы.Содержит(МетаХ));
			ИнфоОР = Новый Соответствие;
			ИнфоЭтиМД.Вставить("ОР", ИнфоОР);
			ИнфоПослед = Новый Соответствие;
			ИнфоЭтиМД.Вставить("Послед", ИнфоОР);
		Иначе
			ИнфоОР = ИнфоЭтиМД.ОР;
			ИнфоПослед = ИнфоЭтиМД.Послед;
		КонецЕсли; 
		Если ИнфоЭтиМД.ЭтоКонст Тогда
			Константы[МетаХ.Имя].Установить(Заменяемые[ТекЗамены[0].Ссылка]);
		ИначеЕсли ИнфоЭтиМД.ЭтоРС Тогда
			СтруктураИзмерений = Новый Структура;
			НаборЗаписей = РегистрыСведений[МетаХ.Имя].СоздатьНаборЗаписей();
			Для Каждого Измерение ИЗ МетаХ.Измерения Цикл
				НаборЗаписей.Отбор[Измерение.Имя].Установить(СтрокаДанных.Данные[Измерение.Имя]);
				СтруктураИзмерений.Вставить(Измерение.Имя);
			КонецЦикла;
			Если МетаХ.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
				НаборЗаписей.Отбор["Период"].Установить(СтрокаДанных.Данные.Период);
			КонецЕсли;
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ТаблицаНабора = НаборЗаписей.Выгрузить();
			НаборЗаписей.Очистить();
			Если ОтключатьКонтрольЗаписи Тогда
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
			КонецЕсли;
			Если Не ВыполнятьВТранзакции Тогда
				НачатьТранзакцию();
			КонецЕсли;
			Попытка
				НаборЗаписей.Записать();
				Для каждого СтрокаНабора Из ТаблицаНабора Цикл
					Для Каждого Колонка ИЗ ТаблицаНабора.Колонки Цикл
						ПравильныйЭЛемент = ЗаменитьСсылку(СтрокаНабора, Колонка.Имя, ТекЗамены, Комментировать_, ВТабло);
						Если СтруктураИзмерений.Свойство(Колонка.Имя) И (ПравильныйЭЛемент <> Неопределено) Тогда
							НаборЗаписей.Отбор[Колонка.Имя].Установить(ПравильныйЭЛемент);
						КонецЕсли;
					КонецЦикла; 
				КонецЦикла;
				НаборЗаписей.Загрузить(ТаблицаНабора);
				НаборЗаписей.Записать();
				Если Не ВыполнятьВТранзакции Тогда
					ЗафиксироватьТранзакцию();
				КонецЕсли; 
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи регистра сведений)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ОтменитьТранзакцию();
				КонецЕсли;
			КонецПопытки;
		ИначеЕсли ИнфоЭтиМД.ЭтоСпр ИЛИ ИнфоЭтиМД.ЭтоДок ИЛИ ИнфоЭтиМД.ЭтоБПлан ИЛИ ИнфоЭтиМД.ЭтоЗадача Тогда
			ИсключенияВДанных = Ложь;
			Попытка
				ТекОбъект = СтрокаДанных.Данные.ПолучитьОбъект();
				Если ОтменитьРегистрациюВОбменах Тогда
					ТекОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				КонецЕсли; 
				//Для каждого Замена Из Заменяемые Цикл //ТекЗамены Цикл
				//	Ссылка = Замена.Ключ;
				//	ПравильныйЭлемент = Замена.Значение;
				Если ИнфоЭтиМД.ЭтоСпр Тогда //А здесь 80000
					//Если МетаХ.Владельцы.Содержит(Ссылка.Метаданные()) И ТекОбъект.Владелец = Ссылка Тогда
					ЗаменитьСсылку(ТекОбъект, "Владелец", ТекЗамены, Комментировать_, ВТабло);
					Если МетаХ.Иерархический Тогда
						ЗаменитьСсылку(ТекОбъект, "Родитель", ТекЗамены, Комментировать_, ВТабло);
					КонецЕсли;
				КонецЕсли;
				Для Каждого Реквизит Из Метаданные.ОбщиеРеквизиты Цикл //Замедляет, часто запускается! 300 тыс раз при 2000 данных и 3000 пар замен!
					Использование_ = ИнфоОР[Реквизит];
					Если Использование_ = Неопределено Тогда
						ЭлементР = Реквизит.Состав.Найти(МетаХ);//Замедляет!!!!!! 40% при 250 тыс. запусках
						Использование_ = Ложь;
						Если ЭлементР <> Неопределено Тогда
							ТекИсп = ЭлементР.Использование;
							Если ТекИсп = ИОР.Авто Тогда
								Если Реквизит.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать Тогда //200000 запусков
									Использование_ = Истина;
								КонецЕсли; 
							ИначеЕсли ТекИсп = ИОР.Использовать Тогда
								Использование_ = Истина;
							КонецЕсли; 
						КонецЕсли;
						Если Реквизит.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
							Если Строка(Реквизит.УсловноеРазделение) <> "" Тогда
								Попытка
									Использование_ = Использование_ И Константы[Реквизит.УсловноеРазделение.Имя].Получить();
								Исключение
									
								КонецПопытки;
							КонецЕсли; 
						КонецЕсли; 
						ИнфоОР.Вставить(Реквизит, Использование_);
					КонецЕсли; 
					Если Использование_ Тогда
						//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Комментировать_, ВТабло);
					КонецЕсли; 
				КонецЦикла;
				Для Каждого Реквизит Из МетаХ.Реквизиты Цикл
					//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда //2,7 млн, 5%
					ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Комментировать_, ВТабло);
				КонецЦикла;
				Для Каждого ТЧ ИЗ МетаХ.ТабличныеЧасти Цикл
					Если ТекОбъект[ТЧ.Имя].Количество() < 200 Тогда
						//Маленькие ТЧ проще перебрать, избавившись от проверок типов и доп. цикла
						Для каждого Строка_ТЧ_ Из ТекОбъект[ТЧ.Имя] Цикл
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
								ЗаменитьСсылку(Строка_ТЧ_, Реквизит.Имя, ТекЗамены, Комментировать_, ВТабло);
							КонецЦикла; 
						КонецЦикла;
					Иначе
						//В больших ТЧ лучше ограничить число колонок
						Для каждого КиЗ Из ТекЗамены Цикл
							ПравильныйЭлемент = КиЗ.Значение;
							Ссылка = КиЗ.Ключ;
							ТипСсылки = ТипЗнч(Ссылка);
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл //5 млн 7%
								Если Реквизит.Тип.СодержитТип(ТипСсылки) Тогда //10 млн, 10%
									СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									Пока СтрокаТабЧасти <> Неопределено Цикл
										СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
										СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									КонецЦикла;
								КонецЕсли; //2%
							КонецЦикла;
						КонецЦикла; 
					КонецЕсли;
				КонецЦикла;
				Если ИнфоЭтиМД.ЭтоЗадача Тогда
					Для Каждого Реквизит Из МетаХ.РеквизитыАдресации Цикл
						//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Комментировать_, ВТабло);
					КонецЦикла;
				КонецЕсли;
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов объекта)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ИсключенияВДанных = Истина;
				КонецЕсли;
			КонецПопытки;
			Если НЕ ИсключенияВДанных Тогда
				КЗаписи = Новый Массив;
				Попытка
					Если ИнфоЭтиМД.ЭтоДок Тогда
						Для Каждого Движение ИЗ МетаХ.Движения Цикл
							ЭтоДвижениеРегистраБухгалтерии = Метаданные.РегистрыБухгалтерии.Содержит(Движение);
							ЕстьКорреспонденция = ЭтоДвижениеРегистраБухгалтерии и ПараметрыХ[Движение.Имя + "Корреспонденция"];
							НаборЗаписей  = ТекОбъект.Движения[Движение.Имя];
							НаборЗаписей.Прочитать(); //1698 запусков 4%
							НадоЗаписывать = Ложь;
							ТаблицаНабора = НаборЗаписей.Выгрузить();
							ТеККолво = ТаблицаНабора.Количество();
							Если ТеККолво = 0 Тогда
								Продолжить;
							ИначеЕсли ТекКолво < 200 Тогда
								Для каждого ТекЗапись Из ТаблицаНабора Цикл
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если ЕстьКорреспонденция И НЕ Измерение.Балансовый Тогда // (Измерение.ПризнакУчета <> Неопределено) Тогда
											ИмяРекв = Измерение.Имя + "Дт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
											ИмяРекв = Измерение.Имя + "Кт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										Иначе
											ИмяРекв = Измерение.Имя;
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если Метаданные.РегистрыСведений.Содержит(Движение) Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											//Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЗаменитьСсылку(ТекЗапись, Ресурс.Имя, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если ЗаменитьСсылку(ТекЗапись, Реквизит.Имя, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубДт, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе							
												СубКт = "Субконто" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;						
										КонецЦикла;
										//Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Если ЕстьКорреспонденция Тогда
												Если ЗаменитьСсылку(ТекЗапись, "СчетДт", ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, "СчетКт", ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе
												Если ЗаменитьСсылку(ТекЗапись, "Счет", ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;
										//КонецЕсли;
									КонецЕсли;
									Если Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
										Если ЗаменитьСсылку(ТекЗапись, "ВидРасчета", ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЕсли;
								КонецЦикла; 
							Иначе
								Для каждого КиЗ Из ТекЗамены Цикл
									ПравильныйЭлемент = КиЗ.Значение;
									Ссылка = КиЗ.Ключ;
									масИменКолонок = Новый Массив;
									// Получим имена измерений, которые могут содержать ссылку
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЕстьКорреспонденция И (Измерение.ПризнакУчета <> Неопределено) Тогда
												масИменКолонок.Добавить(Измерение.Имя + "Дт");
												масИменКолонок.Добавить(Измерение.Имя + "Кт");
											Иначе
												масИменКолонок.Добавить(Измерение.Имя);
											КонецЕсли;
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если Метаданные.РегистрыСведений.Содержит(Движение) Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
												масИменКолонок.Добавить(Ресурс.Имя);
											КонецЕсли;
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											масИменКолонок.Добавить(Реквизит.Имя);
										КонецЕсли;
									КонецЦикла;
									// Произведем замены в таблице
									Для Каждого ИмяКолонки Из масИменКолонок Цикл //4 млн 3%
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки); //3,7 млн, 8%
										Пока СтрокаТабЧасти <> Неопределено Цикл //3,7 млн 2%
											СтрокаТабЧасти[ИмяКолонки] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки);
										КонецЦикла;
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубКт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												КонецЦикла;								
											Иначе							
												СубДт = "Субконто" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;							
											КонецЕсли;						
										КонецЦикла;
										Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Для Каждого СтрокаТабЧасти Из ТаблицаНабора Цикл
												Если ЕстьКорреспонденция Тогда
													Если СтрокаТабЧасти.СчетДт = Ссылка Тогда
														СтрокаТабЧасти.СчетДт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
													Если СтрокаТабЧасти.СчетКт = Ссылка Тогда
														СтрокаТабЧасти.СчетКт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												Иначе
													Если СтрокаТабЧасти.Счет = Ссылка Тогда
														СтрокаТабЧасти.Счет = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												КонецЕсли;
											КонецЦикла;
										КонецЕсли;
									КонецЕсли;
									Если Метаданные.РегистрыРасчета.Содержит(Движение) Тогда //2% 600000
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										Пока СтрокаТабЧасти <> Неопределено Цикл
											СтрокаТабЧасти["ВидРасчета"] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										КонецЦикла;
									КонецЕсли;
								КонецЦикла; 
							КонецЕсли;
							Если НадоЗаписывать Тогда
								НаборЗаписей.Загрузить(ТаблицаНабора);
								Если ОтключатьКонтрольЗаписи Тогда
									НаборЗаписей.ОбменДанными.Загрузка = Истина;
								КонецЕсли;
								КЗаписи.Добавить(НаборЗаписей);
								//НаборЗаписей.Записать();
							КонецЕсли;
						КонецЦикла;
						Для Каждого Последовательность ИЗ Метаданные.Последовательности Цикл
							//Последовательностей мало, а по уму тоже надо в массив выностить
							ТекПослед = ИнфоПослед[Последовательность];
							Если ТекПослед = Неопределено Тогда
								ТекПослед = Последовательность.Документы.Содержит(МетаХ);
								ИнфоПослед.Вставить(Последовательность, ТекПослед);
								НадоЗаписывать = Ложь;
								НаборЗаписи = Последовательности[Последовательность.Имя].СоздатьНаборЗаписей();
								НаборЗаписи.Отбор.Регистратор.Установить(СтрокаДанных.Данные);
								НаборЗаписи.Прочитать();
								Если НаборЗаписи.Количество() > 0 Тогда
									Для Каждого Измерение ИЗ Последовательность.Измерения Цикл
										Если ЗаменитьСсылку(НаборЗаписи[0], Измерение.Имя, ТекЗамены, Комментировать_, ВТабло) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
										//Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) И НаборЗаписи[0][Измерение.Имя]=Ссылка Тогда
										Если НадоЗаписывать Тогда
											Если ОтключатьКонтрольЗаписи Тогда
												НаборЗаписи.ОбменДанными.Загрузка = Истина;
											КонецЕсли;
											КЗаписи.Добавить(НаборЗаписей);
											//НаборЗаписи.Записать();
										КонецЕсли;
									КонецЦикла; 
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли; 
				Исключение	
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов движений)");
					БылиИсключения = Истина;
					Если ВыполнятьВТранзакции Тогда
						Прервать; //На откат
					Иначе
						ИсключенияВДанных = Истина;
					КонецЕсли;
				КонецПопытки;
				Если НЕ ИсключенияВДанных Тогда
					Если ОтключатьКонтрольЗаписи Тогда
						ТекОбъект.ОбменДанными.Загрузка = Истина;
					КонецЕсли;
					Если Не ВыполнятьВТранзакции Тогда
						НачатьТранзакцию();
					КонецЕсли;
					Попытка
						Для каждого ТекЗапись Из КЗаписи Цикл
							ТекЗапись.Записать();
						КонецЦикла; 
						ТекОбъект.Записать();
						Если Не ВыполнятьВТранзакции Тогда
							ЗафиксироватьТранзакцию();
						КонецЕсли; 
					Исключение
						СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи движений или объекта)");
						БылиИсключения = Истина;
						Если ВыполнятьВТранзакции Тогда
							Прервать; //На откат
						Иначе
							ОтменитьТранзакцию();
						КонецЕсли;
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Сообщить("Ссылки типа " + МетаХ + " не заменяются!!");
		КонецЕсли; 
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя(); //Надо (А надо ли?) реализовать с переходом на сервер
		#КонецЕсли
	КонецЦикла;
	Если ВыполнятьВТранзакции Тогда
		Если БылиИсключения Тогда
			ОтменитьТранзакцию();
		Иначе
			ЗафиксироватьТранзакцию();
		КонецЕсли;	
	КонецЕсли;
	Возврат Не БылиИсключения;
КонецФункции //ЗаменитьСсылкиПоСоответствию

#КонецОбласти 

//Переводит строку ГУИД в УИД
//Параметры:
//	GUID_ - Строка - 32 значный ГУИД
//Возвращаемое значение:
//	Строка - в формате УникальныйИдентификатор (36 символов)
Функция GUIDToUUID(GUID_) Экспорт
 
 Возврат Прав(GUID_, 8) + "-" + Сред(GUID_, 21, 4) + "-" + Сред(GUID_, 17, 4) + "-" + Лев(GUID_, 4) + "-" + Сред(GUID_, 5, 12);
 
КонецФункции

//Переводит строку УИД в ГУИД
//Параметры:
//	UUID_ - Строка - в формате УникальныйИдентификатор (36 символов)
//Возвращаемое значение:
//	Строка - 32 значный ГУИД
Функция UUIDToGUID(UUID_) Экспорт
 
 Возврат Сред(UUID_, 20, 4) + Прав(UUID_, 12) + Сред(UUID_, 15, 4) + Сред(UUID_, 10, 4) + Лев(UUID_, 8);
 
КонецФункции

//Возвращает ссылку по строке УИД
//Параметры:
//	УУИД - Строка - 36 значный УИД
//	НайтиВсе - Булево - Найти все ссылки и вернуть массив. При Ложь будет возвращена первая найденная.
//Возвращаемое значение:
//	Массив/Ссылка/Неопределено - Если НайтиВсе - будет массив, иначеесли найдена ссылка - найденная ссылка, если не найдено ничего - неопределено.
Функция UUIDToСсылка(УУИД, НайтиВсе = Ложь) Экспорт
	Результат = Новый Массив;
	ГдеИщем = Новый Соответствие;
	ГдеИщем.Вставить(Справочники, Метаданные.Справочники);
	ГдеИщем.Вставить(Документы, Метаданные.Документы);
	ГдеИщем.Вставить(ПланыВидовХарактеристик, Метаданные.ПланыВидовХарактеристик);
	ГдеИщем.Вставить(ПланыСчетов, Метаданные.ПланыСчетов);
	ГдеИщем.Вставить(ПланыВидовРасчета, Метаданные.ПланыВидовРасчета);
	ГдеИщем.Вставить(БизнесПроцессы, Метаданные.БизнесПроцессы);
	ГдеИщем.Вставить(Задачи, Метаданные.Задачи);
	ГдеИщем.Вставить(ПланыОбмена, Метаданные.ПланыОбмена);
	НУИД = Новый УникальныйИдентификатор(УУИД);
	Для Каждого ВидМетаданных Из ГдеИщем Цикл
		Для каждого л_Менеджер из ВидМетаданных.Значение Цикл
			л_Ссылка = ВидМетаданных.Ключ[л_Менеджер.Имя].ПолучитьСсылку(НУИД);
			//Элементы.ГруппаСсылки.Заголовок = ТипЗнч(л_Ссылка);
			Если л_Ссылка.ПолучитьОбъект() <> Неопределено Тогда
				Если НайтиВсе Тогда
					Результат.Добавить(л_Ссылка);
				Иначе
					Возврат л_Ссылка
				КонецЕсли; 
			КонецЕсли
		КонецЦикла
	КонецЦикла;
	Возврат ?(НайтиВсе, Результат, Неопределено)
КонецФункции

// Возвращает ссылки по УИД, но поиск происходит только по заданным типам
// Параметры:
//  УУИДы  - Строка или Массив строк - УИДы, по которым надо найти ссылку
//  ГдеИскать  - Массив - Допустимые типы ссылки-
// Возвращаемое значение:
//   Массив   - Найденные ссылки или Неопределено
Функция СсылкиЗаданногоТипаПоУИД(УИДы, ГдеИскать) Экспорт
	ЧтоИскать = ПреобразоватьВМассив(УИДы);
	мГдеИскать = Новый Массив;
	Для каждого ТекТип Из ГдеИскать Цикл
		мГдеИскать.Добавить(ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер").Менеджер);
	КонецЦикла;
	Результат = Новый Массив;
	Для каждого УИД Из ЧтоИскать Цикл
		ТекСсылка = Неопределено;
		Для каждого Менеджер Из мГдеИскать Цикл
			ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИД));
			Если ТекСсылка <> Неопределено Тогда
				Прервать;
			КонецЕсли;
			Результат.Добавить(ТекСсылка);
		КонецЦикла; 
	КонецЦикла;
	Возврат Результат
КонецФункции // СсылкиЗаданногоТипаПоУИД()
 
// Возвращает таблицу найденных ссылок по массиву искомых ссылок. Также является вспомогательной для функций замены.
// Параметры:
//  Ссылки  - Массив, список значений или ссылка - искомые ссылки
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоМассиву(Ссылки) Экспорт
	Если ТипЗнч(Ссылки) = Тип("СписокЗначений") Тогда
		МассивЗаменяемых = Ссылки.ВыгрузитьЗначения();
	Иначе
		МассивЗаменяемых = Ссылки;
		ПреобразоватьВМассив(МассивЗаменяемых, Истина);
	КонецЕсли;
	НайденныеСсылки = НайтиПоСсылкам(МассивЗаменяемых);
	НайденныеСсылки.Колонки[0].Имя = "Ссылка";
	НайденныеСсылки.Колонки[1].Имя = "Данные";
	НайденныеСсылки.Колонки[2].Имя = "Метаданные";
	НайденныеСсылки.Колонки.Добавить("Включено", Новый ОписаниеТипов("Булево"));
	НайденныеСсылки.ЗаполнитьЗначения(Истина, "Включено");
	Возврат НайденныеСсылки;
КонецФункции // НайтиСсылкиПоМассиву()
 
// Возвращает таблицу найденных ссылок по таблице замен с колонками ЧтоЗаменять и Пометка
// Параметры:
//	ТабЗамен - Таблица значений - с колонками Пометка и ЧтоЗаменять
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоТаблицеЗамен(ТабЗамен) Экспорт
	ТабЗаменяемых = ТабЗамен.Скопировать(ТабЗамен.НайтиСтроки(Новый Структура("Пометка", Истина)), "ЧтоЗаменять");
	ТабЗаменяемых.Свернуть("ЧтоЗаменять");
	МассивЗаменяемых = ТабЗаменяемых.ВыгрузитьКолонку("ЧтоЗаменять");
	Если МассивЗаменяемых.Количество() = 0 Тогда
		Сообщить("Не выбрано ни одного значения для поиска!");
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	Возврат НайтиСсылкиПоМассиву(МассивЗаменяемых)
КонецФункции

#КонецОбласти 

#Область ДЕРЕВО_МД
	
//Заполняет дерево метаданных по ветви метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ВетвьМД - Объект метаданных - Источник данных для заполнения	
//	Префикс - Строка - Указывается перед пользовательским представлением элемента	
//	СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента	для кода или запроса.
//	Очищать - Булево - Очистить дерево перед заполненияем
//	ЗаполнятьВетви - Булево - При Истина заполняет на всю глубину, при Ложь - без вложенных ветвей (намного быстрее, по умолчанию).	
Процедура ЗаполнитьДеревоМД(ВетвьДерева, ВетвьМД = Неопределено, Префикс = "", СброситьПрефикс = Ложь, Очищать = Ложь, ЗаполнятьВетви = Ложь) Экспорт
	ЭтоДуб = ТипЗнч(ВетвьДерева) = Тип("ДеревоЗначений");
	Если ЭтоДуб Тогда
		Если ВетвьДерева.Колонки.Найти("Представление") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("Представление");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("ТекстДляКода") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("ТекстДляКода");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("ТекстДляЗапроса") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("ТекстДляЗапроса");
		КонецЕсли;
		Если ВетвьДерева.Колонки.Найти("МД") = Неопределено Тогда
			ВетвьДерева.Колонки.Добавить("МД",,, 0);
		КонецЕсли;
	КонецЕсли;
	Если Очищать Тогда
		ВетвьДерева.Строки.Очистить()
	КонецЕсли;
	Продолжать = (ВетвьДерева.Строки.Количество() = 0) ИЛИ НЕ ЭтоДуб;
	Если Продолжать Тогда
		Если ВетвьМД = Неопределено Тогда
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Справочники";
			НоваяСтрокаДерева.ТекстДляКода = "Справочники";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Справочник";
			НоваяСтрокаДерева.МД = Метаданные.Справочники;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Справочники);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Документы";
			НоваяСтрокаДерева.ТекстДляКода = "Документы";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Документ";
			НоваяСтрокаДерева.МД = Метаданные.Документы;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Документы);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Перечисления";
			НоваяСтрокаДерева.ТекстДляКода = "Перечисления";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Перечисление";
			НоваяСтрокаДерева.МД = Метаданные.Перечисления;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Перечисления);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы счетов";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыСчетов";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланСчетов";
			НоваяСтрокаДерева.МД = Метаданные.ПланыСчетов;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыСчетов);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы видов расчетов";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовРасчетов";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовРасчетов";
			НоваяСтрокаДерева.МД = Метаданные.ПланыВидовРасчета;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовРасчета);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы обмена";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыОбмена";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланОбмена";
			НоваяСтрокаДерева.МД = Метаданные.ПланыОбмена;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыОбмена);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Планы видов характеристик";
			НоваяСтрокаДерева.ТекстДляКода = "ПланыВидовХарактеристик";
			НоваяСтрокаДерева.ТекстДляЗапроса = "ПланВидовХарактеристик";
			НоваяСтрокаДерева.МД = Метаданные.ПланыВидовХарактеристик;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.ПланыВидовХарактеристик);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры накопления";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыНакопления";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрНакопления";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыНакопления;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыНакопления);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры бухгалтерии";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыБухгалтерии";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрБухгалтерии";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыБухгалтерии;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыБухгалтерии);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры расчёта";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыРасчета";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрРасчета";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыРасчета;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыРасчета);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Регистры сведений";
			НоваяСтрокаДерева.ТекстДляКода = "РегистрыСведений";
			НоваяСтрокаДерева.ТекстДляЗапроса = "РегистрСведений";
			НоваяСтрокаДерева.МД = Метаданные.РегистрыСведений;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.РегистрыСведений);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Бизнес-процессы";
			НоваяСтрокаДерева.ТекстДляКода = "БизнесПроцессы";
			НоваяСтрокаДерева.ТекстДляЗапроса = "БизнесПроцесс";
			НоваяСтрокаДерева.МД = Метаданные.БизнесПроцессы;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.БизнесПроцессы);
			КонецЕсли; 
			НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
			НоваяСтрокаДерева.Представление = "Задачи";
			НоваяСтрокаДерева.ТекстДляКода = "Задачи";
			НоваяСтрокаДерева.ТекстДляЗапроса = "Задачи";
			НоваяСтрокаДерева.МД = Метаданные.Задачи;
			Если ЗаполнятьВетви Тогда
				ЗаполнитьДеревоМД(НоваяСтрокаДерева, Метаданные.Задачи);
			КонецЕсли; 
		Иначе
			Если ТипЗнч(ВетвьМД) <> Тип("КоллекцияОбъектовМетаданных") Тогда //ВетвьДерева.СПопыткой Тогда
				ПродолжитьЗаполнениеМД(ВетвьДерева, ВетвьМД);
			Иначе
				Для Каждого ОбъектМД Из ВетвьМД Цикл
					НоваяСтрокаДерева = ВетвьДерева.Строки.Добавить();
					НоваяСтрокаДерева.Представление = ОбъектМД.Синоним;
					Если ПустаяСтрока(НоваяСтрокаДерева.Представление) Тогда
						НоваяСтрокаДерева.Представление = ОбъектМД.Имя
					КонецЕсли;
					НоваяСтрокаДерева.Представление = "" + Префикс + НоваяСтрокаДерева.Представление;
					НоваяСтрокаДерева.ТекстДляКода = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляКода + ".") + ОбъектМД.Имя;
					НоваяСтрокаДерева.ТекстДляЗапроса = ?(СброситьПрефикс, "", ВетвьДерева.ТекстДляЗапроса + "." + ОбъектМД.Имя);
					НоваяСтрокаДерева.МД = ОбъектМД;
					//НоваяСтрокаДерева.СПопыткой = Истина;
					Если ЗаполнятьВетви Тогда
						ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры //ЗаполнитьМД

//Вспомогательная для следующей процедуры. Заполняет ветвь дерева значений по реквизиту объекта метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ОбъектМД - Объект метаданных - Источник данных для заполнения	
//	ИмяМД - Строка - Имя реквизита объекта метаданных, по которому надо заполнить ветвь	
//	Префикс - Строка - Указывается перед пользовательским представлением элемента	
//	СброситьПрефикс - Булево - не указывать представление родителя в представлении элемента	для кода или запроса.
Процедура ВызватьЗаполнениеСПопыткой(ВетвьДерева, ОбъектМД, ИмяМД, Префикс = "", СброситьПрефикс = Ложь)
	Попытка
		Коллекция = ОбъектМД[ИмяМД];
	Исключение
		Коллекция = Неопределено
	КонецПопытки;
	Если Коллекция <> Неопределено Тогда
		ЗаполнитьДеревоМД(ВетвьДерева, Коллекция, Префикс, СброситьПрефикс,, Истина)
	КонецЕсли;
КонецПроцедуры
				
//Вспомогательная для предыдущей экспортной процедуры. Заполняет строку дерева по объекту метаданных.
//Параметры:
//	ВетвьДерева - Строка дерева значений или дерево значений - Заполняемый объект	
//	ОбъектМД - Объект метаданных - Источник данных для заполнения	
Процедура ПродолжитьЗаполнениеМД(НоваяСтрокаДерева, ОбъектМД)
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Реквизиты");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "СтандартныеРеквизиты");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ТабличныеЧасти", "#");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Формы", "^", Истина);
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Макеты", "$", Истина);
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "ЗначенияПеречисления");
	ВызватьЗаполнениеСПопыткой(НоваяСтрокаДерева, ОбъектМД, "Команды", ">", Истина);
	НоваяСтрокаДерева.Строки.Сортировать("Представление", Ложь, Новый СравнениеЗначений)
КонецПроцедуры //ПродолжитьЗаполнениеМД

#КонецОбласти 

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возвращает запрос с временной таблицей, содержащей заданные колонки
// Параметры:
//  МассивОбъектов  - Массив или одиночный объект или соответствие - У кого брать реквизиты. Соответствие д.б. в формате (Тип -> Массив объектов)
//  СписокКолонок  - Строка с разделителем "," или Массив - список имён колонок таблицы-результата
//  Мэппинг  - Соответствие или Строка - (Тип -> Структура(Имя колонки таблицы -> ИмяРеквизита) или Текст запроса для объекта заданного типа). ИмяРеквизита м.б. в формате "ЗНАЧ = [Фиксированное значение или параметр]"
//  ДопПараметры  - Структура - Будет добавлена к параметрам запроса, по умолчанию Неопределено - параметры не добавляются.
// Возвращаемое значение:
//   Запрос   - Запрос со сформированной временной таблицей ВТ_Ответ
Функция РеквизитыРазнотипныхОбъектов(МассивОбъектов, СписокКолонок = "Номер,Дата", Мэппинг = Неопределено, ДопПараметры = Неопределено) Экспорт
	СоответствиеТипов = ?(ТипЗнч(МассивОбъектов) = Тип("Соответствие"), МассивОбъектов, РазбитьПоТипам(ПреобразоватьВМассив(МассивОбъектов)));
	Колонки = ?(ТипЗнч(СписокКолонок) = Тип("Строка"), СтрРазделить(СписокКолонок, ",", Ложь), СписокКолонок);
	ТекстЗапроса = "";
	Для каждого ИмяКолонки Из Колонки Цикл
		ТекстЗапроса = ТекстЗапроса + ", NULL КАК " + ИмяКолонки;
	КонецЦикла; 
	ТекстЗапроса = "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + " ПОМЕСТИТЬ ВТ_Ответ ГДЕ ЛОЖЬ" + Символы.ПС;
	Запрос = Новый Запрос(ТекстЗапроса);
	СчПараметров = 0;
	Для каждого КиЗ Из СоответствиеТипов Цикл
		Попытка
			МетаХ = КиЗ.Значение[0].Метаданные();
			ТипОбъекта = ?(ОбщегоНазначения.ЭтоДокумент(МетаХ), "Документ", ?(ОбщегоНазначения.ЭтоСправочник(МетаХ), "Справочник", ?(ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаХ), "ПланВидовХарактеристик", "Прочее")));
		Исключение
			МетаХ = Неопределено;
			ТипОбъекта = "Прочее";
			//ЭтоДокумент = Ложь;
		КонецПопытки;
		ТекМэппинг = ?(Мэппинг = Неопределено, Неопределено, Мэппинг[ТипЗнч(КиЗ.Значение[0])]);
		Если ТипЗнч(ТекМэппинг) = Тип("Строка") Тогда
			ИмяПараметра = "Параметр_" + СчПараметров;
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ " + СтрЗаменить(ТекМэппинг, "[СсылкиНаОбъекты]", ИмяПараметра) + Символы.ПС;
			Запрос.УстановитьПараметр(ИмяПараметра, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		ИначеЕсли ТипОбъекта = "Прочее" Тогда
			Если ТекМэппинг = Неопределено Тогда
				Если Колонки.Найти("Ссылка") <> Неопределено Тогда
					Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
						ЧастныйТекст = "";
						Для каждого Колонка Из Колонки Цикл
							Если Колонка = "Ссылка" Тогда
								ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
								Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение);
								СчПараметров = СчПараметров + 1;
							Иначе
								ЧастныйТекст = ЧастныйТекст + ", NULL";
							КонецЕсли; 
						КонецЦикла; 
						ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
					КонецЦикла; 
				КонецЕсли; 
			Иначе
				Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
					ЧастныйТекст = "";
					Для каждого Колонка Из Колонки Цикл
						Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
							ЧастныйТекст = ЧастныйТекст + ", NULL";
						ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
							ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
						Иначе
							ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
							Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение[ТекМэппинг[Колонка]]);
							СчПараметров = СчПараметров + 1;
						КонецЕсли; 
					КонецЦикла; 
					ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
				КонецЦикла; 
			КонецЕсли; 
		Иначе
			ЧастныйТекст = "";
			Для каждого Колонка Из Колонки Цикл
				Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
					ЧастныйТекст = ЧастныйТекст + ", Док." + Колонка;
				ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
					ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
				Иначе
					ЧастныйТекст = ЧастныйТекст + ", Док." + ТекМэппинг[Колонка];
				КонецЕсли; 
			КонецЦикла; 
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2) + " ИЗ " + ТипОбъекта + "." + МетаХ.Имя + " КАК Док ГДЕ Док.Ссылка В(&Параметр_" + СчПараметров + ")" + Символы.ПС;
			Запрос.УстановитьПараметр("Параметр_" + СчПараметров, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		КонецЕсли;
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	Если ДопПараметры <> Неопределено Тогда
		Для каждого КиЗ Из ДопПараметры Цикл
			Запрос.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
		КонецЦикла; 
	КонецЕсли; 
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.Выполнить();
	Возврат Запрос
КонецФункции // РеквизитыРазнотипныхОбъектов()

// Возращает, есть ли реквизит у объекта. При массивных данных в реквизите может притормозить выполнение.
// Параметры:
//  Реквизит  - Строка - Имя проверяемого реквизита
//  Объект  - Любое значение - Любое значение, имеющее реквизиты
//  ЛюбоеНедопустимоеЗначение  - Любое значение - Любое значение, которое заведомо не может быть в реквизите
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
Функция ЕстьРеквизитОбъекта(Реквизит, УКого, ЛюбоеНедопустимоеЗначение = "@#$%^&$") Экспорт
	Проверятель = Новый Структура(Реквизит, ЛюбоеНедопустимоеЗначение);
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Возврат Проверятель[Реквизит] <> ЛюбоеНедопустимоеЗначение
КонецФункции // ЕстьРеквизитОбъекта()

// Возращает структуру с информацией, есть ли реквизиты у объекта. При массивных данных в реквизитах может притормозить выполнение.
// Параметры:
//  Реквизиты  - Строка с разделеителем - Имена проверяемоых реквизитов
//  Объект  - Любое значение - Любое значение, имеющее реквизиты
//  ЛюбоеНедопустимоеЗначение  - Любое значение - Любое значение, которое заведомо не может быть в реквизите
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
Функция ЕстьРеквизитыОбъекта(Реквизиты, УКого, ЛюбоеНедопустимоеЗначение = "@#$%^&$") Экспорт
	Проверятель = Новый Структура(Реквизиты);
	Для каждого КиЗ Из Проверятель Цикл
		Проверятель.Вставить(КиЗ.Ключ, ЛюбоеНедопустимоеЗначение);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Для каждого КиЗ Из Проверятель Цикл
		Проверятель.Вставить(КиЗ.Ключ, КиЗ.Значение <> ЛюбоеНедопустимоеЗначение);
	КонецЦикла;
	Возврат Проверятель
КонецФункции // ЕстьРеквизитОбъекта()

// Загоняет в структуру все реквизиты объекта
// Параметры:
//  Чьих  - любая ссылка - ссылка на объект для чтения в структуру
//  Табчасти  - Булево - считывать ли табчасти
//  ТабчастиПредставлением  - <Тип.Вид> - <описание параметра>
// Возвращаемое значение:
//   Структура   - ключ - имя реквизита, значение - значение реквизита. Если Чьих не ссылка - ключ "Предмет", а значение - Чьих.
Функция СформироватьСтруктуруВсехРеквизитов(Чьих, Табчасти = Ложь, ТабчастиПредставлением = Ложь, Общие = Истина) Экспорт
	Попытка
		МетаХ = Чьих.Метаданные();
	Исключение
		МетаХ = Неопределено;
	КонецПопытки;
	Если МетаХ = Неопределено Тогда
		Возврат Новый Структура("Предмет", Чьих);
	Иначе
		Результат = Новый Структура;
		Для каждого Реквизит Из МетаХ.Реквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла; 
		Для каждого Реквизит Из МетаХ.СтандартныеРеквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла;
		Если Общие Тогда
			Для Каждого Реквизит Из Метаданные.ОбщиеРеквизиты Цикл
				ЭлементР = Реквизит.Состав.Найти(МетаХ);
				Если ?(ЭлементР = Неопределено, Ложь, ЭлементР.Использование) Тогда
					Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
		Если ТабЧасти Тогда
			Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
				Результат.Вставить(ТЧ.Имя, ?(ТабчастиПредставлением, "Табличная часть", Чьих[Реквизит.Имя]));
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
КонецФункции //  СформироватьСтруктуруВсехРеквизитов()

#Область РеквизитыОбъектаПоТипамИлиЗначениям
	
// Возвращает соответствие, где ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
// Параметры:
//  Источник  - Объект или ссылка, допускающие применение Метаданные() - Объект, в котором ищутся типы или значения
//  ТипыИлиЗначения  - Массив - Типы или значения, которые ищутся.
//  ИскатьВСтандартных  - Булево - Надо ли искать в стандартных реквизитах. По умолчанию Истина.
//  ИскатьВОбщих  - Булево - Надо ли искать в общих реквизитах. По умолчанию Истина.
//  ИскатьВТабЧастях  - Булево - Надо ли искать в табчастях. По умолчанию Истина.
// Возвращаемое значение:
//   Соответствие   - ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
Функция РеквизитыОбъектаПоТипамИлиЗначениям(Источник, ТипыИлиЗначения, ИскатьВСтандартных = Истина, ИскатьВОбщих = Истина, ИскатьВТабЧастях = Истина) Экспорт
	ТипТип = Тип("Тип");
	Результат = Новый Соответствие;
	Для каждого ТекЗнч Из ТипыИлиЗначения Цикл
		Результат.Вставить(ТекЗнч, Новый Массив);
	КонецЦикла; 
	МетаХ = Источник.Метаданные();
	РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.Реквизиты, ТипТип);
	Если ИскатьВСтандартных Тогда
		РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.СтандартныеРеквизиты, ТипТип);
	КонецЕсли;
	Если ИскатьВОбщих Тогда
		Для Каждого Реквизит Из Метаданные.ОбщиеРеквизиты Цикл
			ЭлементР = Реквизит.Состав.Найти(МетаХ);
			Если ?(ЭлементР = Неопределено, Ложь, ЭлементР.Использование) Тогда
				РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ПреобразоватьВМассив(Реквизит), ТипТип);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Если ИскатьВТабЧастях Тогда
		Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
			РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ТЧ.Реквизиты, ТипТип, ТЧ.Имя + ".");
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // РеквизитыОбъектаПоТипамИлиЗначениям
 
//Вспомогательная для РеквизитыОбъектаПоТипамИлиЗначениям
// Параметры:
//  Приёмник  - Соответствие - Ключ = обрабатываемое значение, значение - массив имён реквизитов, найденных по значению
//  Источник  - Объект или ссылка - Объект, в котором ищутся значения
//  МетаКоллекция  - Коллекция объектов метаданных - Коллекция, по которой ищутся типы или значения
//  ТипТип  - Тип - Тип("Тип") - уже вычисленный
//  Префикс  - Строка - префикс имени реквизита (путь к родителю)
Процедура РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Приёмник, Источник, МетаКоллекция, ТипТип, Префикс = "")
	Для каждого Реквизит Из МетаКоллекция Цикл
		Для каждого КиЗ Из Приёмник Цикл
			ТекЗнч = КиЗ.Ключ;
			ЭтоТип = ТекЗнч = ТипТип;
			Если ?(ЭтоТип, Реквизит.Тип.СодержитТип(ТекЗнч), Источник[Реквизит.Имя] = ТекЗнч) Тогда
				КиЗ.Значение.Добавить(Префикс + Реквизит.Имя);
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла;
КонецПроцедуры // РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям

#КонецОбласти 
 
#КонецОбласти 

#Область СКД
	
//Возвращает таблицу значений - результат выполнения СКД
//Параметры:
//	СКД - СхемаКомпоновкиДанных - 
//	НастройкиСКД - Настройки СДК - применяемые при выполнении 
//	ВозможностьПрерыванияПользователем - Булево - Параметр запуска процессора вывода, разрешающий прерывание пользователем
//Возвращаемое значение:
//	ТаблицаЗначений - Результат выполнения СКД
Функция ТаблицаСКД(СКД, НастройкиСКД = Неопределено, ВозможностьПрерыванияПользователем = Ложь) Экспорт
	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = СКД.НастройкиПоУмолчанию;
	КонецЕсли; 
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиСКД,,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных_ = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных_.Инициализировать(МакетКомпоновки,,,Истина);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	Результат = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных_, ВозможностьПрерыванияПользователем);
	Возврат Результат
КонецФункции

//Возвращает элементы структуры настроек схемы компоновки данных по их именам
//Параметры:
//  СтруктураСКД  - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - головной элемент структуры СКД (структура, таблица, строки или колонки),  в которой будет поиск
//  Имена  - Строка или Массив (массив изменяется в процессе!) - Через запятую или в массиве - имена элементов, которые надо найти. Имена у искомых элементов д.б. настроены в конфигураторе.
//  Результат  - Структура - Если структура уже есть, и в неё надо добавить элементы, то она передаётся в этом параметре. Она же будет возвращена.
//Возвращаемое значение:
//   Структура   - ключи - переданные имена, разобранные из строки, значения - найденные элементы
Функция НайтиЭлементыСтруктурыКДПоИменам(СтруктураСКД, Имена, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый Структура;
	КонецЕсли;
	МассивХ = ?(ТипЗнч(Имена) = Тип("Массив"), Имена, СтрРазделить(Имена, ",", Ложь));
	Для каждого СтрокаСтруктуры Из СтруктураСКД Цикл
		Индех = МассивХ.Найти(СтрокаСтруктуры.Имя);
		Если Индех <> Неопределено Тогда
			Результат.Вставить(СтрокаСтруктуры.Имя, СтрокаСтруктуры);
			МассивХ.Удалить(Индех);
		КонецЕсли; 
		//Если Флаги.Свойство(СтрокаСтруктуры.Идентификатор) Тогда
		//	СтрокаСтруктуры.Использование = Флаги[СтрокаСтруктуры.Идентификатор];
		//КонецЕсли;
		Если МассивХ.Количество() Тогда
			Тест = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
			ЗаполнитьЗначенияСвойств(Тест, СтрокаСтруктуры);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Колонки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Строки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Структура, МассивХ, Результат);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // НайтиЭлементыСтруктурыКДПоИменам
 
#Область КОПИРОВАНИЕ_ГРУППИРОВКИ_СКД
	
//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию выбранных полей
//Параметры:
//	СтруктураПриёмник - ВыбранныеПоляКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ВыбранноеПолеКомпоновкиДанных или АвтоВыбранноеПолеКомпоновкиДанных или ГруппаВыбранныхПолейКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьВыбранныеПоля(СтруктураПриёмник, Элемент) Экспорт
	Если Тип(Элемент) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Расположение = Элемент.Расположение; 
		НовЭлемент.Поле = Элемент.Поле; 
		Для каждого Элемент Из Элемент.Выбор.Элементы Цикл 
			ДобавитьВыбранныеПоля(НовЭлемент.Выбор.Элементы, Элемент); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Переносит свойства переданного элемента в соответствующий элемент параметров вывода приёмника.
//Параметры:
//	СтруктураПриёмник - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЗначениеПараметраКомпоновкиДанных или ЗначениеПараметраНастроекКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПараметрыВывода(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Найти(Строка(Элемент.Параметр)); 
	НовЭлемент.Значение = Элемент.Значение; 
	НовЭлемент.Использование = Элемент.Использование; 
	Для каждого Элемент Из Элемент.ЗначенияВложенныхПараметров Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.ЗначенияВложенныхПараметров, Элемент); 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию отборов
//Параметры:
//	СтруктураПриёмник - ОтборКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементОтбораКомпоновкиДанных или ГруппаЭлементовОтбораКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьОтбор(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.ВидСравнения = Элемент.ВидСравнения; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.ЛевоеЗначение = Элемент.ЛевоеЗначение; 
		НовЭлемент.ПравоеЗначение = Элемент.ПравоеЗначение; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
		НовЭлемент.ТипГруппы = Элемент.ТипГруппы; 
		Для каждого ЭлементОтбора Из Элемент.Элементы Цикл 
			ДобавитьОтбор(НовЭлемент.Отбор.Элементы, ЭлементОтбора); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию условного оформления
//Параметры:
//	СтруктураПриёмник - УсловноеОформлениеКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементУсловногоОформленияКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьУсловноеОформление(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Добавить(); 
	НовЭлемент.Представление = Элемент.Представление; 
	НовЭлемент.Использование = Элемент.Использование; 
	//отбор 
	Для каждого ЭлементОтбор Из Элемент.Отбор.Элементы Цикл 
		ДобавитьОтбор(НовЭлемент.Отбор.Элементы,ЭлементОтбор); 
	КонецЦикла; 
	//оформление 
	Для каждого ЭлементОформление Из Элемент.Оформление.Элементы Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.Оформление.Элементы,ЭлементОформление); 
	КонецЦикла; 
	//поля 
	Для каждого ЭлементПоле Из Элемент.Поля.Элементы Цикл 
		НовЭлементПоле = НовЭлемент.Поля.Элементы.Добавить(); 
		НовЭлементПоле.Использование = ЭлементПоле.Использование; 
		НовЭлементПоле.Поле = ЭлементПоле.Поле; 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию порядка
//Параметры:
//	СтруктураПриёмник - ПорядокКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементПорядкаКомпоновкиДанных или АвтоЭлементПорядкаКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПорядок(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
		НовЭлемент.ТипУпорядочивания = Элемент.ТипУпорядочивания; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции

//Копирует элемент структуры СКД в другую (или эту же) структуру СКД.
//Содрана https://forum.infostart.ru/forum9/topic47305/
//Параметры:
//	СтруктураПриёмник - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - куда будет помещён новый элемент
//	ЭлементИсточник - ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных или НастройкиВложенногоОбъектаКомпоновкиДанных - Копируемый элемент структуры настроек СКД.
//			Для некоторых типов м.б. не проверено :(
//	ОткудаУдалитьНаСтаромМесте - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - Коллекция, из которой надо удалять старый элемент (Неопределено по умолчанию - не удалять).
//Возвращаемое значение:
//	Того же типа, что и ЭлементИсточник - Добавленный элемент
Функция СкопироватьЭлементВСтруктуруСКД(СтруктураПриёмник, ЭлементИсточник, ОткудаУдалитьНаСтаромМесте = Неопределено) Экспорт 
	
	ЭтоВТаблице = ТипЗнч(СтруктураПриёмник) = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных");
	Результат = ?(ЭтоВТаблице, СтруктураПриёмник.Добавить(), СтруктураПриёмник.Добавить(ТипЗнч(ЭлементИсточник)));
	
	//выбор 
	Для каждого Элемент Из ЭлементИсточник.Выбор.Элементы Цикл 
		ДобавитьВыбранныеПоля(Результат.Выбор.Элементы, Элемент) 
	КонецЦикла; 
	//использование 
	Результат.Использование = ЭлементИсточник.Использование; 
	//имя 
	Результат.Имя = ЭлементИсточник.Имя; 
	//отбор 
	Для каждого Элемент Из ЭлементИсточник.Отбор.Элементы Цикл 
		ДобавитьОтбор(Результат.Отбор.Элементы, Элемент); 
	КонецЦикла; 
	// параметры вывода 
	Для каждого Элемент Из ЭлементИсточник.ПараметрыВывода.Элементы Цикл 
		ДобавитьПараметрыВывода(Результат.ПараметрыВывода.Элементы,Элемент); 
	КонецЦикла; 
	//поля группировки 
	Для каждого Элемент Из ЭлементИсточник.ПоляГруппировки.Элементы Цикл 
		Если ТипЗнч(Элемент) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
			НовЭлемент.КонецПериода = Элемент.КонецПериода; 
			НовЭлемент.НачалоПериода = Элемент.НачалоПериода; 
			НовЭлемент.Поле = Элемент.Поле; 
			НовЭлемент.ТипГруппировки = Элемент.ТипГруппировки; 
			НовЭлемент.ТипДополнения = Элемент.ТипДополнения; 
		ИначеЕсли ТипЗнч(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
		КонецЕсли; 
	КонецЦикла; 
	//порядок 
	Для каждого Элемент Из ЭлементИсточник.Порядок.Элементы Цикл 
		ДобавитьПорядок(Результат.Порядок.Элементы, Элемент); 
	КонецЦикла; 
	//условное оформление 
	Для каждого Элемент Из ЭлементИсточник.УсловноеОформление.Элементы Цикл 
		ДобавитьУсловноеОформление(Результат.УсловноеОформление.Элементы, Элемент); 
	КонецЦикла; 
	
	//обход структуры рекурсивно 
	ТМП = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
	ЗаполнитьЗначенияСвойств(ТМП, ЭлементИсточник);
	Для каждого Подчинённый Из ТМП.Структура Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Структура, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Строки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Строки, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Колонки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Колонки, Подчинённый) 
	КонецЦикла; 
	
	Если ОткудаУдалитьНаСтаромМесте <> Неопределено Тогда
		ОткудаУдалитьНаСтаромМесте.Удалить(ЭлементИсточник);
	КонецЕсли;
	Возврат Результат
КонецФункции 

#КонецОбласти 

#КонецОбласти

#Область ЭТА_КОНФИГУРАЦИЯ
	
//Возвращает структуру с ключами ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО - есть ли 
// 	регистр ВОЛНА_ДопКонстанты и справочники ДополнительныеОбработки, ВОЛНА_ПереопределяемыеПроцедуры и ВнешниеОтчеты.
//Возвращаемое значение:
//	Структура - ключи ЕстьДК, ЕстьДО, ЕстьПП и ЕстьВО, отражающие наличие объектов внешних обработок и значений разного типа.
Функция ЕстьДопОбработки() Экспорт
	ИмяТипаПП = "ВОЛНА_ПереопределяемыеПроцедуры";
	ИмяТипаВО = "ВнешниеОбработки";
	ИмяТипаДО = "ДополнительныеОтчетыИОбработки";
	ИмяТипаДК = "ВОЛНА_ДопКонстанты";
	Возврат Новый Структура("ЕстьДК,ЕстьДО,ЕстьПП,ЕстьВО,ИмяТипаДК,ИмяТипаДО,ИмяТипаПП,ИмяТипаВО",
			Метаданные.РегистрыСведений.Найти(ИмяТипаДК) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаДО) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаПП) <> Неопределено,
			Метаданные.Справочники.Найти(ИмяТипаВО) <> Неопределено,
			ИмяТипаДК,
			ИмяТипаДО,
			ИмяТипаПП,
			ИмяТипаВО)				   
КонецФункции // ЕстьДопОбработки()
 
//Возвращает версию БСП
//Возвращаемое значение:
//	Строка - версия библиотеки стандартных подсистем
Функция ВерсияБСП() Экспорт
	Попытка
		Результат = Вычислить("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
	Исключение
		Результат = "Нет БСП";
	КонецПопытки;
	Возврат Результат
КонецФункции // ВерсияБСП()

//Возвращает информацию о наличии подсистемы
//Параметры:
//	ИмяПодсистемы - Строка - Имя искомой подсистемы
//Возвращаемое значение:
//	Булево - Подсистема есть
Функция ЕстьПодсистема(ИмяПодсистемы) Экспорт
	Возврат Метаданные.Подсистемы.Найти(ИмяПодсистемы) = Неопределено
КонецФункции

//Возвращает список картинок библиотеки (из макета, иначе не знаю, как получить) - префикс #Б:
//и из общих картинок - префикс #О:. Результат помещается в список значений, где представление - имя картинки,
//значение - имя картинки с префиксом, а картинка - сама картинка.
//Параметры:
//	СписокКартинокБиблиотеки - Строка - Список картинок библиотеки картинок с разделителем ПС. Способа прочитать этот список программно не нашёл, приходится передавать параметром.
//			Если не задан (пустая строка), производится попытка чтения из макета "КартинкиБиблиотеки"
//	ВставлятьКартинки - Булево - Вставлять в список сами картинки.
//Возвращаемое значение:
//	Список значений - список картинок из параметра и из общих картинок.
Функция ПолучитьСписокСтандартныхКартинок(СписокКартинокБиблиотеки = "", ВставлятьКартинки = Истина) Экспорт
	Результат = Новый СписокЗначений;
	Если СписокКартинокБиблиотеки = "" Тогда
		Попытка
			СписокКартинокБиблиотеки = Вычислить("ПолучитьМакет(""КартинкиБиблиотеки"").ПолучитьТекст()");
		Исключение
		КонецПопытки;
	КонецЕсли; 
	Для Ё = 1 По СтрЧислоСтрок(СписокКартинокБиблиотеки) Цикл
		ИмяК = СтрПолучитьСтроку(СписокКартинокБиблиотеки, Ё);
		Попытка
			ТКартинка = БиблиотекаКартинок[ИмяК];
			Результат.Добавить("#Б:" + ИмяК, ИмяК, Ложь, ?(ВставлятьКартинки, ТКартинка, ""));
		Исключение
		КонецПопытки;
	КонецЦикла; 
	Для каждого ТКартинка Из Метаданные.ОбщиеКартинки Цикл
		Результат.Добавить("#О:" + ТКартинка.Имя, ТКартинка.Синоним, Ложь, ?(ВставлятьКартинки, БиблиотекаКартинок[ТКартинка.Имя], ""));
	КонецЦикла; 
	Возврат Результат
КонецФункции // ПолучитьСписокСтандартныхКартинок()
 
#КонецОбласти

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ
	
// Возвращает список областей табличного документа
// Параметры:
//  ТабДок  - Табличный документ - имена областей которого будут выведены в список
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
// Возвращаемое значение:
//   СписокЗначений, Массив или строка   - Список областей ТД
Функция СписокОбластейТД(ТабДок, СтрокаМассивСписок = "Строка") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Область Из ТабДок.Области Цикл
			Результат = Результат + "," + Область.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, 2);
	КонецЕсли;
	Возврат Результат
КонецФункции // СписокОбластейТД
 
//Получает значение из области в структуру или иной аналогичный объект. Не распознаёт ссылки, из строк убирает одиночный апостроф.
//Параметры:
//	Приёмник 			- Структура - Объект-приёмник
//	РеквизитПриёмника	- Строка - Имя реквизита, куда будет помещено значение
//	Источник			- Табличный документ - Откуда будет считано значение
//	НомерСтроки			- Число - Номер строки ячейки, из которой будет считано значение
//	НомерКолонки		- Число - Номер колонки ячейки, из которой будет считано значение
//	ТипДанных			- Строка - Тип данных, к оторому будет приведено значение (Булево/Строка/Число)
Процедура ПолучитьИзОбласти(Приёмник, РеквизитПриёмника, Источник, НомерСтроки, НомерКолонки, ТипДанных = "Строка") Экспорт
	ТДата = ТекущаяДата();
	Если НомерКолонки = 0 Тогда
		Если ТипДанных = "Строка" Тогда
			Приёмник[РеквизитПриёмника] = "";
		ИначеЕсли ТипДанных = "Число" Тогда
			Приёмник[РеквизитПриёмника] = 0;
		ИначеЕсли ТипДанных = "Дата" Тогда
			Приёмник[РеквизитПриёмника] = ТДата;
		Иначе //Булево
			Приёмник[РеквизитПриёмника] = Ложь;
		КонецЕсли; 
	Иначе
		ТекОбласть = Источник.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		НадоПриводитьКФормату = НЕ ТекОбласть.СодержитЗначение;
		Если НадоПриводитьКФормату И (ТипДанных <> "Строка") Тогда
			ТекстОбласти = ТекОбласть.Текст;
			Если ТипДанных = "Дата" Тогда
				//Из форматов "1.3.75" и "750301"
				ТекСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекстОбласти,
						".", Символы.ПС), "/", Символы.ПС), "-", Символы.ПС), "\", Символы.ПС), " ", Символы.ПС), ":", Символы.ПС);
				Если СтрЧислоСтрок(ТекСтрока) = 1 Тогда
					Век = Лев(ТекСтрока, 2);
					Если (Век <> "19") ИЛИ (Век <> "20") Тогда
						ТекСтрока = "20" + ТекСтрока;
					КонецЕсли; 
					Попытка
						НовоеЗначение = Дата(Число(Лев(ТекСтрока, 4)), Число(Сред(ТекСтрока, 5, 2)), Число(Сред(ТекСтрока, 7, 2)), Число(Сред(ТекСтрока, 9, 2)), Число(Сред(ТекСтрока, 11, 2)), Число(Прав(ТекСтрока, 2)));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				Иначе
					Попытка
						ТГод = СтрПолучитьСтроку(ТекСтрока, 3);
						Если ТГод = "" Тогда
							ТГод = "0"
						ИначеЕсли СтрДлина(ТГод) = 2 Тогда
							ТГод = "20" + ТГод;
						КонецЕсли; 
						НовоеЗначение = Дата(Число(ТГод),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 2), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 1), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 4), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 5), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 6), "", "0")));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				КонецЕсли; 
			ИначеЕсли ТипДанных = "Булево" Тогда
				ВРег_ = ВРЕГ(ТекстОбласти);
				НовоеЗначение = НЕ ((ВРег_ = "ЛОЖЬ") ИЛИ (ВРег_ = "НЕТ") ИЛИ ПустаяСтрока(ВРег_) ИЛИ (ВРег_ = "0"));
			Иначе //Число
				Попытка
					НовоеЗначение = Число(ТекстОбласти);
				Исключение
					НовоеЗначение = 0;
				КонецПопытки;
			КонецЕсли;
			Приёмник[РеквизитПриёмника] = НовоеЗначение;
		Иначе
			Приёмник[РеквизитПриёмника] = ?(НадоПриводитьКФормату, ТекОбласть.Текст, ТекОбласть.Значение);
		КонецЕсли; 
		Если ТипЗнч(Приёмник[РеквизитПриёмника]) = Тип("Строка") Тогда
			Приёмник[РеквизитПриёмника] = СокрЛП(Приёмник[РеквизитПриёмника]);
			Если Лев(Приёмник[РеквизитПриёмника], 1) = "'" Тогда
				Приёмник[РеквизитПриёмника] = Сред(Приёмник[РеквизитПриёмника], 2);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры

#КонецОбласти 

//Возвращает массив видов характеристик, содержащих заданный тип
//ПВХ - строка с именем ПВХ, Тип - Тип
//Параметры:
//	ПВХ - строка -  имя плана вида характеристик
//	Тип - Тип -  искомый тип
//Возвращаемое значение:
//	Массив - виды характеристик, содержащие заданный тип.
Функция ВыбратьПВХСодержащиеТип(ПВХ, Тип) Экспорт
	Массив = Новый Массив;
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	ОбъектыСвойств.Ссылка,
	|	ОбъектыСвойств.ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик." + ПВХ + " КАК ОбъектыСвойств");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(Тип) Тогда
			Массив.Добавить(Выборка.Ссылка)
		КонецЕсли
	КонецЦикла;
	Возврат Массив
КонецФункции

//Копирует отбор набора записей в отбор другого НЗ того же регистра
//Параметры:
//	Приёмник - Набор записей или иной объект, содержащий Отбор. - Объект для настройки отбора
//	Источник - Набор записей или иной объект, содержащий Отбор. - Откуда берётся отбор для настройки
Процедура СкопироватьОтборы(Приёмник, Источник) Экспорт
	Для каждого ЭлементОтбора_ из Источник.Отбор Цикл
		ЭлементПриёмник = Приёмник.Отбор.Найти(ЭлементОтбора_.Имя);
		ЭлементПриёмник.Использование = ЭлементОтбора_.Использование;
		ЭлементПриёмник.ВидСравнения = ЭлементОтбора_.ВидСравнения;
		ЭлементПриёмник.Значение = ЭлементОтбора_.Значение;
		ЭлементПриёмник.ЗначениеС = ЭлементОтбора_.ЗначениеС;
		ЭлементПриёмник.ЗначениеПо = ЭлементОтбора_.ЗначениеПо
	КонецЦикла
КонецПроцедуры

//Запись объекта в базу в разных режимах
//Параметры:
//	Объект_				- Ссылка				- Что записывать
//	РежимЗагрузки		- Булево/Строка			- Режим "Обмен данными - Загрузка" загрузки при записи. "Не менять" (по умолчанию) - оставить как есть,
//											"Все" - попробовать без "загрузки", если не получится - то с "загрузкой".
//											Другие значения приведут к отказу от записи (кроме режима проведения).
//											При попытке проведения "Загрузка" всегда сбрасывается, на выходе из функции - восстанавливается как был.
//	ОтключитьМеханизмРегистрацииОбъектов - Булево/Неопределено - Отключить программную регистрацию на типовых планах обмена. Неопределено - не менять режим отключения.
//	ПопытатьсяПровести	- Булево	- Попытаться провести объект. По умолчанию ЛОЖЬ.
//	ПроверитьЧтоДок		- Булево	- Перед попыткой проведения проверить, документ ли это.
//  Сообщать			- Булево/Неопределено - Выдавать сообщения. Неопределено (по умолчанию) - сообщать только об ошибках.
//Возвращаемое значение	- Структура с ключами:
//		* Записан		- Булево, удалось ли записать объект.
//		* ТекстОшибки	- Текст ошибки при записи. "", если ошибки нет.
//		* КакЗаписался	- Строка - "Не записан", "Проведён", "Записан штатно" или "Записан в режиме загрузки".
Функция ЗаписатьОбъект(Объект_, РежимЗагрузки = "Не менять", ОтключитьМеханизмРегистрацииОбъектов = Неопределено, ПопытатьсяПровести = Ложь, ПроверитьЧтоДок = Ложь, Сообщать = Неопределено) Экспорт
	НеЗаписан = Истина;
	ООШ = "";
	КакЗаписался = "Не записан";
	ТекОДЗ = Объект_.ОбменДанными.Загрузка;
	Если ОтключитьМеханизмРегистрацииОбъектов = Неопределено Тогда
	ИначеЕсли ОтключитьМеханизмРегистрацииОбъектов Тогда
		Объект_.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
	ИначеЕсли Объект_.ДополнительныеСвойства.Свойство("ОтключитьМеханизмРегистрацииОбъектов") Тогда
		Объект_.ДополнительныеСвойства.Удалить("ОтключитьМеханизмРегистрацииОбъектов");
	КонецЕсли; 
	Проводить = ?(ПопытатьсяПровести, ?(ПроверитьЧтоДок, Метаданные.Документы.Найти(Объект_.Метаданные()), Истина), Ложь);
	//Попытка проведения
	Если Проводить Тогда
		Попытка
			Объект_.ОбменДанными.Загрузка = Ложь;
			Объект_.Записать(РежимЗаписиДокумента.Проведение);
			Если ?(Сообщать = Неопределено, Ложь, Сообщать) Тогда
				Сообщить("Проведён " + Объект_);
			КонецЕсли;
			НеЗаписан = Ложь;
			КакЗаписался = "Проведён";
		Исключение
			ООШ = ОписаниеОшибки();
			Если ?(Сообщать = Неопределено, Истина, Сообщать) Тогда
				Сообщить("НЕ проведён " + Объект_ + " по причине: " + ООШ);
			КонецЕсли;
		КонецПопытки;
	КонецЕсли;
	//Попытка обычной записи
	Если НеЗаписан 
			И (РежимЗагрузки = Ложь
				ИЛИ РежимЗагрузки = "Все"
				ИЛИ РежимЗагрузки = Неопределено И НЕ ТекОДЗ) Тогда
		Объект_.ОбменДанными.Загрузка = Ложь;
		Попытка
			Объект_.Записать();
			НеЗаписан = Ложь;
			Если ?(Сообщать = Неопределено, Ложь, Сообщать) Тогда
				Сообщить("Записан в штатном режиме " + Объект_);
			КонецЕсли;
			КакЗаписался = "Записан штатно";
		Исключение
			ООШ = ОписаниеОшибки();
			Если ?(Сообщать = Неопределено, Истина, Сообщать) Тогда
				Сообщить("НЕ записан " + Объект_ + " по причине: " + ООШ);
			КонецЕсли;
		КонецПопытки;
	КонецЕсли;
	//Попытка записи в режиме обмена данными
	Если НеЗаписан 
			И (РежимЗагрузки = Истина
				ИЛИ РежимЗагрузки = "Все"
				ИЛИ РежимЗагрузки = Неопределено И ТекОДЗ) Тогда
		Объект_.ОбменДанными.Загрузка = Истина;
		Попытка
			Объект_.Записать();
			Если ?(Сообщать = Неопределено, Ложь, Сообщать) Тогда
				Сообщить("Записан в режиме загрузки " + Объект_);
			КонецЕсли;
			КакЗаписался = "Записан в режиме загрузки";
		Исключение
			ООШ = ОписаниеОшибки();
			Если ?(Сообщать = Неопределено, Истина, Сообщать) Тогда
				Сообщить("НЕ записан в режиме загрузки " + Объект_ + " по причине: " + ООШ);
			КонецЕсли;
		КонецПопытки;
	КонецЕсли;
	Объект_.ОбменДанными.Загрузка = ТекОДЗ;
	Возврат Новый Структура("Записан,ТекстОшибки,КакЗаписался", НЕ НеЗаписан, ООШ, КакЗаписался)
КонецФункции

//"Клиент", "Сервер", и т.д. Старое название - РежимЗапуска
//Возвращаемое значение:
//	Строка - Обозначение текущего места выполнения кода
Функция МестоВыполненияКода() Экспорт
	Результат = "Странный";
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Результат = "ТолстыйКлиентОбычноеПриложение";
	#ИначеЕсли МобильноеПриложениеКлиент Тогда
		Результат = "МобильноеПриложениеКлиент";
	#ИначеЕсли МобильноеПриложениеСервер Тогда
		Результат = "МобильноеПриложениеСервер";
	#ИначеЕсли ТолстыйКлиентУправляемоеПриложение Тогда
		Результат = "ТолстыйКлиентУправляемоеПриложение";
	#ИначеЕсли Сервер Тогда
		Результат = "Сервер";
	#ИначеЕсли ВнешнееСоединение Тогда
		Результат = "ВнешнееСоединение";
	#ИначеЕсли ТонкийКлиент Тогда
		Результат = "ТонкийКлиент";
	#ИначеЕсли ВебКлиент Тогда
		Результат = "ВебКлиент";
	#КонецЕсли
	Возврат Результат
КонецФункции // МестоВыполненияКода()

//Определяет имя метаданных значения перечисления
//Параметры:
//	ЗначениеПеречисления - ПеречислениеСсылка.* - Ссылка, по которой надо вернуть имя
//Возвращаемое значение:
//	Строка - Имя МД значения перечисления
Функция ПолучитьИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
	ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
	ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя  
КонецФункции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  МассивКоэффициентов - Массив - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Коэффициенты, Знач Точность = 2) Экспорт
	Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаКоэффициентов  = 0;
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Коэффициент = Коэффициенты[Индекс];
		АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Новый Массив(Коэффициенты.Количество());
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	// Погрешности округления отнесем на коэффициент с максимальным весом.
	Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
		Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Аналог ЕстьNull - чтобы писать формулу одной строкой и не делать доп.переменных
//Параметры:
//	Первое - Произвольное - Значение, сравниваемое с "нежелательным".
//	Второе - Произвольное - "Нежелательное" значение
//	Третье - Произвольное - Замена "нежелательному" значению.
//Возвращаемое значение:
//	Произвольное - Если Первое = Второму, то Третье, иначе - Первое.
Функция ЕслиПервоеВтороеРавныТоТретьеИначеПервое(Первое, Второе, Третье) Экспорт
	Возврат ?(Первое = Второе, Третье, Первое)
КонецФункции

//Возвращает результат распознавания строкового значения
//Параметры:
//	Значение_ - Строка - Распознаваемое значение в строковом выражении
//	ТипыИлиМенеджеры - Менеджер ссылочного значения или массив таких менеджеров или тип/массивТипов - типы, в которых ищется ссылочное значение. Если опущен, то возвращается простое нессылочное значение.
//	ПоРеквизиту - Строка - Имя реквизита, в котором ищется значение.
//	Родитель - ЛюбаяСсылка - Если требуется поиск по родителю, то задавать сюда. По умолчанию Неопределено (поиск не используется). Для поиска документа по номеру в этот реквизит надо поместить дату.
//	Владелец - ЛюбаяСсылка - Если требуется поиск по владельцу, то задавать сюда. По умолчанию Неопределено (поиск не используется)
//Возвращаемое значение:
//	Произвольный - Распознанное значение
Функция РаспознатьЗначение(Значение_, ТипыИлиМенеджеры = "", ПоРеквизиту = "", Родитель = Неопределено, Владелец = Неопределено) Экспорт
	Результат = Значение_;
	Если ТипыИлиМенеджеры = "" Тогда
		//Возвращается простое значение
		ВРЕГ_ = Врег(Значение_);
		Если ВРЕГ_ = "ДА" ИЛИ ВРЕГ_ = "ИСТИНА" Тогда
			Результат = Истина;
		ИначеЕсли ВРЕГ_ = "НЕТ" ИЛИ ВРЕГ_ = "ЛОЖЬ" Тогда
			Результат = Ложь;
		Иначе
			Попытка
				Результат = Вычислить(Значение_);
			Исключение
				Попытка
					Результат = Число(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение_, " ", ""), " ", ""), ",", "."))
				Исключение
					Попытка
						СтрокаДатаВремя = СтрЗаменить(Значение_, " ", Символы.ПС);
						СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ":", Символы.ПС);
						СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, "/", Символы.ПС);
						СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ".", Символы.ПС);
						День    = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,1)));
						Месяц   = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,2)));
						Год     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,3)));
						Час     = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 3, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,4))), 0);
						Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 4, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,5))), 0);
						Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 5, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя,6))), 0);
						Если ЗначениеЗаполнено(Дата(Год, Месяц, День, Час, Минута, Секунда))  Тогда
							Если Год < 100 Тогда
								Год = 2000 + Год
							КонецЕсли
						КонецЕсли;
						Результат = Дата(Год, Месяц, День, Час, Минута, Секунда)
					Исключение
						Если ЭтоУИД(Значение_) Тогда
							UUIDToСсылка(Значение_);
						КонецЕсли;
					КонецПопытки
				КонецПопытки;
			КонецПопытки
		КонецЕсли
	Иначе
		мТиМ = ПреобразоватьВМассив(ТипыИлиМенеджеры);
		ТипТип = Тип("Тип");
		ТипСтрока = Тип("Строка");
		Для каждого ТекТиМ Из мТиМ Цикл
			ТекТип = ТипЗнч(ТекТиМ);
			Если ТекТип = ТипТип Тогда
				Менеджер = ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер");
			ИначеЕсли ТекТип = ТипСтрока Тогда
				Менеджер = Вычислить(ТекТиМ);
			Иначе
				Менеджер = ТекТиМ;
			КонецЕсли; 
			ТипМенеджера = СтрПолучитьСтроку(СтрЗаменить(Менеджер, ".", Символы.ПС), 1);
			ЭтоУИД_ = ЭтоУИД(Значение_);
			Если ЭтоУИД_ Тогда
				ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение_));
				Если Лев(Строка(ТекСсылка), 18) = "<Объект не найден>" Тогда
					ЭтоУИД_ = Ложь
				Иначе
					Результат = ТекСсылка
				КонецЕсли
			КонецЕсли;
			Если НЕ ЭтоУИД_ Тогда
				Если ТипМенеджера = "Перечисления" Тогда
					//Перечисления грузим особо
					Если ПустаяСтрока(Значение_) Тогда
						Результат = Менеджер.ПустаяСсылка();
					ИначеЕсли Найти(Значение_, " ") > 0 Тогда
						//Это синоним
						Результат = Менеджер.ПустаяСсылка();
						Для каждого ЗначениеПеречисления Из Менеджер.ПустаяСсылка().Метаданные().ЗначенияПеречисления Цикл
							Если ЗначениеПеречисления.Синоним = Значение_ Тогда
								Результат = Менеджер[ЗначениеПеречисления.Имя];
								Прервать;
							КонецЕсли; 
						КонецЦикла; 
					Иначе
						Попытка
							Результат = Менеджер[Значение_]
						Исключение
							Результат = Менеджер.ПустаяСсылка();
						КонецПопытки;
					КонецЕсли; 
				Иначе
					Если ПоРеквизиту = "" Тогда
						ПоРеквизиту = ?((ТипМенеджера = "БизнесПроцессы") ИЛИ (ТипМенеджера = "Документы") ИЛИ (ТипМенеджера = "Задачи"), "Номер",
								?((ТипМенеджера = "ПланыОбмена") ИЛИ (ТипМенеджера = "ПланыСчетов"), "Код", "Наименование"))
					КонецЕсли;
					ИскатьПоНомеру = ?(ПоРеквизиту = "Номер", (ТипМенеджера = "БизнесПроцессы") ИЛИ (ТипМенеджера = "Документы") ИЛИ (ТипМенеджера = "Задачи"), Ложь);
					ИскатьПоКоду = ?(ПоРеквизиту = "Код", (ТипМенеджера = "Справочники") ИЛИ (ТипМенеджера = "ПланыОбмена") ИЛИ
							(ТипМенеджера = "ПланыВидовХарактеристик") ИЛИ (ТипМенеджера = "ПланыСчетов") ИЛИ (ТипМенеджера = "ПланыВидовРасчета"), Ложь);
					ИскатьПоНаименованию = ?(ПоРеквизиту = "Наименование", (ТипМенеджера = "Справочники") ИЛИ (ТипМенеджера = "ПланыОбмена") ИЛИ
							(ТипМенеджера = "ПланыВидовХарактеристик") ИЛИ (ТипМенеджера = "ПланыСчетов") ИЛИ (ТипМенеджера = "ПланыВидовРасчета") ИЛИ (ТипМенеджера = "Задачи"), Ложь);
					ИскатьПоРодителю = ?(Родитель = Неопределено, Ложь, (ТипМенеджера = "Справочники") ИЛИ (ТипМенеджера = "ПланыВидовХарактеристик") ИЛИ (ТипМенеджера = "ПланыСчетов"));
					ИскатьПОВладельцу = ?(Владелец = Неопределено, Ложь, ТипМенеджера = "Справочники");
					Если ИскатьПоНомеру Тогда
						Если ТипМенеджера = "Документы" Тогда
							Результат = Менеджер.НайтиПоНомеру(Значение_, ?(Родитель = Неопределено, ТекущаяДата(), Родитель))
						Иначе
							Результат = Менеджер.НайтиПоНомеру(Значение_)
						КонецЕсли;
					ИначеЕсли ИскатьПоКоду Тогда
						Если ИскатьПоРодителю Тогда
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель, Владелец)
							Иначе
								Если ТипМенеджера = "Справочники" Тогда
									Результат = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель)
								Иначе
									Результат = Менеджер.НайтиПоКоду(Значение_, Родитель)
								КонецЕсли
							КонецЕсли
						Иначе
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоКоду(Значение_, Ложь,, Владелец)
							Иначе
								Если ТипМенеджера = "Справочники" Тогда
									Результат = Менеджер.НайтиПоКоду(Значение_, Ложь)
								Иначе
									Результат = Менеджер.НайтиПоКоду(Значение_)
								КонецЕсли
							КонецЕсли
						КонецЕсли
					ИначеЕсли ИскатьПоНаименованию Тогда
						Если ИскатьПоРодителю Тогда
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель, Владелец)
							Иначе
								Результат = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель)
							КонецЕсли
						Иначе
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоНаименованию(Значение_, Истина,, Владелец)
							Иначе
								Результат = Менеджер.НайтиПоНаименованию(Значение_, Истина)
							КонецЕсли
						КонецЕсли
					Иначе
						Если ИскатьПоРодителю Тогда
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель, Владелец)
							Иначе
								Результат = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель)
							КонецЕсли
						Иначе
							Если ИскатьПоВладельцу Тогда
								Результат = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_,, Владелец)
							Иначе
								Результат = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_)
							КонецЕсли
						КонецЕсли
					КонецЕсли
				КонецЕсли
			КонецЕсли;
			Если Результат <> Значение_ Тогда
				Прервать
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли;
	Возврат Результат
КонецФункции

#КонецОбласти
